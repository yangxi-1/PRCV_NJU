<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<script type="text/javascript">

  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-33108845-1']);
  _gaq.push(['_setDomainName', 'opencv.org']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();

</script>

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Basic C Structures and Operations &mdash; OpenCV 2.4.13.7 documentation</title>
    <link rel="stylesheet" href="../../../_static/default.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../../',
        VERSION:     '2.4.13.7',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../../_static/doctools.js"></script>
    <link rel="top" title="OpenCV 2.4.13.7 documentation" href="../../../index.html" />
    <link rel="up" title="core. The Core Functionality" href="core.html" />
    <link rel="next" title="Dynamic Structures" href="dynamic_structures.html" />
    <link rel="prev" title="Basic Structures" href="basic_structures.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="dynamic_structures.html" title="Dynamic Structures"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="basic_structures.html" title="Basic Structures"
             accesskey="P">previous</a> |</li>
        <li><a href="../../../index.html">OpenCV 2.4.13.7 documentation</a> &raquo;</li>
          <li><a href="../../refman.html" >OpenCV API Reference</a> &raquo;</li>
          <li><a href="core.html" accesskey="U">core. The Core Functionality</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
  
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="basic-c-structures-and-operations">
<h1>Basic C Structures and Operations<a class="headerlink" href="#basic-c-structures-and-operations" title="Permalink to this headline">¶</a></h1>
<p>The section describes the main data structures, used by the OpenCV 1.x API, and the basic functions to create and process the data structures.</p>
<div class="section" id="cvpoint">
<h2>CvPoint<a class="headerlink" href="#cvpoint" title="Permalink to this headline">¶</a></h2>
<dl class="cfunction">
<dt id="CvPoint cvPoint(int x, int y)">
<strong>C:</strong><code class="descname"> </code>CvPoint <code class="descname">cvPoint</code><span class="sig-paren">(</span>int <strong>x</strong>, int <strong>y</strong><span class="sig-paren">)</span><a class="headerlink" href="#CvPoint cvPoint(int x, int y)" title="Permalink to this definition">¶</a></dt>
<dd><p>constructs <code class="docutils literal"><span class="pre">CvPoint</span></code> structure.</p>
</dd></dl>

<dl class="cfunction">
<dt id="CvPoint cvPointFrom32f(CvPoint2D32f point)">
<strong>C:</strong><code class="descname"> </code>CvPoint <code class="descname">cvPointFrom32f</code><span class="sig-paren">(</span>CvPoint2D32f <strong>point</strong><span class="sig-paren">)</span><a class="headerlink" href="#CvPoint cvPointFrom32f(CvPoint2D32f point)" title="Permalink to this definition">¶</a></dt>
<dd><p>converts <code class="docutils literal"><span class="pre">CvPoint2D32f</span></code> to <code class="docutils literal"><span class="pre">CvPoint</span></code>.</p>
</dd></dl>

<dl class="struct">
<dt id="CvPoint">
<em class="property">struct </em><code class="descname">CvPoint</code><a class="headerlink" href="#CvPoint" title="Permalink to this definition">¶</a></dt>
<dd><p>2D point with integer coordinates (usually zero-based).</p>
<blockquote>
<div><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">param x:</th><td class="field-body">x-coordinate of the point.</td>
</tr>
<tr class="field-even field"><th class="field-name">param y:</th><td class="field-body">y-coordinate of the point.</td>
</tr>
<tr class="field-odd field"><th class="field-name">param point:</th><td class="field-body">the point to convert.</td>
</tr>
</tbody>
</table>
</div></blockquote>
</dd></dl>

<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="basic_structures.html#Point_" title="class Point_"><code class="xref ocv ocv-class docutils literal"><span class="pre">Point_</span></code></a></p>
</div>
</div>
<div class="section" id="cvpoint2d32f">
<h2>CvPoint2D32f<a class="headerlink" href="#cvpoint2d32f" title="Permalink to this headline">¶</a></h2>
<dl class="cfunction">
<dt id="CvPoint2D32f cvPoint2D32f(double x, double y)">
<strong>C:</strong><code class="descname"> </code>CvPoint2D32f <code class="descname">cvPoint2D32f</code><span class="sig-paren">(</span>double <strong>x</strong>, double <strong>y</strong><span class="sig-paren">)</span><a class="headerlink" href="#CvPoint2D32f cvPoint2D32f(double x, double y)" title="Permalink to this definition">¶</a></dt>
<dd><p>constructs <code class="docutils literal"><span class="pre">CvPoint2D32f</span></code> structure.</p>
</dd></dl>

<dl class="cfunction">
<dt id="CvPoint2D32f cvPointTo32f(CvPoint point)">
<strong>C:</strong><code class="descname"> </code>CvPoint2D32f <code class="descname">cvPointTo32f</code><span class="sig-paren">(</span>CvPoint <strong>point</strong><span class="sig-paren">)</span><a class="headerlink" href="#CvPoint2D32f cvPointTo32f(CvPoint point)" title="Permalink to this definition">¶</a></dt>
<dd><p>converts <code class="docutils literal"><span class="pre">CvPoint</span></code> to <code class="docutils literal"><span class="pre">CvPoint2D32f</span></code>.</p>
</dd></dl>

<dl class="struct">
<dt id="CvPoint2D32f">
<em class="property">struct </em><code class="descname">CvPoint2D32f</code><a class="headerlink" href="#CvPoint2D32f" title="Permalink to this definition">¶</a></dt>
<dd><p>2D point with floating-point coordinates.</p>
<blockquote>
<div><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">param x:</th><td class="field-body">floating-point x-coordinate of the point.</td>
</tr>
<tr class="field-even field"><th class="field-name">param y:</th><td class="field-body">floating-point y-coordinate of the point.</td>
</tr>
<tr class="field-odd field"><th class="field-name">param point:</th><td class="field-body">the point to convert.</td>
</tr>
</tbody>
</table>
</div></blockquote>
</dd></dl>

<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="basic_structures.html#Point_" title="class Point_"><code class="xref ocv ocv-class docutils literal"><span class="pre">Point_</span></code></a></p>
</div>
</div>
<div class="section" id="cvpoint3d32f">
<h2>CvPoint3D32f<a class="headerlink" href="#cvpoint3d32f" title="Permalink to this headline">¶</a></h2>
<dl class="struct">
<dt id="CvPoint3D32f">
<em class="property">struct </em><code class="descname">CvPoint3D32f</code><a class="headerlink" href="#CvPoint3D32f" title="Permalink to this definition">¶</a></dt>
<dd><p>3D point with floating-point coordinates</p>
</dd></dl>

<dl class="cfunction">
<dt id="CvPoint3D32f cvPoint3D32f(double x, double y, double z)">
<strong>C:</strong><code class="descname"> </code>CvPoint3D32f <code class="descname">cvPoint3D32f</code><span class="sig-paren">(</span>double <strong>x</strong>, double <strong>y</strong>, double <strong>z</strong><span class="sig-paren">)</span><a class="headerlink" href="#CvPoint3D32f cvPoint3D32f(double x, double y, double z)" title="Permalink to this definition">¶</a></dt>
<dd><p>constructs <code class="docutils literal"><span class="pre">CvPoint3D32f</span></code> structure.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>x</strong> &#8211; floating-point x-coordinate of the point.</li>
<li><strong>y</strong> &#8211; floating-point y-coordinate of the point.</li>
<li><strong>z</strong> &#8211; floating-point z-coordinate of the point.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="basic_structures.html#Point3_" title="class Point3_"><code class="xref ocv ocv-class docutils literal"><span class="pre">Point3_</span></code></a></p>
</div>
</div>
<div class="section" id="cvpoint2d64f">
<h2>CvPoint2D64f<a class="headerlink" href="#cvpoint2d64f" title="Permalink to this headline">¶</a></h2>
<dl class="struct">
<dt id="CvPoint2D64f">
<em class="property">struct </em><code class="descname">CvPoint2D64f</code><a class="headerlink" href="#CvPoint2D64f" title="Permalink to this definition">¶</a></dt>
<dd><p>2D point with double-precision floating-point coordinates.</p>
</dd></dl>

<dl class="cfunction">
<dt id="CvPoint2D64f cvPoint2D64f(double x, double y)">
<strong>C:</strong><code class="descname"> </code>CvPoint2D64f <code class="descname">cvPoint2D64f</code><span class="sig-paren">(</span>double <strong>x</strong>, double <strong>y</strong><span class="sig-paren">)</span><a class="headerlink" href="#CvPoint2D64f cvPoint2D64f(double x, double y)" title="Permalink to this definition">¶</a></dt>
<dd><p>constructs <code class="docutils literal"><span class="pre">CvPoint2D64f</span></code> structure.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>x</strong> &#8211; double-precision floating-point x-coordinate of the point.</li>
<li><strong>y</strong> &#8211; double-precision floating-point y-coordinate of the point.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="basic_structures.html#Point_" title="class Point_"><code class="xref ocv ocv-class docutils literal"><span class="pre">Point_</span></code></a></p>
</div>
</div>
<div class="section" id="cvpoint3d64f">
<h2>CvPoint3D64f<a class="headerlink" href="#cvpoint3d64f" title="Permalink to this headline">¶</a></h2>
<dl class="struct">
<dt id="CvPoint3D64f">
<em class="property">struct </em><code class="descname">CvPoint3D64f</code><a class="headerlink" href="#CvPoint3D64f" title="Permalink to this definition">¶</a></dt>
<dd><p>3D point with double-precision floating-point coordinates.</p>
</dd></dl>

<dl class="cfunction">
<dt id="CvPoint3D64f cvPoint3D64f(double x, double y, double z)">
<strong>C:</strong><code class="descname"> </code>CvPoint3D64f <code class="descname">cvPoint3D64f</code><span class="sig-paren">(</span>double <strong>x</strong>, double <strong>y</strong>, double <strong>z</strong><span class="sig-paren">)</span><a class="headerlink" href="#CvPoint3D64f cvPoint3D64f(double x, double y, double z)" title="Permalink to this definition">¶</a></dt>
<dd><p>constructs <code class="docutils literal"><span class="pre">CvPoint3D64f</span></code> structure.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>x</strong> &#8211; double-precision floating-point x-coordinate of the point.</li>
<li><strong>y</strong> &#8211; double-precision floating-point y-coordinate of the point.</li>
<li><strong>z</strong> &#8211; double-precision floating-point z-coordinate of the point.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="basic_structures.html#Point3_" title="class Point3_"><code class="xref ocv ocv-class docutils literal"><span class="pre">Point3_</span></code></a></p>
</div>
</div>
<div class="section" id="cvsize">
<h2>CvSize<a class="headerlink" href="#cvsize" title="Permalink to this headline">¶</a></h2>
<dl class="struct">
<dt id="CvSize">
<em class="property">struct </em><code class="descname">CvSize</code><a class="headerlink" href="#CvSize" title="Permalink to this definition">¶</a></dt>
<dd><p>Size of a rectangle or an image.</p>
</dd></dl>

<dl class="cfunction">
<dt id="CvSize cvSize(int width, int height)">
<strong>C:</strong><code class="descname"> </code>CvSize <code class="descname">cvSize</code><span class="sig-paren">(</span>int <strong>width</strong>, int <strong>height</strong><span class="sig-paren">)</span><a class="headerlink" href="#CvSize cvSize(int width, int height)" title="Permalink to this definition">¶</a></dt>
<dd><p>constructs <code class="docutils literal"><span class="pre">CvSize</span></code> structure.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>width</strong> &#8211; width of the rectangle.</li>
<li><strong>height</strong> &#8211; height of the rectangle.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="basic_structures.html#Size_" title="class Size_"><code class="xref ocv ocv-class docutils literal"><span class="pre">Size_</span></code></a></p>
</div>
</div>
<div class="section" id="cvsize2d32f">
<h2>CvSize2D32f<a class="headerlink" href="#cvsize2d32f" title="Permalink to this headline">¶</a></h2>
<dl class="struct">
<dt id="CvSize2D32f">
<em class="property">struct </em><code class="descname">CvSize2D32f</code><a class="headerlink" href="#CvSize2D32f" title="Permalink to this definition">¶</a></dt>
<dd><p>Sub-pixel accurate size of a rectangle.</p>
</dd></dl>

<dl class="cfunction">
<dt id="CvSize2D32f cvSize2D32f(double width, double height)">
<strong>C:</strong><code class="descname"> </code>CvSize2D32f <code class="descname">cvSize2D32f</code><span class="sig-paren">(</span>double <strong>width</strong>, double <strong>height</strong><span class="sig-paren">)</span><a class="headerlink" href="#CvSize2D32f cvSize2D32f(double width, double height)" title="Permalink to this definition">¶</a></dt>
<dd><p>constructs <code class="docutils literal"><span class="pre">CvSize2D32f</span></code> structure.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>width</strong> &#8211; floating-point width of the rectangle.</li>
<li><strong>height</strong> &#8211; floating-point height of the rectangle.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="basic_structures.html#Size_" title="class Size_"><code class="xref ocv ocv-class docutils literal"><span class="pre">Size_</span></code></a></p>
</div>
</div>
<div class="section" id="cvrect">
<h2>CvRect<a class="headerlink" href="#cvrect" title="Permalink to this headline">¶</a></h2>
<dl class="struct">
<dt id="CvRect">
<em class="property">struct </em><code class="descname">CvRect</code><a class="headerlink" href="#CvRect" title="Permalink to this definition">¶</a></dt>
<dd><p>Stores coordinates of a rectangle.</p>
</dd></dl>

<dl class="cfunction">
<dt id="CvRect cvRect(int x, int y, int width, int height)">
<strong>C:</strong><code class="descname"> </code>CvRect <code class="descname">cvRect</code><span class="sig-paren">(</span>int <strong>x</strong>, int <strong>y</strong>, int <strong>width</strong>, int <strong>height</strong><span class="sig-paren">)</span><a class="headerlink" href="#CvRect cvRect(int x, int y, int width, int height)" title="Permalink to this definition">¶</a></dt>
<dd><p>constructs <code class="docutils literal"><span class="pre">CvRect</span></code> structure.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>x</strong> &#8211; x-coordinate of the top-left corner.</li>
<li><strong>y</strong> &#8211; y-coordinate of the top-left corner (sometimes bottom-left corner).</li>
<li><strong>width</strong> &#8211; width of the rectangle.</li>
<li><strong>height</strong> &#8211; height of the rectangle.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="basic_structures.html#Rect_" title="class Rect_"><code class="xref ocv ocv-class docutils literal"><span class="pre">Rect_</span></code></a></p>
</div>
</div>
<div class="section" id="cvbox2d">
<h2>CvBox2D<a class="headerlink" href="#cvbox2d" title="Permalink to this headline">¶</a></h2>
<dl class="struct">
<dt id="CvBox2D">
<em class="property">struct </em><code class="descname">CvBox2D</code><a class="headerlink" href="#CvBox2D" title="Permalink to this definition">¶</a></dt>
<dd><p>Stores coordinates of a rotated rectangle.</p>
<dl class="member">
<dt id="CvPoint2D32f center">
CvPoint2D32f <code class="descname">center</code><a class="headerlink" href="#CvPoint2D32f center" title="Permalink to this definition">¶</a></dt>
<dd><p>Center of the box</p>
</dd></dl>

<dl class="member">
<dt id="CvSize2D32f size">
CvSize2D32f <code class="descname">size</code><a class="headerlink" href="#CvSize2D32f size" title="Permalink to this definition">¶</a></dt>
<dd><p>Box width and height</p>
</dd></dl>

<dl class="member">
<dt id="float angle">
float <code class="descname">angle</code><a class="headerlink" href="#float angle" title="Permalink to this definition">¶</a></dt>
<dd><p>Angle between the horizontal axis and the first side (i.e. length) in degrees</p>
</dd></dl>

</dd></dl>

<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="basic_structures.html#RotatedRect" title="class RotatedRect"><code class="xref ocv ocv-class docutils literal"><span class="pre">RotatedRect</span></code></a></p>
</div>
</div>
<div class="section" id="cvscalar">
<h2>CvScalar<a class="headerlink" href="#cvscalar" title="Permalink to this headline">¶</a></h2>
<dl class="struct">
<dt id="CvScalar">
<em class="property">struct </em><code class="descname">CvScalar</code><a class="headerlink" href="#CvScalar" title="Permalink to this definition">¶</a></dt>
<dd><p>A container for 1-,2-,3- or 4-tuples of doubles.</p>
<dl class="member">
<dt id="double[4] val">
double[4] <code class="descname">val</code><a class="headerlink" href="#double[4] val" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="basic_structures.html#Scalar_" title="class Scalar_"><code class="xref ocv ocv-class docutils literal"><span class="pre">Scalar_</span></code></a></p>
</div>
</div>
<div class="section" id="cvtermcriteria">
<h2>CvTermCriteria<a class="headerlink" href="#cvtermcriteria" title="Permalink to this headline">¶</a></h2>
<dl class="struct">
<dt id="CvTermCriteria">
<em class="property">struct </em><code class="descname">CvTermCriteria</code><a class="headerlink" href="#CvTermCriteria" title="Permalink to this definition">¶</a></dt>
<dd><p>Termination criteria for iterative algorithms.</p>
<dl class="member">
<dt id="int type">
int <code class="descname">type</code><a class="headerlink" href="#int type" title="Permalink to this definition">¶</a></dt>
<dd><p>type of the termination criteria, one of:</p>
<blockquote>
<div><ul class="simple">
<li><code class="docutils literal"><span class="pre">CV_TERMCRIT_ITER</span></code> - stop the algorithm after <code class="docutils literal"><span class="pre">max_iter</span></code> iterations at maximum.</li>
<li><code class="docutils literal"><span class="pre">CV_TERMCRIT_EPS</span></code> - stop the algorithm after the achieved algorithm-dependent accuracy becomes lower than <code class="docutils literal"><span class="pre">epsilon</span></code>.</li>
<li><code class="docutils literal"><span class="pre">CV_TERMCRIT_ITER+CV_TERMCRIT_EPS</span></code> - stop the algorithm after <code class="docutils literal"><span class="pre">max_iter</span></code> iterations or when the achieved accuracy is lower than <code class="docutils literal"><span class="pre">epsilon</span></code>, whichever comes the earliest.</li>
</ul>
</div></blockquote>
</dd></dl>

<dl class="member">
<dt id="int max_iter">
int <code class="descname">max_iter</code><a class="headerlink" href="#int max_iter" title="Permalink to this definition">¶</a></dt>
<dd><p>Maximum number of iterations</p>
</dd></dl>

<dl class="member">
<dt id="double epsilon">
double <code class="descname">epsilon</code><a class="headerlink" href="#double epsilon" title="Permalink to this definition">¶</a></dt>
<dd><p>Required accuracy</p>
</dd></dl>

</dd></dl>

<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="basic_structures.html#TermCriteria" title="class TermCriteria"><code class="xref ocv ocv-class docutils literal"><span class="pre">TermCriteria</span></code></a></p>
</div>
</div>
<div class="section" id="cvmat">
<h2>CvMat<a class="headerlink" href="#cvmat" title="Permalink to this headline">¶</a></h2>
<dl class="struct">
<dt id="CvMat">
<em class="property">struct </em><code class="descname">CvMat</code><a class="headerlink" href="#CvMat" title="Permalink to this definition">¶</a></dt>
<dd><p>A multi-channel dense matrix.</p>
<dl class="member">
<dt>
int <code class="descname">type</code></dt>
<dd><p><code class="docutils literal"><span class="pre">CvMat</span></code> signature (<code class="docutils literal"><span class="pre">CV_MAT_MAGIC_VAL</span></code>) plus type of the elements. Type of the matrix elements can be retrieved using <code class="docutils literal"><span class="pre">CV_MAT_TYPE</span></code> macro:</p>
<div class="highlight-c"><div class="highlight"><pre><span class="kt">int</span> <span class="n">type</span> <span class="o">=</span> <span class="n">CV_MAT_TYPE</span><span class="p">(</span><span class="n">matrix</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">);</span>
</pre></div>
</div>
<p>For description of possible matrix elements, see <a class="reference internal" href="basic_structures.html#Mat" title="class Mat"><code class="xref ocv ocv-class docutils literal"><span class="pre">Mat</span></code></a>.</p>
</dd></dl>

<dl class="member">
<dt id="int step">
int <code class="descname">step</code><a class="headerlink" href="#int step" title="Permalink to this definition">¶</a></dt>
<dd><p>Full row length in bytes</p>
</dd></dl>

<dl class="member">
<dt id="int* refcount">
int* <code class="descname">refcount</code><a class="headerlink" href="#int* refcount" title="Permalink to this definition">¶</a></dt>
<dd><p>Underlying data reference counter</p>
</dd></dl>

<dl class="member">
<dt id="union data">
union <code class="descname">data</code><a class="headerlink" href="#union data" title="Permalink to this definition">¶</a></dt>
<dd><p>Pointers to the actual matrix data:</p>
<blockquote>
<div><ul class="simple">
<li>ptr - pointer to 8-bit unsigned elements</li>
<li>s - pointer to 16-bit signed elements</li>
<li>i - pointer to 32-bit signed elements</li>
<li>fl - pointer to 32-bit floating-point elements</li>
<li>db - pointer to 64-bit floating-point elements</li>
</ul>
</div></blockquote>
</dd></dl>

<dl class="member">
<dt id="int rows">
int <code class="descname">rows</code><a class="headerlink" href="#int rows" title="Permalink to this definition">¶</a></dt>
<dd><p>Number of rows</p>
</dd></dl>

<dl class="member">
<dt id="int cols">
int <code class="descname">cols</code><a class="headerlink" href="#int cols" title="Permalink to this definition">¶</a></dt>
<dd><p>Number of columns</p>
</dd></dl>

</dd></dl>

<p>Matrix elements are stored row by row. Element (i, j) (i - 0-based row index, j - 0-based column index) of a matrix can be retrieved or modified using <code class="docutils literal"><span class="pre">CV_MAT_ELEM</span></code> macro:</p>
<div class="highlight-c"><div class="highlight"><pre><span class="n">uchar</span> <span class="n">pixval</span> <span class="o">=</span> <span class="n">CV_MAT_ELEM</span><span class="p">(</span><span class="n">grayimg</span><span class="p">,</span> <span class="n">uchar</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span>
<span class="n">CV_MAT_ELEM</span><span class="p">(</span><span class="n">cameraMatrix</span><span class="p">,</span> <span class="kt">float</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="o">=</span> <span class="n">image</span><span class="p">.</span><span class="n">width</span><span class="o">*</span><span class="mf">0.5f</span><span class="p">;</span>
</pre></div>
</div>
<p>To access multiple-channel matrices, you can use <code class="docutils literal"><span class="pre">CV_MAT_ELEM(matrix,</span> <span class="pre">type,</span> <span class="pre">i,</span> <span class="pre">j*nchannels</span> <span class="pre">+</span> <span class="pre">channel_idx)</span></code>.</p>
<p><code class="docutils literal"><span class="pre">CvMat</span></code> is now obsolete; consider using <a class="reference internal" href="basic_structures.html#Mat" title="class Mat"><code class="xref ocv ocv-class docutils literal"><span class="pre">Mat</span></code></a> instead.</p>
</div>
<div class="section" id="cvmatnd">
<h2>CvMatND<a class="headerlink" href="#cvmatnd" title="Permalink to this headline">¶</a></h2>
<dl class="struct">
<dt id="CvMatND">
<em class="property">struct </em><code class="descname">CvMatND</code><a class="headerlink" href="#CvMatND" title="Permalink to this definition">¶</a></dt>
<dd><p>Multi-dimensional dense multi-channel array.</p>
<dl class="member">
<dt>
int <code class="descname">type</code></dt>
<dd><p>A <code class="docutils literal"><span class="pre">CvMatND</span></code> signature (<code class="docutils literal"><span class="pre">CV_MATND_MAGIC_VAL</span></code>) plus the type of elements. Type of the matrix elements can be retrieved using <code class="docutils literal"><span class="pre">CV_MAT_TYPE</span></code> macro:</p>
<div class="highlight-c"><div class="highlight"><pre><span class="kt">int</span> <span class="n">type</span> <span class="o">=</span> <span class="n">CV_MAT_TYPE</span><span class="p">(</span><span class="n">ndmatrix</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">);</span>
</pre></div>
</div>
</dd></dl>

<dl class="member">
<dt id="int dims">
int <code class="descname">dims</code><a class="headerlink" href="#int dims" title="Permalink to this definition">¶</a></dt>
<dd><p>The number of array dimensions</p>
</dd></dl>

<dl class="member">
<dt>
int* <code class="descname">refcount</code></dt>
<dd><p>Underlying data reference counter</p>
</dd></dl>

<dl class="member">
<dt>
union <code class="descname">data</code></dt>
<dd><p>Pointers to the actual matrix data</p>
<blockquote>
<div><ul class="simple">
<li>ptr - pointer to 8-bit unsigned elements</li>
<li>s - pointer to 16-bit signed elements</li>
<li>i - pointer to 32-bit signed elements</li>
<li>fl - pointer to 32-bit floating-point elements</li>
<li>db - pointer to 64-bit floating-point elements</li>
</ul>
</div></blockquote>
</dd></dl>

<dl class="member">
<dt id="array dim">
array <code class="descname">dim</code><a class="headerlink" href="#array dim" title="Permalink to this definition">¶</a></dt>
<dd><p>Arrays of pairs (array size along the i-th dimension, distance between neighbor elements along i-th dimension):</p>
<div class="highlight-c"><div class="highlight"><pre><span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">ndmatrix</span><span class="o">-&gt;</span><span class="n">dims</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;size[i] = %d, step[i] = %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ndmatrix</span><span class="o">-&gt;</span><span class="n">dim</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">size</span><span class="p">,</span> <span class="n">ndmatrix</span><span class="o">-&gt;</span><span class="n">dim</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">step</span><span class="p">);</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

<p><code class="docutils literal"><span class="pre">CvMatND</span></code> is now obsolete; consider using <a class="reference internal" href="basic_structures.html#Mat" title="class Mat"><code class="xref ocv ocv-class docutils literal"><span class="pre">Mat</span></code></a> instead.</p>
</div>
<div class="section" id="cvsparsemat">
<h2>CvSparseMat<a class="headerlink" href="#cvsparsemat" title="Permalink to this headline">¶</a></h2>
<dl class="struct">
<dt id="CvSparseMat">
<em class="property">struct </em><code class="descname">CvSparseMat</code><a class="headerlink" href="#CvSparseMat" title="Permalink to this definition">¶</a></dt>
<dd><p>Multi-dimensional sparse multi-channel array.</p>
<dl class="member">
<dt>
int <code class="descname">type</code></dt>
<dd><p>A <code class="docutils literal"><span class="pre">CvSparseMat</span></code> signature (CV_SPARSE_MAT_MAGIC_VAL) plus the type of sparse matrix elements. Similarly to <code class="docutils literal"><span class="pre">CvMat</span></code> and <code class="docutils literal"><span class="pre">CvMatND</span></code>, use <code class="docutils literal"><span class="pre">CV_MAT_TYPE()</span></code> to retrieve type of the elements.</p>
</dd></dl>

<dl class="member">
<dt>
int <code class="descname">dims</code></dt>
<dd><p>Number of dimensions</p>
</dd></dl>

<dl class="member">
<dt>
int* <code class="descname">refcount</code></dt>
<dd><p>Underlying reference counter. Not used.</p>
</dd></dl>

<dl class="member">
<dt id="CvSet* heap">
CvSet* <code class="descname">heap</code><a class="headerlink" href="#CvSet* heap" title="Permalink to this definition">¶</a></dt>
<dd><p>A pool of hash table nodes</p>
</dd></dl>

<dl class="member">
<dt id="void** hashtable">
void** <code class="descname">hashtable</code><a class="headerlink" href="#void** hashtable" title="Permalink to this definition">¶</a></dt>
<dd><p>The hash table. Each entry is a list of nodes.</p>
</dd></dl>

<dl class="member">
<dt id="int hashsize">
int <code class="descname">hashsize</code><a class="headerlink" href="#int hashsize" title="Permalink to this definition">¶</a></dt>
<dd><p>Size of the hash table</p>
</dd></dl>

<dl class="member">
<dt id="int[] size">
int[] <code class="descname">size</code><a class="headerlink" href="#int[] size" title="Permalink to this definition">¶</a></dt>
<dd><p>Array of dimension sizes</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="iplimage">
<h2>IplImage<a class="headerlink" href="#iplimage" title="Permalink to this headline">¶</a></h2>
<dl class="struct">
<dt id="IplImage">
<em class="property">struct </em><code class="descname">IplImage</code><a class="headerlink" href="#IplImage" title="Permalink to this definition">¶</a></dt>
<dd><p>IPL image header</p>
<dl class="member">
<dt id="int nSize">
int <code class="descname">nSize</code><a class="headerlink" href="#int nSize" title="Permalink to this definition">¶</a></dt>
<dd><p><code class="docutils literal"><span class="pre">sizeof(IplImage)</span></code></p>
</dd></dl>

<dl class="member">
<dt id="int ID">
int <code class="descname">ID</code><a class="headerlink" href="#int ID" title="Permalink to this definition">¶</a></dt>
<dd><p>Version, always equals 0</p>
</dd></dl>

<dl class="member">
<dt id="int nChannels">
int <code class="descname">nChannels</code><a class="headerlink" href="#int nChannels" title="Permalink to this definition">¶</a></dt>
<dd><p>Number of channels. Most OpenCV functions support 1-4 channels.</p>
</dd></dl>

<dl class="member">
<dt id="int alphaChannel">
int <code class="descname">alphaChannel</code><a class="headerlink" href="#int alphaChannel" title="Permalink to this definition">¶</a></dt>
<dd><p>Ignored by OpenCV</p>
</dd></dl>

<dl class="member">
<dt id="int depth">
int <code class="descname">depth</code><a class="headerlink" href="#int depth" title="Permalink to this definition">¶</a></dt>
<dd><p>Channel depth in bits + the optional sign bit ( <code class="docutils literal"><span class="pre">IPL_DEPTH_SIGN</span></code> ). The supported depths are:</p>
<blockquote>
<div><ul class="simple">
<li><code class="docutils literal"><span class="pre">IPL_DEPTH_8U</span></code> - unsigned 8-bit integer. Equivalent to <code class="docutils literal"><span class="pre">CV_8U</span></code> in matrix types.</li>
<li><code class="docutils literal"><span class="pre">IPL_DEPTH_8S</span></code> - signed 8-bit integer. Equivalent to <code class="docutils literal"><span class="pre">CV_8S</span></code> in matrix types.</li>
<li><code class="docutils literal"><span class="pre">IPL_DEPTH_16U</span></code> - unsigned 16-bit integer. Equivalent to <code class="docutils literal"><span class="pre">CV_16U</span></code> in matrix types.</li>
<li><code class="docutils literal"><span class="pre">IPL_DEPTH_16S</span></code> - signed 8-bit integer. Equivalent to <code class="docutils literal"><span class="pre">CV_16S</span></code> in matrix types.</li>
<li><code class="docutils literal"><span class="pre">IPL_DEPTH_32S</span></code> - signed 32-bit integer. Equivalent to <code class="docutils literal"><span class="pre">CV_32S</span></code> in matrix types.</li>
<li><code class="docutils literal"><span class="pre">IPL_DEPTH_32F</span></code> - single-precision floating-point number. Equivalent to <code class="docutils literal"><span class="pre">CV_32F</span></code> in matrix types.</li>
<li><code class="docutils literal"><span class="pre">IPL_DEPTH_64F</span></code> - double-precision floating-point number. Equivalent to <code class="docutils literal"><span class="pre">CV_64F</span></code> in matrix types.</li>
</ul>
</div></blockquote>
</dd></dl>

<dl class="member">
<dt id="char[] colorModel">
char[] <code class="descname">colorModel</code><a class="headerlink" href="#char[] colorModel" title="Permalink to this definition">¶</a></dt>
<dd><p>Ignored by OpenCV.</p>
</dd></dl>

<dl class="member">
<dt id="char[] channelSeq">
char[] <code class="descname">channelSeq</code><a class="headerlink" href="#char[] channelSeq" title="Permalink to this definition">¶</a></dt>
<dd><p>Ignored by OpenCV</p>
</dd></dl>

<dl class="member">
<dt id="int dataOrder">
int <code class="descname">dataOrder</code><a class="headerlink" href="#int dataOrder" title="Permalink to this definition">¶</a></dt>
<dd><p>0 =  <code class="docutils literal"><span class="pre">IPL_DATA_ORDER_PIXEL</span></code>  - interleaved color channels, 1 - separate color channels.  <a class="reference internal" href="#IplImage* cvCreateImage(CvSize size, int depth, int channels)" title="IplImage* cvCreateImage(CvSize size, int depth, int channels)"><code class="xref ocv ocv-cfunc docutils literal"><span class="pre">CreateImage()</span></code></a>  only creates images with interleaved channels. For example, the usual layout of a color image is:  <img class="math" src="../../../_images/math/97c90d7c81729c86c6c8a61813064a732ffafda4.png" alt="b_{00} g_{00} r_{00} b_{10} g_{10} r_{10} ..."/></p>
</dd></dl>

<dl class="member">
<dt id="int origin">
int <code class="descname">origin</code><a class="headerlink" href="#int origin" title="Permalink to this definition">¶</a></dt>
<dd><p>0 - top-left origin, 1 - bottom-left origin (Windows bitmap style)</p>
</dd></dl>

<dl class="member">
<dt id="int align">
int <code class="descname">align</code><a class="headerlink" href="#int align" title="Permalink to this definition">¶</a></dt>
<dd><p>Alignment of image rows (4 or 8). OpenCV ignores this and uses widthStep instead.</p>
</dd></dl>

<dl class="member">
<dt id="int width">
int <code class="descname">width</code><a class="headerlink" href="#int width" title="Permalink to this definition">¶</a></dt>
<dd><p>Image width in pixels</p>
</dd></dl>

<dl class="member">
<dt id="int height">
int <code class="descname">height</code><a class="headerlink" href="#int height" title="Permalink to this definition">¶</a></dt>
<dd><p>Image height in pixels</p>
</dd></dl>

<dl class="member">
<dt id="IplROI* roi">
IplROI* <code class="descname">roi</code><a class="headerlink" href="#IplROI* roi" title="Permalink to this definition">¶</a></dt>
<dd><p>Region Of Interest (ROI). If not NULL, only this image region will be processed.</p>
</dd></dl>

<dl class="member">
<dt id="IplImage* maskROI">
IplImage* <code class="descname">maskROI</code><a class="headerlink" href="#IplImage* maskROI" title="Permalink to this definition">¶</a></dt>
<dd><p>Must be NULL in OpenCV</p>
</dd></dl>

<dl class="member">
<dt id="void* imageId">
void* <code class="descname">imageId</code><a class="headerlink" href="#void* imageId" title="Permalink to this definition">¶</a></dt>
<dd><p>Must be NULL in OpenCV</p>
</dd></dl>

<dl class="member">
<dt id="void* tileInfo">
void* <code class="descname">tileInfo</code><a class="headerlink" href="#void* tileInfo" title="Permalink to this definition">¶</a></dt>
<dd><p>Must be NULL in OpenCV</p>
</dd></dl>

<dl class="member">
<dt id="int imageSize">
int <code class="descname">imageSize</code><a class="headerlink" href="#int imageSize" title="Permalink to this definition">¶</a></dt>
<dd><p>Image data size in bytes. For interleaved data, this equals  <img class="math" src="../../../_images/math/ef824a6abb80889e07aa649323b40b84a4996ab5.png" alt="\texttt{image-&gt;height} \cdot \texttt{image-&gt;widthStep}"/></p>
</dd></dl>

<dl class="member">
<dt id="char* imageData">
char* <code class="descname">imageData</code><a class="headerlink" href="#char* imageData" title="Permalink to this definition">¶</a></dt>
<dd><p>A pointer to the aligned image data. Do not assign imageData directly. Use <a class="reference internal" href="#void cvSetData(CvArr* arr, void* data, int step)" title="void cvSetData(CvArr* arr, void* data, int step)"><code class="xref ocv ocv-cfunc docutils literal"><span class="pre">SetData()</span></code></a>.</p>
</dd></dl>

<dl class="member">
<dt id="int widthStep">
int <code class="descname">widthStep</code><a class="headerlink" href="#int widthStep" title="Permalink to this definition">¶</a></dt>
<dd><p>The size of an aligned image row, in bytes.</p>
</dd></dl>

<dl class="member">
<dt id="int[] BorderMode">
int[] <code class="descname">BorderMode</code><a class="headerlink" href="#int[] BorderMode" title="Permalink to this definition">¶</a></dt>
<dd><p>Border completion mode, ignored by OpenCV</p>
</dd></dl>

<dl class="member">
<dt id="int[] BorderConst">
int[] <code class="descname">BorderConst</code><a class="headerlink" href="#int[] BorderConst" title="Permalink to this definition">¶</a></dt>
<dd><p>Constant border value, ignored by OpenCV</p>
</dd></dl>

<dl class="member">
<dt id="char* imageDataOrigin">
char* <code class="descname">imageDataOrigin</code><a class="headerlink" href="#char* imageDataOrigin" title="Permalink to this definition">¶</a></dt>
<dd><p>A pointer to the origin of the image data (not necessarily aligned). This is used for image deallocation.</p>
</dd></dl>

</dd></dl>

<p>The <code class="docutils literal"><span class="pre">IplImage</span></code> is taken from the Intel Image Processing Library, in which the format is native. OpenCV only supports a subset of possible <code class="docutils literal"><span class="pre">IplImage</span></code> formats, as outlined in the parameter list above.</p>
<p>In addition to the above restrictions, OpenCV handles ROIs differently. OpenCV functions require that the image size or ROI size of all source and destination images match exactly. On the other hand, the Intel Image Processing Library processes the area of intersection between the source and destination images (or ROIs), allowing them to vary independently.</p>
</div>
<div class="section" id="cvarr">
<h2>CvArr<a class="headerlink" href="#cvarr" title="Permalink to this headline">¶</a></h2>
<dl class="struct">
<dt id="CvArr">
<em class="property">struct </em><code class="descname">CvArr</code><a class="headerlink" href="#CvArr" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p>This is the &#8220;metatype&#8221; used <em>only</em> as a function parameter. It denotes that the function accepts arrays of multiple types, such as IplImage*, CvMat* or even CvSeq* sometimes. The particular array type is determined at runtime by analyzing the first 4 bytes of the header. In C++ interface the role of <code class="docutils literal"><span class="pre">CvArr</span></code> is played by <code class="docutils literal"><span class="pre">InputArray</span></code> and <code class="docutils literal"><span class="pre">OutputArray</span></code>.</p>
</div>
<div class="section" id="clearnd">
<h2>ClearND<a class="headerlink" href="#clearnd" title="Permalink to this headline">¶</a></h2>
<p>Clears a specific array element.</p>
<dl class="cfunction">
<dt id="void cvClearND(CvArr* arr, const int* idx)">
<strong>C:</strong><code class="descname"> </code>void <code class="descname">cvClearND</code><span class="sig-paren">(</span>CvArr* <strong>arr</strong>, const int* <strong>idx</strong><span class="sig-paren">)</span><a class="headerlink" href="#void cvClearND(CvArr* arr, const int* idx)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="pyoldfunction">
<dt id="cv.ClearND">
<strong>Python:</strong><code class="descname"> </code><code class="descclassname">cv.</code><code class="descname">ClearND</code><span class="sig-paren">(</span>arr, idx<span class="sig-paren">)</span> &rarr; None<a class="headerlink" href="#cv.ClearND" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>arr</strong> &#8211; Input array</li>
<li><strong>idx</strong> &#8211; Array of the element indices</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<p>The function clears (sets to zero) a specific element of a dense array or deletes the element of a sparse array. If the sparse array element does not exists, the function does nothing.</p>
</div>
<div class="section" id="cloneimage">
<h2>CloneImage<a class="headerlink" href="#cloneimage" title="Permalink to this headline">¶</a></h2>
<p>Makes a full copy of an image, including the header, data, and ROI.</p>
<dl class="cfunction">
<dt id="IplImage* cvCloneImage(const IplImage* image)">
<strong>C:</strong><code class="descname"> </code>IplImage* <code class="descname">cvCloneImage</code><span class="sig-paren">(</span>const IplImage* <strong>image</strong><span class="sig-paren">)</span><a class="headerlink" href="#IplImage* cvCloneImage(const IplImage* image)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="pyoldfunction">
<dt id="cv.CloneImage">
<strong>Python:</strong><code class="descname"> </code><code class="descclassname">cv.</code><code class="descname">CloneImage</code><span class="sig-paren">(</span>image<span class="sig-paren">)</span> &rarr; image<a class="headerlink" href="#cv.CloneImage" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>image</strong> &#8211; The original image</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="clonemat">
<h2>CloneMat<a class="headerlink" href="#clonemat" title="Permalink to this headline">¶</a></h2>
<p>Creates a full matrix copy.</p>
<dl class="cfunction">
<dt id="CvMat* cvCloneMat(const CvMat* mat)">
<strong>C:</strong><code class="descname"> </code>CvMat* <code class="descname">cvCloneMat</code><span class="sig-paren">(</span>const CvMat* <strong>mat</strong><span class="sig-paren">)</span><a class="headerlink" href="#CvMat* cvCloneMat(const CvMat* mat)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="pyoldfunction">
<dt id="cv.CloneMat">
<strong>Python:</strong><code class="descname"> </code><code class="descclassname">cv.</code><code class="descname">CloneMat</code><span class="sig-paren">(</span>mat<span class="sig-paren">)</span> &rarr; mat<a class="headerlink" href="#cv.CloneMat" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>mat</strong> &#8211; Matrix to be copied</td>
</tr>
</tbody>
</table>
</dd></dl>

<p>Creates a full copy of a matrix and returns a pointer to the copy. Note that the matrix copy is compacted, that is, it will not have gaps between rows.</p>
</div>
<div class="section" id="clonematnd">
<h2>CloneMatND<a class="headerlink" href="#clonematnd" title="Permalink to this headline">¶</a></h2>
<p>Creates full copy of a multi-dimensional array and returns a pointer to the copy.</p>
<dl class="cfunction">
<dt id="CvMatND* cvCloneMatND(const CvMatND* mat)">
<strong>C:</strong><code class="descname"> </code>CvMatND* <code class="descname">cvCloneMatND</code><span class="sig-paren">(</span>const CvMatND* <strong>mat</strong><span class="sig-paren">)</span><a class="headerlink" href="#CvMatND* cvCloneMatND(const CvMatND* mat)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="pyoldfunction">
<dt id="cv.CloneMatND">
<strong>Python:</strong><code class="descname"> </code><code class="descclassname">cv.</code><code class="descname">CloneMatND</code><span class="sig-paren">(</span>mat<span class="sig-paren">)</span> &rarr; matND<a class="headerlink" href="#cv.CloneMatND" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>mat</strong> &#8211; Input array</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="clonesparsemat">
<h2>CloneSparseMat<a class="headerlink" href="#clonesparsemat" title="Permalink to this headline">¶</a></h2>
<p>Creates full copy of sparse array.</p>
<dl class="cfunction">
<dt id="CvSparseMat* cvCloneSparseMat(const CvSparseMat* mat)">
<strong>C:</strong><code class="descname"> </code>CvSparseMat* <code class="descname">cvCloneSparseMat</code><span class="sig-paren">(</span>const CvSparseMat* <strong>mat</strong><span class="sig-paren">)</span><a class="headerlink" href="#CvSparseMat* cvCloneSparseMat(const CvSparseMat* mat)" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>mat</strong> &#8211; Input array</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<p>The function creates a copy of the input array and returns pointer to the copy.</p>
</div>
<div class="section" id="convertscale">
<h2>ConvertScale<a class="headerlink" href="#convertscale" title="Permalink to this headline">¶</a></h2>
<p>Converts one array to another with optional linear transformation.</p>
<dl class="cfunction">
<dt id="void cvConvertScale(const CvArr* src, CvArr* dst, double scale, double shift)">
<strong>C:</strong><code class="descname"> </code>void <code class="descname">cvConvertScale</code><span class="sig-paren">(</span>const CvArr* <strong>src</strong>, CvArr* <strong>dst</strong>, double <strong>scale</strong>=1, double <strong>shift</strong>=0<span class="sig-paren">)</span><a class="headerlink" href="#void cvConvertScale(const CvArr* src, CvArr* dst, double scale, double shift)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="pyoldfunction">
<dt id="cv.ConvertScale">
<strong>Python:</strong><code class="descname"> </code><code class="descclassname">cv.</code><code class="descname">ConvertScale</code><span class="sig-paren">(</span>src, dst, scale=1.0, shift=0.0<span class="sig-paren">)</span> &rarr; None<a class="headerlink" href="#cv.ConvertScale" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="pyoldfunction">
<dt id="cv.Convert">
<strong>Python:</strong><code class="descname"> </code><code class="descclassname">cv.</code><code class="descname">Convert</code><span class="sig-paren">(</span>src, dst<span class="sig-paren">)</span> &rarr; None<a class="headerlink" href="#cv.Convert" title="Permalink to this definition">¶</a></dt>
<dd><div class="highlight-c"><div class="highlight"><pre><span class="cp">#define cvCvtScale cvConvertScale</span>
<span class="cp">#define cvScale  cvConvertScale</span>
<span class="cp">#define cvConvert(src, dst )  cvConvertScale((src), (dst), 1, 0 )</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>src</strong> &#8211; Source array</li>
<li><strong>dst</strong> &#8211; Destination array</li>
<li><strong>scale</strong> &#8211; Scale factor</li>
<li><strong>shift</strong> &#8211; Value added to the scaled source array elements</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<p>The function has several different purposes, and thus has several different names. It copies one array to another with optional scaling, which is performed first, and/or optional type conversion, performed after:</p>
<div class="math">
<p><img src="../../../_images/math/be92607882e9d3d6808fa3a36abc0505a759f1ac.png" alt="\texttt{dst} (I) =  \texttt{scale} \texttt{src} (I) + ( \texttt{shift} _0, \texttt{shift} _1,...)"/></p>
</div><p>All the channels of multi-channel arrays are processed independently.</p>
<p>The type of conversion is done with rounding and saturation, that is if the
result of scaling + conversion can not be represented exactly by a value
of the destination array element type, it is set to the nearest representable
value on the real axis.</p>
</div>
<div class="section" id="copy">
<h2>Copy<a class="headerlink" href="#copy" title="Permalink to this headline">¶</a></h2>
<p>Copies one array to another.</p>
<dl class="cfunction">
<dt id="void cvCopy(const CvArr* src, CvArr* dst, const CvArr* mask)">
<strong>C:</strong><code class="descname"> </code>void <code class="descname">cvCopy</code><span class="sig-paren">(</span>const CvArr* <strong>src</strong>, CvArr* <strong>dst</strong>, const CvArr* <strong>mask</strong>=NULL<span class="sig-paren">)</span><a class="headerlink" href="#void cvCopy(const CvArr* src, CvArr* dst, const CvArr* mask)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="pyoldfunction">
<dt id="cv.Copy">
<strong>Python:</strong><code class="descname"> </code><code class="descclassname">cv.</code><code class="descname">Copy</code><span class="sig-paren">(</span>src, dst, mask=None<span class="sig-paren">)</span> &rarr; None<a class="headerlink" href="#cv.Copy" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>src</strong> &#8211; The source array</li>
<li><strong>dst</strong> &#8211; The destination array</li>
<li><strong>mask</strong> &#8211; Operation mask, 8-bit single channel array; specifies elements of the destination array to be changed</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<p>The function copies selected elements from an input array to an output array:</p>
<div class="math">
<p><img src="../../../_images/math/864d5a80a149618d7416fc11915941913e6a9829.png" alt="\texttt{dst} (I)= \texttt{src} (I)  \quad \text{if} \quad \texttt{mask} (I)  \ne 0."/></p>
</div><p>If any of the passed arrays is of <code class="docutils literal"><span class="pre">IplImage</span></code> type, then its ROI and COI fields are used. Both arrays must have the same type, the same number of dimensions, and the same size. The function can also copy sparse arrays (mask is not supported in this case).</p>
</div>
<div class="section" id="createdata">
<h2>CreateData<a class="headerlink" href="#createdata" title="Permalink to this headline">¶</a></h2>
<p>Allocates array data</p>
<dl class="cfunction">
<dt id="void cvCreateData(CvArr* arr)">
<strong>C:</strong><code class="descname"> </code>void <code class="descname">cvCreateData</code><span class="sig-paren">(</span>CvArr* <strong>arr</strong><span class="sig-paren">)</span><a class="headerlink" href="#void cvCreateData(CvArr* arr)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="pyoldfunction">
<dt id="cv.CreateData">
<strong>Python:</strong><code class="descname"> </code><code class="descclassname">cv.</code><code class="descname">CreateData</code><span class="sig-paren">(</span>arr<span class="sig-paren">)</span> &rarr; None<a class="headerlink" href="#cv.CreateData" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>arr</strong> &#8211; Array header</td>
</tr>
</tbody>
</table>
</dd></dl>

<p>The function allocates image, matrix or multi-dimensional dense array data. Note that in the case of matrix types OpenCV allocation functions are used. In the case of IplImage they are used
unless <code class="docutils literal"><span class="pre">CV_TURN_ON_IPL_COMPATIBILITY()</span></code> has been called before. In the latter case IPL functions are used to allocate the data.</p>
</div>
<div class="section" id="createimage">
<h2>CreateImage<a class="headerlink" href="#createimage" title="Permalink to this headline">¶</a></h2>
<p>Creates an image header and allocates the image data.</p>
<dl class="cfunction">
<dt id="IplImage* cvCreateImage(CvSize size, int depth, int channels)">
<strong>C:</strong><code class="descname"> </code>IplImage* <code class="descname">cvCreateImage</code><span class="sig-paren">(</span>CvSize <strong>size</strong>, int <strong>depth</strong>, int <strong>channels</strong><span class="sig-paren">)</span><a class="headerlink" href="#IplImage* cvCreateImage(CvSize size, int depth, int channels)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="pyoldfunction">
<dt id="cv.CreateImage">
<strong>Python:</strong><code class="descname"> </code><code class="descclassname">cv.</code><code class="descname">CreateImage</code><span class="sig-paren">(</span>size, depth, channels<span class="sig-paren">)</span> &rarr; image<a class="headerlink" href="#cv.CreateImage" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>size</strong> &#8211; Image width and height</li>
<li><strong>depth</strong> &#8211; Bit depth of image elements. See  <a class="reference internal" href="#IplImage" title="struct IplImage"><code class="xref ocv ocv-struct docutils literal"><span class="pre">IplImage</span></code></a>  for valid depths.</li>
<li><strong>channels</strong> &#8211; Number of channels per pixel. See  <a class="reference internal" href="#IplImage" title="struct IplImage"><code class="xref ocv ocv-struct docutils literal"><span class="pre">IplImage</span></code></a>  for details. This function only creates images with interleaved channels.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<p>This function call is equivalent to the following code:</p>
<div class="highlight-c"><div class="highlight"><pre><span class="n">header</span> <span class="o">=</span> <span class="n">cvCreateImageHeader</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="n">depth</span><span class="p">,</span> <span class="n">channels</span><span class="p">);</span>
<span class="n">cvCreateData</span><span class="p">(</span><span class="n">header</span><span class="p">);</span>
</pre></div>
</div>
</div>
<div class="section" id="createimageheader">
<h2>CreateImageHeader<a class="headerlink" href="#createimageheader" title="Permalink to this headline">¶</a></h2>
<p>Creates an image header but does not allocate the image data.</p>
<dl class="cfunction">
<dt id="IplImage* cvCreateImageHeader(CvSize size, int depth, int channels)">
<strong>C:</strong><code class="descname"> </code>IplImage* <code class="descname">cvCreateImageHeader</code><span class="sig-paren">(</span>CvSize <strong>size</strong>, int <strong>depth</strong>, int <strong>channels</strong><span class="sig-paren">)</span><a class="headerlink" href="#IplImage* cvCreateImageHeader(CvSize size, int depth, int channels)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="pyoldfunction">
<dt id="cv.CreateImageHeader">
<strong>Python:</strong><code class="descname"> </code><code class="descclassname">cv.</code><code class="descname">CreateImageHeader</code><span class="sig-paren">(</span>size, depth, channels<span class="sig-paren">)</span> &rarr; image<a class="headerlink" href="#cv.CreateImageHeader" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>size</strong> &#8211; Image width and height</li>
<li><strong>depth</strong> &#8211; Image depth (see  <a class="reference internal" href="#IplImage* cvCreateImage(CvSize size, int depth, int channels)" title="IplImage* cvCreateImage(CvSize size, int depth, int channels)"><code class="xref ocv ocv-cfunc docutils literal"><span class="pre">CreateImage()</span></code></a> )</li>
<li><strong>channels</strong> &#8211; Number of channels (see  <a class="reference internal" href="#IplImage* cvCreateImage(CvSize size, int depth, int channels)" title="IplImage* cvCreateImage(CvSize size, int depth, int channels)"><code class="xref ocv ocv-cfunc docutils literal"><span class="pre">CreateImage()</span></code></a> )</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="createmat">
<h2>CreateMat<a class="headerlink" href="#createmat" title="Permalink to this headline">¶</a></h2>
<p>Creates a matrix header and allocates the matrix data.</p>
<dl class="cfunction">
<dt id="CvMat* cvCreateMat(int rows, int cols, int type)">
<strong>C:</strong><code class="descname"> </code>CvMat* <code class="descname">cvCreateMat</code><span class="sig-paren">(</span>int <strong>rows</strong>, int <strong>cols</strong>, int <strong>type</strong><span class="sig-paren">)</span><a class="headerlink" href="#CvMat* cvCreateMat(int rows, int cols, int type)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="pyoldfunction">
<dt id="cv.CreateMat">
<strong>Python:</strong><code class="descname"> </code><code class="descclassname">cv.</code><code class="descname">CreateMat</code><span class="sig-paren">(</span>rows, cols, type<span class="sig-paren">)</span> &rarr; mat<a class="headerlink" href="#cv.CreateMat" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>rows</strong> &#8211; Number of rows in the matrix</li>
<li><strong>cols</strong> &#8211; Number of columns in the matrix</li>
<li><strong>type</strong> &#8211; The type of the matrix elements in the form  <code class="docutils literal"><span class="pre">CV_&lt;bit</span> <span class="pre">depth&gt;&lt;S|U|F&gt;C&lt;number</span> <span class="pre">of</span> <span class="pre">channels&gt;</span></code> , where S=signed, U=unsigned, F=float. For example, CV _ 8UC1 means the elements are 8-bit unsigned and the there is 1 channel, and CV _ 32SC2 means the elements are 32-bit signed and there are 2 channels.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<p>The function call is equivalent to the following code:</p>
<div class="highlight-c"><div class="highlight"><pre><span class="n">CvMat</span><span class="o">*</span> <span class="n">mat</span> <span class="o">=</span> <span class="n">cvCreateMatHeader</span><span class="p">(</span><span class="n">rows</span><span class="p">,</span> <span class="n">cols</span><span class="p">,</span> <span class="n">type</span><span class="p">);</span>
<span class="n">cvCreateData</span><span class="p">(</span><span class="n">mat</span><span class="p">);</span>
</pre></div>
</div>
</div>
<div class="section" id="creatematheader">
<h2>CreateMatHeader<a class="headerlink" href="#creatematheader" title="Permalink to this headline">¶</a></h2>
<p>Creates a matrix header but does not allocate the matrix data.</p>
<dl class="cfunction">
<dt id="CvMat* cvCreateMatHeader(int rows, int cols, int type)">
<strong>C:</strong><code class="descname"> </code>CvMat* <code class="descname">cvCreateMatHeader</code><span class="sig-paren">(</span>int <strong>rows</strong>, int <strong>cols</strong>, int <strong>type</strong><span class="sig-paren">)</span><a class="headerlink" href="#CvMat* cvCreateMatHeader(int rows, int cols, int type)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="pyoldfunction">
<dt id="cv.CreateMatHeader">
<strong>Python:</strong><code class="descname"> </code><code class="descclassname">cv.</code><code class="descname">CreateMatHeader</code><span class="sig-paren">(</span>rows, cols, type<span class="sig-paren">)</span> &rarr; mat<a class="headerlink" href="#cv.CreateMatHeader" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>rows</strong> &#8211; Number of rows in the matrix</li>
<li><strong>cols</strong> &#8211; Number of columns in the matrix</li>
<li><strong>type</strong> &#8211; Type of the matrix elements, see  <a class="reference internal" href="#CvMat* cvCreateMat(int rows, int cols, int type)" title="CvMat* cvCreateMat(int rows, int cols, int type)"><code class="xref ocv ocv-cfunc docutils literal"><span class="pre">CreateMat()</span></code></a></li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<p>The function allocates a new matrix header and returns a pointer to it. The matrix data can then be allocated using <a class="reference internal" href="#void cvCreateData(CvArr* arr)" title="void cvCreateData(CvArr* arr)"><code class="xref ocv ocv-cfunc docutils literal"><span class="pre">CreateData()</span></code></a> or set explicitly to user-allocated data via <a class="reference internal" href="#void cvSetData(CvArr* arr, void* data, int step)" title="void cvSetData(CvArr* arr, void* data, int step)"><code class="xref ocv ocv-cfunc docutils literal"><span class="pre">SetData()</span></code></a>.</p>
</div>
<div class="section" id="creatematnd">
<h2>CreateMatND<a class="headerlink" href="#creatematnd" title="Permalink to this headline">¶</a></h2>
<p>Creates the header and allocates the data for a multi-dimensional dense array.</p>
<dl class="cfunction">
<dt id="CvMatND* cvCreateMatND(int dims, const int* sizes, int type)">
<strong>C:</strong><code class="descname"> </code>CvMatND* <code class="descname">cvCreateMatND</code><span class="sig-paren">(</span>int <strong>dims</strong>, const int* <strong>sizes</strong>, int <strong>type</strong><span class="sig-paren">)</span><a class="headerlink" href="#CvMatND* cvCreateMatND(int dims, const int* sizes, int type)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="pyoldfunction">
<dt id="cv.CreateMatND">
<strong>Python:</strong><code class="descname"> </code><code class="descclassname">cv.</code><code class="descname">CreateMatND</code><span class="sig-paren">(</span>dims, type<span class="sig-paren">)</span> &rarr; matND<a class="headerlink" href="#cv.CreateMatND" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>dims</strong> &#8211; Number of array dimensions. This must not exceed CV_MAX_DIM (32 by default, but can be changed at build time).</li>
<li><strong>sizes</strong> &#8211; Array of dimension sizes.</li>
<li><strong>type</strong> &#8211; Type of array elements, see  <a class="reference internal" href="#CvMat* cvCreateMat(int rows, int cols, int type)" title="CvMat* cvCreateMat(int rows, int cols, int type)"><code class="xref ocv ocv-cfunc docutils literal"><span class="pre">CreateMat()</span></code></a> .</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<p>This function call is equivalent to the following code:</p>
<div class="highlight-c"><div class="highlight"><pre><span class="n">CvMatND</span><span class="o">*</span> <span class="n">mat</span> <span class="o">=</span> <span class="n">cvCreateMatNDHeader</span><span class="p">(</span><span class="n">dims</span><span class="p">,</span> <span class="n">sizes</span><span class="p">,</span> <span class="n">type</span><span class="p">);</span>
<span class="n">cvCreateData</span><span class="p">(</span><span class="n">mat</span><span class="p">);</span>
</pre></div>
</div>
</div>
<div class="section" id="creatematndheader">
<h2>CreateMatNDHeader<a class="headerlink" href="#creatematndheader" title="Permalink to this headline">¶</a></h2>
<p>Creates a new matrix header but does not allocate the matrix data.</p>
<dl class="cfunction">
<dt id="CvMatND* cvCreateMatNDHeader(int dims, const int* sizes, int type)">
<strong>C:</strong><code class="descname"> </code>CvMatND* <code class="descname">cvCreateMatNDHeader</code><span class="sig-paren">(</span>int <strong>dims</strong>, const int* <strong>sizes</strong>, int <strong>type</strong><span class="sig-paren">)</span><a class="headerlink" href="#CvMatND* cvCreateMatNDHeader(int dims, const int* sizes, int type)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="pyoldfunction">
<dt id="cv.CreateMatNDHeader">
<strong>Python:</strong><code class="descname"> </code><code class="descclassname">cv.</code><code class="descname">CreateMatNDHeader</code><span class="sig-paren">(</span>dims, type<span class="sig-paren">)</span> &rarr; matND<a class="headerlink" href="#cv.CreateMatNDHeader" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>dims</strong> &#8211; Number of array dimensions</li>
<li><strong>sizes</strong> &#8211; Array of dimension sizes</li>
<li><strong>type</strong> &#8211; Type of array elements, see  <a class="reference internal" href="#CvMat* cvCreateMat(int rows, int cols, int type)" title="CvMat* cvCreateMat(int rows, int cols, int type)"><code class="xref ocv ocv-cfunc docutils literal"><span class="pre">CreateMat()</span></code></a></li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<p>The function allocates a header for a multi-dimensional dense array. The array data can further be allocated using  <a class="reference internal" href="#void cvCreateData(CvArr* arr)" title="void cvCreateData(CvArr* arr)"><code class="xref ocv ocv-cfunc docutils literal"><span class="pre">CreateData()</span></code></a> or set explicitly to user-allocated data via  <a class="reference internal" href="#void cvSetData(CvArr* arr, void* data, int step)" title="void cvSetData(CvArr* arr, void* data, int step)"><code class="xref ocv ocv-cfunc docutils literal"><span class="pre">SetData()</span></code></a>.</p>
</div>
<div class="section" id="createsparsemat">
<h2>CreateSparseMat<a class="headerlink" href="#createsparsemat" title="Permalink to this headline">¶</a></h2>
<p>Creates sparse array.</p>
<dl class="cfunction">
<dt id="CvSparseMat* cvCreateSparseMat(int dims, const int* sizes, int type)">
<strong>C:</strong><code class="descname"> </code>CvSparseMat* <code class="descname">cvCreateSparseMat</code><span class="sig-paren">(</span>int <strong>dims</strong>, const int* <strong>sizes</strong>, int <strong>type</strong><span class="sig-paren">)</span><a class="headerlink" href="#CvSparseMat* cvCreateSparseMat(int dims, const int* sizes, int type)" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>dims</strong> &#8211; Number of array dimensions. In contrast to the dense matrix, the number of dimensions is practically unlimited (up to  <img class="math" src="../../../_images/math/178faa8ce9f1ba63862e15a1ce3edcbfd634919b.png" alt="2^{16}"/> ).</li>
<li><strong>sizes</strong> &#8211; Array of dimension sizes</li>
<li><strong>type</strong> &#8211; Type of array elements. The same as for CvMat</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<p>The function allocates a multi-dimensional sparse array. Initially the array contain no elements, that is
<a class="reference internal" href="#uchar* cvPtrND(const CvArr* arr, const int* idx, int* type, int create_node, unsigned* precalc_hashval)" title="uchar* cvPtrND(const CvArr* arr, const int* idx, int* type, int create_node, unsigned* precalc_hashval)"><code class="xref ocv ocv-cfunc docutils literal"><span class="pre">PtrND()</span></code></a> and other related functions will return 0 for every index.</p>
</div>
<div class="section" id="crossproduct">
<h2>CrossProduct<a class="headerlink" href="#crossproduct" title="Permalink to this headline">¶</a></h2>
<p>Calculates the cross product of two 3D vectors.</p>
<dl class="cfunction">
<dt id="void cvCrossProduct(const CvArr* src1, const CvArr* src2, CvArr* dst)">
<strong>C:</strong><code class="descname"> </code>void <code class="descname">cvCrossProduct</code><span class="sig-paren">(</span>const CvArr* <strong>src1</strong>, const CvArr* <strong>src2</strong>, CvArr* <strong>dst</strong><span class="sig-paren">)</span><a class="headerlink" href="#void cvCrossProduct(const CvArr* src1, const CvArr* src2, CvArr* dst)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="pyoldfunction">
<dt id="cv.CrossProduct">
<strong>Python:</strong><code class="descname"> </code><code class="descclassname">cv.</code><code class="descname">CrossProduct</code><span class="sig-paren">(</span>src1, src2, dst<span class="sig-paren">)</span> &rarr; None<a class="headerlink" href="#cv.CrossProduct" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>src1</strong> &#8211; The first source vector</li>
<li><strong>src2</strong> &#8211; The second source vector</li>
<li><strong>dst</strong> &#8211; The destination vector</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<p>The function calculates the cross product of two 3D vectors:</p>
<div class="math">
<p><img src="../../../_images/math/e2465c99347512bc05e1eedd1ca313cb81b35d48.png" alt="\texttt{dst} =  \texttt{src1} \times \texttt{src2}"/></p>
</div><p>or:</p>
<div class="math">
<p><img src="../../../_images/math/319c08a18a77d1ff77fd0f766ad1dbb2d31a6c51.png" alt="\begin{array}{l} \texttt{dst} _1 =  \texttt{src1} _2  \texttt{src2} _3 -  \texttt{src1} _3  \texttt{src2} _2 \\ \texttt{dst} _2 =  \texttt{src1} _3  \texttt{src2} _1 -  \texttt{src1} _1  \texttt{src2} _3 \\ \texttt{dst} _3 =  \texttt{src1} _1  \texttt{src2} _2 -  \texttt{src1} _2  \texttt{src2} _1 \end{array}"/></p>
</div></div>
<div class="section" id="dotproduct">
<h2>DotProduct<a class="headerlink" href="#dotproduct" title="Permalink to this headline">¶</a></h2>
<p>Calculates the dot product of two arrays in Euclidean metrics.</p>
<dl class="cfunction">
<dt id="double cvDotProduct(const CvArr* src1, const CvArr* src2)">
<strong>C:</strong><code class="descname"> </code>double <code class="descname">cvDotProduct</code><span class="sig-paren">(</span>const CvArr* <strong>src1</strong>, const CvArr* <strong>src2</strong><span class="sig-paren">)</span><a class="headerlink" href="#double cvDotProduct(const CvArr* src1, const CvArr* src2)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="pyoldfunction">
<dt id="cv.DotProduct">
<strong>Python:</strong><code class="descname"> </code><code class="descclassname">cv.</code><code class="descname">DotProduct</code><span class="sig-paren">(</span>src1, src2<span class="sig-paren">)</span> &rarr; float<a class="headerlink" href="#cv.DotProduct" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>src1</strong> &#8211; The first source array</li>
<li><strong>src2</strong> &#8211; The second source array</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<p>The function calculates and returns the Euclidean dot product of two arrays.</p>
<div class="math">
<p><img src="../../../_images/math/2e55aa064716c56c28c7cb14c8d02ae883dabb2e.png" alt="src1  \bullet src2 =  \sum _I ( \texttt{src1} (I)  \texttt{src2} (I))"/></p>
</div><p>In the case of multiple channel arrays, the results for all channels are accumulated. In particular,
<code class="docutils literal"><span class="pre">cvDotProduct(a,a)</span></code> where  <code class="docutils literal"><span class="pre">a</span></code> is a complex vector, will return  <img class="math" src="../../../_images/math/7bee88b8830bae2186f7041bf02e796e1efb0cc9.png" alt="||\texttt{a}||^2"/>.
The function can process multi-dimensional arrays, row by row, layer by layer, and so on.</p>
</div>
<div class="section" id="get-d">
<h2>Get?D<a class="headerlink" href="#get-d" title="Permalink to this headline">¶</a></h2>
<dl class="cfunction">
<dt id="CvScalar cvGet1D(const CvArr* arr, int idx0)">
<strong>C:</strong><code class="descname"> </code>CvScalar <code class="descname">cvGet1D</code><span class="sig-paren">(</span>const CvArr* <strong>arr</strong>, int <strong>idx0</strong><span class="sig-paren">)</span><a class="headerlink" href="#CvScalar cvGet1D(const CvArr* arr, int idx0)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="cfunction">
<dt id="CvScalar cvGet2D(const CvArr* arr, int idx0, int idx1)">
<strong>C:</strong><code class="descname"> </code>CvScalar <code class="descname">cvGet2D</code><span class="sig-paren">(</span>const CvArr* <strong>arr</strong>, int <strong>idx0</strong>, int <strong>idx1</strong><span class="sig-paren">)</span><a class="headerlink" href="#CvScalar cvGet2D(const CvArr* arr, int idx0, int idx1)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="cfunction">
<dt id="CvScalar cvGet3D(const CvArr* arr, int idx0, int idx1, int idx2)">
<strong>C:</strong><code class="descname"> </code>CvScalar <code class="descname">cvGet3D</code><span class="sig-paren">(</span>const CvArr* <strong>arr</strong>, int <strong>idx0</strong>, int <strong>idx1</strong>, int <strong>idx2</strong><span class="sig-paren">)</span><a class="headerlink" href="#CvScalar cvGet3D(const CvArr* arr, int idx0, int idx1, int idx2)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="cfunction">
<dt id="CvScalar cvGetND(const CvArr* arr, const int* idx)">
<strong>C:</strong><code class="descname"> </code>CvScalar <code class="descname">cvGetND</code><span class="sig-paren">(</span>const CvArr* <strong>arr</strong>, const int* <strong>idx</strong><span class="sig-paren">)</span><a class="headerlink" href="#CvScalar cvGetND(const CvArr* arr, const int* idx)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="pyoldfunction">
<dt id="cv.Get1D">
<strong>Python:</strong><code class="descname"> </code><code class="descclassname">cv.</code><code class="descname">Get1D</code><span class="sig-paren">(</span>arr, idx<span class="sig-paren">)</span> &rarr; scalar<a class="headerlink" href="#cv.Get1D" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="pyoldfunction">
<dt id="cv.Get2D">
<strong>Python:</strong><code class="descname"> </code><code class="descclassname">cv.</code><code class="descname">Get2D</code><span class="sig-paren">(</span>arr, idx0, idx1<span class="sig-paren">)</span> &rarr; scalar<a class="headerlink" href="#cv.Get2D" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="pyoldfunction">
<dt id="cv.Get3D">
<strong>Python:</strong><code class="descname"> </code><code class="descclassname">cv.</code><code class="descname">Get3D</code><span class="sig-paren">(</span>arr, idx0, idx1, idx2<span class="sig-paren">)</span> &rarr; scalar<a class="headerlink" href="#cv.Get3D" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="pyoldfunction">
<dt id="cv.GetND">
<strong>Python:</strong><code class="descname"> </code><code class="descclassname">cv.</code><code class="descname">GetND</code><span class="sig-paren">(</span>arr, indices<span class="sig-paren">)</span> &rarr; scalar<a class="headerlink" href="#cv.GetND" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a specific array element.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>arr</strong> &#8211; Input array</li>
<li><strong>idx0</strong> &#8211; The first zero-based component of the element index</li>
<li><strong>idx1</strong> &#8211; The second zero-based component of the element index</li>
<li><strong>idx2</strong> &#8211; The third zero-based component of the element index</li>
<li><strong>idx</strong> &#8211; Array of the element indices</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<p>The functions return a specific array element. In the case of a sparse array the functions return 0 if the requested node does not exist (no new node is created by the functions).</p>
</div>
<div class="section" id="getcol-s">
<h2>GetCol(s)<a class="headerlink" href="#getcol-s" title="Permalink to this headline">¶</a></h2>
<p>Returns one of more array columns.</p>
<dl class="cfunction">
<dt id="CvMat* cvGetCol(const CvArr* arr, CvMat* submat, int col)">
<strong>C:</strong><code class="descname"> </code>CvMat* <code class="descname">cvGetCol</code><span class="sig-paren">(</span>const CvArr* <strong>arr</strong>, CvMat* <strong>submat</strong>, int <strong>col</strong><span class="sig-paren">)</span><a class="headerlink" href="#CvMat* cvGetCol(const CvArr* arr, CvMat* submat, int col)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="cfunction">
<dt id="CvMat* cvGetCols(const CvArr* arr, CvMat* submat, int start_col, int end_col)">
<strong>C:</strong><code class="descname"> </code>CvMat* <code class="descname">cvGetCols</code><span class="sig-paren">(</span>const CvArr* <strong>arr</strong>, CvMat* <strong>submat</strong>, int <strong>start_col</strong>, int <strong>end_col</strong><span class="sig-paren">)</span><a class="headerlink" href="#CvMat* cvGetCols(const CvArr* arr, CvMat* submat, int start_col, int end_col)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="pyoldfunction">
<dt id="cv.GetCol">
<strong>Python:</strong><code class="descname"> </code><code class="descclassname">cv.</code><code class="descname">GetCol</code><span class="sig-paren">(</span>arr, col<span class="sig-paren">)</span> &rarr; submat<a class="headerlink" href="#cv.GetCol" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="pyoldfunction">
<dt id="cv.GetCols">
<strong>Python:</strong><code class="descname"> </code><code class="descclassname">cv.</code><code class="descname">GetCols</code><span class="sig-paren">(</span>arr, startCol, endCol<span class="sig-paren">)</span> &rarr; submat<a class="headerlink" href="#cv.GetCols" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>arr</strong> &#8211; Input array</li>
<li><strong>submat</strong> &#8211; Pointer to the resulting sub-array header</li>
<li><strong>col</strong> &#8211; Zero-based index of the selected column</li>
<li><strong>start_col</strong> &#8211; Zero-based index of the starting column (inclusive) of the span</li>
<li><strong>end_col</strong> &#8211; Zero-based index of the ending column (exclusive) of the span</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<p>The functions return the header, corresponding to a specified column span of the input array. That is, no data is copied. Therefore, any modifications of the submatrix will affect the original array. If you need to copy the columns, use <a class="reference internal" href="#CvMat* cvCloneMat(const CvMat* mat)" title="CvMat* cvCloneMat(const CvMat* mat)"><code class="xref ocv ocv-cfunc docutils literal"><span class="pre">CloneMat()</span></code></a>. <code class="docutils literal"><span class="pre">cvGetCol(arr,</span> <span class="pre">submat,</span> <span class="pre">col)</span></code> is a shortcut for <code class="docutils literal"><span class="pre">cvGetCols(arr,</span> <span class="pre">submat,</span> <span class="pre">col,</span> <span class="pre">col+1)</span></code>.</p>
</div>
<div class="section" id="getdiag">
<h2>GetDiag<a class="headerlink" href="#getdiag" title="Permalink to this headline">¶</a></h2>
<p>Returns one of array diagonals.</p>
<dl class="cfunction">
<dt id="CvMat* cvGetDiag(const CvArr* arr, CvMat* submat, int diag)">
<strong>C:</strong><code class="descname"> </code>CvMat* <code class="descname">cvGetDiag</code><span class="sig-paren">(</span>const CvArr* <strong>arr</strong>, CvMat* <strong>submat</strong>, int <strong>diag</strong>=0<span class="sig-paren">)</span><a class="headerlink" href="#CvMat* cvGetDiag(const CvArr* arr, CvMat* submat, int diag)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="pyoldfunction">
<dt id="cv.GetDiag">
<strong>Python:</strong><code class="descname"> </code><code class="descclassname">cv.</code><code class="descname">GetDiag</code><span class="sig-paren">(</span>arr, diag=0<span class="sig-paren">)</span> &rarr; submat<a class="headerlink" href="#cv.GetDiag" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>arr</strong> &#8211; Input array</li>
<li><strong>submat</strong> &#8211; Pointer to the resulting sub-array header</li>
<li><strong>diag</strong> &#8211; Index of the array diagonal. Zero value corresponds to the main diagonal, -1 corresponds to the diagonal above the main, 1 corresponds to the diagonal below the main, and so forth.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<p>The function returns the header, corresponding to a specified diagonal of the input array.</p>
</div>
<div class="section" id="getdims">
<h2>GetDims<a class="headerlink" href="#getdims" title="Permalink to this headline">¶</a></h2>
<p>Return number of array dimensions</p>
<dl class="cfunction">
<dt id="int cvGetDims(const CvArr* arr, int* sizes)">
<strong>C:</strong><code class="descname"> </code>int <code class="descname">cvGetDims</code><span class="sig-paren">(</span>const CvArr* <strong>arr</strong>, int* <strong>sizes</strong>=NULL<span class="sig-paren">)</span><a class="headerlink" href="#int cvGetDims(const CvArr* arr, int* sizes)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="pyoldfunction">
<dt id="cv.GetDims">
<strong>Python:</strong><code class="descname"> </code><code class="descclassname">cv.</code><code class="descname">GetDims</code><span class="sig-paren">(</span>arr) -&gt; (dim1, dim2, ...<span class="sig-paren">)</span><a class="headerlink" href="#cv.GetDims" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>arr</strong> &#8211; Input array</li>
<li><strong>sizes</strong> &#8211; Optional output vector of the array dimension sizes. For
2d arrays the number of rows (height) goes first, number of columns
(width) next.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<p>The function returns the array dimensionality and the array of dimension sizes. In the case of  <code class="docutils literal"><span class="pre">IplImage</span></code> or <cite>CvMat</cite> it always returns 2 regardless of number of image/matrix rows. For example, the following code calculates total number of array elements:</p>
<div class="highlight-c"><div class="highlight"><pre><span class="kt">int</span> <span class="n">sizes</span><span class="p">[</span><span class="n">CV_MAX_DIM</span><span class="p">];</span>
<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">total</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">dims</span> <span class="o">=</span> <span class="n">cvGetDims</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
<span class="k">for</span><span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">dims</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span> <span class="p">)</span>
    <span class="n">total</span> <span class="o">*=</span> <span class="n">sizes</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
</pre></div>
</div>
</div>
<div class="section" id="getdimsize">
<h2>GetDimSize<a class="headerlink" href="#getdimsize" title="Permalink to this headline">¶</a></h2>
<p>Returns array size along the specified dimension.</p>
<dl class="cfunction">
<dt id="int cvGetDimSize(const CvArr* arr, int index)">
<strong>C:</strong><code class="descname"> </code>int <code class="descname">cvGetDimSize</code><span class="sig-paren">(</span>const CvArr* <strong>arr</strong>, int <strong>index</strong><span class="sig-paren">)</span><a class="headerlink" href="#int cvGetDimSize(const CvArr* arr, int index)" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>arr</strong> &#8211; Input array</li>
<li><strong>index</strong> &#8211; Zero-based dimension index (for matrices 0 means number of rows, 1 means number of columns; for images 0 means height, 1 means width)</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="getelemtype">
<h2>GetElemType<a class="headerlink" href="#getelemtype" title="Permalink to this headline">¶</a></h2>
<p>Returns type of array elements.</p>
<dl class="cfunction">
<dt id="int cvGetElemType(const CvArr* arr)">
<strong>C:</strong><code class="descname"> </code>int <code class="descname">cvGetElemType</code><span class="sig-paren">(</span>const CvArr* <strong>arr</strong><span class="sig-paren">)</span><a class="headerlink" href="#int cvGetElemType(const CvArr* arr)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="pyoldfunction">
<dt id="cv.GetElemType">
<strong>Python:</strong><code class="descname"> </code><code class="descclassname">cv.</code><code class="descname">GetElemType</code><span class="sig-paren">(</span>arr<span class="sig-paren">)</span> &rarr; int<a class="headerlink" href="#cv.GetElemType" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>arr</strong> &#8211; Input array</td>
</tr>
</tbody>
</table>
</dd></dl>

<p>The function returns type of the array elements. In the case of <code class="docutils literal"><span class="pre">IplImage</span></code> the type is converted to <code class="docutils literal"><span class="pre">CvMat</span></code>-like representation. For example, if the image has been created as:</p>
<div class="highlight-c"><div class="highlight"><pre><span class="n">IplImage</span><span class="o">*</span> <span class="n">img</span> <span class="o">=</span> <span class="n">cvCreateImage</span><span class="p">(</span><span class="n">cvSize</span><span class="p">(</span><span class="mi">640</span><span class="p">,</span> <span class="mi">480</span><span class="p">),</span> <span class="n">IPL_DEPTH_8U</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span>
</pre></div>
</div>
<p>The code <code class="docutils literal"><span class="pre">cvGetElemType(img)</span></code> will return <code class="docutils literal"><span class="pre">CV_8UC3</span></code>.</p>
</div>
<div class="section" id="getimage">
<h2>GetImage<a class="headerlink" href="#getimage" title="Permalink to this headline">¶</a></h2>
<p>Returns image header for arbitrary array.</p>
<dl class="cfunction">
<dt id="IplImage* cvGetImage(const CvArr* arr, IplImage* image_header)">
<strong>C:</strong><code class="descname"> </code>IplImage* <code class="descname">cvGetImage</code><span class="sig-paren">(</span>const CvArr* <strong>arr</strong>, IplImage* <strong>image_header</strong><span class="sig-paren">)</span><a class="headerlink" href="#IplImage* cvGetImage(const CvArr* arr, IplImage* image_header)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="pyoldfunction">
<dt id="cv.GetImage">
<strong>Python:</strong><code class="descname"> </code><code class="descclassname">cv.</code><code class="descname">GetImage</code><span class="sig-paren">(</span>arr<span class="sig-paren">)</span> &rarr; iplimage<a class="headerlink" href="#cv.GetImage" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>arr</strong> &#8211; Input array</li>
<li><strong>image_header</strong> &#8211; Pointer to  <code class="docutils literal"><span class="pre">IplImage</span></code>  structure used as a temporary buffer</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<p>The function returns the image header for the input array that can be a matrix (<a class="reference internal" href="#CvMat" title="struct CvMat"><code class="xref ocv ocv-struct docutils literal"><span class="pre">CvMat</span></code></a>) or image (<a class="reference internal" href="#IplImage" title="struct IplImage"><code class="xref ocv ocv-struct docutils literal"><span class="pre">IplImage</span></code></a>). In the case of an image the function simply returns the input pointer. In the case of <code class="docutils literal"><span class="pre">CvMat</span></code> it initializes an <code class="docutils literal"><span class="pre">image_header</span></code> structure with the parameters of the input matrix. Note that if we transform <code class="docutils literal"><span class="pre">IplImage</span></code> to <code class="docutils literal"><span class="pre">CvMat</span></code> using <a class="reference internal" href="#CvMat* cvGetMat(const CvArr* arr, CvMat* header, int* coi, int allowND)" title="CvMat* cvGetMat(const CvArr* arr, CvMat* header, int* coi, int allowND)"><code class="xref ocv ocv-cfunc docutils literal"><span class="pre">GetMat()</span></code></a> and then transform <code class="docutils literal"><span class="pre">CvMat</span></code> back to IplImage using this function, we will get different headers if the ROI is set in the original image.</p>
</div>
<div class="section" id="getimagecoi">
<h2>GetImageCOI<a class="headerlink" href="#getimagecoi" title="Permalink to this headline">¶</a></h2>
<p>Returns the index of the channel of interest.</p>
<dl class="cfunction">
<dt id="int cvGetImageCOI(const IplImage* image)">
<strong>C:</strong><code class="descname"> </code>int <code class="descname">cvGetImageCOI</code><span class="sig-paren">(</span>const IplImage* <strong>image</strong><span class="sig-paren">)</span><a class="headerlink" href="#int cvGetImageCOI(const IplImage* image)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="pyoldfunction">
<dt id="cv.GetImageCOI">
<strong>Python:</strong><code class="descname"> </code><code class="descclassname">cv.</code><code class="descname">GetImageCOI</code><span class="sig-paren">(</span>image<span class="sig-paren">)</span> &rarr; int<a class="headerlink" href="#cv.GetImageCOI" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>image</strong> &#8211; A pointer to the image header</td>
</tr>
</tbody>
</table>
</dd></dl>

<p>Returns the channel of interest of in an IplImage. Returned values correspond to the <code class="docutils literal"><span class="pre">coi</span></code> in
<a class="reference internal" href="#void cvSetImageCOI(IplImage* image, int coi)" title="void cvSetImageCOI(IplImage* image, int coi)"><code class="xref ocv ocv-cfunc docutils literal"><span class="pre">SetImageCOI()</span></code></a>.</p>
</div>
<div class="section" id="getimageroi">
<h2>GetImageROI<a class="headerlink" href="#getimageroi" title="Permalink to this headline">¶</a></h2>
<p>Returns the image ROI.</p>
<dl class="cfunction">
<dt id="CvRect cvGetImageROI(const IplImage* image)">
<strong>C:</strong><code class="descname"> </code>CvRect <code class="descname">cvGetImageROI</code><span class="sig-paren">(</span>const IplImage* <strong>image</strong><span class="sig-paren">)</span><a class="headerlink" href="#CvRect cvGetImageROI(const IplImage* image)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="pyoldfunction">
<dt id="cv.GetImageROI">
<strong>Python:</strong><code class="descname"> </code><code class="descclassname">cv.</code><code class="descname">GetImageROI</code><span class="sig-paren">(</span>image<span class="sig-paren">)</span> &rarr; CvRect<a class="headerlink" href="#cv.GetImageROI" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>image</strong> &#8211; A pointer to the image header</td>
</tr>
</tbody>
</table>
</dd></dl>

<p>If there is no ROI set, <code class="docutils literal"><span class="pre">cvRect(0,0,image-&gt;width,image-&gt;height)</span></code> is returned.</p>
</div>
<div class="section" id="getmat">
<h2>GetMat<a class="headerlink" href="#getmat" title="Permalink to this headline">¶</a></h2>
<p>Returns matrix header for arbitrary array.</p>
<dl class="cfunction">
<dt id="CvMat* cvGetMat(const CvArr* arr, CvMat* header, int* coi, int allowND)">
<strong>C:</strong><code class="descname"> </code>CvMat* <code class="descname">cvGetMat</code><span class="sig-paren">(</span>const CvArr* <strong>arr</strong>, CvMat* <strong>header</strong>, int* <strong>coi</strong>=NULL, int <strong>allowND</strong>=0<span class="sig-paren">)</span><a class="headerlink" href="#CvMat* cvGetMat(const CvArr* arr, CvMat* header, int* coi, int allowND)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="pyoldfunction">
<dt id="cv.GetMat">
<strong>Python:</strong><code class="descname"> </code><code class="descclassname">cv.</code><code class="descname">GetMat</code><span class="sig-paren">(</span>arr, allowND=0<span class="sig-paren">)</span> &rarr; mat<a class="headerlink" href="#cv.GetMat" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>arr</strong> &#8211; Input array</li>
<li><strong>header</strong> &#8211; Pointer to  <a class="reference internal" href="#CvMat" title="struct CvMat"><code class="xref ocv ocv-struct docutils literal"><span class="pre">CvMat</span></code></a>  structure used as a temporary buffer</li>
<li><strong>coi</strong> &#8211; Optional output parameter for storing COI</li>
<li><strong>allowND</strong> &#8211; If non-zero, the function accepts multi-dimensional dense arrays (CvMatND*) and returns 2D matrix (if CvMatND has two dimensions) or 1D matrix (when CvMatND has 1 dimension or more than 2 dimensions). The <code class="docutils literal"><span class="pre">CvMatND</span></code> array must be continuous.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<p>The function returns a matrix header for the input array that can be a matrix - <a class="reference internal" href="#CvMat" title="struct CvMat"><code class="xref ocv ocv-struct docutils literal"><span class="pre">CvMat</span></code></a>, an image - <a class="reference internal" href="#IplImage" title="struct IplImage"><code class="xref ocv ocv-struct docutils literal"><span class="pre">IplImage</span></code></a>, or a multi-dimensional dense array - <a class="reference internal" href="#CvMatND" title="struct CvMatND"><code class="xref ocv ocv-struct docutils literal"><span class="pre">CvMatND</span></code></a> (the third option is allowed only if <code class="docutils literal"><span class="pre">allowND</span> <span class="pre">!=</span> <span class="pre">0</span></code>) . In the case of matrix the function simply returns the input pointer. In the case of <code class="docutils literal"><span class="pre">IplImage*</span></code> or <code class="docutils literal"><span class="pre">CvMatND</span></code> it initializes the <code class="docutils literal"><span class="pre">header</span></code> structure with parameters of the current image ROI and returns <code class="docutils literal"><span class="pre">&amp;header</span></code>. Because COI is not supported by <code class="docutils literal"><span class="pre">CvMat</span></code>, it is returned separately.</p>
<p>The function provides an easy way to handle both types of arrays - <code class="docutils literal"><span class="pre">IplImage</span></code> and  <code class="docutils literal"><span class="pre">CvMat</span></code> using the same code. Input array must have non-zero data pointer, otherwise the function will report an error.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#IplImage* cvGetImage(const CvArr* arr, IplImage* image_header)" title="IplImage* cvGetImage(const CvArr* arr, IplImage* image_header)"><code class="xref ocv ocv-cfunc docutils literal"><span class="pre">GetImage()</span></code></a>, <a class="reference internal" href="operations_on_arrays.html#Mat cvarrToMat(const CvArr* arr, bool copyData, bool allowND, int coiMode)" title="Mat cvarrToMat(const CvArr* arr, bool copyData, bool allowND, int coiMode)"><code class="xref ocv ocv-func docutils literal"><span class="pre">cvarrToMat()</span></code></a>.</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">If the input array is <code class="docutils literal"><span class="pre">IplImage</span></code> with planar data layout and COI set, the function returns the pointer to the selected plane and <code class="docutils literal"><span class="pre">COI</span> <span class="pre">==</span> <span class="pre">0</span></code>. This feature allows user to process <code class="docutils literal"><span class="pre">IplImage</span></code> structures with planar data layout, even though OpenCV does not support such images.</p>
</div>
</div>
<div class="section" id="getnextsparsenode">
<h2>GetNextSparseNode<a class="headerlink" href="#getnextsparsenode" title="Permalink to this headline">¶</a></h2>
<p>Returns the next sparse matrix element</p>
<dl class="cfunction">
<dt id="CvSparseNode* cvGetNextSparseNode(CvSparseMatIterator* mat_iterator)">
<strong>C:</strong><code class="descname"> </code>CvSparseNode* <code class="descname">cvGetNextSparseNode</code><span class="sig-paren">(</span>CvSparseMatIterator* <strong>mat_iterator</strong><span class="sig-paren">)</span><a class="headerlink" href="#CvSparseNode* cvGetNextSparseNode(CvSparseMatIterator* mat_iterator)" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>mat_iterator</strong> &#8211; Sparse array iterator</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<p>The function moves iterator to the next sparse matrix element and returns pointer to it. In the current version there is no any particular order of the elements, because they are stored in the hash table. The sample below demonstrates how to iterate through the sparse matrix:</p>
<div class="highlight-c"><div class="highlight"><pre><span class="c1">// print all the non-zero sparse matrix elements and compute their sum</span>
<span class="kt">double</span> <span class="n">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">dims</span> <span class="o">=</span> <span class="n">cvGetDims</span><span class="p">(</span><span class="n">sparsemat</span><span class="p">);</span>
<span class="n">CvSparseMatIterator</span> <span class="n">it</span><span class="p">;</span>
<span class="n">CvSparseNode</span><span class="o">*</span> <span class="n">node</span> <span class="o">=</span> <span class="n">cvInitSparseMatIterator</span><span class="p">(</span><span class="n">sparsemat</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">it</span><span class="p">);</span>

<span class="k">for</span><span class="p">(;</span> <span class="n">node</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">node</span> <span class="o">=</span> <span class="n">cvGetNextSparseNode</span><span class="p">(</span><span class="o">&amp;</span><span class="n">it</span><span class="p">))</span>
<span class="p">{</span>
    <span class="cm">/* get pointer to the element indices */</span>
    <span class="kt">int</span><span class="o">*</span> <span class="n">idx</span> <span class="o">=</span> <span class="n">CV_NODE_IDX</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">node</span><span class="p">);</span>
    <span class="cm">/* get value of the element (assume that the type is CV_32FC1) */</span>
    <span class="kt">float</span> <span class="n">val</span> <span class="o">=</span> <span class="o">*</span><span class="p">(</span><span class="kt">float</span><span class="o">*</span><span class="p">)</span><span class="n">CV_NODE_VAL</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">node</span><span class="p">);</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;M&quot;</span><span class="p">);</span>
    <span class="k">for</span><span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">dims</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span> <span class="p">)</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">&quot;[%d]&quot;</span><span class="p">,</span> <span class="n">idx</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;=%g</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>

    <span class="n">sum</span> <span class="o">+=</span> <span class="n">val</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">printf</span><span class="p">(</span><span class="s">&quot;nTotal sum = %g</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">sum</span><span class="p">);</span>
</pre></div>
</div>
</div>
<div class="section" id="getrawdata">
<h2>GetRawData<a class="headerlink" href="#getrawdata" title="Permalink to this headline">¶</a></h2>
<p>Retrieves low-level information about the array.</p>
<dl class="cfunction">
<dt id="void cvGetRawData(const CvArr* arr, uchar** data, int* step, CvSize* roi_size)">
<strong>C:</strong><code class="descname"> </code>void <code class="descname">cvGetRawData</code><span class="sig-paren">(</span>const CvArr* <strong>arr</strong>, uchar** <strong>data</strong>, int* <strong>step</strong>=NULL, CvSize* <strong>roi_size</strong>=NULL <span class="sig-paren">)</span><a class="headerlink" href="#void cvGetRawData(const CvArr* arr, uchar** data, int* step, CvSize* roi_size)" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>arr</strong> &#8211; Array header</li>
<li><strong>data</strong> &#8211; Output pointer to the whole image origin or ROI origin if ROI is set</li>
<li><strong>step</strong> &#8211; Output full row length in bytes</li>
<li><strong>roi_size</strong> &#8211; Output ROI size</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<p>The function fills output variables with low-level information about the array data. All output parameters are optional, so some of the pointers may be set to <code class="docutils literal"><span class="pre">NULL</span></code>. If the array is <code class="docutils literal"><span class="pre">IplImage</span></code> with ROI set, the parameters of ROI are returned.</p>
<p>The following example shows how to get access to array elements. It computes absolute values of the array elements</p>
<div class="highlight-c"><div class="highlight"><pre><span class="kt">float</span><span class="o">*</span> <span class="n">data</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">step</span><span class="p">;</span>
<span class="n">CvSize</span> <span class="n">size</span><span class="p">;</span>

<span class="n">cvGetRawData</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="p">(</span><span class="n">uchar</span><span class="o">**</span><span class="p">)</span><span class="o">&amp;</span><span class="n">data</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">step</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">size</span><span class="p">);</span>
<span class="n">step</span> <span class="o">/=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>

<span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">y</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">y</span> <span class="o">&lt;</span> <span class="n">size</span><span class="p">.</span><span class="n">height</span><span class="p">;</span> <span class="n">y</span><span class="o">++</span><span class="p">,</span> <span class="n">data</span> <span class="o">+=</span> <span class="n">step</span> <span class="p">)</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="n">size</span><span class="p">.</span><span class="n">width</span><span class="p">;</span> <span class="n">x</span><span class="o">++</span> <span class="p">)</span>
        <span class="n">data</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="kt">float</span><span class="p">)</span><span class="n">fabs</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">x</span><span class="p">]);</span>
</pre></div>
</div>
</div>
<div class="section" id="getreal-d">
<h2>GetReal?D<a class="headerlink" href="#getreal-d" title="Permalink to this headline">¶</a></h2>
<p>Return a specific element of single-channel 1D, 2D, 3D or nD array.</p>
<dl class="cfunction">
<dt id="double cvGetReal1D(const CvArr* arr, int idx0)">
<strong>C:</strong><code class="descname"> </code>double <code class="descname">cvGetReal1D</code><span class="sig-paren">(</span>const CvArr* <strong>arr</strong>, int <strong>idx0</strong><span class="sig-paren">)</span><a class="headerlink" href="#double cvGetReal1D(const CvArr* arr, int idx0)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="cfunction">
<dt id="double cvGetReal2D(const CvArr* arr, int idx0, int idx1)">
<strong>C:</strong><code class="descname"> </code>double <code class="descname">cvGetReal2D</code><span class="sig-paren">(</span>const CvArr* <strong>arr</strong>, int <strong>idx0</strong>, int <strong>idx1</strong><span class="sig-paren">)</span><a class="headerlink" href="#double cvGetReal2D(const CvArr* arr, int idx0, int idx1)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="cfunction">
<dt id="double cvGetReal3D(const CvArr* arr, int idx0, int idx1, int idx2)">
<strong>C:</strong><code class="descname"> </code>double <code class="descname">cvGetReal3D</code><span class="sig-paren">(</span>const CvArr* <strong>arr</strong>, int <strong>idx0</strong>, int <strong>idx1</strong>, int <strong>idx2</strong><span class="sig-paren">)</span><a class="headerlink" href="#double cvGetReal3D(const CvArr* arr, int idx0, int idx1, int idx2)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="cfunction">
<dt id="double cvGetRealND(const CvArr* arr, const int* idx)">
<strong>C:</strong><code class="descname"> </code>double <code class="descname">cvGetRealND</code><span class="sig-paren">(</span>const CvArr* <strong>arr</strong>, const int* <strong>idx</strong><span class="sig-paren">)</span><a class="headerlink" href="#double cvGetRealND(const CvArr* arr, const int* idx)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="pyoldfunction">
<dt id="cv.GetReal1D">
<strong>Python:</strong><code class="descname"> </code><code class="descclassname">cv.</code><code class="descname">GetReal1D</code><span class="sig-paren">(</span>arr, idx0<span class="sig-paren">)</span> &rarr; float<a class="headerlink" href="#cv.GetReal1D" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="pyoldfunction">
<dt id="cv.GetReal2D">
<strong>Python:</strong><code class="descname"> </code><code class="descclassname">cv.</code><code class="descname">GetReal2D</code><span class="sig-paren">(</span>arr, idx0, idx1<span class="sig-paren">)</span> &rarr; float<a class="headerlink" href="#cv.GetReal2D" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="pyoldfunction">
<dt id="cv.GetReal3D">
<strong>Python:</strong><code class="descname"> </code><code class="descclassname">cv.</code><code class="descname">GetReal3D</code><span class="sig-paren">(</span>arr, idx0, idx1, idx2<span class="sig-paren">)</span> &rarr; float<a class="headerlink" href="#cv.GetReal3D" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="pyoldfunction">
<dt id="cv.GetRealND">
<strong>Python:</strong><code class="descname"> </code><code class="descclassname">cv.</code><code class="descname">GetRealND</code><span class="sig-paren">(</span>arr, idx<span class="sig-paren">)</span> &rarr; float<a class="headerlink" href="#cv.GetRealND" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>arr</strong> &#8211; Input array. Must have a single channel.</li>
<li><strong>idx0</strong> &#8211; The first zero-based component of the element index</li>
<li><strong>idx1</strong> &#8211; The second zero-based component of the element index</li>
<li><strong>idx2</strong> &#8211; The third zero-based component of the element index</li>
<li><strong>idx</strong> &#8211; Array of the element indices</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<p>Returns a specific element of a single-channel array. If the array has multiple channels, a runtime error is raised. Note that <code class="docutils literal"><span class="pre">Get?D</span></code> functions can be used safely for both single-channel and multiple-channel arrays though they are a bit slower.</p>
<p>In the case of a sparse array the functions return 0 if the requested node does not exist (no new node is created by the functions).</p>
</div>
<div class="section" id="getrow-s">
<h2>GetRow(s)<a class="headerlink" href="#getrow-s" title="Permalink to this headline">¶</a></h2>
<p>Returns array row or row span.</p>
<dl class="cfunction">
<dt id="CvMat* cvGetRow(const CvArr* arr, CvMat* submat, int row)">
<strong>C:</strong><code class="descname"> </code>CvMat* <code class="descname">cvGetRow</code><span class="sig-paren">(</span>const CvArr* <strong>arr</strong>, CvMat* <strong>submat</strong>, int <strong>row</strong><span class="sig-paren">)</span><a class="headerlink" href="#CvMat* cvGetRow(const CvArr* arr, CvMat* submat, int row)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="cfunction">
<dt id="CvMat* cvGetRows(const CvArr* arr, CvMat* submat, int start_row, int end_row, int delta_row)">
<strong>C:</strong><code class="descname"> </code>CvMat* <code class="descname">cvGetRows</code><span class="sig-paren">(</span>const CvArr* <strong>arr</strong>, CvMat* <strong>submat</strong>, int <strong>start_row</strong>, int <strong>end_row</strong>, int <strong>delta_row</strong>=1 <span class="sig-paren">)</span><a class="headerlink" href="#CvMat* cvGetRows(const CvArr* arr, CvMat* submat, int start_row, int end_row, int delta_row)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="pyoldfunction">
<dt id="cv.GetRow">
<strong>Python:</strong><code class="descname"> </code><code class="descclassname">cv.</code><code class="descname">GetRow</code><span class="sig-paren">(</span>arr, row<span class="sig-paren">)</span> &rarr; submat<a class="headerlink" href="#cv.GetRow" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="pyoldfunction">
<dt id="cv.GetRows">
<strong>Python:</strong><code class="descname"> </code><code class="descclassname">cv.</code><code class="descname">GetRows</code><span class="sig-paren">(</span>arr, startRow, endRow, deltaRow=1<span class="sig-paren">)</span> &rarr; submat<a class="headerlink" href="#cv.GetRows" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>arr</strong> &#8211; Input array</li>
<li><strong>submat</strong> &#8211; Pointer to the resulting sub-array header</li>
<li><strong>row</strong> &#8211; Zero-based index of the selected row</li>
<li><strong>start_row</strong> &#8211; Zero-based index of the starting row (inclusive) of the span</li>
<li><strong>end_row</strong> &#8211; Zero-based index of the ending row (exclusive) of the span</li>
<li><strong>delta_row</strong> &#8211; Index step in the row span. That is, the function extracts every  <code class="docutils literal"><span class="pre">delta_row</span></code> -th row from  <code class="docutils literal"><span class="pre">start_row</span></code>  and up to (but not including)  <code class="docutils literal"><span class="pre">end_row</span></code> .</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<p>The functions return the header, corresponding to a specified row/row span of the input array. <code class="docutils literal"><span class="pre">cvGetRow(arr,</span> <span class="pre">submat,</span> <span class="pre">row)</span></code> is a shortcut for <code class="docutils literal"><span class="pre">cvGetRows(arr,</span> <span class="pre">submat,</span> <span class="pre">row,</span> <span class="pre">row+1)</span></code>.</p>
</div>
<div class="section" id="getsize">
<h2>GetSize<a class="headerlink" href="#getsize" title="Permalink to this headline">¶</a></h2>
<p>Returns size of matrix or image ROI.</p>
<dl class="cfunction">
<dt id="CvSize cvGetSize(const CvArr* arr)">
<strong>C:</strong><code class="descname"> </code>CvSize <code class="descname">cvGetSize</code><span class="sig-paren">(</span>const CvArr* <strong>arr</strong><span class="sig-paren">)</span><a class="headerlink" href="#CvSize cvGetSize(const CvArr* arr)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="pyoldfunction">
<dt id="cv.GetSize">
<strong>Python:</strong><code class="descname"> </code><code class="descclassname">cv.</code><code class="descname">GetSize</code><span class="sig-paren">(</span>arr)-&gt; (width, height<span class="sig-paren">)</span><a class="headerlink" href="#cv.GetSize" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>arr</strong> &#8211; array header</td>
</tr>
</tbody>
</table>
</dd></dl>

<p>The function returns number of rows (CvSize::height) and number of columns (CvSize::width) of the input matrix or image. In the case of image the size of ROI is returned.</p>
</div>
<div class="section" id="getsubrect">
<h2>GetSubRect<a class="headerlink" href="#getsubrect" title="Permalink to this headline">¶</a></h2>
<p>Returns matrix header corresponding to the rectangular sub-array of input image or matrix.</p>
<dl class="cfunction">
<dt id="CvMat* cvGetSubRect(const CvArr* arr, CvMat* submat, CvRect rect)">
<strong>C:</strong><code class="descname"> </code>CvMat* <code class="descname">cvGetSubRect</code><span class="sig-paren">(</span>const CvArr* <strong>arr</strong>, CvMat* <strong>submat</strong>, CvRect <strong>rect</strong><span class="sig-paren">)</span><a class="headerlink" href="#CvMat* cvGetSubRect(const CvArr* arr, CvMat* submat, CvRect rect)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="pyoldfunction">
<dt id="cv.GetSubRect">
<strong>Python:</strong><code class="descname"> </code><code class="descclassname">cv.</code><code class="descname">GetSubRect</code><span class="sig-paren">(</span>arr, rect<span class="sig-paren">)</span> &rarr; submat<a class="headerlink" href="#cv.GetSubRect" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>arr</strong> &#8211; Input array</li>
<li><strong>submat</strong> &#8211; Pointer to the resultant sub-array header</li>
<li><strong>rect</strong> &#8211; Zero-based coordinates of the rectangle of interest</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<p>The function returns header, corresponding to a specified rectangle of the input array. In other words, it allows the user to treat a rectangular part of input array as a stand-alone array. ROI is taken into account by the function so the sub-array of ROI is actually extracted.</p>
</div>
<div class="section" id="decrefdata">
<h2>DecRefData<a class="headerlink" href="#decrefdata" title="Permalink to this headline">¶</a></h2>
<p>Decrements an array data reference counter.</p>
<dl class="cfunction">
<dt id="void cvDecRefData(CvArr* arr)">
<strong>C:</strong><code class="descname"> </code>void <code class="descname">cvDecRefData</code><span class="sig-paren">(</span>CvArr* <strong>arr</strong><span class="sig-paren">)</span><a class="headerlink" href="#void cvDecRefData(CvArr* arr)" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>arr</strong> &#8211; Pointer to an array header</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<p>The function decrements the data reference counter in a <a class="reference internal" href="#CvMat" title="struct CvMat"><code class="xref ocv ocv-struct docutils literal"><span class="pre">CvMat</span></code></a> or <a class="reference internal" href="#CvMatND" title="struct CvMatND"><code class="xref ocv ocv-struct docutils literal"><span class="pre">CvMatND</span></code></a> if the reference counter pointer is not NULL. If the counter reaches zero, the data is deallocated. In the current implementation the reference counter is not NULL only if the data was allocated using the  <a class="reference internal" href="#void cvCreateData(CvArr* arr)" title="void cvCreateData(CvArr* arr)"><code class="xref ocv ocv-cfunc docutils literal"><span class="pre">CreateData()</span></code></a> function. The counter will be NULL in other cases such as: external data was assigned to the header using <a class="reference internal" href="#void cvSetData(CvArr* arr, void* data, int step)" title="void cvSetData(CvArr* arr, void* data, int step)"><code class="xref ocv ocv-cfunc docutils literal"><span class="pre">SetData()</span></code></a>, header is part of a larger matrix or image, or the header was converted from an image or n-dimensional matrix header.</p>
</div>
<div class="section" id="increfdata">
<h2>IncRefData<a class="headerlink" href="#increfdata" title="Permalink to this headline">¶</a></h2>
<p>Increments array data reference counter.</p>
<dl class="cfunction">
<dt id="int cvIncRefData(CvArr* arr)">
<strong>C:</strong><code class="descname"> </code>int <code class="descname">cvIncRefData</code><span class="sig-paren">(</span>CvArr* <strong>arr</strong><span class="sig-paren">)</span><a class="headerlink" href="#int cvIncRefData(CvArr* arr)" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>arr</strong> &#8211; Array header</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<p>The function increments <a class="reference internal" href="#CvMat" title="struct CvMat"><code class="xref ocv ocv-struct docutils literal"><span class="pre">CvMat</span></code></a> or <a class="reference internal" href="#CvMatND" title="struct CvMatND"><code class="xref ocv ocv-struct docutils literal"><span class="pre">CvMatND</span></code></a> data reference counter and returns the new counter value if the reference counter pointer is not NULL, otherwise it returns zero.</p>
</div>
<div class="section" id="initimageheader">
<h2>InitImageHeader<a class="headerlink" href="#initimageheader" title="Permalink to this headline">¶</a></h2>
<p>Initializes an image header that was previously allocated.</p>
<dl class="cfunction">
<dt id="IplImage* cvInitImageHeader(IplImage* image, CvSize size, int depth, int channels, int origin, int align)">
<strong>C:</strong><code class="descname"> </code>IplImage* <code class="descname">cvInitImageHeader</code><span class="sig-paren">(</span>IplImage* <strong>image</strong>, CvSize <strong>size</strong>, int <strong>depth</strong>, int <strong>channels</strong>, int <strong>origin</strong>=0, int <strong>align</strong>=4<span class="sig-paren">)</span><a class="headerlink" href="#IplImage* cvInitImageHeader(IplImage* image, CvSize size, int depth, int channels, int origin, int align)" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>image</strong> &#8211; Image header to initialize</li>
<li><strong>size</strong> &#8211; Image width and height</li>
<li><strong>depth</strong> &#8211; Image depth (see  <a class="reference internal" href="#IplImage* cvCreateImage(CvSize size, int depth, int channels)" title="IplImage* cvCreateImage(CvSize size, int depth, int channels)"><code class="xref ocv ocv-cfunc docutils literal"><span class="pre">CreateImage()</span></code></a> )</li>
<li><strong>channels</strong> &#8211; Number of channels (see  <a class="reference internal" href="#IplImage* cvCreateImage(CvSize size, int depth, int channels)" title="IplImage* cvCreateImage(CvSize size, int depth, int channels)"><code class="xref ocv ocv-cfunc docutils literal"><span class="pre">CreateImage()</span></code></a> )</li>
<li><strong>origin</strong> &#8211; Top-left  <code class="docutils literal"><span class="pre">IPL_ORIGIN_TL</span></code>  or bottom-left  <code class="docutils literal"><span class="pre">IPL_ORIGIN_BL</span></code></li>
<li><strong>align</strong> &#8211; Alignment for image rows, typically 4 or 8 bytes</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<p>The returned <code class="docutils literal"><span class="pre">IplImage*</span></code> points to the initialized header.</p>
</div>
<div class="section" id="initmatheader">
<h2>InitMatHeader<a class="headerlink" href="#initmatheader" title="Permalink to this headline">¶</a></h2>
<p>Initializes a pre-allocated matrix header.</p>
<dl class="cfunction">
<dt id="CvMat* cvInitMatHeader(CvMat* mat, int rows, int cols, int type, void* data, int step)">
<strong>C:</strong><code class="descname"> </code>CvMat* <code class="descname">cvInitMatHeader</code><span class="sig-paren">(</span>CvMat* <strong>mat</strong>, int <strong>rows</strong>, int <strong>cols</strong>, int <strong>type</strong>, void* <strong>data</strong>=NULL, int <strong>step</strong>=CV_AUTOSTEP<span class="sig-paren">)</span><a class="headerlink" href="#CvMat* cvInitMatHeader(CvMat* mat, int rows, int cols, int type, void* data, int step)" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>mat</strong> &#8211; A pointer to the matrix header to be initialized</li>
<li><strong>rows</strong> &#8211; Number of rows in the matrix</li>
<li><strong>cols</strong> &#8211; Number of columns in the matrix</li>
<li><strong>type</strong> &#8211; Type of the matrix elements, see  <a class="reference internal" href="#CvMat* cvCreateMat(int rows, int cols, int type)" title="CvMat* cvCreateMat(int rows, int cols, int type)"><code class="xref ocv ocv-cfunc docutils literal"><span class="pre">CreateMat()</span></code></a> .</li>
<li><strong>data</strong> &#8211; Optional: data pointer assigned to the matrix header</li>
<li><strong>step</strong> &#8211; Optional: full row width in bytes of the assigned data. By default, the minimal possible step is used which assumes there are no gaps between subsequent rows of the matrix.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<p>This function is often used to process raw data with OpenCV matrix functions. For example, the following code computes the matrix product of two matrices, stored as ordinary arrays:</p>
<div class="highlight-c"><div class="highlight"><pre><span class="kt">double</span> <span class="n">a</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span>
               <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span>
               <span class="mi">9</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">11</span><span class="p">,</span> <span class="mi">12</span> <span class="p">};</span>

<span class="kt">double</span> <span class="n">b</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span>
               <span class="mi">2</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span>
               <span class="mi">3</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">11</span><span class="p">,</span>
               <span class="mi">4</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">12</span> <span class="p">};</span>

<span class="kt">double</span> <span class="n">c</span><span class="p">[</span><span class="mi">9</span><span class="p">];</span>
<span class="n">CvMat</span> <span class="n">Ma</span><span class="p">,</span> <span class="n">Mb</span><span class="p">,</span> <span class="n">Mc</span> <span class="p">;</span>

<span class="n">cvInitMatHeader</span><span class="p">(</span><span class="o">&amp;</span><span class="n">Ma</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="n">CV_64FC1</span><span class="p">,</span> <span class="n">a</span><span class="p">);</span>
<span class="n">cvInitMatHeader</span><span class="p">(</span><span class="o">&amp;</span><span class="n">Mb</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="n">CV_64FC1</span><span class="p">,</span> <span class="n">b</span><span class="p">);</span>
<span class="n">cvInitMatHeader</span><span class="p">(</span><span class="o">&amp;</span><span class="n">Mc</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="n">CV_64FC1</span><span class="p">,</span> <span class="n">c</span><span class="p">);</span>

<span class="n">cvMatMulAdd</span><span class="p">(</span><span class="o">&amp;</span><span class="n">Ma</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">Mb</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">Mc</span><span class="p">);</span>
<span class="c1">// the c array now contains the product of a (3x4) and b (4x3)</span>
</pre></div>
</div>
</div>
<div class="section" id="initmatndheader">
<h2>InitMatNDHeader<a class="headerlink" href="#initmatndheader" title="Permalink to this headline">¶</a></h2>
<p>Initializes a pre-allocated multi-dimensional array header.</p>
<dl class="cfunction">
<dt id="CvMatND* cvInitMatNDHeader(CvMatND* mat, int dims, const int* sizes, int type, void* data)">
<strong>C:</strong><code class="descname"> </code>CvMatND* <code class="descname">cvInitMatNDHeader</code><span class="sig-paren">(</span>CvMatND* <strong>mat</strong>, int <strong>dims</strong>, const int* <strong>sizes</strong>, int <strong>type</strong>, void* <strong>data</strong>=NULL<span class="sig-paren">)</span><a class="headerlink" href="#CvMatND* cvInitMatNDHeader(CvMatND* mat, int dims, const int* sizes, int type, void* data)" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>mat</strong> &#8211; A pointer to the array header to be initialized</li>
<li><strong>dims</strong> &#8211; The number of array dimensions</li>
<li><strong>sizes</strong> &#8211; An array of dimension sizes</li>
<li><strong>type</strong> &#8211; Type of array elements, see  <a class="reference internal" href="#CvMat* cvCreateMat(int rows, int cols, int type)" title="CvMat* cvCreateMat(int rows, int cols, int type)"><code class="xref ocv ocv-cfunc docutils literal"><span class="pre">CreateMat()</span></code></a></li>
<li><strong>data</strong> &#8211; Optional data pointer assigned to the matrix header</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="initsparsematiterator">
<h2>InitSparseMatIterator<a class="headerlink" href="#initsparsematiterator" title="Permalink to this headline">¶</a></h2>
<p>Initializes sparse array elements iterator.</p>
<dl class="cfunction">
<dt id="CvSparseNode* cvInitSparseMatIterator(const CvSparseMat* mat, CvSparseMatIterator* mat_iterator)">
<strong>C:</strong><code class="descname"> </code>CvSparseNode* <code class="descname">cvInitSparseMatIterator</code><span class="sig-paren">(</span>const CvSparseMat* <strong>mat</strong>, CvSparseMatIterator* <strong>mat_iterator</strong><span class="sig-paren">)</span><a class="headerlink" href="#CvSparseNode* cvInitSparseMatIterator(const CvSparseMat* mat, CvSparseMatIterator* mat_iterator)" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>mat</strong> &#8211; Input array</li>
<li><strong>mat_iterator</strong> &#8211; Initialized iterator</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<p>The function initializes iterator of sparse array elements and returns pointer to the first element, or NULL if the array is empty.</p>
</div>
<div class="section" id="mat">
<h2>Mat<a class="headerlink" href="#mat" title="Permalink to this headline">¶</a></h2>
<p>Initializes matrix header (lightweight variant).</p>
<dl class="cfunction">
<dt id="CvMat cvMat(int rows, int cols, int type, void* data)">
<strong>C:</strong><code class="descname"> </code>CvMat <code class="descname">cvMat</code><span class="sig-paren">(</span>int <strong>rows</strong>, int <strong>cols</strong>, int <strong>type</strong>, void* <strong>data</strong>=NULL<span class="sig-paren">)</span><a class="headerlink" href="#CvMat cvMat(int rows, int cols, int type, void* data)" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>rows</strong> &#8211; Number of rows in the matrix</li>
<li><strong>cols</strong> &#8211; Number of columns in the matrix</li>
<li><strong>type</strong> &#8211; Type of the matrix elements - see  <a class="reference internal" href="#CvMat* cvCreateMat(int rows, int cols, int type)" title="CvMat* cvCreateMat(int rows, int cols, int type)"><code class="xref ocv ocv-cfunc docutils literal"><span class="pre">CreateMat()</span></code></a></li>
<li><strong>data</strong> &#8211; Optional data pointer assigned to the matrix header</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<p>Initializes a matrix header and assigns data to it. The matrix is filled <em>row</em>-wise (the first <code class="docutils literal"><span class="pre">cols</span></code> elements of data form the first row of the matrix, etc.)</p>
<p>This function is a fast inline substitution for <a class="reference internal" href="#CvMat* cvInitMatHeader(CvMat* mat, int rows, int cols, int type, void* data, int step)" title="CvMat* cvInitMatHeader(CvMat* mat, int rows, int cols, int type, void* data, int step)"><code class="xref ocv ocv-cfunc docutils literal"><span class="pre">InitMatHeader()</span></code></a>. Namely, it is equivalent to:</p>
<div class="highlight-c"><div class="highlight"><pre><span class="n">CvMat</span> <span class="n">mat</span><span class="p">;</span>
<span class="n">cvInitMatHeader</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mat</span><span class="p">,</span> <span class="n">rows</span><span class="p">,</span> <span class="n">cols</span><span class="p">,</span> <span class="n">type</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">CV_AUTOSTEP</span><span class="p">);</span>
</pre></div>
</div>
</div>
<div class="section" id="ptr-d">
<h2>Ptr?D<a class="headerlink" href="#ptr-d" title="Permalink to this headline">¶</a></h2>
<p>Return pointer to a particular array element.</p>
<dl class="cfunction">
<dt id="uchar* cvPtr1D(const CvArr* arr, int idx0, int* type)">
<strong>C:</strong><code class="descname"> </code>uchar* <code class="descname">cvPtr1D</code><span class="sig-paren">(</span>const CvArr* <strong>arr</strong>, int <strong>idx0</strong>, int* <strong>type</strong>=NULL<span class="sig-paren">)</span><a class="headerlink" href="#uchar* cvPtr1D(const CvArr* arr, int idx0, int* type)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="cfunction">
<dt id="uchar* cvPtr2D(const CvArr* arr, int idx0, int idx1, int* type)">
<strong>C:</strong><code class="descname"> </code>uchar* <code class="descname">cvPtr2D</code><span class="sig-paren">(</span>const CvArr* <strong>arr</strong>, int <strong>idx0</strong>, int <strong>idx1</strong>, int* <strong>type</strong>=NULL<span class="sig-paren">)</span><a class="headerlink" href="#uchar* cvPtr2D(const CvArr* arr, int idx0, int idx1, int* type)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="cfunction">
<dt id="uchar* cvPtr3D(const CvArr* arr, int idx0, int idx1, int idx2, int* type)">
<strong>C:</strong><code class="descname"> </code>uchar* <code class="descname">cvPtr3D</code><span class="sig-paren">(</span>const CvArr* <strong>arr</strong>, int <strong>idx0</strong>, int <strong>idx1</strong>, int <strong>idx2</strong>, int* <strong>type</strong>=NULL<span class="sig-paren">)</span><a class="headerlink" href="#uchar* cvPtr3D(const CvArr* arr, int idx0, int idx1, int idx2, int* type)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="cfunction">
<dt id="uchar* cvPtrND(const CvArr* arr, const int* idx, int* type, int create_node, unsigned* precalc_hashval)">
<strong>C:</strong><code class="descname"> </code>uchar* <code class="descname">cvPtrND</code><span class="sig-paren">(</span>const CvArr* <strong>arr</strong>, const int* <strong>idx</strong>, int* <strong>type</strong>=NULL, int <strong>create_node</strong>=1, unsigned int* <strong>precalc_hashval</strong>=NULL <span class="sig-paren">)</span><a class="headerlink" href="#uchar* cvPtrND(const CvArr* arr, const int* idx, int* type, int create_node, unsigned* precalc_hashval)" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>arr</strong> &#8211; Input array</li>
<li><strong>idx0</strong> &#8211; The first zero-based component of the element index</li>
<li><strong>idx1</strong> &#8211; The second zero-based component of the element index</li>
<li><strong>idx2</strong> &#8211; The third zero-based component of the element index</li>
<li><strong>idx</strong> &#8211; Array of the element indices</li>
<li><strong>type</strong> &#8211; Optional output parameter: type of matrix elements</li>
<li><strong>create_node</strong> &#8211; Optional input parameter for sparse matrices. Non-zero value of the parameter means that the requested element is created if it does not exist already.</li>
<li><strong>precalc_hashval</strong> &#8211; Optional input parameter for sparse matrices. If the pointer is not NULL, the function does not recalculate the node hash value, but takes it from the specified location. It is useful for speeding up pair-wise operations (TODO: provide an example)</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<p>The functions return a pointer to a specific array element. Number of array dimension should match to the number of indices passed to the function except for <code class="docutils literal"><span class="pre">cvPtr1D</span></code> function that can be used for sequential access to 1D, 2D or nD dense arrays.</p>
<p>The functions can be used for sparse arrays as well - if the requested node does not exist they create it and set it to zero.</p>
<p>All these as well as other functions accessing array elements (
<a class="reference internal" href="#CvScalar cvGetND(const CvArr* arr, const int* idx)" title="CvScalar cvGetND(const CvArr* arr, const int* idx)"><code class="xref ocv ocv-cfunc docutils literal"><span class="pre">GetND()</span></code></a>
,
<a class="reference internal" href="#double cvGetRealND(const CvArr* arr, const int* idx)" title="double cvGetRealND(const CvArr* arr, const int* idx)"><code class="xref ocv ocv-cfunc docutils literal"><span class="pre">GetRealND()</span></code></a>
,
<a class="reference internal" href="#void cvSet(CvArr* arr, CvScalar value, const CvArr* mask)" title="void cvSet(CvArr* arr, CvScalar value, const CvArr* mask)"><code class="xref ocv ocv-cfunc docutils literal"><span class="pre">Set()</span></code></a>
,
<a class="reference internal" href="#void cvSetND(CvArr* arr, const int* idx, CvScalar value)" title="void cvSetND(CvArr* arr, const int* idx, CvScalar value)"><code class="xref ocv ocv-cfunc docutils literal"><span class="pre">SetND()</span></code></a>
,
<a class="reference internal" href="#void cvSetRealND(CvArr* arr, const int* idx, double value)" title="void cvSetRealND(CvArr* arr, const int* idx, double value)"><code class="xref ocv ocv-cfunc docutils literal"><span class="pre">SetRealND()</span></code></a>
) raise an error in case if the element index is out of range.</p>
</div>
<div class="section" id="releasedata">
<h2>ReleaseData<a class="headerlink" href="#releasedata" title="Permalink to this headline">¶</a></h2>
<p>Releases array data.</p>
<dl class="cfunction">
<dt id="void cvReleaseData(CvArr* arr)">
<strong>C:</strong><code class="descname"> </code>void <code class="descname">cvReleaseData</code><span class="sig-paren">(</span>CvArr* <strong>arr</strong><span class="sig-paren">)</span><a class="headerlink" href="#void cvReleaseData(CvArr* arr)" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>arr</strong> &#8211; Array header</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<p>The function releases the array data. In the case of
<a class="reference internal" href="#CvMat" title="struct CvMat"><code class="xref ocv ocv-struct docutils literal"><span class="pre">CvMat</span></code></a>
or
<a class="reference internal" href="#CvMatND" title="struct CvMatND"><code class="xref ocv ocv-struct docutils literal"><span class="pre">CvMatND</span></code></a>
it simply calls cvDecRefData(), that is the function can not deallocate external data. See also the note to
<a class="reference internal" href="#void cvCreateData(CvArr* arr)" title="void cvCreateData(CvArr* arr)"><code class="xref ocv ocv-cfunc docutils literal"><span class="pre">CreateData()</span></code></a>
.</p>
</div>
<div class="section" id="releaseimage">
<h2>ReleaseImage<a class="headerlink" href="#releaseimage" title="Permalink to this headline">¶</a></h2>
<p>Deallocates the image header and the image data.</p>
<dl class="cfunction">
<dt id="void cvReleaseImage(IplImage** image)">
<strong>C:</strong><code class="descname"> </code>void <code class="descname">cvReleaseImage</code><span class="sig-paren">(</span>IplImage** <strong>image</strong><span class="sig-paren">)</span><a class="headerlink" href="#void cvReleaseImage(IplImage** image)" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>image</strong> &#8211; Double pointer to the image header</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<p>This call is a shortened form of</p>
<div class="highlight-c"><div class="highlight"><pre><span class="k">if</span><span class="p">(</span><span class="o">*</span><span class="n">image</span> <span class="p">)</span>
<span class="p">{</span>
    <span class="n">cvReleaseData</span><span class="p">(</span><span class="o">*</span><span class="n">image</span><span class="p">);</span>
    <span class="n">cvReleaseImageHeader</span><span class="p">(</span><span class="n">image</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="releaseimageheader">
<h2>ReleaseImageHeader<a class="headerlink" href="#releaseimageheader" title="Permalink to this headline">¶</a></h2>
<p>Deallocates an image header.</p>
<dl class="cfunction">
<dt id="void cvReleaseImageHeader(IplImage** image)">
<strong>C:</strong><code class="descname"> </code>void <code class="descname">cvReleaseImageHeader</code><span class="sig-paren">(</span>IplImage** <strong>image</strong><span class="sig-paren">)</span><a class="headerlink" href="#void cvReleaseImageHeader(IplImage** image)" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>image</strong> &#8211; Double pointer to the image header</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<p>This call is an analogue of</p>
<div class="highlight-c"><div class="highlight"><pre><span class="k">if</span><span class="p">(</span><span class="n">image</span> <span class="p">)</span>
<span class="p">{</span>
    <span class="n">iplDeallocate</span><span class="p">(</span><span class="o">*</span><span class="n">image</span><span class="p">,</span> <span class="n">IPL_IMAGE_HEADER</span> <span class="o">|</span> <span class="n">IPL_IMAGE_ROI</span><span class="p">);</span>
    <span class="o">*</span><span class="n">image</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>but it does not use IPL functions by default (see the <code class="docutils literal"><span class="pre">CV_TURN_ON_IPL_COMPATIBILITY</span></code> macro).</p>
</div>
<div class="section" id="releasemat">
<h2>ReleaseMat<a class="headerlink" href="#releasemat" title="Permalink to this headline">¶</a></h2>
<p>Deallocates a matrix.</p>
<dl class="cfunction">
<dt id="void cvReleaseMat(CvMat** mat)">
<strong>C:</strong><code class="descname"> </code>void <code class="descname">cvReleaseMat</code><span class="sig-paren">(</span>CvMat** <strong>mat</strong><span class="sig-paren">)</span><a class="headerlink" href="#void cvReleaseMat(CvMat** mat)" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>mat</strong> &#8211; Double pointer to the matrix</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<p>The function decrements the matrix data reference counter and deallocates matrix header. If the data reference counter is 0, it also deallocates the data.</p>
<div class="highlight-c"><div class="highlight"><pre><span class="k">if</span><span class="p">(</span><span class="o">*</span><span class="n">mat</span> <span class="p">)</span>
    <span class="n">cvDecRefData</span><span class="p">(</span><span class="o">*</span><span class="n">mat</span><span class="p">);</span>
<span class="n">cvFree</span><span class="p">((</span><span class="kt">void</span><span class="o">**</span><span class="p">)</span><span class="n">mat</span><span class="p">);</span>
</pre></div>
</div>
</div>
<div class="section" id="releasematnd">
<h2>ReleaseMatND<a class="headerlink" href="#releasematnd" title="Permalink to this headline">¶</a></h2>
<p>Deallocates a multi-dimensional array.</p>
<dl class="cfunction">
<dt id="void cvReleaseMatND(CvMatND** mat)">
<strong>C:</strong><code class="descname"> </code>void <code class="descname">cvReleaseMatND</code><span class="sig-paren">(</span>CvMatND** <strong>mat</strong><span class="sig-paren">)</span><a class="headerlink" href="#void cvReleaseMatND(CvMatND** mat)" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>mat</strong> &#8211; Double pointer to the array</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<p>The function decrements the array data reference counter and releases the array header. If the reference counter reaches 0, it also deallocates the data.</p>
<div class="highlight-c"><div class="highlight"><pre><span class="k">if</span><span class="p">(</span><span class="o">*</span><span class="n">mat</span> <span class="p">)</span>
    <span class="n">cvDecRefData</span><span class="p">(</span><span class="o">*</span><span class="n">mat</span><span class="p">);</span>
<span class="n">cvFree</span><span class="p">((</span><span class="kt">void</span><span class="o">**</span><span class="p">)</span><span class="n">mat</span><span class="p">);</span>
</pre></div>
</div>
</div>
<div class="section" id="releasesparsemat">
<h2>ReleaseSparseMat<a class="headerlink" href="#releasesparsemat" title="Permalink to this headline">¶</a></h2>
<p>Deallocates sparse array.</p>
<dl class="cfunction">
<dt id="void cvReleaseSparseMat(CvSparseMat** mat)">
<strong>C:</strong><code class="descname"> </code>void <code class="descname">cvReleaseSparseMat</code><span class="sig-paren">(</span>CvSparseMat** <strong>mat</strong><span class="sig-paren">)</span><a class="headerlink" href="#void cvReleaseSparseMat(CvSparseMat** mat)" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>mat</strong> &#8211; Double pointer to the array</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<p>The function releases the sparse array and clears the array pointer upon exit.</p>
</div>
<div class="section" id="resetimageroi">
<h2>ResetImageROI<a class="headerlink" href="#resetimageroi" title="Permalink to this headline">¶</a></h2>
<p>Resets the image ROI to include the entire image and releases the ROI structure.</p>
<dl class="cfunction">
<dt id="void cvResetImageROI(IplImage* image)">
<strong>C:</strong><code class="descname"> </code>void <code class="descname">cvResetImageROI</code><span class="sig-paren">(</span>IplImage* <strong>image</strong><span class="sig-paren">)</span><a class="headerlink" href="#void cvResetImageROI(IplImage* image)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="pyoldfunction">
<dt id="cv.ResetImageROI">
<strong>Python:</strong><code class="descname"> </code><code class="descclassname">cv.</code><code class="descname">ResetImageROI</code><span class="sig-paren">(</span>image<span class="sig-paren">)</span> &rarr; None<a class="headerlink" href="#cv.ResetImageROI" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>image</strong> &#8211; A pointer to the image header</td>
</tr>
</tbody>
</table>
</dd></dl>

<p>This produces a similar result to the following, but in addition it releases the ROI structure.</p>
<div class="highlight-c"><div class="highlight"><pre><span class="n">cvSetImageROI</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">cvRect</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">image</span><span class="o">-&gt;</span><span class="n">width</span><span class="p">,</span> <span class="n">image</span><span class="o">-&gt;</span><span class="n">height</span> <span class="p">));</span>
<span class="n">cvSetImageCOI</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
</pre></div>
</div>
</div>
<div class="section" id="reshape">
<h2>Reshape<a class="headerlink" href="#reshape" title="Permalink to this headline">¶</a></h2>
<p>Changes shape of matrix/image without copying data.</p>
<dl class="cfunction">
<dt id="CvMat* cvReshape(const CvArr* arr, CvMat* header, int new_cn, int new_rows)">
<strong>C:</strong><code class="descname"> </code>CvMat* <code class="descname">cvReshape</code><span class="sig-paren">(</span>const CvArr* <strong>arr</strong>, CvMat* <strong>header</strong>, int <strong>new_cn</strong>, int <strong>new_rows</strong>=0 <span class="sig-paren">)</span><a class="headerlink" href="#CvMat* cvReshape(const CvArr* arr, CvMat* header, int new_cn, int new_rows)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="pyoldfunction">
<dt id="cv.Reshape">
<strong>Python:</strong><code class="descname"> </code><code class="descclassname">cv.</code><code class="descname">Reshape</code><span class="sig-paren">(</span>arr, newCn, newRows=0<span class="sig-paren">)</span> &rarr; mat<a class="headerlink" href="#cv.Reshape" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>arr</strong> &#8211; Input array</li>
<li><strong>header</strong> &#8211; Output header to be filled</li>
<li><strong>new_cn</strong> &#8211; New number of channels. &#8216;new_cn = 0&#8217; means that the number of channels remains unchanged.</li>
<li><strong>new_rows</strong> &#8211; New number of rows. &#8216;new_rows = 0&#8217; means that the number of rows remains unchanged unless it needs to be changed according to  <code class="docutils literal"><span class="pre">new_cn</span></code>  value.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<p>The function initializes the CvMat header so that it points to the same data as the original array but has a different shape - different number of channels, different number of rows, or both.</p>
<p>The following example code creates one image buffer and two image headers, the first is for a 320x240x3 image and the second is for a 960x240x1 image:</p>
<div class="highlight-c"><div class="highlight"><pre><span class="n">IplImage</span><span class="o">*</span> <span class="n">color_img</span> <span class="o">=</span> <span class="n">cvCreateImage</span><span class="p">(</span><span class="n">cvSize</span><span class="p">(</span><span class="mi">320</span><span class="p">,</span><span class="mi">240</span><span class="p">),</span> <span class="n">IPL_DEPTH_8U</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span>
<span class="n">CvMat</span> <span class="n">gray_mat_hdr</span><span class="p">;</span>
<span class="n">IplImage</span> <span class="n">gray_img_hdr</span><span class="p">,</span> <span class="o">*</span><span class="n">gray_img</span><span class="p">;</span>
<span class="n">cvReshape</span><span class="p">(</span><span class="n">color_img</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">gray_mat_hdr</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
<span class="n">gray_img</span> <span class="o">=</span> <span class="n">cvGetImage</span><span class="p">(</span><span class="o">&amp;</span><span class="n">gray_mat_hdr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">gray_img_hdr</span><span class="p">);</span>
</pre></div>
</div>
<p>And the next example converts a 3x3 matrix to a single 1x9 vector:</p>
<div class="highlight-c"><div class="highlight"><pre><span class="n">CvMat</span><span class="o">*</span> <span class="n">mat</span> <span class="o">=</span> <span class="n">cvCreateMat</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="n">CV_32F</span><span class="p">);</span>
<span class="n">CvMat</span> <span class="n">row_header</span><span class="p">,</span> <span class="o">*</span><span class="n">row</span><span class="p">;</span>
<span class="n">row</span> <span class="o">=</span> <span class="n">cvReshape</span><span class="p">(</span><span class="n">mat</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">row_header</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
</pre></div>
</div>
</div>
<div class="section" id="reshapematnd">
<h2>ReshapeMatND<a class="headerlink" href="#reshapematnd" title="Permalink to this headline">¶</a></h2>
<p>Changes the shape of a multi-dimensional array without copying the data.</p>
<dl class="cfunction">
<dt id="CvArr* cvReshapeMatND(const CvArr* arr, int sizeof_header, CvArr* header, int new_cn, int new_dims, int* new_sizes)">
<strong>C:</strong><code class="descname"> </code>CvArr* <code class="descname">cvReshapeMatND</code><span class="sig-paren">(</span>const CvArr* <strong>arr</strong>, int <strong>sizeof_header</strong>, CvArr* <strong>header</strong>, int <strong>new_cn</strong>, int <strong>new_dims</strong>, int* <strong>new_sizes</strong><span class="sig-paren">)</span><a class="headerlink" href="#CvArr* cvReshapeMatND(const CvArr* arr, int sizeof_header, CvArr* header, int new_cn, int new_dims, int* new_sizes)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="pyoldfunction">
<dt id="cv.ReshapeMatND">
<strong>Python:</strong><code class="descname"> </code><code class="descclassname">cv.</code><code class="descname">ReshapeMatND</code><span class="sig-paren">(</span>arr, newCn, newDims<span class="sig-paren">)</span> &rarr; mat<a class="headerlink" href="#cv.ReshapeMatND" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>arr</strong> &#8211; Input array</li>
<li><strong>sizeof_header</strong> &#8211; Size of output header to distinguish between IplImage, CvMat and CvMatND output headers</li>
<li><strong>header</strong> &#8211; Output header to be filled</li>
<li><strong>new_cn</strong> &#8211; New number of channels. <code class="docutils literal"><span class="pre">new_cn</span> <span class="pre">=</span> <span class="pre">0</span></code>  means that the number of channels remains unchanged.</li>
<li><strong>new_dims</strong> &#8211; New number of dimensions. <code class="docutils literal"><span class="pre">new_dims</span> <span class="pre">=</span> <span class="pre">0</span></code> means that the number of dimensions remains the same.</li>
<li><strong>new_sizes</strong> &#8211; Array of new dimension sizes. Only  <code class="docutils literal"><span class="pre">new_dims-1</span></code>  values are used, because the total number of elements must remain the same. Thus, if  <code class="docutils literal"><span class="pre">new_dims</span> <span class="pre">=</span> <span class="pre">1</span></code>,  <code class="docutils literal"><span class="pre">new_sizes</span></code>  array is not used.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<p>The function is an advanced version of <a class="reference internal" href="#CvMat* cvReshape(const CvArr* arr, CvMat* header, int new_cn, int new_rows)" title="CvMat* cvReshape(const CvArr* arr, CvMat* header, int new_cn, int new_rows)"><code class="xref ocv ocv-cfunc docutils literal"><span class="pre">Reshape()</span></code></a> that can work with multi-dimensional arrays as well (though it can work with ordinary images and matrices) and change the number of dimensions.</p>
<p>Below are the two samples from the
<a class="reference internal" href="#CvMat* cvReshape(const CvArr* arr, CvMat* header, int new_cn, int new_rows)" title="CvMat* cvReshape(const CvArr* arr, CvMat* header, int new_cn, int new_rows)"><code class="xref ocv ocv-cfunc docutils literal"><span class="pre">Reshape()</span></code></a>
description rewritten using
<a class="reference internal" href="#CvArr* cvReshapeMatND(const CvArr* arr, int sizeof_header, CvArr* header, int new_cn, int new_dims, int* new_sizes)" title="CvArr* cvReshapeMatND(const CvArr* arr, int sizeof_header, CvArr* header, int new_cn, int new_dims, int* new_sizes)"><code class="xref ocv ocv-cfunc docutils literal"><span class="pre">ReshapeMatND()</span></code></a>
:</p>
<div class="highlight-c"><div class="highlight"><pre><span class="n">IplImage</span><span class="o">*</span> <span class="n">color_img</span> <span class="o">=</span> <span class="n">cvCreateImage</span><span class="p">(</span><span class="n">cvSize</span><span class="p">(</span><span class="mi">320</span><span class="p">,</span><span class="mi">240</span><span class="p">),</span> <span class="n">IPL_DEPTH_8U</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span>
<span class="n">IplImage</span> <span class="n">gray_img_hdr</span><span class="p">,</span> <span class="o">*</span><span class="n">gray_img</span><span class="p">;</span>
<span class="n">gray_img</span> <span class="o">=</span> <span class="p">(</span><span class="n">IplImage</span><span class="o">*</span><span class="p">)</span><span class="n">cvReshapeMatND</span><span class="p">(</span><span class="n">color_img</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">gray_img_hdr</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">gray_img_hdr</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

<span class="p">...</span>

<span class="cm">/* second example is modified to convert 2x2x2 array to 8x1 vector */</span>
<span class="kt">int</span> <span class="n">size</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span> <span class="p">};</span>
<span class="n">CvMatND</span><span class="o">*</span> <span class="n">mat</span> <span class="o">=</span> <span class="n">cvCreateMatND</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">CV_32F</span><span class="p">);</span>
<span class="n">CvMat</span> <span class="n">row_header</span><span class="p">,</span> <span class="o">*</span><span class="n">row</span><span class="p">;</span>
<span class="n">row</span> <span class="o">=</span> <span class="p">(</span><span class="n">CvMat</span><span class="o">*</span><span class="p">)</span><span class="n">cvReshapeMatND</span><span class="p">(</span><span class="n">mat</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">row_header</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">row_header</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
</pre></div>
</div>
<p>In C, the header file for this function includes a convenient macro <code class="docutils literal"><span class="pre">cvReshapeND</span></code> that does away with the <code class="docutils literal"><span class="pre">sizeof_header</span></code> parameter. So, the lines containing the call to <code class="docutils literal"><span class="pre">cvReshapeMatND</span></code> in the examples may be replaced as follow:</p>
<div class="highlight-c"><div class="highlight"><pre><span class="n">gray_img</span> <span class="o">=</span> <span class="p">(</span><span class="n">IplImage</span><span class="o">*</span><span class="p">)</span><span class="n">cvReshapeND</span><span class="p">(</span><span class="n">color_img</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">gray_img_hdr</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

<span class="p">...</span>

<span class="n">row</span> <span class="o">=</span> <span class="p">(</span><span class="n">CvMat</span><span class="o">*</span><span class="p">)</span><span class="n">cvReshapeND</span><span class="p">(</span><span class="n">mat</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">row_header</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
</pre></div>
</div>
</div>
<div class="section" id="set">
<h2>Set<a class="headerlink" href="#set" title="Permalink to this headline">¶</a></h2>
<p>Sets every element of an array to a given value.</p>
<dl class="cfunction">
<dt id="void cvSet(CvArr* arr, CvScalar value, const CvArr* mask)">
<strong>C:</strong><code class="descname"> </code>void <code class="descname">cvSet</code><span class="sig-paren">(</span>CvArr* <strong>arr</strong>, CvScalar <strong>value</strong>, const CvArr* <strong>mask</strong>=NULL<span class="sig-paren">)</span><a class="headerlink" href="#void cvSet(CvArr* arr, CvScalar value, const CvArr* mask)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="pyoldfunction">
<dt id="cv.Set">
<strong>Python:</strong><code class="descname"> </code><code class="descclassname">cv.</code><code class="descname">Set</code><span class="sig-paren">(</span>arr, value, mask=None<span class="sig-paren">)</span> &rarr; None<a class="headerlink" href="#cv.Set" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>arr</strong> &#8211; The destination array</li>
<li><strong>value</strong> &#8211; Fill value</li>
<li><strong>mask</strong> &#8211; Operation mask, 8-bit single channel array; specifies elements of the destination array to be changed</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<p>The function copies the scalar <code class="docutils literal"><span class="pre">value</span></code> to every selected element of the destination array:</p>
<div class="math">
<p><img src="../../../_images/math/1dbfd588a7c96d0b111b62132412fa6fb33a0415.png" alt="\texttt{arr} (I)= \texttt{value} \quad \text{if} \quad \texttt{mask} (I)  \ne 0"/></p>
</div><p>If array <code class="docutils literal"><span class="pre">arr</span></code> is of <code class="docutils literal"><span class="pre">IplImage</span></code> type, then is ROI used, but COI must not be set.</p>
</div>
<div class="section" id="set-d">
<h2>Set?D<a class="headerlink" href="#set-d" title="Permalink to this headline">¶</a></h2>
<p>Change the particular array element.</p>
<dl class="cfunction">
<dt id="void cvSet1D(CvArr* arr, int idx0, CvScalar value)">
<strong>C:</strong><code class="descname"> </code>void <code class="descname">cvSet1D</code><span class="sig-paren">(</span>CvArr* <strong>arr</strong>, int <strong>idx0</strong>, CvScalar <strong>value</strong><span class="sig-paren">)</span><a class="headerlink" href="#void cvSet1D(CvArr* arr, int idx0, CvScalar value)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="cfunction">
<dt id="void cvSet2D(CvArr* arr, int idx0, int idx1, CvScalar value)">
<strong>C:</strong><code class="descname"> </code>void <code class="descname">cvSet2D</code><span class="sig-paren">(</span>CvArr* <strong>arr</strong>, int <strong>idx0</strong>, int <strong>idx1</strong>, CvScalar <strong>value</strong><span class="sig-paren">)</span><a class="headerlink" href="#void cvSet2D(CvArr* arr, int idx0, int idx1, CvScalar value)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="cfunction">
<dt id="void cvSet3D(CvArr* arr, int idx0, int idx1, int idx2, CvScalar value)">
<strong>C:</strong><code class="descname"> </code>void <code class="descname">cvSet3D</code><span class="sig-paren">(</span>CvArr* <strong>arr</strong>, int <strong>idx0</strong>, int <strong>idx1</strong>, int <strong>idx2</strong>, CvScalar <strong>value</strong><span class="sig-paren">)</span><a class="headerlink" href="#void cvSet3D(CvArr* arr, int idx0, int idx1, int idx2, CvScalar value)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="cfunction">
<dt id="void cvSetND(CvArr* arr, const int* idx, CvScalar value)">
<strong>C:</strong><code class="descname"> </code>void <code class="descname">cvSetND</code><span class="sig-paren">(</span>CvArr* <strong>arr</strong>, const int* <strong>idx</strong>, CvScalar <strong>value</strong><span class="sig-paren">)</span><a class="headerlink" href="#void cvSetND(CvArr* arr, const int* idx, CvScalar value)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="pyoldfunction">
<dt id="cv.Set1D">
<strong>Python:</strong><code class="descname"> </code><code class="descclassname">cv.</code><code class="descname">Set1D</code><span class="sig-paren">(</span>arr, idx, value<span class="sig-paren">)</span> &rarr; None<a class="headerlink" href="#cv.Set1D" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="pyoldfunction">
<dt id="cv.Set2D">
<strong>Python:</strong><code class="descname"> </code><code class="descclassname">cv.</code><code class="descname">Set2D</code><span class="sig-paren">(</span>arr, idx0, idx1, value<span class="sig-paren">)</span> &rarr; None<a class="headerlink" href="#cv.Set2D" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="pyoldfunction">
<dt id="cv.Set3D">
<strong>Python:</strong><code class="descname"> </code><code class="descclassname">cv.</code><code class="descname">Set3D</code><span class="sig-paren">(</span>arr, idx0, idx1, idx2, value<span class="sig-paren">)</span> &rarr; None<a class="headerlink" href="#cv.Set3D" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="pyoldfunction">
<dt id="cv.SetND">
<strong>Python:</strong><code class="descname"> </code><code class="descclassname">cv.</code><code class="descname">SetND</code><span class="sig-paren">(</span>arr, indices, value<span class="sig-paren">)</span> &rarr; None<a class="headerlink" href="#cv.SetND" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>arr</strong> &#8211; Input array</li>
<li><strong>idx0</strong> &#8211; The first zero-based component of the element index</li>
<li><strong>idx1</strong> &#8211; The second zero-based component of the element index</li>
<li><strong>idx2</strong> &#8211; The third zero-based component of the element index</li>
<li><strong>idx</strong> &#8211; Array of the element indices</li>
<li><strong>value</strong> &#8211; The assigned value</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<p>The functions assign the new value to a particular array element. In the case of a sparse array the functions create the node if it does not exist yet.</p>
</div>
<div class="section" id="setdata">
<h2>SetData<a class="headerlink" href="#setdata" title="Permalink to this headline">¶</a></h2>
<p>Assigns user data to the array header.</p>
<dl class="cfunction">
<dt id="void cvSetData(CvArr* arr, void* data, int step)">
<strong>C:</strong><code class="descname"> </code>void <code class="descname">cvSetData</code><span class="sig-paren">(</span>CvArr* <strong>arr</strong>, void* <strong>data</strong>, int <strong>step</strong><span class="sig-paren">)</span><a class="headerlink" href="#void cvSetData(CvArr* arr, void* data, int step)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="pyoldfunction">
<dt id="cv.SetData">
<strong>Python:</strong><code class="descname"> </code><code class="descclassname">cv.</code><code class="descname">SetData</code><span class="sig-paren">(</span>arr, data, step<span class="sig-paren">)</span> &rarr; None<a class="headerlink" href="#cv.SetData" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>arr</strong> &#8211; Array header</li>
<li><strong>data</strong> &#8211; User data</li>
<li><strong>step</strong> &#8211; Full row length in bytes</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<p>The function assigns user data to the array header. Header should be initialized before using
<a class="reference internal" href="#CvMat* cvCreateMatHeader(int rows, int cols, int type)" title="CvMat* cvCreateMatHeader(int rows, int cols, int type)"><code class="xref ocv ocv-cfunc docutils literal"><span class="pre">cvCreateMatHeader()</span></code></a>, <a class="reference internal" href="#IplImage* cvCreateImageHeader(CvSize size, int depth, int channels)" title="IplImage* cvCreateImageHeader(CvSize size, int depth, int channels)"><code class="xref ocv ocv-cfunc docutils literal"><span class="pre">cvCreateImageHeader()</span></code></a>, <a class="reference internal" href="#CvMatND* cvCreateMatNDHeader(int dims, const int* sizes, int type)" title="CvMatND* cvCreateMatNDHeader(int dims, const int* sizes, int type)"><code class="xref ocv ocv-cfunc docutils literal"><span class="pre">cvCreateMatNDHeader()</span></code></a>,
<a class="reference internal" href="#CvMat* cvInitMatHeader(CvMat* mat, int rows, int cols, int type, void* data, int step)" title="CvMat* cvInitMatHeader(CvMat* mat, int rows, int cols, int type, void* data, int step)"><code class="xref ocv ocv-cfunc docutils literal"><span class="pre">cvInitMatHeader()</span></code></a>, <a class="reference internal" href="#IplImage* cvInitImageHeader(IplImage* image, CvSize size, int depth, int channels, int origin, int align)" title="IplImage* cvInitImageHeader(IplImage* image, CvSize size, int depth, int channels, int origin, int align)"><code class="xref ocv ocv-cfunc docutils literal"><span class="pre">cvInitImageHeader()</span></code></a> or <a class="reference internal" href="#CvMatND* cvInitMatNDHeader(CvMatND* mat, int dims, const int* sizes, int type, void* data)" title="CvMatND* cvInitMatNDHeader(CvMatND* mat, int dims, const int* sizes, int type, void* data)"><code class="xref ocv ocv-cfunc docutils literal"><span class="pre">cvInitMatNDHeader()</span></code></a>.</p>
</div>
<div class="section" id="setimagecoi">
<h2>SetImageCOI<a class="headerlink" href="#setimagecoi" title="Permalink to this headline">¶</a></h2>
<p>Sets the channel of interest in an IplImage.</p>
<dl class="cfunction">
<dt id="void cvSetImageCOI(IplImage* image, int coi)">
<strong>C:</strong><code class="descname"> </code>void <code class="descname">cvSetImageCOI</code><span class="sig-paren">(</span>IplImage* <strong>image</strong>, int <strong>coi</strong><span class="sig-paren">)</span><a class="headerlink" href="#void cvSetImageCOI(IplImage* image, int coi)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="pyoldfunction">
<dt id="cv.SetImageCOI">
<strong>Python:</strong><code class="descname"> </code><code class="descclassname">cv.</code><code class="descname">SetImageCOI</code><span class="sig-paren">(</span>image, coi<span class="sig-paren">)</span> &rarr; None<a class="headerlink" href="#cv.SetImageCOI" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>image</strong> &#8211; A pointer to the image header</li>
<li><strong>coi</strong> &#8211; The channel of interest. 0 - all channels are selected, 1 - first channel is selected, etc. Note that the channel indices become 1-based.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<p>If the ROI is set to <code class="docutils literal"><span class="pre">NULL</span></code> and the coi is <em>not</em> 0, the ROI is allocated. Most OpenCV functions do  <em>not</em> support the COI setting, so to process an individual image/matrix channel one may copy (via <a class="reference internal" href="#void cvCopy(const CvArr* src, CvArr* dst, const CvArr* mask)" title="void cvCopy(const CvArr* src, CvArr* dst, const CvArr* mask)"><code class="xref ocv ocv-cfunc docutils literal"><span class="pre">Copy()</span></code></a> or <a class="reference internal" href="operations_on_arrays.html#void cvSplit(const CvArr* src, CvArr* dst0, CvArr* dst1, CvArr* dst2, CvArr* dst3)" title="void cvSplit(const CvArr* src, CvArr* dst0, CvArr* dst1, CvArr* dst2, CvArr* dst3)"><code class="xref ocv ocv-cfunc docutils literal"><span class="pre">Split()</span></code></a>) the channel to a separate image/matrix, process it and then copy the result back (via <a class="reference internal" href="#void cvCopy(const CvArr* src, CvArr* dst, const CvArr* mask)" title="void cvCopy(const CvArr* src, CvArr* dst, const CvArr* mask)"><code class="xref ocv ocv-cfunc docutils literal"><span class="pre">Copy()</span></code></a> or <a class="reference internal" href="operations_on_arrays.html#void cvMerge(const CvArr* src0, const CvArr* src1, const CvArr* src2, const CvArr* src3, CvArr* dst)" title="void cvMerge(const CvArr* src0, const CvArr* src1, const CvArr* src2, const CvArr* src3, CvArr* dst)"><code class="xref ocv ocv-cfunc docutils literal"><span class="pre">Merge()</span></code></a>) if needed.</p>
</div>
<div class="section" id="setimageroi">
<h2>SetImageROI<a class="headerlink" href="#setimageroi" title="Permalink to this headline">¶</a></h2>
<p>Sets an image Region Of Interest (ROI) for a given rectangle.</p>
<dl class="cfunction">
<dt id="void cvSetImageROI(IplImage* image, CvRect rect)">
<strong>C:</strong><code class="descname"> </code>void <code class="descname">cvSetImageROI</code><span class="sig-paren">(</span>IplImage* <strong>image</strong>, CvRect <strong>rect</strong><span class="sig-paren">)</span><a class="headerlink" href="#void cvSetImageROI(IplImage* image, CvRect rect)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="pyoldfunction">
<dt id="cv.SetImageROI">
<strong>Python:</strong><code class="descname"> </code><code class="descclassname">cv.</code><code class="descname">SetImageROI</code><span class="sig-paren">(</span>image, rect<span class="sig-paren">)</span> &rarr; None<a class="headerlink" href="#cv.SetImageROI" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>image</strong> &#8211; A pointer to the image header</li>
<li><strong>rect</strong> &#8211; The ROI rectangle</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<p>If the original image ROI was <code class="docutils literal"><span class="pre">NULL</span></code> and the <code class="docutils literal"><span class="pre">rect</span></code> is not the whole image, the ROI structure is allocated.</p>
<p>Most OpenCV functions support the use of ROI and treat the image rectangle as a separate image. For example, all of the pixel coordinates are counted from the top-left (or bottom-left) corner of the ROI, not the original image.</p>
</div>
<div class="section" id="setreal-d">
<h2>SetReal?D<a class="headerlink" href="#setreal-d" title="Permalink to this headline">¶</a></h2>
<p>Change a specific array element.</p>
<dl class="cfunction">
<dt id="void cvSetReal1D(CvArr* arr, int idx0, double value)">
<strong>C:</strong><code class="descname"> </code>void <code class="descname">cvSetReal1D</code><span class="sig-paren">(</span>CvArr* <strong>arr</strong>, int <strong>idx0</strong>, double <strong>value</strong><span class="sig-paren">)</span><a class="headerlink" href="#void cvSetReal1D(CvArr* arr, int idx0, double value)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="cfunction">
<dt id="void cvSetReal2D(CvArr* arr, int idx0, int idx1, double value)">
<strong>C:</strong><code class="descname"> </code>void <code class="descname">cvSetReal2D</code><span class="sig-paren">(</span>CvArr* <strong>arr</strong>, int <strong>idx0</strong>, int <strong>idx1</strong>, double <strong>value</strong><span class="sig-paren">)</span><a class="headerlink" href="#void cvSetReal2D(CvArr* arr, int idx0, int idx1, double value)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="cfunction">
<dt id="void cvSetReal3D(CvArr* arr, int idx0, int idx1, int idx2, double value)">
<strong>C:</strong><code class="descname"> </code>void <code class="descname">cvSetReal3D</code><span class="sig-paren">(</span>CvArr* <strong>arr</strong>, int <strong>idx0</strong>, int <strong>idx1</strong>, int <strong>idx2</strong>, double <strong>value</strong><span class="sig-paren">)</span><a class="headerlink" href="#void cvSetReal3D(CvArr* arr, int idx0, int idx1, int idx2, double value)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="cfunction">
<dt id="void cvSetRealND(CvArr* arr, const int* idx, double value)">
<strong>C:</strong><code class="descname"> </code>void <code class="descname">cvSetRealND</code><span class="sig-paren">(</span>CvArr* <strong>arr</strong>, const int* <strong>idx</strong>, double <strong>value</strong><span class="sig-paren">)</span><a class="headerlink" href="#void cvSetRealND(CvArr* arr, const int* idx, double value)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="pyoldfunction">
<dt id="cv.SetReal1D">
<strong>Python:</strong><code class="descname"> </code><code class="descclassname">cv.</code><code class="descname">SetReal1D</code><span class="sig-paren">(</span>arr, idx, value<span class="sig-paren">)</span> &rarr; None<a class="headerlink" href="#cv.SetReal1D" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="pyoldfunction">
<dt id="cv.SetReal2D">
<strong>Python:</strong><code class="descname"> </code><code class="descclassname">cv.</code><code class="descname">SetReal2D</code><span class="sig-paren">(</span>arr, idx0, idx1, value<span class="sig-paren">)</span> &rarr; None<a class="headerlink" href="#cv.SetReal2D" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="pyoldfunction">
<dt id="cv.SetReal3D">
<strong>Python:</strong><code class="descname"> </code><code class="descclassname">cv.</code><code class="descname">SetReal3D</code><span class="sig-paren">(</span>arr, idx0, idx1, idx2, value<span class="sig-paren">)</span> &rarr; None<a class="headerlink" href="#cv.SetReal3D" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="pyoldfunction">
<dt id="cv.SetRealND">
<strong>Python:</strong><code class="descname"> </code><code class="descclassname">cv.</code><code class="descname">SetRealND</code><span class="sig-paren">(</span>arr, indices, value<span class="sig-paren">)</span> &rarr; None<a class="headerlink" href="#cv.SetRealND" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>arr</strong> &#8211; Input array</li>
<li><strong>idx0</strong> &#8211; The first zero-based component of the element index</li>
<li><strong>idx1</strong> &#8211; The second zero-based component of the element index</li>
<li><strong>idx2</strong> &#8211; The third zero-based component of the element index</li>
<li><strong>idx</strong> &#8211; Array of the element indices</li>
<li><strong>value</strong> &#8211; The assigned value</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<p>The functions assign a new value to a specific element of a single-channel array. If the array has multiple channels, a runtime error is raised. Note that the <code class="docutils literal"><span class="pre">Set*D</span></code> function can be used safely for both single-channel and multiple-channel arrays, though they are a bit slower.</p>
<p>In the case of a sparse array the functions create the node if it does not yet exist.</p>
</div>
<div class="section" id="setzero">
<h2>SetZero<a class="headerlink" href="#setzero" title="Permalink to this headline">¶</a></h2>
<p>Clears the array.</p>
<dl class="cfunction">
<dt id="void cvSetZero(CvArr* arr)">
<strong>C:</strong><code class="descname"> </code>void <code class="descname">cvSetZero</code><span class="sig-paren">(</span>CvArr* <strong>arr</strong><span class="sig-paren">)</span><a class="headerlink" href="#void cvSetZero(CvArr* arr)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="pyoldfunction">
<dt id="cv.SetZero">
<strong>Python:</strong><code class="descname"> </code><code class="descclassname">cv.</code><code class="descname">SetZero</code><span class="sig-paren">(</span>arr<span class="sig-paren">)</span> &rarr; None<a class="headerlink" href="#cv.SetZero" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>arr</strong> &#8211; Array to be cleared</td>
</tr>
</tbody>
</table>
</dd></dl>

<p>The function clears the array. In the case of dense arrays (CvMat, CvMatND or IplImage), cvZero(array) is equivalent to cvSet(array,cvScalarAll(0),0). In the case of sparse arrays all the elements are removed.</p>
</div>
<div class="section" id="mget">
<h2>mGet<a class="headerlink" href="#mget" title="Permalink to this headline">¶</a></h2>
<p>Returns the particular element of single-channel floating-point matrix.</p>
<dl class="cfunction">
<dt id="double cvmGet(const CvMat* mat, int row, int col)">
<strong>C:</strong><code class="descname"> </code>double <code class="descname">cvmGet</code><span class="sig-paren">(</span>const CvMat* <strong>mat</strong>, int <strong>row</strong>, int <strong>col</strong><span class="sig-paren">)</span><a class="headerlink" href="#double cvmGet(const CvMat* mat, int row, int col)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="pyoldfunction">
<dt id="cv.mGet">
<strong>Python:</strong><code class="descname"> </code><code class="descclassname">cv.</code><code class="descname">mGet</code><span class="sig-paren">(</span>mat, row, col<span class="sig-paren">)</span> &rarr; float<a class="headerlink" href="#cv.mGet" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>mat</strong> &#8211; Input matrix</li>
<li><strong>row</strong> &#8211; The zero-based index of row</li>
<li><strong>col</strong> &#8211; The zero-based index of column</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<p>The function is a fast replacement for <a class="reference internal" href="#double cvGetReal2D(const CvArr* arr, int idx0, int idx1)" title="double cvGetReal2D(const CvArr* arr, int idx0, int idx1)"><code class="xref ocv ocv-cfunc docutils literal"><span class="pre">GetReal2D()</span></code></a> in the case of single-channel floating-point matrices. It is faster because it is inline, it does fewer checks for array type and array element type, and it checks for the row and column ranges only in debug mode.</p>
</div>
<div class="section" id="mset">
<h2>mSet<a class="headerlink" href="#mset" title="Permalink to this headline">¶</a></h2>
<p>Sets a specific element of a single-channel floating-point matrix.</p>
<dl class="cfunction">
<dt id="void cvmSet(CvMat* mat, int row, int col, double value)">
<strong>C:</strong><code class="descname"> </code>void <code class="descname">cvmSet</code><span class="sig-paren">(</span>CvMat* <strong>mat</strong>, int <strong>row</strong>, int <strong>col</strong>, double <strong>value</strong><span class="sig-paren">)</span><a class="headerlink" href="#void cvmSet(CvMat* mat, int row, int col, double value)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="pyoldfunction">
<dt id="cv.mSet">
<strong>Python:</strong><code class="descname"> </code><code class="descclassname">cv.</code><code class="descname">mSet</code><span class="sig-paren">(</span>mat, row, col, value<span class="sig-paren">)</span> &rarr; None<a class="headerlink" href="#cv.mSet" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>mat</strong> &#8211; The matrix</li>
<li><strong>row</strong> &#8211; The zero-based index of row</li>
<li><strong>col</strong> &#8211; The zero-based index of column</li>
<li><strong>value</strong> &#8211; The new value of the matrix element</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<p>The function is a fast replacement for <a class="reference internal" href="#void cvSetReal2D(CvArr* arr, int idx0, int idx1, double value)" title="void cvSetReal2D(CvArr* arr, int idx0, int idx1, double value)"><code class="xref ocv ocv-cfunc docutils literal"><span class="pre">SetReal2D()</span></code></a> in the case of single-channel floating-point matrices. It is faster because it is inline, it does fewer checks for array type and array element type,  and it checks for the row and column ranges only in debug mode.</p>
</div>
<div class="section" id="setiplallocators">
<h2>SetIPLAllocators<a class="headerlink" href="#setiplallocators" title="Permalink to this headline">¶</a></h2>
<p>Makes OpenCV use IPL functions for allocating IplImage and IplROI structures.</p>
<dl class="cfunction">
<dt id="void cvSetIPLAllocators(Cv_iplCreateImageHeader create_header, Cv_iplAllocateImageData allocate_data, Cv_iplDeallocate deallocate, Cv_iplCreateROI create_roi, Cv_iplCloneImage clone_image)">
<strong>C:</strong><code class="descname"> </code>void <code class="descname">cvSetIPLAllocators</code><span class="sig-paren">(</span>Cv_iplCreateImageHeader <strong>create_header</strong>, Cv_iplAllocateImageData <strong>allocate_data</strong>, Cv_iplDeallocate <strong>deallocate</strong>, Cv_iplCreateROI <strong>create_roi</strong>, Cv_iplCloneImage <strong>clone_image</strong><span class="sig-paren">)</span><a class="headerlink" href="#void cvSetIPLAllocators(Cv_iplCreateImageHeader create_header, Cv_iplAllocateImageData allocate_data, Cv_iplDeallocate deallocate, Cv_iplCreateROI create_roi, Cv_iplCloneImage clone_image)" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>create_header</strong> &#8211; pointer to a function, creating IPL image header.</li>
<li><strong>allocate_data</strong> &#8211; pointer to a function, allocating IPL image data.</li>
<li><strong>deallocate</strong> &#8211; pointer to a function, deallocating IPL image.</li>
<li><strong>create_roi</strong> &#8211; pointer to a function, creating IPL image ROI (i.e. Region of Interest).</li>
<li><strong>clone_image</strong> &#8211; pointer to a function, cloning an IPL image.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<p>Normally, the function is not called directly. Instead, a simple macro <code class="docutils literal"><span class="pre">CV_TURN_ON_IPL_COMPATIBILITY()</span></code> is used that calls <code class="docutils literal"><span class="pre">cvSetIPLAllocators</span></code> and passes there pointers to IPL allocation functions.</p>
<div class="highlight-c"><div class="highlight"><pre><span class="p">...</span>
<span class="n">CV_TURN_ON_IPL_COMPATIBILITY</span><span class="p">()</span>
<span class="p">...</span>
</pre></div>
</div>
</div>
<div class="section" id="rng">
<h2>RNG<a class="headerlink" href="#rng" title="Permalink to this headline">¶</a></h2>
<p>Initializes a random number generator state.</p>
<dl class="cfunction">
<dt id="CvRNG cvRNG(int64 seed)">
<strong>C:</strong><code class="descname"> </code>CvRNG <code class="descname">cvRNG</code><span class="sig-paren">(</span>int64 <strong>seed</strong>=-1<span class="sig-paren">)</span><a class="headerlink" href="#CvRNG cvRNG(int64 seed)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="pyoldfunction">
<dt id="cv.RNG">
<strong>Python:</strong><code class="descname"> </code><code class="descclassname">cv.</code><code class="descname">RNG</code><span class="sig-paren">(</span>seed=-1LL<span class="sig-paren">)</span> &rarr; CvRNG<a class="headerlink" href="#cv.RNG" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>seed</strong> &#8211; 64-bit value used to initiate a random sequence</td>
</tr>
</tbody>
</table>
</dd></dl>

<p>The function initializes a random number generator and returns the state. The pointer to the state can be then passed to the <a class="reference internal" href="#unsigned cvRandInt(CvRNG* rng)" title="unsigned cvRandInt(CvRNG* rng)"><code class="xref ocv ocv-cfunc docutils literal"><span class="pre">RandInt()</span></code></a>, <a class="reference internal" href="#double cvRandReal(CvRNG* rng)" title="double cvRandReal(CvRNG* rng)"><code class="xref ocv ocv-cfunc docutils literal"><span class="pre">RandReal()</span></code></a> and <a class="reference internal" href="#void cvRandArr(CvRNG* rng, CvArr* arr, int dist_type, CvScalar param1, CvScalar param2)" title="void cvRandArr(CvRNG* rng, CvArr* arr, int dist_type, CvScalar param1, CvScalar param2)"><code class="xref ocv ocv-cfunc docutils literal"><span class="pre">RandArr()</span></code></a> functions. In the current implementation a multiply-with-carry generator is used.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">the C++ class <a class="reference internal" href="operations_on_arrays.html#RNG" title="class RNG"><code class="xref ocv ocv-class docutils literal"><span class="pre">RNG</span></code></a> replaced <code class="docutils literal"><span class="pre">CvRNG</span></code>.</p>
</div>
</div>
<div class="section" id="randarr">
<h2>RandArr<a class="headerlink" href="#randarr" title="Permalink to this headline">¶</a></h2>
<p>Fills an array with random numbers and updates the RNG state.</p>
<dl class="cfunction">
<dt id="void cvRandArr(CvRNG* rng, CvArr* arr, int dist_type, CvScalar param1, CvScalar param2)">
<strong>C:</strong><code class="descname"> </code>void <code class="descname">cvRandArr</code><span class="sig-paren">(</span>CvRNG* <strong>rng</strong>, CvArr* <strong>arr</strong>, int <strong>dist_type</strong>, CvScalar <strong>param1</strong>, CvScalar <strong>param2</strong><span class="sig-paren">)</span><a class="headerlink" href="#void cvRandArr(CvRNG* rng, CvArr* arr, int dist_type, CvScalar param1, CvScalar param2)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="pyoldfunction">
<dt id="cv.RandArr">
<strong>Python:</strong><code class="descname"> </code><code class="descclassname">cv.</code><code class="descname">RandArr</code><span class="sig-paren">(</span>rng, arr, distType, param1, param2<span class="sig-paren">)</span> &rarr; None<a class="headerlink" href="#cv.RandArr" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>rng</strong> &#8211; CvRNG state initialized by <a class="reference internal" href="#CvRNG cvRNG(int64 seed)" title="CvRNG cvRNG(int64 seed)"><code class="xref ocv ocv-cfunc docutils literal"><span class="pre">RNG()</span></code></a></li>
<li><strong>arr</strong> &#8211; The destination array</li>
<li><strong>dist_type</strong> &#8211; <p>Distribution type</p>
<ul>
<li><strong>CV_RAND_UNI</strong> uniform distribution</li>
<li><strong>CV_RAND_NORMAL</strong> normal or Gaussian distribution</li>
</ul>
</li>
<li><strong>param1</strong> &#8211; The first parameter of the distribution. In the case of a uniform distribution it is the inclusive lower boundary of the random numbers range. In the case of a normal distribution it is the mean value of the random numbers.</li>
<li><strong>param2</strong> &#8211; The second parameter of the distribution. In the case of a uniform distribution it is the exclusive upper boundary of the random numbers range. In the case of a normal distribution it is the standard deviation of the random numbers.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<p>The function fills the destination array with uniformly or normally distributed random numbers.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="operations_on_arrays.html#template&lt;typename _Tp&gt; _Tp randu()" title="template&lt;typename _Tp&gt; _Tp randu()"><code class="xref ocv ocv-func docutils literal"><span class="pre">randu()</span></code></a>, <a class="reference internal" href="operations_on_arrays.html#void randn(InputOutputArray dst, InputArray mean, InputArray stddev)" title="void randn(InputOutputArray dst, InputArray mean, InputArray stddev)"><code class="xref ocv ocv-func docutils literal"><span class="pre">randn()</span></code></a>, <a class="reference internal" href="operations_on_arrays.html#void RNG::fill(InputOutputArray mat, int distType, InputArray a, InputArray b, bool saturateRange)" title="void RNG::fill(InputOutputArray mat, int distType, InputArray a, InputArray b, bool saturateRange)"><code class="xref ocv ocv-func docutils literal"><span class="pre">RNG::fill()</span></code></a>.</p>
</div>
</div>
<div class="section" id="randint">
<h2>RandInt<a class="headerlink" href="#randint" title="Permalink to this headline">¶</a></h2>
<p>Returns a 32-bit unsigned integer and updates RNG.</p>
<dl class="cfunction">
<dt id="unsigned cvRandInt(CvRNG* rng)">
<strong>C:</strong><code class="descname"> </code>unsigned int <code class="descname">cvRandInt</code><span class="sig-paren">(</span>CvRNG* <strong>rng</strong><span class="sig-paren">)</span><a class="headerlink" href="#unsigned cvRandInt(CvRNG* rng)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="pyoldfunction">
<dt id="cv.RandInt">
<strong>Python:</strong><code class="descname"> </code><code class="descclassname">cv.</code><code class="descname">RandInt</code><span class="sig-paren">(</span>rng<span class="sig-paren">)</span> &rarr; unsigned<a class="headerlink" href="#cv.RandInt" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>rng</strong> &#8211; CvRNG state initialized by  <a class="reference internal" href="#CvRNG cvRNG(int64 seed)" title="CvRNG cvRNG(int64 seed)"><code class="xref ocv ocv-cfunc docutils literal"><span class="pre">RNG()</span></code></a>.</td>
</tr>
</tbody>
</table>
</dd></dl>

<p>The function returns a uniformly-distributed random 32-bit unsigned integer and updates the RNG state. It is similar to the rand() function from the C runtime library, except that OpenCV functions always generates a 32-bit random number, regardless of the platform.</p>
</div>
<div class="section" id="randreal">
<h2>RandReal<a class="headerlink" href="#randreal" title="Permalink to this headline">¶</a></h2>
<p>Returns a floating-point random number and updates RNG.</p>
<dl class="cfunction">
<dt id="double cvRandReal(CvRNG* rng)">
<strong>C:</strong><code class="descname"> </code>double <code class="descname">cvRandReal</code><span class="sig-paren">(</span>CvRNG* <strong>rng</strong><span class="sig-paren">)</span><a class="headerlink" href="#double cvRandReal(CvRNG* rng)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="pyoldfunction">
<dt id="cv.RandReal">
<strong>Python:</strong><code class="descname"> </code><code class="descclassname">cv.</code><code class="descname">RandReal</code><span class="sig-paren">(</span>rng<span class="sig-paren">)</span> &rarr; float<a class="headerlink" href="#cv.RandReal" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>rng</strong> &#8211; RNG state initialized by  <a class="reference internal" href="#CvRNG cvRNG(int64 seed)" title="CvRNG cvRNG(int64 seed)"><code class="xref ocv ocv-cfunc docutils literal"><span class="pre">RNG()</span></code></a></td>
</tr>
</tbody>
</table>
</dd></dl>

<p>The function returns a uniformly-distributed random floating-point number between 0 and 1 (1 is not included).</p>
</div>
<div class="section" id="fromarray">
<h2>fromarray<a class="headerlink" href="#fromarray" title="Permalink to this headline">¶</a></h2>
<p>Create a CvMat from an object that supports the array interface.</p>
<dl class="pyoldfunction">
<dt id="cv.fromarray">
<strong>Python:</strong><code class="descname"> </code><code class="descclassname">cv.</code><code class="descname">fromarray</code><span class="sig-paren">(</span>array, allowND=False<span class="sig-paren">)</span> &rarr; mat<a class="headerlink" href="#cv.fromarray" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>object</strong> &#8211; Any object that supports the array interface</li>
<li><strong>allowND</strong> &#8211; If true, will return a CvMatND</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<p>If the object supports the <a class="reference external" href="http://docs.scipy.org/doc/numpy/reference/arrays.interface.html">array interface</a>
,
return a <a class="reference internal" href="#CvMat" title="struct CvMat"><code class="xref ocv ocv-struct docutils literal"><span class="pre">CvMat</span></code></a> or <a class="reference internal" href="#CvMatND" title="struct CvMatND"><code class="xref ocv ocv-struct docutils literal"><span class="pre">CvMatND</span></code></a>, depending on <code class="docutils literal"><span class="pre">allowND</span></code> flag:</p>
<blockquote>
<div><ul class="simple">
<li>If <code class="docutils literal"><span class="pre">allowND</span> <span class="pre">=</span> <span class="pre">False</span></code>, then the object&#8217;s array must be either 2D or 3D. If it is 2D, then the returned CvMat has a single channel.  If it is 3D, then the returned CvMat will have N channels, where N is the last dimension of the array. In this case, N cannot be greater than OpenCV&#8217;s channel limit, <code class="docutils literal"><span class="pre">CV_CN_MAX</span></code>.</li>
<li>If``allowND = True``, then <code class="docutils literal"><span class="pre">fromarray</span></code> returns a single-channel <a class="reference internal" href="#CvMatND" title="struct CvMatND"><code class="xref ocv ocv-struct docutils literal"><span class="pre">CvMatND</span></code></a> with the same shape as the original array.</li>
</ul>
</div></blockquote>
<p>For example, <a class="reference external" href="http://numpy.scipy.org/">NumPy</a> arrays support the array interface, so can be converted to OpenCV objects:</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">In the new Python wrappers (<strong>cv2</strong> module) the function is not needed, since cv2 can process  Numpy arrays (and this is the only supported array type).</p>
</div>
</div>
</div>


          </div>
          <div class="feedback">
              <h2>Help and Feedback</h2>
              You did not find what you were looking for?
              <ul>
                  
                  
                  
                  <li>Ask a question on the <a href="http://answers.opencv.org">Q&A forum</a>.</li>
                  <li>If you think something is missing or wrong in the documentation,
                  please file a <a href="http://code.opencv.org">bug report</a>.</li>
              </ul>
          </div>
        </div>
      </div>

      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../../../index.html">
              <img class="logo" src="../../../_static/opencv-logo-white.png" alt="Logo"/>
            </a></p>
<div id="searchbox" style="display: none">
      <form class="search" action="../../../search.html" method="get">
      <input type="text" name="q" size="18" />
      <input type="submit" value="Search" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
      </p>
    </form>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
  <h3><a href="../../../index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Basic C Structures and Operations</a><ul>
<li><a class="reference internal" href="#cvpoint">CvPoint</a></li>
<li><a class="reference internal" href="#cvpoint2d32f">CvPoint2D32f</a></li>
<li><a class="reference internal" href="#cvpoint3d32f">CvPoint3D32f</a></li>
<li><a class="reference internal" href="#cvpoint2d64f">CvPoint2D64f</a></li>
<li><a class="reference internal" href="#cvpoint3d64f">CvPoint3D64f</a></li>
<li><a class="reference internal" href="#cvsize">CvSize</a></li>
<li><a class="reference internal" href="#cvsize2d32f">CvSize2D32f</a></li>
<li><a class="reference internal" href="#cvrect">CvRect</a></li>
<li><a class="reference internal" href="#cvbox2d">CvBox2D</a></li>
<li><a class="reference internal" href="#cvscalar">CvScalar</a></li>
<li><a class="reference internal" href="#cvtermcriteria">CvTermCriteria</a></li>
<li><a class="reference internal" href="#cvmat">CvMat</a></li>
<li><a class="reference internal" href="#cvmatnd">CvMatND</a></li>
<li><a class="reference internal" href="#cvsparsemat">CvSparseMat</a></li>
<li><a class="reference internal" href="#iplimage">IplImage</a></li>
<li><a class="reference internal" href="#cvarr">CvArr</a></li>
<li><a class="reference internal" href="#clearnd">ClearND</a></li>
<li><a class="reference internal" href="#cloneimage">CloneImage</a></li>
<li><a class="reference internal" href="#clonemat">CloneMat</a></li>
<li><a class="reference internal" href="#clonematnd">CloneMatND</a></li>
<li><a class="reference internal" href="#clonesparsemat">CloneSparseMat</a></li>
<li><a class="reference internal" href="#convertscale">ConvertScale</a></li>
<li><a class="reference internal" href="#copy">Copy</a></li>
<li><a class="reference internal" href="#createdata">CreateData</a></li>
<li><a class="reference internal" href="#createimage">CreateImage</a></li>
<li><a class="reference internal" href="#createimageheader">CreateImageHeader</a></li>
<li><a class="reference internal" href="#createmat">CreateMat</a></li>
<li><a class="reference internal" href="#creatematheader">CreateMatHeader</a></li>
<li><a class="reference internal" href="#creatematnd">CreateMatND</a></li>
<li><a class="reference internal" href="#creatematndheader">CreateMatNDHeader</a></li>
<li><a class="reference internal" href="#createsparsemat">CreateSparseMat</a></li>
<li><a class="reference internal" href="#crossproduct">CrossProduct</a></li>
<li><a class="reference internal" href="#dotproduct">DotProduct</a></li>
<li><a class="reference internal" href="#get-d">Get?D</a></li>
<li><a class="reference internal" href="#getcol-s">GetCol(s)</a></li>
<li><a class="reference internal" href="#getdiag">GetDiag</a></li>
<li><a class="reference internal" href="#getdims">GetDims</a></li>
<li><a class="reference internal" href="#getdimsize">GetDimSize</a></li>
<li><a class="reference internal" href="#getelemtype">GetElemType</a></li>
<li><a class="reference internal" href="#getimage">GetImage</a></li>
<li><a class="reference internal" href="#getimagecoi">GetImageCOI</a></li>
<li><a class="reference internal" href="#getimageroi">GetImageROI</a></li>
<li><a class="reference internal" href="#getmat">GetMat</a></li>
<li><a class="reference internal" href="#getnextsparsenode">GetNextSparseNode</a></li>
<li><a class="reference internal" href="#getrawdata">GetRawData</a></li>
<li><a class="reference internal" href="#getreal-d">GetReal?D</a></li>
<li><a class="reference internal" href="#getrow-s">GetRow(s)</a></li>
<li><a class="reference internal" href="#getsize">GetSize</a></li>
<li><a class="reference internal" href="#getsubrect">GetSubRect</a></li>
<li><a class="reference internal" href="#decrefdata">DecRefData</a></li>
<li><a class="reference internal" href="#increfdata">IncRefData</a></li>
<li><a class="reference internal" href="#initimageheader">InitImageHeader</a></li>
<li><a class="reference internal" href="#initmatheader">InitMatHeader</a></li>
<li><a class="reference internal" href="#initmatndheader">InitMatNDHeader</a></li>
<li><a class="reference internal" href="#initsparsematiterator">InitSparseMatIterator</a></li>
<li><a class="reference internal" href="#mat">Mat</a></li>
<li><a class="reference internal" href="#ptr-d">Ptr?D</a></li>
<li><a class="reference internal" href="#releasedata">ReleaseData</a></li>
<li><a class="reference internal" href="#releaseimage">ReleaseImage</a></li>
<li><a class="reference internal" href="#releaseimageheader">ReleaseImageHeader</a></li>
<li><a class="reference internal" href="#releasemat">ReleaseMat</a></li>
<li><a class="reference internal" href="#releasematnd">ReleaseMatND</a></li>
<li><a class="reference internal" href="#releasesparsemat">ReleaseSparseMat</a></li>
<li><a class="reference internal" href="#resetimageroi">ResetImageROI</a></li>
<li><a class="reference internal" href="#reshape">Reshape</a></li>
<li><a class="reference internal" href="#reshapematnd">ReshapeMatND</a></li>
<li><a class="reference internal" href="#set">Set</a></li>
<li><a class="reference internal" href="#set-d">Set?D</a></li>
<li><a class="reference internal" href="#setdata">SetData</a></li>
<li><a class="reference internal" href="#setimagecoi">SetImageCOI</a></li>
<li><a class="reference internal" href="#setimageroi">SetImageROI</a></li>
<li><a class="reference internal" href="#setreal-d">SetReal?D</a></li>
<li><a class="reference internal" href="#setzero">SetZero</a></li>
<li><a class="reference internal" href="#mget">mGet</a></li>
<li><a class="reference internal" href="#mset">mSet</a></li>
<li><a class="reference internal" href="#setiplallocators">SetIPLAllocators</a></li>
<li><a class="reference internal" href="#rng">RNG</a></li>
<li><a class="reference internal" href="#randarr">RandArr</a></li>
<li><a class="reference internal" href="#randint">RandInt</a></li>
<li><a class="reference internal" href="#randreal">RandReal</a></li>
<li><a class="reference internal" href="#fromarray">fromarray</a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="basic_structures.html"
                        title="previous chapter">Basic Structures</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="dynamic_structures.html"
                        title="next chapter">Dynamic Structures</a></p>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../../../_sources/modules/core/doc/old_basic_structures.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="dynamic_structures.html" title="Dynamic Structures"
             >next</a> |</li>
        <li class="right" >
          <a href="basic_structures.html" title="Basic Structures"
             >previous</a> |</li>
        <li><a href="../../../index.html">OpenCV 2.4.13.7 documentation</a> &raquo;</li>
          <li><a href="../../refman.html" >OpenCV API Reference</a> &raquo;</li>
          <li><a href="core.html" >core. The Core Functionality</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2011-2014, opencv dev team.
      Last updated on Jul 12, 2018.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.3.6.
    </div>
  </body>
</html>
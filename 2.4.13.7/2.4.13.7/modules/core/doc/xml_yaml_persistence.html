<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<script type="text/javascript">

  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-33108845-1']);
  _gaq.push(['_setDomainName', 'opencv.org']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();

</script>

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>XML/YAML Persistence &mdash; OpenCV 2.4.13.7 documentation</title>
    <link rel="stylesheet" href="../../../_static/default.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../../',
        VERSION:     '2.4.13.7',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../../_static/doctools.js"></script>
    <link rel="top" title="OpenCV 2.4.13.7 documentation" href="../../../index.html" />
    <link rel="up" title="core. The Core Functionality" href="core.html" />
    <link rel="next" title="XML/YAML Persistence (C API)" href="old_xml_yaml_persistence.html" />
    <link rel="prev" title="Drawing Functions" href="drawing_functions.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="old_xml_yaml_persistence.html" title="XML/YAML Persistence (C API)"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="drawing_functions.html" title="Drawing Functions"
             accesskey="P">previous</a> |</li>
        <li><a href="../../../index.html">OpenCV 2.4.13.7 documentation</a> &raquo;</li>
          <li><a href="../../refman.html" >OpenCV API Reference</a> &raquo;</li>
          <li><a href="core.html" accesskey="U">core. The Core Functionality</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
  
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="xml-yaml-persistence">
<h1>XML/YAML Persistence<a class="headerlink" href="#xml-yaml-persistence" title="Permalink to this headline">¶</a></h1>
<div class="section" id="xml-yaml-file-storages-writing-to-a-file-storage">
<h2>XML/YAML file storages. Writing to a file storage.<a class="headerlink" href="#xml-yaml-file-storages-writing-to-a-file-storage" title="Permalink to this headline">¶</a></h2>
<p>You can store and then restore various OpenCV data structures to/from XML (<a class="reference external" href="http://www.w3c.org/XML">http://www.w3c.org/XML</a>) or YAML
(<a class="reference external" href="http://www.yaml.org">http://www.yaml.org</a>) formats. Also, it is possible store and load arbitrarily complex data structures, which include OpenCV data structures, as well as primitive data types (integer and floating-point numbers and text strings) as their elements.</p>
<dl class="docutils">
<dt>Use the following procedure to write something to XML or YAML:</dt>
<dd><ol class="first last arabic simple">
<li>Create new <a class="reference internal" href="#FileStorage" title="class FileStorage"><code class="xref ocv ocv-class docutils literal"><span class="pre">FileStorage</span></code></a> and open it for writing. It can be done with a single call to <a class="reference internal" href="#FileStorage::FileStorage()" title="FileStorage::FileStorage()"><code class="xref ocv ocv-func docutils literal"><span class="pre">FileStorage::FileStorage()</span></code></a> constructor that takes a filename, or you can use the default constructor and then call <a class="reference internal" href="#bool FileStorage::open(const string&amp; filename, int flags, const string&amp; encoding)" title="bool FileStorage::open(const string&amp; filename, int flags, const string&amp; encoding)"><code class="xref ocv ocv-func docutils literal"><span class="pre">FileStorage::open()</span></code></a>. Format of the file (XML or YAML) is determined from the filename extension (&#8221;.xml&#8221; and &#8221;.yml&#8221;/&#8221;.yaml&#8221;, respectively)</li>
<li>Write all the data you want using the streaming operator <code class="docutils literal"><span class="pre">&lt;&lt;</span></code>, just like in the case of STL streams.</li>
<li>Close the file using <a class="reference internal" href="#void FileStorage::release()" title="void FileStorage::release()"><code class="xref ocv ocv-func docutils literal"><span class="pre">FileStorage::release()</span></code></a>. <code class="docutils literal"><span class="pre">FileStorage</span></code> destructor also closes the file.</li>
</ol>
</dd>
</dl>
<p>Here is an example:</p>
<div class="highlight-cpp"><div class="highlight"><pre><span class="cp">#include</span> <span class="cpf">&quot;opencv2/opencv.hpp&quot;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;time.h&gt;</span><span class="cp"></span>

<span class="k">using</span> <span class="k">namespace</span> <span class="n">cv</span><span class="p">;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">char</span><span class="o">**</span> <span class="n">argv</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">FileStorage</span> <span class="n">fs</span><span class="p">(</span><span class="s">&quot;test.yml&quot;</span><span class="p">,</span> <span class="n">FileStorage</span><span class="o">::</span><span class="n">WRITE</span><span class="p">);</span>

    <span class="n">fs</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;frameCount&quot;</span> <span class="o">&lt;&lt;</span> <span class="mi">5</span><span class="p">;</span>
    <span class="kt">time_t</span> <span class="n">rawtime</span><span class="p">;</span> <span class="n">time</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rawtime</span><span class="p">);</span>
    <span class="n">fs</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;calibrationDate&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">asctime</span><span class="p">(</span><span class="n">localtime</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rawtime</span><span class="p">));</span>
    <span class="n">Mat</span> <span class="n">cameraMatrix</span> <span class="o">=</span> <span class="p">(</span><span class="n">Mat_</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">1000</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">320</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1000</span><span class="p">,</span> <span class="mi">240</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
    <span class="n">Mat</span> <span class="n">distCoeffs</span> <span class="o">=</span> <span class="p">(</span><span class="n">Mat_</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.01</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.001</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
    <span class="n">fs</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;cameraMatrix&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">cameraMatrix</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;distCoeffs&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">distCoeffs</span><span class="p">;</span>
    <span class="n">fs</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;features&quot;</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;[&quot;</span><span class="p">;</span>
    <span class="k">for</span><span class="p">(</span> <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span> <span class="p">)</span>
    <span class="p">{</span>
        <span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="n">rand</span><span class="p">()</span> <span class="o">%</span> <span class="mi">640</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">y</span> <span class="o">=</span> <span class="n">rand</span><span class="p">()</span> <span class="o">%</span> <span class="mi">480</span><span class="p">;</span>
        <span class="n">uchar</span> <span class="n">lbp</span> <span class="o">=</span> <span class="n">rand</span><span class="p">()</span> <span class="o">%</span> <span class="mi">256</span><span class="p">;</span>

        <span class="n">fs</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;{:&quot;</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;x&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">x</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;y&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">y</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;lbp&quot;</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;[:&quot;</span><span class="p">;</span>
        <span class="k">for</span><span class="p">(</span> <span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="mi">8</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span> <span class="p">)</span>
            <span class="n">fs</span> <span class="o">&lt;&lt;</span> <span class="p">((</span><span class="n">lbp</span> <span class="o">&gt;&gt;</span> <span class="n">j</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">);</span>
        <span class="n">fs</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;]&quot;</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;}&quot;</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">fs</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;]&quot;</span><span class="p">;</span>
    <span class="n">fs</span><span class="p">.</span><span class="n">release</span><span class="p">();</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The sample above stores to XML and integer, text string (calibration date), 2 matrices, and a custom structure &#8220;feature&#8221;, which includes feature coordinates and LBP (local binary pattern) value. Here is output of the sample:</p>
<div class="highlight-yaml"><div class="highlight"><pre>%YAML:1.0
frameCount: 5
calibrationDate: &quot;Fri Jun 17 14:09:29 2011\n&quot;
cameraMatrix: !!opencv-matrix
   rows: 3
   cols: 3
   dt: d
   data: [ 1000., 0., 320., 0., 1000., 240., 0., 0., 1. ]
distCoeffs: !!opencv-matrix
   rows: 5
   cols: 1
   dt: d
   data: [ 1.0000000000000001e-01, 1.0000000000000000e-02,
       -1.0000000000000000e-03, 0., 0. ]
features:
   - { x:167, y:49, lbp:[ 1, 0, 0, 1, 1, 0, 1, 1 ] }
   - { x:298, y:130, lbp:[ 0, 0, 0, 1, 0, 0, 1, 1 ] }
   - { x:344, y:158, lbp:[ 1, 1, 0, 0, 0, 0, 1, 0 ] }
</pre></div>
</div>
<p>As an exercise, you can replace &#8221;.yml&#8221; with &#8221;.xml&#8221; in the sample above and see, how the corresponding XML file will look like.</p>
<dl class="docutils">
<dt>Several things can be noted by looking at the sample code and the output:</dt>
<dd><ul class="first last">
<li><p class="first">The produced YAML (and XML) consists of heterogeneous collections that can be nested. There are 2 types of collections: named collections (mappings) and unnamed collections (sequences). In mappings each element has a name and is accessed by name. This is similar to structures and <code class="docutils literal"><span class="pre">std::map</span></code> in C/C++ and dictionaries in Python. In sequences elements do not have names, they are accessed by indices. This is similar to arrays and <code class="docutils literal"><span class="pre">std::vector</span></code> in C/C++ and lists, tuples in Python. &#8220;Heterogeneous&#8221; means that elements of each single collection can have different types.</p>
<p>Top-level collection in YAML/XML is a mapping. Each matrix is stored as a mapping, and the matrix elements are stored as a sequence. Then, there is a sequence of features, where each feature is represented a mapping, and lbp value in a nested sequence.</p>
</li>
<li><p class="first">When you write to a mapping (a structure), you write element name followed by its value. When you write to a sequence, you simply write the elements one by one. OpenCV data structures (such as cv::Mat) are written in absolutely the same way as simple C data structures - using <strong>``&lt;&lt;``</strong> operator.</p>
</li>
<li><p class="first">To write a mapping, you first write the special string <strong>&#8220;{&#8220;</strong> to the storage, then write the elements as pairs (<code class="docutils literal"><span class="pre">fs</span> <span class="pre">&lt;&lt;</span> <span class="pre">&lt;element_name&gt;</span> <span class="pre">&lt;&lt;</span> <span class="pre">&lt;element_value&gt;</span></code>) and then write the closing <strong>&#8220;}&#8221;</strong>.</p>
</li>
<li><p class="first">To write a sequence, you first write the special string <strong>&#8220;[&#8220;</strong>, then write the elements, then write the closing <strong>&#8220;]&#8221;</strong>.</p>
</li>
<li><p class="first">In YAML (but not XML), mappings and sequences can be written in a compact Python-like inline form. In the sample above matrix elements, as well as each feature, including its lbp value, is stored in such inline form. To store a mapping/sequence in a compact form, put &#8221;:&#8221; after the opening character, e.g. use <strong>&#8220;{:&#8221;</strong> instead of <strong>&#8220;{&#8220;</strong> and <strong>&#8220;[:&#8221;</strong> instead of <strong>&#8220;[&#8220;</strong>. When the data is written to XML, those extra &#8221;:&#8221; are ignored.</p>
</li>
</ul>
</dd>
</dl>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<ul class="last simple">
<li>A complete example using the FileStorage interface can be found at opencv_source_code/samples/cpp/filestorage.cpp</li>
</ul>
</div>
</div>
<div class="section" id="reading-data-from-a-file-storage">
<h2>Reading data from a file storage.<a class="headerlink" href="#reading-data-from-a-file-storage" title="Permalink to this headline">¶</a></h2>
<p>To read the previously written XML or YAML file, do the following:</p>
<blockquote>
<div><ol class="arabic simple">
<li>Open the file storage using <a class="reference internal" href="#FileStorage::FileStorage()" title="FileStorage::FileStorage()"><code class="xref ocv ocv-func docutils literal"><span class="pre">FileStorage::FileStorage()</span></code></a> constructor or <a class="reference internal" href="#bool FileStorage::open(const string&amp; filename, int flags, const string&amp; encoding)" title="bool FileStorage::open(const string&amp; filename, int flags, const string&amp; encoding)"><code class="xref ocv ocv-func docutils literal"><span class="pre">FileStorage::open()</span></code></a> method. In the current implementation the whole file is parsed and the whole representation of file storage is built in memory as a hierarchy of file nodes (see <a class="reference internal" href="#FileNode" title="class FileNode"><code class="xref ocv ocv-class docutils literal"><span class="pre">FileNode</span></code></a>)</li>
<li>Read the data you are interested in. Use <a class="reference internal" href="#FileNode FileStorage::operator[](const string&amp; nodename) const" title="FileNode FileStorage::operator[](const string&amp; nodename) const"><code class="xref ocv ocv-func docutils literal"><span class="pre">FileStorage::operator</span> <span class="pre">[]()</span></code></a>, <a class="reference internal" href="#FileNode FileNode::operator[](const string&amp; nodename) const" title="FileNode FileNode::operator[](const string&amp; nodename) const"><code class="xref ocv ocv-func docutils literal"><span class="pre">FileNode::operator</span> <span class="pre">[]()</span></code></a> and/or <a class="reference internal" href="#FileNodeIterator" title="class FileNodeIterator"><code class="xref ocv ocv-class docutils literal"><span class="pre">FileNodeIterator</span></code></a>.</li>
<li>Close the storage using <a class="reference internal" href="#void FileStorage::release()" title="void FileStorage::release()"><code class="xref ocv ocv-func docutils literal"><span class="pre">FileStorage::release()</span></code></a>.</li>
</ol>
</div></blockquote>
<p>Here is how to read the file created by the code sample above:</p>
<div class="highlight-cpp"><div class="highlight"><pre><span class="n">FileStorage</span> <span class="nf">fs2</span><span class="p">(</span><span class="s">&quot;test.yml&quot;</span><span class="p">,</span> <span class="n">FileStorage</span><span class="o">::</span><span class="n">READ</span><span class="p">);</span>

<span class="c1">// first method: use (type) operator on FileNode.</span>
<span class="kt">int</span> <span class="n">frameCount</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">fs2</span><span class="p">[</span><span class="s">&quot;frameCount&quot;</span><span class="p">];</span>

<span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">date</span><span class="p">;</span>
<span class="c1">// second method: use FileNode::operator &gt;&gt;</span>
<span class="n">fs2</span><span class="p">[</span><span class="s">&quot;calibrationDate&quot;</span><span class="p">]</span> <span class="o">&gt;&gt;</span> <span class="n">date</span><span class="p">;</span>

<span class="n">Mat</span> <span class="n">cameraMatrix2</span><span class="p">,</span> <span class="n">distCoeffs2</span><span class="p">;</span>
<span class="n">fs2</span><span class="p">[</span><span class="s">&quot;cameraMatrix&quot;</span><span class="p">]</span> <span class="o">&gt;&gt;</span> <span class="n">cameraMatrix2</span><span class="p">;</span>
<span class="n">fs2</span><span class="p">[</span><span class="s">&quot;distCoeffs&quot;</span><span class="p">]</span> <span class="o">&gt;&gt;</span> <span class="n">distCoeffs2</span><span class="p">;</span>

<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;frameCount: &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">frameCount</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span>
     <span class="o">&lt;&lt;</span> <span class="s">&quot;calibration date: &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">date</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span>
     <span class="o">&lt;&lt;</span> <span class="s">&quot;camera matrix: &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">cameraMatrix2</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span>
     <span class="o">&lt;&lt;</span> <span class="s">&quot;distortion coeffs: &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">distCoeffs2</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>

<span class="n">FileNode</span> <span class="n">features</span> <span class="o">=</span> <span class="n">fs2</span><span class="p">[</span><span class="s">&quot;features&quot;</span><span class="p">];</span>
<span class="n">FileNodeIterator</span> <span class="n">it</span> <span class="o">=</span> <span class="n">features</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">it_end</span> <span class="o">=</span> <span class="n">features</span><span class="p">.</span><span class="n">end</span><span class="p">();</span>
<span class="kt">int</span> <span class="n">idx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">uchar</span><span class="o">&gt;</span> <span class="n">lbpval</span><span class="p">;</span>

<span class="c1">// iterate through a sequence using FileNodeIterator</span>
<span class="k">for</span><span class="p">(</span> <span class="p">;</span> <span class="n">it</span> <span class="o">!=</span> <span class="n">it_end</span><span class="p">;</span> <span class="o">++</span><span class="n">it</span><span class="p">,</span> <span class="n">idx</span><span class="o">++</span> <span class="p">)</span>
<span class="p">{</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;feature #&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">idx</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;: &quot;</span><span class="p">;</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;x=&quot;</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="kt">int</span><span class="p">)(</span><span class="o">*</span><span class="n">it</span><span class="p">)[</span><span class="s">&quot;x&quot;</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;, y=&quot;</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="kt">int</span><span class="p">)(</span><span class="o">*</span><span class="n">it</span><span class="p">)[</span><span class="s">&quot;y&quot;</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;, lbp: (&quot;</span><span class="p">;</span>
    <span class="c1">// you can also easily read numerical arrays using FileNode &gt;&gt; std::vector operator.</span>
    <span class="p">(</span><span class="o">*</span><span class="n">it</span><span class="p">)[</span><span class="s">&quot;lbp&quot;</span><span class="p">]</span> <span class="o">&gt;&gt;</span> <span class="n">lbpval</span><span class="p">;</span>
    <span class="k">for</span><span class="p">(</span> <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">lbpval</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span> <span class="p">)</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot; &quot;</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">lbpval</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;)&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">fs</span><span class="p">.</span><span class="n">release</span><span class="p">();</span>
</pre></div>
</div>
</div>
<div class="section" id="filestorage">
<h2>FileStorage<a class="headerlink" href="#filestorage" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="FileStorage">
<em class="property">class </em><code class="descname">FileStorage</code><a class="headerlink" href="#FileStorage" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p>XML/YAML file storage class that encapsulates all the information necessary for writing or reading data to/from a file.</p>
</div>
<div class="section" id="filestorage-filestorage">
<h2>FileStorage::FileStorage<a class="headerlink" href="#filestorage-filestorage" title="Permalink to this headline">¶</a></h2>
<p>The constructors.</p>
<dl class="function">
<dt id="FileStorage::FileStorage()">
<strong>C++:</strong><code class="descname"> </code> <code class="descclassname">FileStorage::</code><code class="descname">FileStorage</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#FileStorage::FileStorage()" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="FileStorage::FileStorage(const string&amp; source, int flags, const string&amp; encoding)">
<strong>C++:</strong><code class="descname"> </code> <code class="descclassname">FileStorage::</code><code class="descname">FileStorage</code><span class="sig-paren">(</span>const string&amp; <strong>source</strong>, int <strong>flags</strong>, const string&amp; <strong>encoding</strong>=string()<span class="sig-paren">)</span><a class="headerlink" href="#FileStorage::FileStorage(const string& source, int flags, const string& encoding)" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>source</strong> &#8211; Name of the file to open or the text string to read the data from. Extension of the file (<code class="docutils literal"><span class="pre">.xml</span></code> or <code class="docutils literal"><span class="pre">.yml</span></code>/<code class="docutils literal"><span class="pre">.yaml</span></code>) determines its format (XML or YAML respectively). Also you can append <code class="docutils literal"><span class="pre">.gz</span></code> to work with compressed files, for example <code class="docutils literal"><span class="pre">myHugeMatrix.xml.gz</span></code>. If both <code class="docutils literal"><span class="pre">FileStorage::WRITE</span></code> and <code class="docutils literal"><span class="pre">FileStorage::MEMORY</span></code> flags are specified, <code class="docutils literal"><span class="pre">source</span></code> is used just to specify the output file format (e.g. <code class="docutils literal"><span class="pre">mydata.xml</span></code>, <code class="docutils literal"><span class="pre">.yml</span></code> etc.).</li>
<li><strong>flags</strong> &#8211; <p>Mode of operation. Possible values are:</p>
<ul>
<li><strong>FileStorage::READ</strong> Open the file for reading.</li>
<li><strong>FileStorage::WRITE</strong> Open the file for writing.</li>
<li><strong>FileStorage::APPEND</strong> Open the file for appending.</li>
<li><strong>FileStorage::MEMORY</strong> Read data from <code class="docutils literal"><span class="pre">source</span></code> or write data to the internal buffer (which is returned by <code class="docutils literal"><span class="pre">FileStorage::release</span></code>)</li>
</ul>
</li>
<li><strong>encoding</strong> &#8211; Encoding of the file. Note that UTF-16 XML encoding is not supported currently and you should use 8-bit encoding instead of it.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<p>The full constructor opens the file. Alternatively you can use the default constructor and then call <a class="reference internal" href="#bool FileStorage::open(const string&amp; filename, int flags, const string&amp; encoding)" title="bool FileStorage::open(const string&amp; filename, int flags, const string&amp; encoding)"><code class="xref ocv ocv-func docutils literal"><span class="pre">FileStorage::open()</span></code></a>.</p>
</div>
<div class="section" id="filestorage-open">
<h2>FileStorage::open<a class="headerlink" href="#filestorage-open" title="Permalink to this headline">¶</a></h2>
<p>Opens a file.</p>
<dl class="function">
<dt id="bool FileStorage::open(const string&amp; filename, int flags, const string&amp; encoding)">
<strong>C++:</strong><code class="descname"> </code>bool <code class="descclassname">FileStorage::</code><code class="descname">open</code><span class="sig-paren">(</span>const string&amp; <strong>filename</strong>, int <strong>flags</strong>, const string&amp; <strong>encoding</strong>=string()<span class="sig-paren">)</span><a class="headerlink" href="#bool FileStorage::open(const string& filename, int flags, const string& encoding)" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>filename</strong> &#8211; Name of the file to open or the text string to read the data from.
Extension of the file (<code class="docutils literal"><span class="pre">.xml</span></code> or <code class="docutils literal"><span class="pre">.yml</span></code>/<code class="docutils literal"><span class="pre">.yaml</span></code>) determines its format (XML or YAML respectively).
Also you can append <code class="docutils literal"><span class="pre">.gz</span></code> to work with compressed files, for example <code class="docutils literal"><span class="pre">myHugeMatrix.xml.gz</span></code>.
If both <code class="docutils literal"><span class="pre">FileStorage::WRITE</span></code> and <code class="docutils literal"><span class="pre">FileStorage::MEMORY</span></code> flags are specified, <code class="docutils literal"><span class="pre">source</span></code>
is used just to specify the output file format (e.g. <code class="docutils literal"><span class="pre">mydata.xml</span></code>, <code class="docutils literal"><span class="pre">.yml</span></code> etc.).</li>
<li><strong>flags</strong> &#8211; Mode of operation. See FileStorage constructor for more details.</li>
<li><strong>encoding</strong> &#8211; Encoding of the file. Note that UTF-16 XML encoding is not supported currently and you should use 8-bit encoding instead of it.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<p>See description of parameters in <a class="reference internal" href="#FileStorage::FileStorage()" title="FileStorage::FileStorage()"><code class="xref ocv ocv-func docutils literal"><span class="pre">FileStorage::FileStorage()</span></code></a>. The method calls <a class="reference internal" href="#void FileStorage::release()" title="void FileStorage::release()"><code class="xref ocv ocv-func docutils literal"><span class="pre">FileStorage::release()</span></code></a> before opening the file.</p>
</div>
<div class="section" id="filestorage-isopened">
<h2>FileStorage::isOpened<a class="headerlink" href="#filestorage-isopened" title="Permalink to this headline">¶</a></h2>
<p>Checks whether the file is opened.</p>
<dl class="function">
<dt id="bool FileStorage::isOpened() const">
<strong>C++:</strong><code class="descname"> </code>bool <code class="descclassname">FileStorage::</code><code class="descname">isOpened</code><span class="sig-paren">(</span><span class="sig-paren">)</span><code class="descclassname"> const</code><a class="headerlink" href="#bool FileStorage::isOpened() const" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><code class="docutils literal"><span class="pre">true</span></code> if the object is associated with the current file and <code class="docutils literal"><span class="pre">false</span></code> otherwise.</td>
</tr>
</tbody>
</table>
</dd></dl>

<p>It is a good practice to call this method after you tried to open a file.</p>
</div>
<div class="section" id="filestorage-release">
<h2>FileStorage::release<a class="headerlink" href="#filestorage-release" title="Permalink to this headline">¶</a></h2>
<p>Closes the file and releases all the memory buffers.</p>
<dl class="function">
<dt id="void FileStorage::release()">
<strong>C++:</strong><code class="descname"> </code>void <code class="descclassname">FileStorage::</code><code class="descname">release</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#void FileStorage::release()" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p>Call this method after all I/O operations with the storage are finished.</p>
</div>
<div class="section" id="filestorage-releaseandgetstring">
<h2>FileStorage::releaseAndGetString<a class="headerlink" href="#filestorage-releaseandgetstring" title="Permalink to this headline">¶</a></h2>
<p>Closes the file and releases all the memory buffers.</p>
<dl class="function">
<dt id="string FileStorage::releaseAndGetString()">
<strong>C++:</strong><code class="descname"> </code>string <code class="descclassname">FileStorage::</code><code class="descname">releaseAndGetString</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#string FileStorage::releaseAndGetString()" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p>Call this method after all I/O operations with the storage are finished. If the storage was opened for writing data and <code class="docutils literal"><span class="pre">FileStorage::WRITE</span></code> was specified</p>
</div>
<div class="section" id="filestorage-getfirsttoplevelnode">
<h2>FileStorage::getFirstTopLevelNode<a class="headerlink" href="#filestorage-getfirsttoplevelnode" title="Permalink to this headline">¶</a></h2>
<p>Returns the first element of the top-level mapping.</p>
<dl class="function">
<dt id="FileNode FileStorage::getFirstTopLevelNode() const">
<strong>C++:</strong><code class="descname"> </code>FileNode <code class="descclassname">FileStorage::</code><code class="descname">getFirstTopLevelNode</code><span class="sig-paren">(</span><span class="sig-paren">)</span><code class="descclassname"> const</code><a class="headerlink" href="#FileNode FileStorage::getFirstTopLevelNode() const" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">The first element of the top-level mapping.</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="filestorage-root">
<h2>FileStorage::root<a class="headerlink" href="#filestorage-root" title="Permalink to this headline">¶</a></h2>
<p>Returns the top-level mapping</p>
<dl class="function">
<dt id="FileNode FileStorage::root(int streamidx) const">
<strong>C++:</strong><code class="descname"> </code>FileNode <code class="descclassname">FileStorage::</code><code class="descname">root</code><span class="sig-paren">(</span>int <strong>streamidx</strong>=0<span class="sig-paren">)</span><code class="descclassname"> const</code><a class="headerlink" href="#FileNode FileStorage::root(int streamidx) const" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>streamidx</strong> &#8211; Zero-based index of the stream. In most cases there is only one stream in the file. However, YAML supports multiple streams and so there can be several.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">The top-level mapping.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="filestorage-operator">
<h2>FileStorage::operator[]<a class="headerlink" href="#filestorage-operator" title="Permalink to this headline">¶</a></h2>
<p>Returns the specified element of the top-level mapping.</p>
<dl class="function">
<dt id="FileNode FileStorage::operator[](const string&amp; nodename) const">
<strong>C++:</strong><code class="descname"> </code>FileNode <code class="descclassname">FileStorage::</code><code class="descname">operator[]</code><span class="sig-paren">(</span>const string&amp; <strong>nodename</strong><span class="sig-paren">)</span><code class="descclassname"> const</code><a class="headerlink" href="#FileNode FileStorage::operator[](const string& nodename) const" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="FileNode FileStorage::operator[](const char* nodename) const">
<strong>C++:</strong><code class="descname"> </code>FileNode <code class="descclassname">FileStorage::</code><code class="descname">operator[]</code><span class="sig-paren">(</span>const char* <strong>nodename</strong><span class="sig-paren">)</span><code class="descclassname"> const</code><a class="headerlink" href="#FileNode FileStorage::operator[](const char* nodename) const" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>nodename</strong> &#8211; Name of the file node.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">Node with the given name.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="id1">
<h2>FileStorage::operator*<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h2>
<p>Returns the obsolete C FileStorage structure.</p>
<dl class="function">
<dt id="CvFileStorage* FileStorage::operator *()">
<strong>C++:</strong><code class="descname"> </code>CvFileStorage* <code class="descclassname">FileStorage::</code><code class="descname">operator*</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#CvFileStorage* FileStorage::operator *()" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="const CvFileStorage* FileStorage::operator *() const">
<strong>C++:</strong><code class="descname"> </code>const CvFileStorage* <code class="descclassname">FileStorage::</code><code class="descname">operator*</code><span class="sig-paren">(</span><span class="sig-paren">)</span><code class="descclassname"> const</code><a class="headerlink" href="#const CvFileStorage* FileStorage::operator *() const" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">Pointer to the underlying C FileStorage structure</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="filestorage-writeraw">
<h2>FileStorage::writeRaw<a class="headerlink" href="#filestorage-writeraw" title="Permalink to this headline">¶</a></h2>
<p>Writes multiple numbers.</p>
<dl class="function">
<dt id="void FileStorage::writeRaw(const string&amp; fmt, const uchar* vec, size_t len)">
<strong>C++:</strong><code class="descname"> </code>void <code class="descclassname">FileStorage::</code><code class="descname">writeRaw</code><span class="sig-paren">(</span>const string&amp; <strong>fmt</strong>, const uchar* <strong>vec</strong>, size_t <strong>len</strong><span class="sig-paren">)</span><a class="headerlink" href="#void FileStorage::writeRaw(const string& fmt, const uchar* vec, size_t len)" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>fmt</strong> &#8211; <p>Specification of each array element that has the following format  <code class="docutils literal"><span class="pre">([count]{'u'|'c'|'w'|'s'|'i'|'f'|'d'})...</span></code> where the characters correspond to fundamental C++ types:</p>
<ul>
<li><strong>u</strong> 8-bit unsigned number</li>
<li><strong>c</strong> 8-bit signed number</li>
<li><strong>w</strong> 16-bit unsigned number</li>
<li><strong>s</strong> 16-bit signed number</li>
<li><strong>i</strong> 32-bit signed number</li>
<li><strong>f</strong> single precision floating-point number</li>
<li><strong>d</strong> double precision floating-point number</li>
<li><strong>r</strong> pointer, 32 lower bits of which are written as a signed integer. The type can be used to store structures with links between the elements.</li>
</ul>
<p><code class="docutils literal"><span class="pre">count</span></code>  is the optional counter of values of a given type. For example,  <code class="docutils literal"><span class="pre">2if</span></code>  means that each array element is a structure of 2 integers, followed by a single-precision floating-point number. The equivalent notations of the above specification are &#8216; <code class="docutils literal"><span class="pre">iif</span></code> &#8216;, &#8216; <code class="docutils literal"><span class="pre">2i1f</span></code> &#8216; and so forth. Other examples:  <code class="docutils literal"><span class="pre">u</span></code>  means that the array consists of bytes, and  <code class="docutils literal"><span class="pre">2d</span></code>  means the array consists of pairs  of doubles.</p>
</li>
<li><strong>vec</strong> &#8211; Pointer to the written array.</li>
<li><strong>len</strong> &#8211; Number of the <code class="docutils literal"><span class="pre">uchar</span></code> elements to write.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<p>Writes one or more numbers of the specified format to the currently written structure. Usually it is more convenient to use <a class="reference internal" href="#template&lt;typename _Tp&gt; FileStorage&amp; operator &lt;&lt; (FileStorage&amp; fs, const _Tp&amp; value)" title="template&lt;typename _Tp&gt; FileStorage&amp; operator &lt;&lt; (FileStorage&amp; fs, const _Tp&amp; value)"><code class="xref ocv ocv-func docutils literal"><span class="pre">operator</span> <span class="pre">&lt;&lt;()</span></code></a> instead of this method.</p>
</div>
<div class="section" id="filestorage-writeobj">
<h2>FileStorage::writeObj<a class="headerlink" href="#filestorage-writeobj" title="Permalink to this headline">¶</a></h2>
<p>Writes the registered C structure (CvMat, CvMatND, CvSeq).</p>
<dl class="function">
<dt id="void FileStorage::writeObj(const string&amp; name, const void* obj)">
<strong>C++:</strong><code class="descname"> </code>void <code class="descclassname">FileStorage::</code><code class="descname">writeObj</code><span class="sig-paren">(</span>const string&amp; <strong>name</strong>, const void* <strong>obj</strong><span class="sig-paren">)</span><a class="headerlink" href="#void FileStorage::writeObj(const string& name, const void* obj)" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>name</strong> &#8211; Name of the written object.</li>
<li><strong>obj</strong> &#8211; Pointer to the object.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<p>See <a class="reference internal" href="old_xml_yaml_persistence.html#void cvWrite(CvFileStorage* fs, const char* name, const void* ptr, CvAttrList attributes)" title="void cvWrite(CvFileStorage* fs, const char* name, const void* ptr, CvAttrList attributes)"><code class="xref ocv ocv-cfunc docutils literal"><span class="pre">Write()</span></code></a> for details.</p>
</div>
<div class="section" id="filestorage-getdefaultobjectname">
<h2>FileStorage::getDefaultObjectName<a class="headerlink" href="#filestorage-getdefaultobjectname" title="Permalink to this headline">¶</a></h2>
<p>Returns the normalized object name for the specified name of a file.</p>
<dl class="function">
<dt id="static string FileStorage::getDefaultObjectName(const string&amp; filename)">
<strong>C++:</strong><code class="descname"> </code><em class="property">static</em> string <code class="descclassname">FileStorage::</code><code class="descname">getDefaultObjectName</code><span class="sig-paren">(</span>const string&amp; <strong>filename</strong><span class="sig-paren">)</span><a class="headerlink" href="#static string FileStorage::getDefaultObjectName(const string& filename)" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>filename</strong> &#8211; Name of a file</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">The normalized object name.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="operator">
<h2>operator &lt;&lt;<a class="headerlink" href="#operator" title="Permalink to this headline">¶</a></h2>
<p>Writes data to a file storage.</p>
<dl class="function">
<dt id="template&lt;typename _Tp&gt; FileStorage&amp; operator &lt;&lt; (FileStorage&amp; fs, const _Tp&amp; value)">
<strong>C++:</strong><code class="descname"> </code>template&lt;typename _Tp&gt; FileStorage&amp; <code class="descname">operator&lt;&lt;</code><span class="sig-paren">(</span>FileStorage&amp; <strong>fs</strong>, const _Tp&amp; <strong>value</strong><span class="sig-paren">)</span><a class="headerlink" href="#template<typename _Tp> FileStorage& operator << (FileStorage& fs, const _Tp& value)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="template&lt;typename _Tp&gt; FileStorage&amp; operator &lt;&lt; (FileStorage&amp; fs, const vector&lt;_Tp&gt;&amp; vec)">
<strong>C++:</strong><code class="descname"> </code>template&lt;typename _Tp&gt; FileStorage&amp; <code class="descname">operator&lt;&lt;</code><span class="sig-paren">(</span>FileStorage&amp; <strong>fs</strong>, const vector&lt;_Tp&gt;&amp; <strong>vec</strong><span class="sig-paren">)</span><a class="headerlink" href="#template<typename _Tp> FileStorage& operator << (FileStorage& fs, const vector<_Tp>& vec)" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>fs</strong> &#8211; Opened file storage to write data.</li>
<li><strong>value</strong> &#8211; Value to be written to the file storage.</li>
<li><strong>vec</strong> &#8211; Vector of values to be written to the file storage.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<p>It is the main function to write data to a file storage. See an example of its usage at the beginning of the section.</p>
</div>
<div class="section" id="id2">
<h2>operator &gt;&gt;<a class="headerlink" href="#id2" title="Permalink to this headline">¶</a></h2>
<p>Reads data from a file storage.</p>
<dl class="function">
<dt id="template&lt;typename _Tp&gt; void operator &gt;&gt; (const FileNode&amp; n, _Tp&amp; value)">
<strong>C++:</strong><code class="descname"> </code>template&lt;typename _Tp&gt; void <code class="descname">operator&gt;&gt;</code><span class="sig-paren">(</span>const FileNode&amp; <strong>n</strong>, _Tp&amp; <strong>value</strong><span class="sig-paren">)</span><a class="headerlink" href="#template<typename _Tp> void operator >> (const FileNode& n, _Tp& value)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="template&lt;typename _Tp&gt; void operator &gt;&gt; (const FileNode&amp; n, vector&lt;_Tp&gt;&amp; vec)">
<strong>C++:</strong><code class="descname"> </code>template&lt;typename _Tp&gt; void <code class="descname">operator&gt;&gt;</code><span class="sig-paren">(</span>const FileNode&amp; <strong>n</strong>, vector&lt;_Tp&gt;&amp; <strong>vec</strong><span class="sig-paren">)</span><a class="headerlink" href="#template<typename _Tp> void operator >> (const FileNode& n, vector<_Tp>& vec)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="template&lt;typename _Tp&gt; FileNodeIterator&amp; operator &gt;&gt; (FileNodeIterator&amp; it, _Tp&amp; value)">
<strong>C++:</strong><code class="descname"> </code>template&lt;typename _Tp&gt; FileNodeIterator&amp; <code class="descname">operator&gt;&gt;</code><span class="sig-paren">(</span>FileNodeIterator&amp; <strong>it</strong>, _Tp&amp; <strong>value</strong><span class="sig-paren">)</span><a class="headerlink" href="#template<typename _Tp> FileNodeIterator& operator >> (FileNodeIterator& it, _Tp& value)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="template&lt;typename _Tp&gt; FileNodeIterator&amp; operator &gt;&gt; (FileNodeIterator&amp; it, vector&lt;_Tp&gt;&amp; vec)">
<strong>C++:</strong><code class="descname"> </code>template&lt;typename _Tp&gt; FileNodeIterator&amp; <code class="descname">operator&gt;&gt;</code><span class="sig-paren">(</span>FileNodeIterator&amp; <strong>it</strong>, vector&lt;_Tp&gt;&amp; <strong>vec</strong><span class="sig-paren">)</span><a class="headerlink" href="#template<typename _Tp> FileNodeIterator& operator >> (FileNodeIterator& it, vector<_Tp>& vec)" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>n</strong> &#8211; Node from which data will be read.</li>
<li><strong>it</strong> &#8211; Iterator from which data will be read.</li>
<li><strong>value</strong> &#8211; Value to be read from the file storage.</li>
<li><strong>vec</strong> &#8211; Vector of values to be read from the file storage.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<p>It is the main function to read data from a file storage. See an example of its usage at the beginning of the section.</p>
</div>
<div class="section" id="filenode">
<h2>FileNode<a class="headerlink" href="#filenode" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="FileNode">
<em class="property">class </em><code class="descname">FileNode</code><a class="headerlink" href="#FileNode" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p>File Storage Node class. The node is used to store each and every element of the file storage opened for reading. When XML/YAML file is read, it is first parsed and stored in the memory as a hierarchical collection of nodes. Each node can be a “leaf” that is contain a single number or a string, or be a collection of other nodes. There can be named collections (mappings) where each element has a name and it is accessed by a name, and ordered collections (sequences) where elements do not have names but rather accessed by index. Type of the file node can be determined using <a class="reference internal" href="#int FileNode::type() const" title="int FileNode::type() const"><code class="xref ocv ocv-func docutils literal"><span class="pre">FileNode::type()</span></code></a> method.</p>
<p>Note that file nodes are only used for navigating file storages opened for reading. When a file storage is opened for writing, no data is stored in memory after it is written.</p>
</div>
<div class="section" id="filenode-filenode">
<h2>FileNode::FileNode<a class="headerlink" href="#filenode-filenode" title="Permalink to this headline">¶</a></h2>
<p>The constructors.</p>
<dl class="function">
<dt id="FileNode::FileNode()">
<strong>C++:</strong><code class="descname"> </code> <code class="descclassname">FileNode::</code><code class="descname">FileNode</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#FileNode::FileNode()" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="FileNode::FileNode(const CvFileStorage* fs, const CvFileNode* node)">
<strong>C++:</strong><code class="descname"> </code> <code class="descclassname">FileNode::</code><code class="descname">FileNode</code><span class="sig-paren">(</span>const CvFileStorage* <strong>fs</strong>, const CvFileNode* <strong>node</strong><span class="sig-paren">)</span><a class="headerlink" href="#FileNode::FileNode(const CvFileStorage* fs, const CvFileNode* node)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="FileNode::FileNode(const FileNode&amp; node)">
<strong>C++:</strong><code class="descname"> </code> <code class="descclassname">FileNode::</code><code class="descname">FileNode</code><span class="sig-paren">(</span>const FileNode&amp; <strong>node</strong><span class="sig-paren">)</span><a class="headerlink" href="#FileNode::FileNode(const FileNode& node)" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>fs</strong> &#8211; Pointer to the obsolete file storage structure.</li>
<li><strong>node</strong> &#8211; File node to be used as initialization for the created file node.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<p>These constructors are used to create a default file node, construct it from obsolete structures or from the another file node.</p>
</div>
<div class="section" id="filenode-operator">
<h2>FileNode::operator[]<a class="headerlink" href="#filenode-operator" title="Permalink to this headline">¶</a></h2>
<p>Returns element of a mapping node or a sequence node.</p>
<dl class="function">
<dt id="FileNode FileNode::operator[](const string&amp; nodename) const">
<strong>C++:</strong><code class="descname"> </code>FileNode <code class="descclassname">FileNode::</code><code class="descname">operator[]</code><span class="sig-paren">(</span>const string&amp; <strong>nodename</strong><span class="sig-paren">)</span><code class="descclassname"> const</code><a class="headerlink" href="#FileNode FileNode::operator[](const string& nodename) const" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="FileNode FileNode::operator[](const char* nodename) const">
<strong>C++:</strong><code class="descname"> </code>FileNode <code class="descclassname">FileNode::</code><code class="descname">operator[]</code><span class="sig-paren">(</span>const char* <strong>nodename</strong><span class="sig-paren">)</span><code class="descclassname"> const</code><a class="headerlink" href="#FileNode FileNode::operator[](const char* nodename) const" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="FileNode FileNode::operator[](int i) const">
<strong>C++:</strong><code class="descname"> </code>FileNode <code class="descclassname">FileNode::</code><code class="descname">operator[]</code><span class="sig-paren">(</span>int <strong>i</strong><span class="sig-paren">)</span><code class="descclassname"> const</code><a class="headerlink" href="#FileNode FileNode::operator[](int i) const" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>nodename</strong> &#8211; Name of an element in the mapping node.</li>
<li><strong>i</strong> &#8211; Index of an element in the sequence node.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">Returns the element with the given identifier.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="filenode-type">
<h2>FileNode::type<a class="headerlink" href="#filenode-type" title="Permalink to this headline">¶</a></h2>
<p>Returns type of the node.</p>
<dl class="function">
<dt id="int FileNode::type() const">
<strong>C++:</strong><code class="descname"> </code>int <code class="descclassname">FileNode::</code><code class="descname">type</code><span class="sig-paren">(</span><span class="sig-paren">)</span><code class="descclassname"> const</code><a class="headerlink" href="#int FileNode::type() const" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">Type of the node. Possible values are:<ul class="simple">
<li><strong>FileNode::NONE</strong> Empty node.</li>
<li><strong>FileNode::INT</strong> Integer.</li>
<li><strong>FileNode::REAL</strong> Floating-point number.</li>
<li><strong>FileNode::FLOAT</strong> Synonym or <code class="docutils literal"><span class="pre">REAL</span></code>.</li>
<li><strong>FileNode::STR</strong> Text string in UTF-8 encoding.</li>
<li><strong>FileNode::STRING</strong> Synonym for <code class="docutils literal"><span class="pre">STR</span></code>.</li>
<li><strong>FileNode::REF</strong> Integer of type <code class="docutils literal"><span class="pre">size_t</span></code>. Typically used for storing complex dynamic structures where some elements reference the others.</li>
<li><strong>FileNode::SEQ</strong> Sequence.</li>
<li><strong>FileNode::MAP</strong> Mapping.</li>
<li><strong>FileNode::FLOW</strong> Compact representation of a sequence or mapping. Used only by the YAML writer.</li>
<li><strong>FileNode::USER</strong> Registered object (e.g. a matrix).</li>
<li><strong>FileNode::EMPTY</strong> Empty structure (sequence or mapping).</li>
<li><strong>FileNode::NAMED</strong> The node has a name (i.e. it is an element of a mapping).</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="filenode-empty">
<h2>FileNode::empty<a class="headerlink" href="#filenode-empty" title="Permalink to this headline">¶</a></h2>
<p>Checks whether the node is empty.</p>
<dl class="function">
<dt id="bool FileNode::empty() const">
<strong>C++:</strong><code class="descname"> </code>bool <code class="descclassname">FileNode::</code><code class="descname">empty</code><span class="sig-paren">(</span><span class="sig-paren">)</span><code class="descclassname"> const</code><a class="headerlink" href="#bool FileNode::empty() const" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><code class="docutils literal"><span class="pre">true</span></code> if the node is empty.</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="filenode-isnone">
<h2>FileNode::isNone<a class="headerlink" href="#filenode-isnone" title="Permalink to this headline">¶</a></h2>
<p>Checks whether the node is a &#8220;none&#8221; object</p>
<dl class="function">
<dt id="bool FileNode::isNone() const">
<strong>C++:</strong><code class="descname"> </code>bool <code class="descclassname">FileNode::</code><code class="descname">isNone</code><span class="sig-paren">(</span><span class="sig-paren">)</span><code class="descclassname"> const</code><a class="headerlink" href="#bool FileNode::isNone() const" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><code class="docutils literal"><span class="pre">true</span></code> if the node is a &#8220;none&#8221; object.</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="filenode-isseq">
<h2>FileNode::isSeq<a class="headerlink" href="#filenode-isseq" title="Permalink to this headline">¶</a></h2>
<p>Checks whether the node is a sequence.</p>
<dl class="function">
<dt id="bool FileNode::isSeq() const">
<strong>C++:</strong><code class="descname"> </code>bool <code class="descclassname">FileNode::</code><code class="descname">isSeq</code><span class="sig-paren">(</span><span class="sig-paren">)</span><code class="descclassname"> const</code><a class="headerlink" href="#bool FileNode::isSeq() const" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><code class="docutils literal"><span class="pre">true</span></code> if the node is a sequence.</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="filenode-ismap">
<h2>FileNode::isMap<a class="headerlink" href="#filenode-ismap" title="Permalink to this headline">¶</a></h2>
<p>Checks whether the node is a mapping.</p>
<dl class="function">
<dt id="bool FileNode::isMap() const">
<strong>C++:</strong><code class="descname"> </code>bool <code class="descclassname">FileNode::</code><code class="descname">isMap</code><span class="sig-paren">(</span><span class="sig-paren">)</span><code class="descclassname"> const</code><a class="headerlink" href="#bool FileNode::isMap() const" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><code class="docutils literal"><span class="pre">true</span></code> if the node is a mapping.</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="filenode-isint">
<h2>FileNode::isInt<a class="headerlink" href="#filenode-isint" title="Permalink to this headline">¶</a></h2>
<p>Checks whether the node is an integer.</p>
<dl class="function">
<dt id="bool FileNode::isInt() const">
<strong>C++:</strong><code class="descname"> </code>bool <code class="descclassname">FileNode::</code><code class="descname">isInt</code><span class="sig-paren">(</span><span class="sig-paren">)</span><code class="descclassname"> const</code><a class="headerlink" href="#bool FileNode::isInt() const" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><code class="docutils literal"><span class="pre">true</span></code> if the node is an integer.</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="filenode-isreal">
<h2>FileNode::isReal<a class="headerlink" href="#filenode-isreal" title="Permalink to this headline">¶</a></h2>
<p>Checks whether the node is a floating-point number.</p>
<dl class="function">
<dt id="bool FileNode::isReal() const">
<strong>C++:</strong><code class="descname"> </code>bool <code class="descclassname">FileNode::</code><code class="descname">isReal</code><span class="sig-paren">(</span><span class="sig-paren">)</span><code class="descclassname"> const</code><a class="headerlink" href="#bool FileNode::isReal() const" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><code class="docutils literal"><span class="pre">true</span></code> if the node is a floating-point number.</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="filenode-isstring">
<h2>FileNode::isString<a class="headerlink" href="#filenode-isstring" title="Permalink to this headline">¶</a></h2>
<p>Checks whether the node is a text string.</p>
<dl class="function">
<dt id="bool FileNode::isString() const">
<strong>C++:</strong><code class="descname"> </code>bool <code class="descclassname">FileNode::</code><code class="descname">isString</code><span class="sig-paren">(</span><span class="sig-paren">)</span><code class="descclassname"> const</code><a class="headerlink" href="#bool FileNode::isString() const" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><code class="docutils literal"><span class="pre">true</span></code> if the node is a text string.</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="filenode-isnamed">
<h2>FileNode::isNamed<a class="headerlink" href="#filenode-isnamed" title="Permalink to this headline">¶</a></h2>
<p>Checks whether the node has a name.</p>
<dl class="function">
<dt id="bool FileNode::isNamed() const">
<strong>C++:</strong><code class="descname"> </code>bool <code class="descclassname">FileNode::</code><code class="descname">isNamed</code><span class="sig-paren">(</span><span class="sig-paren">)</span><code class="descclassname"> const</code><a class="headerlink" href="#bool FileNode::isNamed() const" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><code class="docutils literal"><span class="pre">true</span></code> if the node has a name.</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="filenode-name">
<h2>FileNode::name<a class="headerlink" href="#filenode-name" title="Permalink to this headline">¶</a></h2>
<p>Returns the node name.</p>
<dl class="function">
<dt id="string FileNode::name() const">
<strong>C++:</strong><code class="descname"> </code>string <code class="descclassname">FileNode::</code><code class="descname">name</code><span class="sig-paren">(</span><span class="sig-paren">)</span><code class="descclassname"> const</code><a class="headerlink" href="#string FileNode::name() const" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">The node name or an empty string if the node is nameless.</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="filenode-size">
<h2>FileNode::size<a class="headerlink" href="#filenode-size" title="Permalink to this headline">¶</a></h2>
<p>Returns the number of elements in the node.</p>
<dl class="function">
<dt id="size_t FileNode::size() const">
<strong>C++:</strong><code class="descname"> </code>size_t <code class="descclassname">FileNode::</code><code class="descname">size</code><span class="sig-paren">(</span><span class="sig-paren">)</span><code class="descclassname"> const</code><a class="headerlink" href="#size_t FileNode::size() const" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">The number of elements in the node, if it is a sequence or mapping, or 1 otherwise.</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="filenode-operator-int">
<h2>FileNode::operator int<a class="headerlink" href="#filenode-operator-int" title="Permalink to this headline">¶</a></h2>
<p>Returns the node content as an integer.</p>
<dl class="function">
<dt id="FileNode::operator int() const">
<strong>C++:</strong><code class="descname"> </code> <code class="descclassname">FileNode::</code><code class="descname">operator</code> int<span class="sig-paren">(</span><span class="sig-paren">)</span><code class="descclassname"> const</code><a class="headerlink" href="#FileNode::operator int() const" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">The node content as an integer. If the node stores a floating-point number, it is rounded.</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="filenode-operator-float">
<h2>FileNode::operator float<a class="headerlink" href="#filenode-operator-float" title="Permalink to this headline">¶</a></h2>
<p>Returns the node content as float.</p>
<dl class="function">
<dt id="FileNode::operator float() const">
<strong>C++:</strong><code class="descname"> </code> <code class="descclassname">FileNode::</code><code class="descname">operator</code> float<span class="sig-paren">(</span><span class="sig-paren">)</span><code class="descclassname"> const</code><a class="headerlink" href="#FileNode::operator float() const" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">The node content as float.</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="filenode-operator-double">
<h2>FileNode::operator double<a class="headerlink" href="#filenode-operator-double" title="Permalink to this headline">¶</a></h2>
<p>Returns the node content as double.</p>
<dl class="function">
<dt id="FileNode::operator double() const">
<strong>C++:</strong><code class="descname"> </code> <code class="descclassname">FileNode::</code><code class="descname">operator</code> double<span class="sig-paren">(</span><span class="sig-paren">)</span><code class="descclassname"> const</code><a class="headerlink" href="#FileNode::operator double() const" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">The node content as double.</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="filenode-operator-string">
<h2>FileNode::operator string<a class="headerlink" href="#filenode-operator-string" title="Permalink to this headline">¶</a></h2>
<p>Returns the node content as text string.</p>
<dl class="function">
<dt id="FileNode::operator string() const">
<strong>C++:</strong><code class="descname"> </code> <code class="descclassname">FileNode::</code><code class="descname">operator</code> string<span class="sig-paren">(</span><span class="sig-paren">)</span><code class="descclassname"> const</code><a class="headerlink" href="#FileNode::operator string() const" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">The node content as a text string.</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="id3">
<h2>FileNode::operator*<a class="headerlink" href="#id3" title="Permalink to this headline">¶</a></h2>
<p>Returns pointer to the underlying obsolete file node structure.</p>
<dl class="function">
<dt id="CvFileNode* FileNode::operator *()">
<strong>C++:</strong><code class="descname"> </code>CvFileNode* <code class="descclassname">FileNode::</code><code class="descname">operator*</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#CvFileNode* FileNode::operator *()" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">Pointer to the underlying obsolete file node structure.</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="filenode-begin">
<h2>FileNode::begin<a class="headerlink" href="#filenode-begin" title="Permalink to this headline">¶</a></h2>
<p>Returns the iterator pointing to the first node element.</p>
<dl class="function">
<dt id="FileNodeIterator FileNode::begin() const">
<strong>C++:</strong><code class="descname"> </code>FileNodeIterator <code class="descclassname">FileNode::</code><code class="descname">begin</code><span class="sig-paren">(</span><span class="sig-paren">)</span><code class="descclassname"> const</code><a class="headerlink" href="#FileNodeIterator FileNode::begin() const" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">Iterator pointing to the first node element.</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="filenode-end">
<h2>FileNode::end<a class="headerlink" href="#filenode-end" title="Permalink to this headline">¶</a></h2>
<p>Returns the iterator pointing to the element following the last node element.</p>
<dl class="function">
<dt id="FileNodeIterator FileNode::end() const">
<strong>C++:</strong><code class="descname"> </code>FileNodeIterator <code class="descclassname">FileNode::</code><code class="descname">end</code><span class="sig-paren">(</span><span class="sig-paren">)</span><code class="descclassname"> const</code><a class="headerlink" href="#FileNodeIterator FileNode::end() const" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">Iterator pointing to the element following the last node element.</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="filenode-readraw">
<h2>FileNode::readRaw<a class="headerlink" href="#filenode-readraw" title="Permalink to this headline">¶</a></h2>
<p>Reads node elements to the buffer with the specified format.</p>
<dl class="function">
<dt id="void FileNode::readRaw(const string&amp; fmt, uchar* vec, size_t len) const">
<strong>C++:</strong><code class="descname"> </code>void <code class="descclassname">FileNode::</code><code class="descname">readRaw</code><span class="sig-paren">(</span>const string&amp; <strong>fmt</strong>, uchar* <strong>vec</strong>, size_t <strong>len</strong><span class="sig-paren">)</span><code class="descclassname"> const</code><a class="headerlink" href="#void FileNode::readRaw(const string& fmt, uchar* vec, size_t len) const" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>fmt</strong> &#8211; Specification of each array element. It has the same format as in <a class="reference internal" href="#void FileStorage::writeRaw(const string&amp; fmt, const uchar* vec, size_t len)" title="void FileStorage::writeRaw(const string&amp; fmt, const uchar* vec, size_t len)"><code class="xref ocv ocv-func docutils literal"><span class="pre">FileStorage::writeRaw()</span></code></a>.</li>
<li><strong>vec</strong> &#8211; Pointer to the destination array.</li>
<li><strong>len</strong> &#8211; Number of elements to read. If it is greater than number of remaining elements then all of them will be read.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<p>Usually it is more convenient to use <a class="reference internal" href="#template&lt;typename _Tp&gt; void operator &gt;&gt; (const FileNode&amp; n, _Tp&amp; value)" title="template&lt;typename _Tp&gt; void operator &gt;&gt; (const FileNode&amp; n, _Tp&amp; value)"><code class="xref ocv ocv-func docutils literal"><span class="pre">operator</span> <span class="pre">&gt;&gt;()</span></code></a> instead of this method.</p>
</div>
<div class="section" id="filenode-readobj">
<h2>FileNode::readObj<a class="headerlink" href="#filenode-readobj" title="Permalink to this headline">¶</a></h2>
<p>Reads the registered object.</p>
<dl class="function">
<dt id="void* FileNode::readObj() const">
<strong>C++:</strong><code class="descname"> </code>void* <code class="descclassname">FileNode::</code><code class="descname">readObj</code><span class="sig-paren">(</span><span class="sig-paren">)</span><code class="descclassname"> const</code><a class="headerlink" href="#void* FileNode::readObj() const" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">Pointer to the read object.</td>
</tr>
</tbody>
</table>
</dd></dl>

<p>See <a class="reference internal" href="old_xml_yaml_persistence.html#void* cvRead(CvFileStorage* fs, CvFileNode* node, CvAttrList* attributes)" title="void* cvRead(CvFileStorage* fs, CvFileNode* node, CvAttrList* attributes)"><code class="xref ocv ocv-cfunc docutils literal"><span class="pre">Read()</span></code></a> for details.</p>
</div>
<div class="section" id="filenodeiterator">
<h2>FileNodeIterator<a class="headerlink" href="#filenodeiterator" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="FileNodeIterator">
<em class="property">class </em><code class="descname">FileNodeIterator</code><a class="headerlink" href="#FileNodeIterator" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p>The class <code class="docutils literal"><span class="pre">FileNodeIterator</span></code> is used to iterate through sequences and mappings. A standard STL notation, with <code class="docutils literal"><span class="pre">node.begin()</span></code>, <code class="docutils literal"><span class="pre">node.end()</span></code> denoting the beginning and the end of a sequence, stored in <code class="docutils literal"><span class="pre">node</span></code>.  See the data reading sample in the beginning of the section.</p>
</div>
<div class="section" id="filenodeiterator-filenodeiterator">
<h2>FileNodeIterator::FileNodeIterator<a class="headerlink" href="#filenodeiterator-filenodeiterator" title="Permalink to this headline">¶</a></h2>
<p>The constructors.</p>
<dl class="function">
<dt id="FileNodeIterator::FileNodeIterator()">
<strong>C++:</strong><code class="descname"> </code> <code class="descclassname">FileNodeIterator::</code><code class="descname">FileNodeIterator</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#FileNodeIterator::FileNodeIterator()" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="FileNodeIterator::FileNodeIterator(const CvFileStorage* fs, const CvFileNode* node, size_t ofs)">
<strong>C++:</strong><code class="descname"> </code> <code class="descclassname">FileNodeIterator::</code><code class="descname">FileNodeIterator</code><span class="sig-paren">(</span>const CvFileStorage* <strong>fs</strong>, const CvFileNode* <strong>node</strong>, size_t <strong>ofs</strong>=0<span class="sig-paren">)</span><a class="headerlink" href="#FileNodeIterator::FileNodeIterator(const CvFileStorage* fs, const CvFileNode* node, size_t ofs)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="FileNodeIterator::FileNodeIterator(const FileNodeIterator&amp; it)">
<strong>C++:</strong><code class="descname"> </code> <code class="descclassname">FileNodeIterator::</code><code class="descname">FileNodeIterator</code><span class="sig-paren">(</span>const FileNodeIterator&amp; <strong>it</strong><span class="sig-paren">)</span><a class="headerlink" href="#FileNodeIterator::FileNodeIterator(const FileNodeIterator& it)" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>fs</strong> &#8211; File storage for the iterator.</li>
<li><strong>node</strong> &#8211; File node for the iterator.</li>
<li><strong>ofs</strong> &#8211; Index of the element in the node. The created iterator will point to this element.</li>
<li><strong>it</strong> &#8211; Iterator to be used as initialization for the created iterator.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<p>These constructors are used to create a default iterator, set it to specific element in a file node or construct it from another iterator.</p>
</div>
<div class="section" id="filenodeiterator-operator">
<h2>FileNodeIterator::operator*<a class="headerlink" href="#filenodeiterator-operator" title="Permalink to this headline">¶</a></h2>
<p>Returns the currently observed element.</p>
<dl class="function">
<dt id="FileNode FileNodeIterator::operator *() const">
<strong>C++:</strong><code class="descname"> </code>FileNode <code class="descclassname">FileNodeIterator::</code><code class="descname">operator*</code><span class="sig-paren">(</span><span class="sig-paren">)</span><code class="descclassname"> const</code><a class="headerlink" href="#FileNode FileNodeIterator::operator *() const" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">Currently observed element.</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="id4">
<h2>FileNodeIterator::operator-&gt;<a class="headerlink" href="#id4" title="Permalink to this headline">¶</a></h2>
<p>Accesses methods of the currently observed element.</p>
<dl class="function">
<dt id="FileNode FileNodeIterator::operator -&gt;() const">
<strong>C++:</strong><code class="descname"> </code>FileNode <code class="descclassname">FileNodeIterator::</code><code class="descname">operator-&gt;</code><span class="sig-paren">(</span><span class="sig-paren">)</span><code class="descclassname"> const</code><a class="headerlink" href="#FileNode FileNodeIterator::operator ->() const" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</div>
<div class="section" id="id5">
<h2>FileNodeIterator::operator ++<a class="headerlink" href="#id5" title="Permalink to this headline">¶</a></h2>
<p>Moves iterator to the next node.</p>
<dl class="function">
<dt id="FileNodeIterator&amp; FileNodeIterator::operator ++ ()">
<strong>C++:</strong><code class="descname"> </code>FileNodeIterator&amp; <code class="descclassname">FileNodeIterator::</code><code class="descname">operator++</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#FileNodeIterator& FileNodeIterator::operator ++ ()" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="FileNodeIterator FileNodeIterator::operator ++ (int)">
<strong>C++:</strong><code class="descname"> </code>FileNodeIterator <code class="descclassname">FileNodeIterator::</code><code class="descname">operator++</code><span class="sig-paren">(</span>int <strong>None</strong><span class="sig-paren">)</span><a class="headerlink" href="#FileNodeIterator FileNodeIterator::operator ++ (int)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</div>
<div class="section" id="id6">
<h2>FileNodeIterator::operator &#8211;<a class="headerlink" href="#id6" title="Permalink to this headline">¶</a></h2>
<p>Moves iterator to the previous node.</p>
<dl class="function">
<dt id="FileNodeIterator&amp; FileNodeIterator::operator -- ()">
<strong>C++:</strong><code class="descname"> </code>FileNodeIterator&amp; <code class="descclassname">FileNodeIterator::</code><code class="descname">operator--</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#FileNodeIterator& FileNodeIterator::operator -- ()" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="FileNodeIterator FileNodeIterator::operator -- (int)">
<strong>C++:</strong><code class="descname"> </code>FileNodeIterator <code class="descclassname">FileNodeIterator::</code><code class="descname">operator--</code><span class="sig-paren">(</span>int <strong>None</strong><span class="sig-paren">)</span><a class="headerlink" href="#FileNodeIterator FileNodeIterator::operator -- (int)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</div>
<div class="section" id="id7">
<h2>FileNodeIterator::operator +=<a class="headerlink" href="#id7" title="Permalink to this headline">¶</a></h2>
<p>Moves iterator forward by the specified offset.</p>
<dl class="function">
<dt id="FileNodeIterator&amp; FileNodeIterator::operator +=(int ofs)">
<strong>C++:</strong><code class="descname"> </code>FileNodeIterator&amp; <code class="descclassname">FileNodeIterator::</code><code class="descname">operator+=</code><span class="sig-paren">(</span>int <strong>ofs</strong><span class="sig-paren">)</span><a class="headerlink" href="#FileNodeIterator& FileNodeIterator::operator +=(int ofs)" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>ofs</strong> &#8211; Offset (possibly negative) to move the iterator.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="id8">
<h2>FileNodeIterator::operator -=<a class="headerlink" href="#id8" title="Permalink to this headline">¶</a></h2>
<p>Moves iterator backward by the specified offset (possibly negative).</p>
<dl class="function">
<dt id="FileNodeIterator&amp; FileNodeIterator::operator -=(int ofs)">
<strong>C++:</strong><code class="descname"> </code>FileNodeIterator&amp; <code class="descclassname">FileNodeIterator::</code><code class="descname">operator-=</code><span class="sig-paren">(</span>int <strong>ofs</strong><span class="sig-paren">)</span><a class="headerlink" href="#FileNodeIterator& FileNodeIterator::operator -=(int ofs)" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>ofs</strong> &#8211; Offset (possibly negative) to move the iterator.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="filenodeiterator-readraw">
<h2>FileNodeIterator::readRaw<a class="headerlink" href="#filenodeiterator-readraw" title="Permalink to this headline">¶</a></h2>
<p>Reads node elements to the buffer with the specified format.</p>
<dl class="function">
<dt id="FileNodeIterator&amp; FileNodeIterator::readRaw(const string&amp; fmt, uchar* vec, size_t maxCount=(size_t)INT_MAX)">
<strong>C++:</strong><code class="descname"> </code>FileNodeIterator&amp; <code class="descclassname">FileNodeIterator::</code><code class="descname">readRaw</code><span class="sig-paren">(</span>const string&amp; <strong>fmt</strong>, uchar* <strong>vec</strong>, size_t <strong>maxCount</strong>=(size_t)INT_MAX <span class="sig-paren">)</span><a class="headerlink" href="#FileNodeIterator& FileNodeIterator::readRaw(const string& fmt, uchar* vec, size_t maxCount=(size_t)INT_MAX)" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>fmt</strong> &#8211; Specification of each array element. It has the same format as in <a class="reference internal" href="#void FileStorage::writeRaw(const string&amp; fmt, const uchar* vec, size_t len)" title="void FileStorage::writeRaw(const string&amp; fmt, const uchar* vec, size_t len)"><code class="xref ocv ocv-func docutils literal"><span class="pre">FileStorage::writeRaw()</span></code></a>.</li>
<li><strong>vec</strong> &#8211; Pointer to the destination array.</li>
<li><strong>maxCount</strong> &#8211; Number of elements to read. If it is greater than number of remaining elements then all of them will be read.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<p>Usually it is more convenient to use <a class="reference internal" href="#template&lt;typename _Tp&gt; void operator &gt;&gt; (const FileNode&amp; n, _Tp&amp; value)" title="template&lt;typename _Tp&gt; void operator &gt;&gt; (const FileNode&amp; n, _Tp&amp; value)"><code class="xref ocv ocv-func docutils literal"><span class="pre">operator</span> <span class="pre">&gt;&gt;()</span></code></a> instead of this method.</p>
</div>
</div>


          </div>
          <div class="feedback">
              <h2>Help and Feedback</h2>
              You did not find what you were looking for?
              <ul>
                  
                  
                  
                  <li>Ask a question on the <a href="http://answers.opencv.org">Q&A forum</a>.</li>
                  <li>If you think something is missing or wrong in the documentation,
                  please file a <a href="http://code.opencv.org">bug report</a>.</li>
              </ul>
          </div>
        </div>
      </div>

      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../../../index.html">
              <img class="logo" src="../../../_static/opencv-logo-white.png" alt="Logo"/>
            </a></p>
<div id="searchbox" style="display: none">
      <form class="search" action="../../../search.html" method="get">
      <input type="text" name="q" size="18" />
      <input type="submit" value="Search" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
      </p>
    </form>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
  <h3><a href="../../../index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">XML/YAML Persistence</a><ul>
<li><a class="reference internal" href="#xml-yaml-file-storages-writing-to-a-file-storage">XML/YAML file storages. Writing to a file storage.</a></li>
<li><a class="reference internal" href="#reading-data-from-a-file-storage">Reading data from a file storage.</a></li>
<li><a class="reference internal" href="#filestorage">FileStorage</a></li>
<li><a class="reference internal" href="#filestorage-filestorage">FileStorage::FileStorage</a></li>
<li><a class="reference internal" href="#filestorage-open">FileStorage::open</a></li>
<li><a class="reference internal" href="#filestorage-isopened">FileStorage::isOpened</a></li>
<li><a class="reference internal" href="#filestorage-release">FileStorage::release</a></li>
<li><a class="reference internal" href="#filestorage-releaseandgetstring">FileStorage::releaseAndGetString</a></li>
<li><a class="reference internal" href="#filestorage-getfirsttoplevelnode">FileStorage::getFirstTopLevelNode</a></li>
<li><a class="reference internal" href="#filestorage-root">FileStorage::root</a></li>
<li><a class="reference internal" href="#filestorage-operator">FileStorage::operator[]</a></li>
<li><a class="reference internal" href="#id1">FileStorage::operator*</a></li>
<li><a class="reference internal" href="#filestorage-writeraw">FileStorage::writeRaw</a></li>
<li><a class="reference internal" href="#filestorage-writeobj">FileStorage::writeObj</a></li>
<li><a class="reference internal" href="#filestorage-getdefaultobjectname">FileStorage::getDefaultObjectName</a></li>
<li><a class="reference internal" href="#operator">operator &lt;&lt;</a></li>
<li><a class="reference internal" href="#id2">operator &gt;&gt;</a></li>
<li><a class="reference internal" href="#filenode">FileNode</a></li>
<li><a class="reference internal" href="#filenode-filenode">FileNode::FileNode</a></li>
<li><a class="reference internal" href="#filenode-operator">FileNode::operator[]</a></li>
<li><a class="reference internal" href="#filenode-type">FileNode::type</a></li>
<li><a class="reference internal" href="#filenode-empty">FileNode::empty</a></li>
<li><a class="reference internal" href="#filenode-isnone">FileNode::isNone</a></li>
<li><a class="reference internal" href="#filenode-isseq">FileNode::isSeq</a></li>
<li><a class="reference internal" href="#filenode-ismap">FileNode::isMap</a></li>
<li><a class="reference internal" href="#filenode-isint">FileNode::isInt</a></li>
<li><a class="reference internal" href="#filenode-isreal">FileNode::isReal</a></li>
<li><a class="reference internal" href="#filenode-isstring">FileNode::isString</a></li>
<li><a class="reference internal" href="#filenode-isnamed">FileNode::isNamed</a></li>
<li><a class="reference internal" href="#filenode-name">FileNode::name</a></li>
<li><a class="reference internal" href="#filenode-size">FileNode::size</a></li>
<li><a class="reference internal" href="#filenode-operator-int">FileNode::operator int</a></li>
<li><a class="reference internal" href="#filenode-operator-float">FileNode::operator float</a></li>
<li><a class="reference internal" href="#filenode-operator-double">FileNode::operator double</a></li>
<li><a class="reference internal" href="#filenode-operator-string">FileNode::operator string</a></li>
<li><a class="reference internal" href="#id3">FileNode::operator*</a></li>
<li><a class="reference internal" href="#filenode-begin">FileNode::begin</a></li>
<li><a class="reference internal" href="#filenode-end">FileNode::end</a></li>
<li><a class="reference internal" href="#filenode-readraw">FileNode::readRaw</a></li>
<li><a class="reference internal" href="#filenode-readobj">FileNode::readObj</a></li>
<li><a class="reference internal" href="#filenodeiterator">FileNodeIterator</a></li>
<li><a class="reference internal" href="#filenodeiterator-filenodeiterator">FileNodeIterator::FileNodeIterator</a></li>
<li><a class="reference internal" href="#filenodeiterator-operator">FileNodeIterator::operator*</a></li>
<li><a class="reference internal" href="#id4">FileNodeIterator::operator-&gt;</a></li>
<li><a class="reference internal" href="#id5">FileNodeIterator::operator ++</a></li>
<li><a class="reference internal" href="#id6">FileNodeIterator::operator &#8211;</a></li>
<li><a class="reference internal" href="#id7">FileNodeIterator::operator +=</a></li>
<li><a class="reference internal" href="#id8">FileNodeIterator::operator -=</a></li>
<li><a class="reference internal" href="#filenodeiterator-readraw">FileNodeIterator::readRaw</a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="drawing_functions.html"
                        title="previous chapter">Drawing Functions</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="old_xml_yaml_persistence.html"
                        title="next chapter">XML/YAML Persistence (C API)</a></p>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../../../_sources/modules/core/doc/xml_yaml_persistence.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="old_xml_yaml_persistence.html" title="XML/YAML Persistence (C API)"
             >next</a> |</li>
        <li class="right" >
          <a href="drawing_functions.html" title="Drawing Functions"
             >previous</a> |</li>
        <li><a href="../../../index.html">OpenCV 2.4.13.7 documentation</a> &raquo;</li>
          <li><a href="../../refman.html" >OpenCV API Reference</a> &raquo;</li>
          <li><a href="core.html" >core. The Core Functionality</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2011-2014, opencv dev team.
      Last updated on Jul 12, 2018.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.3.6.
    </div>
  </body>
</html>
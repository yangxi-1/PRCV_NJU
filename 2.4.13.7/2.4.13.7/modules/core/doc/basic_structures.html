<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<script type="text/javascript">

  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-33108845-1']);
  _gaq.push(['_setDomainName', 'opencv.org']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();

</script>

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Basic Structures &mdash; OpenCV 2.4.13.7 documentation</title>
    <link rel="stylesheet" href="../../../_static/default.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../../',
        VERSION:     '2.4.13.7',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../../_static/doctools.js"></script>
    <link rel="top" title="OpenCV 2.4.13.7 documentation" href="../../../index.html" />
    <link rel="up" title="core. The Core Functionality" href="core.html" />
    <link rel="next" title="Basic C Structures and Operations" href="old_basic_structures.html" />
    <link rel="prev" title="core. The Core Functionality" href="core.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="old_basic_structures.html" title="Basic C Structures and Operations"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="core.html" title="core. The Core Functionality"
             accesskey="P">previous</a> |</li>
        <li><a href="../../../index.html">OpenCV 2.4.13.7 documentation</a> &raquo;</li>
          <li><a href="../../refman.html" >OpenCV API Reference</a> &raquo;</li>
          <li><a href="core.html" accesskey="U">core. The Core Functionality</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
  
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="basic-structures">
<h1>Basic Structures<a class="headerlink" href="#basic-structures" title="Permalink to this headline">¶</a></h1>
<div class="section" id="datatype">
<h2>DataType<a class="headerlink" href="#datatype" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="DataType">
<em class="property">class </em><code class="descname">DataType</code><a class="headerlink" href="#DataType" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p>Template &#8220;trait&#8221; class for OpenCV primitive data types. A primitive OpenCV data type is one of <code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">char</span></code>, <code class="docutils literal"><span class="pre">bool</span></code>, <code class="docutils literal"><span class="pre">signed</span> <span class="pre">char</span></code>, <code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">short</span></code>, <code class="docutils literal"><span class="pre">signed</span> <span class="pre">short</span></code>, <code class="docutils literal"><span class="pre">int</span></code>, <code class="docutils literal"><span class="pre">float</span></code>, <code class="docutils literal"><span class="pre">double</span></code>, or a tuple of values of one of these types, where all the values in the tuple have the same type. Any primitive type from the list can be defined by an identifier in the form <code class="docutils literal"><span class="pre">CV_&lt;bit-depth&gt;{U|S|F}C(&lt;number_of_channels&gt;)</span></code>, for example: <code class="docutils literal"><span class="pre">uchar</span></code> ~ <code class="docutils literal"><span class="pre">CV_8UC1</span></code>, 3-element floating-point tuple ~ <code class="docutils literal"><span class="pre">CV_32FC3</span></code>, and so on. A universal OpenCV structure that is able to store a single instance of such a primitive data type is
<a class="reference internal" href="#Vec" title="class Vec"><code class="xref ocv ocv-class docutils literal"><span class="pre">Vec</span></code></a>. Multiple instances of such a type can be stored in a <code class="docutils literal"><span class="pre">std::vector</span></code>, <code class="docutils literal"><span class="pre">Mat</span></code>, <code class="docutils literal"><span class="pre">Mat_</span></code>, <code class="docutils literal"><span class="pre">SparseMat</span></code>, <code class="docutils literal"><span class="pre">SparseMat_</span></code>, or any other container that is able to store <code class="docutils literal"><span class="pre">Vec</span></code> instances.</p>
<p>The <code class="docutils literal"><span class="pre">DataType</span></code> class is basically used to provide a description of such primitive data types without adding any fields or methods to the corresponding classes (and it is actually impossible to add anything to primitive C/C++ data types). This technique is known in C++ as class traits. It is not <code class="docutils literal"><span class="pre">DataType</span></code> itself that is used but its specialized versions, such as:</p>
<div class="highlight-cpp"><div class="highlight"><pre><span class="k">template</span><span class="o">&lt;&gt;</span> <span class="k">class</span> <span class="nc">DataType</span><span class="o">&lt;</span><span class="n">uchar</span><span class="o">&gt;</span>
<span class="p">{</span>
    <span class="k">typedef</span> <span class="n">uchar</span> <span class="n">value_type</span><span class="p">;</span>
    <span class="k">typedef</span> <span class="kt">int</span> <span class="n">work_type</span><span class="p">;</span>
    <span class="k">typedef</span> <span class="n">uchar</span> <span class="n">channel_type</span><span class="p">;</span>
    <span class="k">enum</span> <span class="p">{</span> <span class="n">channel_type</span> <span class="o">=</span> <span class="n">CV_8U</span><span class="p">,</span> <span class="n">channels</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">fmt</span><span class="o">=</span><span class="sc">&#39;u&#39;</span><span class="p">,</span> <span class="n">type</span> <span class="o">=</span> <span class="n">CV_8U</span> <span class="p">};</span>
<span class="p">};</span>
<span class="p">...</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">_Tp</span><span class="o">&gt;</span> <span class="n">DataType</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">complex</span><span class="o">&lt;</span><span class="n">_Tp</span><span class="o">&gt;</span> <span class="o">&gt;</span>
<span class="p">{</span>
    <span class="k">typedef</span> <span class="n">std</span><span class="o">::</span><span class="n">complex</span><span class="o">&lt;</span><span class="n">_Tp</span><span class="o">&gt;</span> <span class="n">value_type</span><span class="p">;</span>
    <span class="k">typedef</span> <span class="n">std</span><span class="o">::</span><span class="n">complex</span><span class="o">&lt;</span><span class="n">_Tp</span><span class="o">&gt;</span> <span class="n">work_type</span><span class="p">;</span>
    <span class="k">typedef</span> <span class="n">_Tp</span> <span class="n">channel_type</span><span class="p">;</span>
    <span class="c1">// DataDepth is another helper trait class</span>
    <span class="k">enum</span> <span class="p">{</span> <span class="n">depth</span> <span class="o">=</span> <span class="n">DataDepth</span><span class="o">&lt;</span><span class="n">_Tp</span><span class="o">&gt;::</span><span class="n">value</span><span class="p">,</span> <span class="n">channels</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
        <span class="n">fmt</span><span class="o">=</span><span class="p">(</span><span class="n">channels</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="mi">256</span><span class="o">+</span><span class="n">DataDepth</span><span class="o">&lt;</span><span class="n">_Tp</span><span class="o">&gt;::</span><span class="n">fmt</span><span class="p">,</span>
        <span class="n">type</span><span class="o">=</span><span class="n">CV_MAKETYPE</span><span class="p">(</span><span class="n">depth</span><span class="p">,</span> <span class="n">channels</span><span class="p">)</span> <span class="p">};</span>
<span class="p">};</span>
<span class="p">...</span>
</pre></div>
</div>
<p>The main purpose of this class is to convert compilation-time type information to an OpenCV-compatible data type identifier, for example:</p>
<div class="highlight-cpp"><div class="highlight"><pre><span class="c1">// allocates a 30x40 floating-point matrix</span>
<span class="n">Mat</span> <span class="nf">A</span><span class="p">(</span><span class="mi">30</span><span class="p">,</span> <span class="mi">40</span><span class="p">,</span> <span class="n">DataType</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;::</span><span class="n">type</span><span class="p">);</span>

<span class="n">Mat</span> <span class="n">B</span> <span class="o">=</span> <span class="n">Mat_</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">complex</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span> <span class="o">&gt;</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span>
<span class="c1">// the statement below will print 6, 2 /*, that is depth == CV_64F, channels == 2 */</span>
<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">B</span><span class="p">.</span><span class="n">depth</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;, &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">B</span><span class="p">.</span><span class="n">channels</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</pre></div>
</div>
<p>So, such traits are used to tell OpenCV which data type you are working with, even if such a type is not native to OpenCV. For example, the matrix <code class="docutils literal"><span class="pre">B</span></code> initialization above is compiled because OpenCV defines the proper specialized template class <code class="docutils literal"><span class="pre">DataType&lt;complex&lt;_Tp&gt;</span> <span class="pre">&gt;</span></code> . This mechanism is also useful (and used in OpenCV this way) for generic algorithms implementations.</p>
</div>
<div class="section" id="point">
<h2>Point_<a class="headerlink" href="#point" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="Point_">
<em class="property">class </em><code class="descname">Point_</code><a class="headerlink" href="#Point_" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<div class="highlight-cpp"><div class="highlight"><pre><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">_Tp</span><span class="o">&gt;</span> <span class="k">class</span> <span class="nc">CV_EXPORTS</span> <span class="n">Point_</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="k">typedef</span> <span class="n">_Tp</span> <span class="n">value_type</span><span class="p">;</span>

    <span class="c1">// various constructors</span>
    <span class="n">Point_</span><span class="p">();</span>
    <span class="n">Point_</span><span class="p">(</span><span class="n">_Tp</span> <span class="n">_x</span><span class="p">,</span> <span class="n">_Tp</span> <span class="n">_y</span><span class="p">);</span>
    <span class="n">Point_</span><span class="p">(</span><span class="k">const</span> <span class="n">Point_</span><span class="o">&amp;</span> <span class="n">pt</span><span class="p">);</span>
    <span class="n">Point_</span><span class="p">(</span><span class="k">const</span> <span class="n">CvPoint</span><span class="o">&amp;</span> <span class="n">pt</span><span class="p">);</span>
    <span class="n">Point_</span><span class="p">(</span><span class="k">const</span> <span class="n">CvPoint2D32f</span><span class="o">&amp;</span> <span class="n">pt</span><span class="p">);</span>
    <span class="n">Point_</span><span class="p">(</span><span class="k">const</span> <span class="n">Size_</span><span class="o">&lt;</span><span class="n">_Tp</span><span class="o">&gt;&amp;</span> <span class="n">sz</span><span class="p">);</span>
    <span class="n">Point_</span><span class="p">(</span><span class="k">const</span> <span class="n">Vec</span><span class="o">&lt;</span><span class="n">_Tp</span><span class="p">,</span> <span class="mi">2</span><span class="o">&gt;&amp;</span> <span class="n">v</span><span class="p">);</span>

    <span class="n">Point_</span><span class="o">&amp;</span> <span class="k">operator</span> <span class="o">=</span> <span class="p">(</span><span class="k">const</span> <span class="n">Point_</span><span class="o">&amp;</span> <span class="n">pt</span><span class="p">);</span>
    <span class="c1">//! conversion to another data type</span>
    <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">_Tp2</span><span class="o">&gt;</span> <span class="k">operator</span> <span class="n">Point_</span><span class="o">&lt;</span><span class="n">_Tp2</span><span class="o">&gt;</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>

    <span class="c1">//! conversion to the old-style C structures</span>
    <span class="k">operator</span> <span class="nf">CvPoint</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
    <span class="k">operator</span> <span class="nf">CvPoint2D32f</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
    <span class="k">operator</span> <span class="n">Vec</span><span class="o">&lt;</span><span class="n">_Tp</span><span class="p">,</span> <span class="mi">2</span><span class="o">&gt;</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>

    <span class="c1">//! dot product</span>
    <span class="n">_Tp</span> <span class="nf">dot</span><span class="p">(</span><span class="k">const</span> <span class="n">Point_</span><span class="o">&amp;</span> <span class="n">pt</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
    <span class="c1">//! dot product computed in double-precision arithmetics</span>
    <span class="kt">double</span> <span class="nf">ddot</span><span class="p">(</span><span class="k">const</span> <span class="n">Point_</span><span class="o">&amp;</span> <span class="n">pt</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
    <span class="c1">//! cross-product</span>
    <span class="kt">double</span> <span class="nf">cross</span><span class="p">(</span><span class="k">const</span> <span class="n">Point_</span><span class="o">&amp;</span> <span class="n">pt</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
    <span class="c1">//! checks whether the point is inside the specified rectangle</span>
    <span class="kt">bool</span> <span class="nf">inside</span><span class="p">(</span><span class="k">const</span> <span class="n">Rect_</span><span class="o">&lt;</span><span class="n">_Tp</span><span class="o">&gt;&amp;</span> <span class="n">r</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>

    <span class="n">_Tp</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">;</span> <span class="c1">//&lt; the point coordinates</span>
<span class="p">};</span>
</pre></div>
</div>
<p>Template class for 2D points specified by its coordinates
<img class="math" src="../../../_images/math/275d1cfd2234a22c171bcf9ee37dd451fffd5e1b.png" alt="x"/> and
<img class="math" src="../../../_images/math/8be61bd3f15e9c74771dd331d4fee2be8dbe30d5.png" alt="y"/> .
An instance of the class is interchangeable with C structures, <code class="docutils literal"><span class="pre">CvPoint</span></code> and <code class="docutils literal"><span class="pre">CvPoint2D32f</span></code> . There is also a cast operator to convert point coordinates to the specified type. The conversion from floating-point coordinates to integer coordinates is done by rounding. Commonly, the conversion uses this
operation for each of the coordinates. Besides the class members listed in the declaration above, the following operations on points are implemented:</p>
<div class="highlight-cpp"><div class="highlight"><pre><span class="n">pt1</span> <span class="o">=</span> <span class="n">pt2</span> <span class="o">+</span> <span class="n">pt3</span><span class="p">;</span>
<span class="n">pt1</span> <span class="o">=</span> <span class="n">pt2</span> <span class="o">-</span> <span class="n">pt3</span><span class="p">;</span>
<span class="n">pt1</span> <span class="o">=</span> <span class="n">pt2</span> <span class="o">*</span> <span class="n">a</span><span class="p">;</span>
<span class="n">pt1</span> <span class="o">=</span> <span class="n">a</span> <span class="o">*</span> <span class="n">pt2</span><span class="p">;</span>
<span class="n">pt1</span> <span class="o">+=</span> <span class="n">pt2</span><span class="p">;</span>
<span class="n">pt1</span> <span class="o">-=</span> <span class="n">pt2</span><span class="p">;</span>
<span class="n">pt1</span> <span class="o">*=</span> <span class="n">a</span><span class="p">;</span>
<span class="kt">double</span> <span class="n">value</span> <span class="o">=</span> <span class="n">norm</span><span class="p">(</span><span class="n">pt</span><span class="p">);</span> <span class="c1">// L2 norm</span>
<span class="n">pt1</span> <span class="o">==</span> <span class="n">pt2</span><span class="p">;</span>
<span class="n">pt1</span> <span class="o">!=</span> <span class="n">pt2</span><span class="p">;</span>
</pre></div>
</div>
<p>For your convenience, the following type aliases are defined:</p>
<div class="highlight-cpp"><div class="highlight"><pre><span class="k">typedef</span> <span class="n">Point_</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">Point2i</span><span class="p">;</span>
<span class="k">typedef</span> <span class="n">Point2i</span> <span class="n">Point</span><span class="p">;</span>
<span class="k">typedef</span> <span class="n">Point_</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span> <span class="n">Point2f</span><span class="p">;</span>
<span class="k">typedef</span> <span class="n">Point_</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span> <span class="n">Point2d</span><span class="p">;</span>
</pre></div>
</div>
<p>Example:</p>
<div class="highlight-cpp"><div class="highlight"><pre><span class="n">Point2f</span> <span class="nf">a</span><span class="p">(</span><span class="mf">0.3f</span><span class="p">,</span> <span class="mf">0.f</span><span class="p">),</span> <span class="n">b</span><span class="p">(</span><span class="mf">0.f</span><span class="p">,</span> <span class="mf">0.4f</span><span class="p">);</span>
<span class="n">Point</span> <span class="n">pt</span> <span class="o">=</span> <span class="p">(</span><span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="p">)</span><span class="o">*</span><span class="mf">10.f</span><span class="p">;</span>
<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">pt</span><span class="p">.</span><span class="n">x</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;, &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">pt</span><span class="p">.</span><span class="n">y</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</pre></div>
</div>
</div>
<div class="section" id="point3">
<h2>Point3_<a class="headerlink" href="#point3" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="Point3_">
<em class="property">class </em><code class="descname">Point3_</code><a class="headerlink" href="#Point3_" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<div class="highlight-cpp"><div class="highlight"><pre><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">_Tp</span><span class="o">&gt;</span> <span class="k">class</span> <span class="nc">CV_EXPORTS</span> <span class="n">Point3_</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="k">typedef</span> <span class="n">_Tp</span> <span class="n">value_type</span><span class="p">;</span>

    <span class="c1">// various constructors</span>
    <span class="n">Point3_</span><span class="p">();</span>
    <span class="n">Point3_</span><span class="p">(</span><span class="n">_Tp</span> <span class="n">_x</span><span class="p">,</span> <span class="n">_Tp</span> <span class="n">_y</span><span class="p">,</span> <span class="n">_Tp</span> <span class="n">_z</span><span class="p">);</span>
    <span class="n">Point3_</span><span class="p">(</span><span class="k">const</span> <span class="n">Point3_</span><span class="o">&amp;</span> <span class="n">pt</span><span class="p">);</span>
    <span class="k">explicit</span> <span class="nf">Point3_</span><span class="p">(</span><span class="k">const</span> <span class="n">Point_</span><span class="o">&lt;</span><span class="n">_Tp</span><span class="o">&gt;&amp;</span> <span class="n">pt</span><span class="p">);</span>
    <span class="n">Point3_</span><span class="p">(</span><span class="k">const</span> <span class="n">CvPoint3D32f</span><span class="o">&amp;</span> <span class="n">pt</span><span class="p">);</span>
    <span class="n">Point3_</span><span class="p">(</span><span class="k">const</span> <span class="n">Vec</span><span class="o">&lt;</span><span class="n">_Tp</span><span class="p">,</span> <span class="mi">3</span><span class="o">&gt;&amp;</span> <span class="n">v</span><span class="p">);</span>

    <span class="n">Point3_</span><span class="o">&amp;</span> <span class="k">operator</span> <span class="o">=</span> <span class="p">(</span><span class="k">const</span> <span class="n">Point3_</span><span class="o">&amp;</span> <span class="n">pt</span><span class="p">);</span>
    <span class="c1">//! conversion to another data type</span>
    <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">_Tp2</span><span class="o">&gt;</span> <span class="k">operator</span> <span class="n">Point3_</span><span class="o">&lt;</span><span class="n">_Tp2</span><span class="o">&gt;</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
    <span class="c1">//! conversion to the old-style CvPoint...</span>
    <span class="k">operator</span> <span class="nf">CvPoint3D32f</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
    <span class="c1">//! conversion to cv::Vec&lt;&gt;</span>
    <span class="k">operator</span> <span class="n">Vec</span><span class="o">&lt;</span><span class="n">_Tp</span><span class="p">,</span> <span class="mi">3</span><span class="o">&gt;</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>

    <span class="c1">//! dot product</span>
    <span class="n">_Tp</span> <span class="nf">dot</span><span class="p">(</span><span class="k">const</span> <span class="n">Point3_</span><span class="o">&amp;</span> <span class="n">pt</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
    <span class="c1">//! dot product computed in double-precision arithmetics</span>
    <span class="kt">double</span> <span class="nf">ddot</span><span class="p">(</span><span class="k">const</span> <span class="n">Point3_</span><span class="o">&amp;</span> <span class="n">pt</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
    <span class="c1">//! cross product of the 2 3D points</span>
    <span class="n">Point3_</span> <span class="nf">cross</span><span class="p">(</span><span class="k">const</span> <span class="n">Point3_</span><span class="o">&amp;</span> <span class="n">pt</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>

    <span class="n">_Tp</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">;</span> <span class="c1">//&lt; the point coordinates</span>
<span class="p">};</span>
</pre></div>
</div>
<p>Template class for 3D points specified by its coordinates
<img class="math" src="../../../_images/math/275d1cfd2234a22c171bcf9ee37dd451fffd5e1b.png" alt="x"/>,
<img class="math" src="../../../_images/math/8be61bd3f15e9c74771dd331d4fee2be8dbe30d5.png" alt="y"/> and
<img class="math" src="../../../_images/math/14e25445812dd6114e136478c67a95cbbf223228.png" alt="z"/> .
An instance of the class is interchangeable with the C structure <code class="docutils literal"><span class="pre">CvPoint2D32f</span></code> . Similarly to <code class="docutils literal"><span class="pre">Point_</span></code> , the coordinates of 3D points can be converted to another type. The vector arithmetic and comparison operations are also supported.</p>
<p>The following <code class="docutils literal"><span class="pre">Point3_&lt;&gt;</span></code> aliases are available:</p>
<div class="highlight-cpp"><div class="highlight"><pre><span class="k">typedef</span> <span class="n">Point3_</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">Point3i</span><span class="p">;</span>
<span class="k">typedef</span> <span class="n">Point3_</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span> <span class="n">Point3f</span><span class="p">;</span>
<span class="k">typedef</span> <span class="n">Point3_</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span> <span class="n">Point3d</span><span class="p">;</span>
</pre></div>
</div>
</div>
<div class="section" id="size">
<h2>Size_<a class="headerlink" href="#size" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="Size_">
<em class="property">class </em><code class="descname">Size_</code><a class="headerlink" href="#Size_" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<div class="highlight-cpp"><div class="highlight"><pre><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">_Tp</span><span class="o">&gt;</span> <span class="k">class</span> <span class="nc">CV_EXPORTS</span> <span class="n">Size_</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="k">typedef</span> <span class="n">_Tp</span> <span class="n">value_type</span><span class="p">;</span>

    <span class="c1">//! various constructors</span>
    <span class="n">Size_</span><span class="p">();</span>
    <span class="n">Size_</span><span class="p">(</span><span class="n">_Tp</span> <span class="n">_width</span><span class="p">,</span> <span class="n">_Tp</span> <span class="n">_height</span><span class="p">);</span>
    <span class="n">Size_</span><span class="p">(</span><span class="k">const</span> <span class="n">Size_</span><span class="o">&amp;</span> <span class="n">sz</span><span class="p">);</span>
    <span class="n">Size_</span><span class="p">(</span><span class="k">const</span> <span class="n">CvSize</span><span class="o">&amp;</span> <span class="n">sz</span><span class="p">);</span>
    <span class="n">Size_</span><span class="p">(</span><span class="k">const</span> <span class="n">CvSize2D32f</span><span class="o">&amp;</span> <span class="n">sz</span><span class="p">);</span>
    <span class="n">Size_</span><span class="p">(</span><span class="k">const</span> <span class="n">Point_</span><span class="o">&lt;</span><span class="n">_Tp</span><span class="o">&gt;&amp;</span> <span class="n">pt</span><span class="p">);</span>

    <span class="n">Size_</span><span class="o">&amp;</span> <span class="k">operator</span> <span class="o">=</span> <span class="p">(</span><span class="k">const</span> <span class="n">Size_</span><span class="o">&amp;</span> <span class="n">sz</span><span class="p">);</span>
    <span class="c1">//! the area (width*height)</span>
    <span class="n">_Tp</span> <span class="nf">area</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>

    <span class="c1">//! conversion of another data type.</span>
    <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">_Tp2</span><span class="o">&gt;</span> <span class="k">operator</span> <span class="n">Size_</span><span class="o">&lt;</span><span class="n">_Tp2</span><span class="o">&gt;</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>

    <span class="c1">//! conversion to the old-style OpenCV types</span>
    <span class="k">operator</span> <span class="nf">CvSize</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
    <span class="k">operator</span> <span class="nf">CvSize2D32f</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>

    <span class="n">_Tp</span> <span class="n">width</span><span class="p">,</span> <span class="n">height</span><span class="p">;</span> <span class="c1">// the width and the height</span>
<span class="p">};</span>
</pre></div>
</div>
<p>Template class for specifying the size of an image or rectangle. The class includes two members called <code class="docutils literal"><span class="pre">width</span></code> and <code class="docutils literal"><span class="pre">height</span></code>. The structure can be converted to and from the old OpenCV structures
<code class="docutils literal"><span class="pre">CvSize</span></code> and <code class="docutils literal"><span class="pre">CvSize2D32f</span></code> . The same set of arithmetic and comparison operations as for <code class="docutils literal"><span class="pre">Point_</span></code> is available.</p>
<p>OpenCV defines the following <code class="docutils literal"><span class="pre">Size_&lt;&gt;</span></code> aliases:</p>
<div class="highlight-cpp"><div class="highlight"><pre><span class="k">typedef</span> <span class="n">Size_</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">Size2i</span><span class="p">;</span>
<span class="k">typedef</span> <span class="n">Size2i</span> <span class="n">Size</span><span class="p">;</span>
<span class="k">typedef</span> <span class="n">Size_</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span> <span class="n">Size2f</span><span class="p">;</span>
</pre></div>
</div>
</div>
<div class="section" id="rect">
<h2>Rect_<a class="headerlink" href="#rect" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="Rect_">
<em class="property">class </em><code class="descname">Rect_</code><a class="headerlink" href="#Rect_" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<div class="highlight-cpp"><div class="highlight"><pre><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">_Tp</span><span class="o">&gt;</span> <span class="k">class</span> <span class="nc">CV_EXPORTS</span> <span class="n">Rect_</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="k">typedef</span> <span class="n">_Tp</span> <span class="n">value_type</span><span class="p">;</span>

    <span class="c1">//! various constructors</span>
    <span class="n">Rect_</span><span class="p">();</span>
    <span class="n">Rect_</span><span class="p">(</span><span class="n">_Tp</span> <span class="n">_x</span><span class="p">,</span> <span class="n">_Tp</span> <span class="n">_y</span><span class="p">,</span> <span class="n">_Tp</span> <span class="n">_width</span><span class="p">,</span> <span class="n">_Tp</span> <span class="n">_height</span><span class="p">);</span>
    <span class="n">Rect_</span><span class="p">(</span><span class="k">const</span> <span class="n">Rect_</span><span class="o">&amp;</span> <span class="n">r</span><span class="p">);</span>
    <span class="n">Rect_</span><span class="p">(</span><span class="k">const</span> <span class="n">CvRect</span><span class="o">&amp;</span> <span class="n">r</span><span class="p">);</span>
    <span class="n">Rect_</span><span class="p">(</span><span class="k">const</span> <span class="n">Point_</span><span class="o">&lt;</span><span class="n">_Tp</span><span class="o">&gt;&amp;</span> <span class="n">org</span><span class="p">,</span> <span class="k">const</span> <span class="n">Size_</span><span class="o">&lt;</span><span class="n">_Tp</span><span class="o">&gt;&amp;</span> <span class="n">sz</span><span class="p">);</span>
    <span class="n">Rect_</span><span class="p">(</span><span class="k">const</span> <span class="n">Point_</span><span class="o">&lt;</span><span class="n">_Tp</span><span class="o">&gt;&amp;</span> <span class="n">pt1</span><span class="p">,</span> <span class="k">const</span> <span class="n">Point_</span><span class="o">&lt;</span><span class="n">_Tp</span><span class="o">&gt;&amp;</span> <span class="n">pt2</span><span class="p">);</span>

    <span class="n">Rect_</span><span class="o">&amp;</span> <span class="k">operator</span> <span class="o">=</span> <span class="p">(</span> <span class="k">const</span> <span class="n">Rect_</span><span class="o">&amp;</span> <span class="n">r</span> <span class="p">);</span>
    <span class="c1">//! the top-left corner</span>
    <span class="n">Point_</span><span class="o">&lt;</span><span class="n">_Tp</span><span class="o">&gt;</span> <span class="n">tl</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
    <span class="c1">//! the bottom-right corner</span>
    <span class="n">Point_</span><span class="o">&lt;</span><span class="n">_Tp</span><span class="o">&gt;</span> <span class="n">br</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>

    <span class="c1">//! size (width, height) of the rectangle</span>
    <span class="n">Size_</span><span class="o">&lt;</span><span class="n">_Tp</span><span class="o">&gt;</span> <span class="n">size</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
    <span class="c1">//! area (width*height) of the rectangle</span>
    <span class="n">_Tp</span> <span class="nf">area</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>

    <span class="c1">//! conversion to another data type</span>
    <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">_Tp2</span><span class="o">&gt;</span> <span class="k">operator</span> <span class="n">Rect_</span><span class="o">&lt;</span><span class="n">_Tp2</span><span class="o">&gt;</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
    <span class="c1">//! conversion to the old-style CvRect</span>
    <span class="k">operator</span> <span class="nf">CvRect</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>

    <span class="c1">//! checks whether the rectangle contains the point</span>
    <span class="kt">bool</span> <span class="nf">contains</span><span class="p">(</span><span class="k">const</span> <span class="n">Point_</span><span class="o">&lt;</span><span class="n">_Tp</span><span class="o">&gt;&amp;</span> <span class="n">pt</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>

    <span class="n">_Tp</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">width</span><span class="p">,</span> <span class="n">height</span><span class="p">;</span> <span class="c1">//&lt; the top-left corner, as well as width and height of the rectangle</span>
<span class="p">};</span>
</pre></div>
</div>
<p>Template class for 2D rectangles, described by the following parameters:</p>
<ul class="simple">
<li>Coordinates of the top-left corner. This is a default interpretation of <code class="docutils literal"><span class="pre">Rect_::x</span></code> and <code class="docutils literal"><span class="pre">Rect_::y</span></code> in OpenCV. Though, in your algorithms you may count <code class="docutils literal"><span class="pre">x</span></code> and <code class="docutils literal"><span class="pre">y</span></code> from the bottom-left corner.</li>
<li>Rectangle width and height.</li>
</ul>
<p>OpenCV typically assumes that the top and left boundary of the rectangle are inclusive, while the right and bottom boundaries are not. For example, the method <code class="docutils literal"><span class="pre">Rect_::contains</span></code> returns <code class="docutils literal"><span class="pre">true</span></code> if</p>
<div class="math">
<p><img src="../../../_images/math/0bcc5289b0a19435c8979cf0cd750fcb21fc48b7.png" alt="x  \leq pt.x &lt; x+width,
      y  \leq pt.y &lt; y+height"/></p>
</div><p>Virtually every loop over an image
ROI in OpenCV (where ROI is specified by <code class="docutils literal"><span class="pre">Rect_&lt;int&gt;</span></code> ) is implemented as:</p>
<div class="highlight-cpp"><div class="highlight"><pre><span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">y</span> <span class="o">=</span> <span class="n">roi</span><span class="p">.</span><span class="n">y</span><span class="p">;</span> <span class="n">y</span> <span class="o">&lt;</span> <span class="n">roi</span><span class="p">.</span><span class="n">y</span> <span class="o">+</span> <span class="n">rect</span><span class="p">.</span><span class="n">height</span><span class="p">;</span> <span class="n">y</span><span class="o">++</span><span class="p">)</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="n">roi</span><span class="p">.</span><span class="n">x</span><span class="p">;</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="n">roi</span><span class="p">.</span><span class="n">x</span> <span class="o">+</span> <span class="n">rect</span><span class="p">.</span><span class="n">width</span><span class="p">;</span> <span class="n">x</span><span class="o">++</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="c1">// ...</span>
    <span class="p">}</span>
</pre></div>
</div>
<p>In addition to the class members, the following operations on rectangles are implemented:</p>
<ul class="simple">
<li><img class="math" src="../../../_images/math/400e9a15c0c2197a2e69e05bf02e3c9c5282eaa6.png" alt="\texttt{rect} = \texttt{rect} \pm \texttt{point}"/>     (shifting a rectangle by a certain offset)</li>
<li><img class="math" src="../../../_images/math/871857cb8b0391e93cb390210103e7a846d4b5ad.png" alt="\texttt{rect} = \texttt{rect} \pm \texttt{size}"/>     (expanding or shrinking a rectangle by a certain amount)</li>
<li><code class="docutils literal"><span class="pre">rect</span> <span class="pre">+=</span> <span class="pre">point,</span> <span class="pre">rect</span> <span class="pre">-=</span> <span class="pre">point,</span> <span class="pre">rect</span> <span class="pre">+=</span> <span class="pre">size,</span> <span class="pre">rect</span> <span class="pre">-=</span> <span class="pre">size</span></code>     (augmenting operations)</li>
<li><code class="docutils literal"><span class="pre">rect</span> <span class="pre">=</span> <span class="pre">rect1</span> <span class="pre">&amp;</span> <span class="pre">rect2</span></code>     (rectangle intersection)</li>
<li><code class="docutils literal"><span class="pre">rect</span> <span class="pre">=</span> <span class="pre">rect1</span> <span class="pre">|</span> <span class="pre">rect2</span></code>     (minimum area rectangle containing <code class="docutils literal"><span class="pre">rect2</span></code>     and <code class="docutils literal"><span class="pre">rect3</span></code>     )</li>
<li><code class="docutils literal"><span class="pre">rect</span> <span class="pre">&amp;=</span> <span class="pre">rect1,</span> <span class="pre">rect</span> <span class="pre">|=</span> <span class="pre">rect1</span></code>     (and the corresponding augmenting operations)</li>
<li><code class="docutils literal"><span class="pre">rect</span> <span class="pre">==</span> <span class="pre">rect1,</span> <span class="pre">rect</span> <span class="pre">!=</span> <span class="pre">rect1</span></code>     (rectangle comparison)</li>
</ul>
<p>This is an example how the partial ordering on rectangles can be established (rect1
<img class="math" src="../../../_images/math/37e2ff831976855edf17c4763e3cdce5befc08f2.png" alt="\subseteq"/> rect2):</p>
<div class="highlight-cpp"><div class="highlight"><pre><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">_Tp</span><span class="o">&gt;</span> <span class="kr">inline</span> <span class="kt">bool</span>
<span class="k">operator</span> <span class="o">&lt;=</span> <span class="p">(</span><span class="k">const</span> <span class="n">Rect_</span><span class="o">&lt;</span><span class="n">_Tp</span><span class="o">&gt;&amp;</span> <span class="n">r1</span><span class="p">,</span> <span class="k">const</span> <span class="n">Rect_</span><span class="o">&lt;</span><span class="n">_Tp</span><span class="o">&gt;&amp;</span> <span class="n">r2</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">r1</span> <span class="o">&amp;</span> <span class="n">r2</span><span class="p">)</span> <span class="o">==</span> <span class="n">r1</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>For your convenience, the <code class="docutils literal"><span class="pre">Rect_&lt;&gt;</span></code> alias is available:</p>
<div class="highlight-cpp"><div class="highlight"><pre><span class="k">typedef</span> <span class="n">Rect_</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">Rect</span><span class="p">;</span>
</pre></div>
</div>
</div>
<div class="section" id="rotatedrect">
<h2>RotatedRect<a class="headerlink" href="#rotatedrect" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="RotatedRect">
<em class="property">class </em><code class="descname">RotatedRect</code><a class="headerlink" href="#RotatedRect" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<div class="highlight-cpp"><div class="highlight"><pre><span class="k">class</span> <span class="nc">CV_EXPORTS</span> <span class="n">RotatedRect</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="c1">//! various constructors</span>
    <span class="n">RotatedRect</span><span class="p">();</span>
    <span class="n">RotatedRect</span><span class="p">(</span><span class="k">const</span> <span class="n">Point2f</span><span class="o">&amp;</span> <span class="n">center</span><span class="p">,</span> <span class="k">const</span> <span class="n">Size2f</span><span class="o">&amp;</span> <span class="n">size</span><span class="p">,</span> <span class="kt">float</span> <span class="n">angle</span><span class="p">);</span>
    <span class="n">RotatedRect</span><span class="p">(</span><span class="k">const</span> <span class="n">CvBox2D</span><span class="o">&amp;</span> <span class="n">box</span><span class="p">);</span>

    <span class="c1">//! returns 4 vertices of the rectangle</span>
    <span class="kt">void</span> <span class="nf">points</span><span class="p">(</span><span class="n">Point2f</span> <span class="n">pts</span><span class="p">[])</span> <span class="k">const</span><span class="p">;</span>
    <span class="c1">//! returns the minimal up-right rectangle containing the rotated rectangle</span>
    <span class="n">Rect</span> <span class="nf">boundingRect</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
    <span class="c1">//! conversion to the old-style CvBox2D structure</span>
    <span class="k">operator</span> <span class="nf">CvBox2D</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>

    <span class="n">Point2f</span> <span class="n">center</span><span class="p">;</span> <span class="c1">//&lt; the rectangle mass center</span>
    <span class="n">Size2f</span> <span class="n">size</span><span class="p">;</span>    <span class="c1">//&lt; width and height of the rectangle</span>
    <span class="kt">float</span> <span class="n">angle</span><span class="p">;</span>    <span class="c1">//&lt; the rotation angle. When the angle is 0, 90, 180, 270 etc., the rectangle becomes an up-right rectangle.</span>
<span class="p">};</span>
</pre></div>
</div>
<p>The class represents rotated (i.e. not up-right) rectangles on a plane. Each rectangle is specified by the center point (mass center), length of each side (represented by cv::Size2f structure) and the rotation angle in degrees.</p>
<blockquote>
<div><dl class="function">
<dt id="RotatedRect::RotatedRect()">
<strong>C++:</strong><code class="descname"> </code> <code class="descclassname">RotatedRect::</code><code class="descname">RotatedRect</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#RotatedRect::RotatedRect()" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="RotatedRect::RotatedRect(const Point2f&amp; center, const Size2f&amp; size, float angle)">
<strong>C++:</strong><code class="descname"> </code> <code class="descclassname">RotatedRect::</code><code class="descname">RotatedRect</code><span class="sig-paren">(</span>const Point2f&amp; <strong>center</strong>, const Size2f&amp; <strong>size</strong>, float <strong>angle</strong><span class="sig-paren">)</span><a class="headerlink" href="#RotatedRect::RotatedRect(const Point2f& center, const Size2f& size, float angle)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="RotatedRect::RotatedRect(const CvBox2D&amp; box)">
<strong>C++:</strong><code class="descname"> </code> <code class="descclassname">RotatedRect::</code><code class="descname">RotatedRect</code><span class="sig-paren">(</span>const CvBox2D&amp; <strong>box</strong><span class="sig-paren">)</span><a class="headerlink" href="#RotatedRect::RotatedRect(const CvBox2D& box)" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>center</strong> &#8211; The rectangle mass center.</li>
<li><strong>size</strong> &#8211; Width and height of the rectangle.</li>
<li><strong>angle</strong> &#8211; The rotation angle in a clockwise direction. When the angle is 0, 90, 180, 270 etc., the rectangle becomes an up-right rectangle.</li>
<li><strong>box</strong> &#8211; The rotated rectangle parameters as the obsolete CvBox2D structure.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="void RotatedRect::points(Point2f pts[]) const">
<strong>C++:</strong><code class="descname"> </code>void <code class="descclassname">RotatedRect::</code><code class="descname">points</code><span class="sig-paren">(</span>Point2f <strong>pts</strong>[]<span class="sig-paren">)</span><code class="descclassname"> const</code><a class="headerlink" href="#void RotatedRect::points(Point2f pts[]) const" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="Rect RotatedRect::boundingRect() const">
<strong>C++:</strong><code class="descname"> </code>Rect <code class="descclassname">RotatedRect::</code><code class="descname">boundingRect</code><span class="sig-paren">(</span><span class="sig-paren">)</span><code class="descclassname"> const</code><a class="headerlink" href="#Rect RotatedRect::boundingRect() const" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="RotatedRect::operator CvBox2D() const">
<strong>C++:</strong><code class="descname"> </code> <code class="descclassname">RotatedRect::</code><code class="descname">operator</code> CvBox2D<span class="sig-paren">(</span><span class="sig-paren">)</span><code class="descclassname"> const</code><a class="headerlink" href="#RotatedRect::operator CvBox2D() const" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>pts</strong> &#8211; The points array for storing rectangle vertices.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div></blockquote>
<p>The sample below demonstrates how to use RotatedRect:</p>
<div class="highlight-cpp"><div class="highlight"><pre><span class="n">Mat</span> <span class="nf">image</span><span class="p">(</span><span class="mi">200</span><span class="p">,</span> <span class="mi">200</span><span class="p">,</span> <span class="n">CV_8UC3</span><span class="p">,</span> <span class="n">Scalar</span><span class="p">(</span><span class="mi">0</span><span class="p">));</span>
<span class="n">RotatedRect</span> <span class="n">rRect</span> <span class="o">=</span> <span class="n">RotatedRect</span><span class="p">(</span><span class="n">Point2f</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span><span class="mi">100</span><span class="p">),</span> <span class="n">Size2f</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span><span class="mi">50</span><span class="p">),</span> <span class="mi">30</span><span class="p">);</span>

<span class="n">Point2f</span> <span class="n">vertices</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>
<span class="n">rRect</span><span class="p">.</span><span class="n">points</span><span class="p">(</span><span class="n">vertices</span><span class="p">);</span>
<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">4</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="n">line</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">vertices</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">vertices</span><span class="p">[(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">%</span><span class="mi">4</span><span class="p">],</span> <span class="n">Scalar</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">255</span><span class="p">,</span><span class="mi">0</span><span class="p">));</span>

<span class="n">Rect</span> <span class="n">brect</span> <span class="o">=</span> <span class="n">rRect</span><span class="p">.</span><span class="n">boundingRect</span><span class="p">();</span>
<span class="n">rectangle</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">brect</span><span class="p">,</span> <span class="n">Scalar</span><span class="p">(</span><span class="mi">255</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">));</span>

<span class="n">imshow</span><span class="p">(</span><span class="s">&quot;rectangles&quot;</span><span class="p">,</span> <span class="n">image</span><span class="p">);</span>
<span class="n">waitKey</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
</pre></div>
</div>
<img alt="../../../_images/rotatedrect.png" src="../../../_images/rotatedrect.png" />
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="../../video/doc/motion_analysis_and_object_tracking.html#RotatedRect CamShift(InputArray probImage, Rect&amp; window, TermCriteria criteria)" title="RotatedRect CamShift(InputArray probImage, Rect&amp; window, TermCriteria criteria)"><code class="xref ocv ocv-func docutils literal"><span class="pre">CamShift()</span></code></a> ,
<a class="reference internal" href="../../imgproc/doc/structural_analysis_and_shape_descriptors.html#RotatedRect fitEllipse(InputArray points)" title="RotatedRect fitEllipse(InputArray points)"><code class="xref ocv ocv-func docutils literal"><span class="pre">fitEllipse()</span></code></a> ,
<a class="reference internal" href="../../imgproc/doc/structural_analysis_and_shape_descriptors.html#RotatedRect minAreaRect(InputArray points)" title="RotatedRect minAreaRect(InputArray points)"><code class="xref ocv ocv-func docutils literal"><span class="pre">minAreaRect()</span></code></a> ,
<a class="reference internal" href="old_basic_structures.html#CvBox2D" title="struct CvBox2D"><code class="xref ocv ocv-struct docutils literal"><span class="pre">CvBox2D</span></code></a></p>
</div>
</div>
<div class="section" id="termcriteria">
<h2>TermCriteria<a class="headerlink" href="#termcriteria" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="TermCriteria">
<em class="property">class </em><code class="descname">TermCriteria</code><a class="headerlink" href="#TermCriteria" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<div class="highlight-cpp"><div class="highlight"><pre><span class="k">class</span> <span class="nc">CV_EXPORTS</span> <span class="n">TermCriteria</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="k">enum</span>
    <span class="p">{</span>
        <span class="n">COUNT</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="c1">//!&lt; the maximum number of iterations or elements to compute</span>
        <span class="n">MAX_ITER</span><span class="o">=</span><span class="n">COUNT</span><span class="p">,</span> <span class="c1">//!&lt; ditto</span>
        <span class="n">EPS</span><span class="o">=</span><span class="mi">2</span> <span class="c1">//!&lt; the desired accuracy or change in parameters at which the iterative algorithm stops</span>
    <span class="p">};</span>

    <span class="c1">//! default constructor</span>
    <span class="n">TermCriteria</span><span class="p">();</span>
    <span class="c1">//! full constructor</span>
    <span class="n">TermCriteria</span><span class="p">(</span><span class="kt">int</span> <span class="n">type</span><span class="p">,</span> <span class="kt">int</span> <span class="n">maxCount</span><span class="p">,</span> <span class="kt">double</span> <span class="n">epsilon</span><span class="p">);</span>
    <span class="c1">//! conversion from CvTermCriteria</span>
    <span class="n">TermCriteria</span><span class="p">(</span><span class="k">const</span> <span class="n">CvTermCriteria</span><span class="o">&amp;</span> <span class="n">criteria</span><span class="p">);</span>
    <span class="c1">//! conversion to CvTermCriteria</span>
    <span class="k">operator</span> <span class="nf">CvTermCriteria</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>

    <span class="kt">int</span> <span class="n">type</span><span class="p">;</span> <span class="c1">//!&lt; the type of termination criteria: COUNT, EPS or COUNT + EPS</span>
    <span class="kt">int</span> <span class="n">maxCount</span><span class="p">;</span> <span class="c1">// the maximum number of iterations/elements</span>
    <span class="kt">double</span> <span class="n">epsilon</span><span class="p">;</span> <span class="c1">// the desired accuracy</span>
<span class="p">};</span>
</pre></div>
</div>
<p>The class defining termination criteria for iterative algorithms. You can initialize it by default constructor and then override any parameters, or the structure may be fully initialized using the advanced variant of the constructor.</p>
</div>
<div class="section" id="termcriteria-termcriteria">
<h2>TermCriteria::TermCriteria<a class="headerlink" href="#termcriteria-termcriteria" title="Permalink to this headline">¶</a></h2>
<p>The constructors.</p>
<dl class="function">
<dt id="TermCriteria::TermCriteria()">
<strong>C++:</strong><code class="descname"> </code> <code class="descclassname">TermCriteria::</code><code class="descname">TermCriteria</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#TermCriteria::TermCriteria()" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="TermCriteria::TermCriteria(int type, int maxCount, double epsilon)">
<strong>C++:</strong><code class="descname"> </code> <code class="descclassname">TermCriteria::</code><code class="descname">TermCriteria</code><span class="sig-paren">(</span>int <strong>type</strong>, int <strong>maxCount</strong>, double <strong>epsilon</strong><span class="sig-paren">)</span><a class="headerlink" href="#TermCriteria::TermCriteria(int type, int maxCount, double epsilon)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="TermCriteria::TermCriteria(const CvTermCriteria&amp; criteria)">
<strong>C++:</strong><code class="descname"> </code> <code class="descclassname">TermCriteria::</code><code class="descname">TermCriteria</code><span class="sig-paren">(</span>const CvTermCriteria&amp; <strong>criteria</strong><span class="sig-paren">)</span><a class="headerlink" href="#TermCriteria::TermCriteria(const CvTermCriteria& criteria)" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>type</strong> &#8211; The type of termination criteria: <code class="docutils literal"><span class="pre">TermCriteria::COUNT</span></code>, <code class="docutils literal"><span class="pre">TermCriteria::EPS</span></code> or <code class="docutils literal"><span class="pre">TermCriteria::COUNT</span></code> + <code class="docutils literal"><span class="pre">TermCriteria::EPS</span></code>.</li>
<li><strong>maxCount</strong> &#8211; The maximum number of iterations or elements to compute.</li>
<li><strong>epsilon</strong> &#8211; The desired accuracy or change in parameters at which the iterative algorithm stops.</li>
<li><strong>criteria</strong> &#8211; Termination criteria in the deprecated <code class="docutils literal"><span class="pre">CvTermCriteria</span></code> format.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="termcriteria-operator-cvtermcriteria">
<h2>TermCriteria::operator CvTermCriteria<a class="headerlink" href="#termcriteria-operator-cvtermcriteria" title="Permalink to this headline">¶</a></h2>
<p>Converts to the deprecated <code class="docutils literal"><span class="pre">CvTermCriteria</span></code> format.</p>
<dl class="function">
<dt id="TermCriteria::operator CvTermCriteria() const">
<strong>C++:</strong><code class="descname"> </code> <code class="descclassname">TermCriteria::</code><code class="descname">operator</code> CvTermCriteria<span class="sig-paren">(</span><span class="sig-paren">)</span><code class="descclassname"> const</code><a class="headerlink" href="#TermCriteria::operator CvTermCriteria() const" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</div>
<div class="section" id="matx">
<h2>Matx<a class="headerlink" href="#matx" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="Matx">
<em class="property">class </em><code class="descname">Matx</code><a class="headerlink" href="#Matx" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p>Template class for small matrices whose type and size are known at compilation time:</p>
<div class="highlight-cpp"><div class="highlight"><pre><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">_Tp</span><span class="p">,</span> <span class="kt">int</span> <span class="n">m</span><span class="p">,</span> <span class="kt">int</span> <span class="n">n</span><span class="o">&gt;</span> <span class="k">class</span> <span class="nc">Matx</span> <span class="p">{...};</span>

<span class="k">typedef</span> <span class="n">Matx</span><span class="o">&lt;</span><span class="kt">float</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="o">&gt;</span> <span class="n">Matx12f</span><span class="p">;</span>
<span class="k">typedef</span> <span class="n">Matx</span><span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="o">&gt;</span> <span class="n">Matx12d</span><span class="p">;</span>
<span class="p">...</span>
<span class="k">typedef</span> <span class="n">Matx</span><span class="o">&lt;</span><span class="kt">float</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">6</span><span class="o">&gt;</span> <span class="n">Matx16f</span><span class="p">;</span>
<span class="k">typedef</span> <span class="n">Matx</span><span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">6</span><span class="o">&gt;</span> <span class="n">Matx16d</span><span class="p">;</span>

<span class="k">typedef</span> <span class="n">Matx</span><span class="o">&lt;</span><span class="kt">float</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="o">&gt;</span> <span class="n">Matx21f</span><span class="p">;</span>
<span class="k">typedef</span> <span class="n">Matx</span><span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="o">&gt;</span> <span class="n">Matx21d</span><span class="p">;</span>
<span class="p">...</span>
<span class="k">typedef</span> <span class="n">Matx</span><span class="o">&lt;</span><span class="kt">float</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">1</span><span class="o">&gt;</span> <span class="n">Matx61f</span><span class="p">;</span>
<span class="k">typedef</span> <span class="n">Matx</span><span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">1</span><span class="o">&gt;</span> <span class="n">Matx61d</span><span class="p">;</span>

<span class="k">typedef</span> <span class="n">Matx</span><span class="o">&lt;</span><span class="kt">float</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="o">&gt;</span> <span class="n">Matx22f</span><span class="p">;</span>
<span class="k">typedef</span> <span class="n">Matx</span><span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="o">&gt;</span> <span class="n">Matx22d</span><span class="p">;</span>
<span class="p">...</span>
<span class="k">typedef</span> <span class="n">Matx</span><span class="o">&lt;</span><span class="kt">float</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">6</span><span class="o">&gt;</span> <span class="n">Matx66f</span><span class="p">;</span>
<span class="k">typedef</span> <span class="n">Matx</span><span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">6</span><span class="o">&gt;</span> <span class="n">Matx66d</span><span class="p">;</span>
</pre></div>
</div>
<p>If you need a more flexible type, use <a class="reference internal" href="#Mat" title="class Mat"><code class="xref ocv ocv-class docutils literal"><span class="pre">Mat</span></code></a> . The elements of the matrix <code class="docutils literal"><span class="pre">M</span></code> are accessible using the <code class="docutils literal"><span class="pre">M(i,j)</span></code> notation. Most of the common matrix operations (see also
<a class="reference internal" href="#matrixexpressions"><span>Matrix Expressions</span></a> ) are available. To do an operation on <code class="docutils literal"><span class="pre">Matx</span></code> that is not implemented, you can easily convert the matrix to
<code class="docutils literal"><span class="pre">Mat</span></code> and backwards.</p>
<div class="highlight-cpp"><div class="highlight"><pre><span class="n">Matx33f</span> <span class="nf">m</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span>
          <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span>
          <span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">9</span><span class="p">);</span>
<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">sum</span><span class="p">(</span><span class="n">Mat</span><span class="p">(</span><span class="n">m</span><span class="o">*</span><span class="n">m</span><span class="p">.</span><span class="n">t</span><span class="p">()))</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</pre></div>
</div>
</div>
<div class="section" id="vec">
<h2>Vec<a class="headerlink" href="#vec" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="Vec">
<em class="property">class </em><code class="descname">Vec</code><a class="headerlink" href="#Vec" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p>Template class for short numerical vectors, a partial case of <a class="reference internal" href="#Matx" title="class Matx"><code class="xref ocv ocv-class docutils literal"><span class="pre">Matx</span></code></a>:</p>
<div class="highlight-cpp"><div class="highlight"><pre><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">_Tp</span><span class="p">,</span> <span class="kt">int</span> <span class="n">n</span><span class="o">&gt;</span> <span class="k">class</span> <span class="nc">Vec</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Matx</span><span class="o">&lt;</span><span class="n">_Tp</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="mi">1</span><span class="o">&gt;</span> <span class="p">{...};</span>

<span class="k">typedef</span> <span class="n">Vec</span><span class="o">&lt;</span><span class="n">uchar</span><span class="p">,</span> <span class="mi">2</span><span class="o">&gt;</span> <span class="n">Vec2b</span><span class="p">;</span>
<span class="k">typedef</span> <span class="n">Vec</span><span class="o">&lt;</span><span class="n">uchar</span><span class="p">,</span> <span class="mi">3</span><span class="o">&gt;</span> <span class="n">Vec3b</span><span class="p">;</span>
<span class="k">typedef</span> <span class="n">Vec</span><span class="o">&lt;</span><span class="n">uchar</span><span class="p">,</span> <span class="mi">4</span><span class="o">&gt;</span> <span class="n">Vec4b</span><span class="p">;</span>

<span class="k">typedef</span> <span class="n">Vec</span><span class="o">&lt;</span><span class="kt">short</span><span class="p">,</span> <span class="mi">2</span><span class="o">&gt;</span> <span class="n">Vec2s</span><span class="p">;</span>
<span class="k">typedef</span> <span class="n">Vec</span><span class="o">&lt;</span><span class="kt">short</span><span class="p">,</span> <span class="mi">3</span><span class="o">&gt;</span> <span class="n">Vec3s</span><span class="p">;</span>
<span class="k">typedef</span> <span class="n">Vec</span><span class="o">&lt;</span><span class="kt">short</span><span class="p">,</span> <span class="mi">4</span><span class="o">&gt;</span> <span class="n">Vec4s</span><span class="p">;</span>

<span class="k">typedef</span> <span class="n">Vec</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="mi">2</span><span class="o">&gt;</span> <span class="n">Vec2i</span><span class="p">;</span>
<span class="k">typedef</span> <span class="n">Vec</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="mi">3</span><span class="o">&gt;</span> <span class="n">Vec3i</span><span class="p">;</span>
<span class="k">typedef</span> <span class="n">Vec</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="mi">4</span><span class="o">&gt;</span> <span class="n">Vec4i</span><span class="p">;</span>

<span class="k">typedef</span> <span class="n">Vec</span><span class="o">&lt;</span><span class="kt">float</span><span class="p">,</span> <span class="mi">2</span><span class="o">&gt;</span> <span class="n">Vec2f</span><span class="p">;</span>
<span class="k">typedef</span> <span class="n">Vec</span><span class="o">&lt;</span><span class="kt">float</span><span class="p">,</span> <span class="mi">3</span><span class="o">&gt;</span> <span class="n">Vec3f</span><span class="p">;</span>
<span class="k">typedef</span> <span class="n">Vec</span><span class="o">&lt;</span><span class="kt">float</span><span class="p">,</span> <span class="mi">4</span><span class="o">&gt;</span> <span class="n">Vec4f</span><span class="p">;</span>
<span class="k">typedef</span> <span class="n">Vec</span><span class="o">&lt;</span><span class="kt">float</span><span class="p">,</span> <span class="mi">6</span><span class="o">&gt;</span> <span class="n">Vec6f</span><span class="p">;</span>

<span class="k">typedef</span> <span class="n">Vec</span><span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span> <span class="mi">2</span><span class="o">&gt;</span> <span class="n">Vec2d</span><span class="p">;</span>
<span class="k">typedef</span> <span class="n">Vec</span><span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span> <span class="mi">3</span><span class="o">&gt;</span> <span class="n">Vec3d</span><span class="p">;</span>
<span class="k">typedef</span> <span class="n">Vec</span><span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span> <span class="mi">4</span><span class="o">&gt;</span> <span class="n">Vec4d</span><span class="p">;</span>
<span class="k">typedef</span> <span class="n">Vec</span><span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span> <span class="mi">6</span><span class="o">&gt;</span> <span class="n">Vec6d</span><span class="p">;</span>
</pre></div>
</div>
<p>It is possible to convert <code class="docutils literal"><span class="pre">Vec&lt;T,2&gt;</span></code> to/from <code class="docutils literal"><span class="pre">Point_</span></code>, <code class="docutils literal"><span class="pre">Vec&lt;T,3&gt;</span></code> to/from <code class="docutils literal"><span class="pre">Point3_</span></code> , and <code class="docutils literal"><span class="pre">Vec&lt;T,4&gt;</span></code> to <a class="reference internal" href="old_basic_structures.html#CvScalar" title="struct CvScalar"><code class="xref ocv ocv-struct docutils literal"><span class="pre">CvScalar</span></code></a> or <a class="reference internal" href="#Scalar_" title="class Scalar_"><code class="xref ocv ocv-class docutils literal"><span class="pre">Scalar_</span></code></a>. Use <code class="docutils literal"><span class="pre">operator[]</span></code> to access the elements of <code class="docutils literal"><span class="pre">Vec</span></code>.</p>
<p>All the expected vector operations are also implemented:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">v1</span> <span class="pre">=</span> <span class="pre">v2</span> <span class="pre">+</span> <span class="pre">v3</span></code></li>
<li><code class="docutils literal"><span class="pre">v1</span> <span class="pre">=</span> <span class="pre">v2</span> <span class="pre">-</span> <span class="pre">v3</span></code></li>
<li><code class="docutils literal"><span class="pre">v1</span> <span class="pre">=</span> <span class="pre">v2</span> <span class="pre">*</span> <span class="pre">scale</span></code></li>
<li><code class="docutils literal"><span class="pre">v1</span> <span class="pre">=</span> <span class="pre">scale</span> <span class="pre">*</span> <span class="pre">v2</span></code></li>
<li><code class="docutils literal"><span class="pre">v1</span> <span class="pre">=</span> <span class="pre">-v2</span></code></li>
<li><code class="docutils literal"><span class="pre">v1</span> <span class="pre">+=</span> <span class="pre">v2</span></code> and other augmenting operations</li>
<li><code class="docutils literal"><span class="pre">v1</span> <span class="pre">==</span> <span class="pre">v2,</span> <span class="pre">v1</span> <span class="pre">!=</span> <span class="pre">v2</span></code></li>
<li><code class="docutils literal"><span class="pre">norm(v1)</span></code>  (euclidean norm)</li>
</ul>
<p>The <code class="docutils literal"><span class="pre">Vec</span></code> class is commonly used to describe pixel types of multi-channel arrays. See <a class="reference internal" href="#Mat" title="class Mat"><code class="xref ocv ocv-class docutils literal"><span class="pre">Mat</span></code></a> for details.</p>
</div>
<div class="section" id="scalar">
<h2>Scalar_<a class="headerlink" href="#scalar" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="Scalar_">
<em class="property">class </em><code class="descname">Scalar_</code><a class="headerlink" href="#Scalar_" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p>Template class for a 4-element vector derived from Vec.</p>
<div class="highlight-cpp"><div class="highlight"><pre><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">_Tp</span><span class="o">&gt;</span> <span class="k">class</span> <span class="nc">CV_EXPORTS</span> <span class="nl">Scalar_</span> <span class="p">:</span> <span class="k">public</span> <span class="n">Vec</span><span class="o">&lt;</span><span class="n">_Tp</span><span class="p">,</span> <span class="mi">4</span><span class="o">&gt;</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="c1">//! various constructors</span>
    <span class="n">Scalar_</span><span class="p">();</span>
    <span class="n">Scalar_</span><span class="p">(</span><span class="n">_Tp</span> <span class="n">v0</span><span class="p">,</span> <span class="n">_Tp</span> <span class="n">v1</span><span class="p">,</span> <span class="n">_Tp</span> <span class="n">v2</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">_Tp</span> <span class="n">v3</span><span class="o">=</span><span class="mi">0</span><span class="p">);</span>
    <span class="n">Scalar_</span><span class="p">(</span><span class="k">const</span> <span class="n">CvScalar</span><span class="o">&amp;</span> <span class="n">s</span><span class="p">);</span>
    <span class="n">Scalar_</span><span class="p">(</span><span class="n">_Tp</span> <span class="n">v0</span><span class="p">);</span>

    <span class="c1">//! returns a scalar with all elements set to v0</span>
    <span class="k">static</span> <span class="n">Scalar_</span><span class="o">&lt;</span><span class="n">_Tp</span><span class="o">&gt;</span> <span class="n">all</span><span class="p">(</span><span class="n">_Tp</span> <span class="n">v0</span><span class="p">);</span>
    <span class="c1">//! conversion to the old-style CvScalar</span>
    <span class="k">operator</span> <span class="nf">CvScalar</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>

    <span class="c1">//! conversion to another data type</span>
    <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T2</span><span class="o">&gt;</span> <span class="k">operator</span> <span class="n">Scalar_</span><span class="o">&lt;</span><span class="n">T2</span><span class="o">&gt;</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>

    <span class="c1">//! per-element product</span>
    <span class="n">Scalar_</span><span class="o">&lt;</span><span class="n">_Tp</span><span class="o">&gt;</span> <span class="n">mul</span><span class="p">(</span><span class="k">const</span> <span class="n">Scalar_</span><span class="o">&lt;</span><span class="n">_Tp</span><span class="o">&gt;&amp;</span> <span class="n">t</span><span class="p">,</span> <span class="kt">double</span> <span class="n">scale</span><span class="o">=</span><span class="mi">1</span> <span class="p">)</span> <span class="k">const</span><span class="p">;</span>

    <span class="c1">// returns (v0, -v1, -v2, -v3)</span>
    <span class="n">Scalar_</span><span class="o">&lt;</span><span class="n">_Tp</span><span class="o">&gt;</span> <span class="n">conj</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>

    <span class="c1">// returns true iff v1 == v2 == v3 == 0</span>
    <span class="kt">bool</span> <span class="nf">isReal</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">typedef</span> <span class="n">Scalar_</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span> <span class="n">Scalar</span><span class="p">;</span>
</pre></div>
</div>
<p>Being derived from <code class="docutils literal"><span class="pre">Vec&lt;_Tp,</span> <span class="pre">4&gt;</span></code> , <code class="docutils literal"><span class="pre">Scalar_</span></code> and <code class="docutils literal"><span class="pre">Scalar</span></code> can be used just as typical 4-element vectors. In addition, they can be converted to/from <code class="docutils literal"><span class="pre">CvScalar</span></code> . The type <code class="docutils literal"><span class="pre">Scalar</span></code> is widely used in OpenCV to pass pixel values.</p>
</div>
<div class="section" id="range">
<h2>Range<a class="headerlink" href="#range" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="Range">
<em class="property">class </em><code class="descname">Range</code><a class="headerlink" href="#Range" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p>Template class specifying a continuous subsequence (slice) of a sequence.</p>
<div class="highlight-cpp"><div class="highlight"><pre><span class="k">class</span> <span class="nc">CV_EXPORTS</span> <span class="n">Range</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">Range</span><span class="p">();</span>
    <span class="n">Range</span><span class="p">(</span><span class="kt">int</span> <span class="n">_start</span><span class="p">,</span> <span class="kt">int</span> <span class="n">_end</span><span class="p">);</span>
    <span class="n">Range</span><span class="p">(</span><span class="k">const</span> <span class="n">CvSlice</span><span class="o">&amp;</span> <span class="n">slice</span><span class="p">);</span>
    <span class="kt">int</span> <span class="nf">size</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
    <span class="kt">bool</span> <span class="nf">empty</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
    <span class="k">static</span> <span class="n">Range</span> <span class="nf">all</span><span class="p">();</span>
    <span class="k">operator</span> <span class="nf">CvSlice</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>

    <span class="kt">int</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
<p>The class is used to specify a row or a column span in a matrix (
<a class="reference internal" href="#Mat" title="class Mat"><code class="xref ocv ocv-class docutils literal"><span class="pre">Mat</span></code></a> ) and for many other purposes. <code class="docutils literal"><span class="pre">Range(a,b)</span></code> is basically the same as <code class="docutils literal"><span class="pre">a:b</span></code> in Matlab or <code class="docutils literal"><span class="pre">a..b</span></code> in Python. As in Python, <code class="docutils literal"><span class="pre">start</span></code> is an inclusive left boundary of the range and <code class="docutils literal"><span class="pre">end</span></code> is an exclusive right boundary of the range. Such a half-opened interval is usually denoted as
<img class="math" src="../../../_images/math/0a4e6a7a6a4ecef0aac03ae92bff26a7b07f152d.png" alt="[start,end)"/> .</p>
<p>The static method <code class="docutils literal"><span class="pre">Range::all()</span></code> returns a special variable that means &#8220;the whole sequence&#8221; or &#8220;the whole range&#8221;, just like &#8221; <code class="docutils literal"><span class="pre">:</span></code> &#8221; in Matlab or &#8221; <code class="docutils literal"><span class="pre">...</span></code> &#8221; in Python. All the methods and functions in OpenCV that take <code class="docutils literal"><span class="pre">Range</span></code> support this special <code class="docutils literal"><span class="pre">Range::all()</span></code> value. But, of course, in case of your own custom processing, you will probably have to check and handle it explicitly:</p>
<div class="highlight-cpp"><div class="highlight"><pre><span class="kt">void</span> <span class="nf">my_function</span><span class="p">(...,</span> <span class="k">const</span> <span class="n">Range</span><span class="o">&amp;</span> <span class="n">r</span><span class="p">,</span> <span class="p">....)</span>
<span class="p">{</span>
    <span class="k">if</span><span class="p">(</span><span class="n">r</span> <span class="o">==</span> <span class="n">Range</span><span class="o">::</span><span class="n">all</span><span class="p">())</span> <span class="p">{</span>
        <span class="c1">// process all the data</span>
    <span class="p">}</span>
    <span class="k">else</span> <span class="p">{</span>
        <span class="c1">// process [r.start, r.end)</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="ptr">
<span id="id1"></span><h2>Ptr<a class="headerlink" href="#ptr" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="Ptr">
<em class="property">class </em><code class="descname">Ptr</code><a class="headerlink" href="#Ptr" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p>Template class for smart reference-counting pointers</p>
<div class="highlight-cpp"><div class="highlight"><pre><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">_Tp</span><span class="o">&gt;</span> <span class="k">class</span> <span class="nc">Ptr</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="c1">// default constructor</span>
    <span class="n">Ptr</span><span class="p">();</span>
    <span class="c1">// constructor that wraps the object pointer</span>
    <span class="n">Ptr</span><span class="p">(</span><span class="n">_Tp</span><span class="o">*</span> <span class="n">_obj</span><span class="p">);</span>
    <span class="c1">// destructor: calls release()</span>
    <span class="o">~</span><span class="n">Ptr</span><span class="p">();</span>
    <span class="c1">// copy constructor; increments ptr&#39;s reference counter</span>
    <span class="n">Ptr</span><span class="p">(</span><span class="k">const</span> <span class="n">Ptr</span><span class="o">&amp;</span> <span class="n">ptr</span><span class="p">);</span>
    <span class="c1">// assignment operator; decrements own reference counter</span>
    <span class="c1">// (with release()) and increments ptr&#39;s reference counter</span>
    <span class="n">Ptr</span><span class="o">&amp;</span> <span class="k">operator</span> <span class="o">=</span> <span class="p">(</span><span class="k">const</span> <span class="n">Ptr</span><span class="o">&amp;</span> <span class="n">ptr</span><span class="p">);</span>
    <span class="c1">// increments reference counter</span>
    <span class="kt">void</span> <span class="nf">addref</span><span class="p">();</span>
    <span class="c1">// decrements reference counter; when it becomes 0,</span>
    <span class="c1">// delete_obj() is called</span>
    <span class="kt">void</span> <span class="nf">release</span><span class="p">();</span>
    <span class="c1">// user-specified custom object deletion operation.</span>
    <span class="c1">// by default, &quot;delete obj;&quot; is called</span>
    <span class="kt">void</span> <span class="nf">delete_obj</span><span class="p">();</span>
    <span class="c1">// returns true if obj == 0;</span>
    <span class="kt">bool</span> <span class="nf">empty</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>

    <span class="c1">// provide access to the object fields and methods</span>
    <span class="n">_Tp</span><span class="o">*</span> <span class="k">operator</span> <span class="o">-&gt;</span> <span class="p">();</span>
    <span class="k">const</span> <span class="n">_Tp</span><span class="o">*</span> <span class="k">operator</span> <span class="o">-&gt;</span> <span class="p">()</span> <span class="k">const</span><span class="p">;</span>

    <span class="c1">// return the underlying object pointer;</span>
    <span class="c1">// thanks to the methods, the Ptr&lt;_Tp&gt; can be</span>
    <span class="c1">// used instead of _Tp*</span>
    <span class="k">operator</span> <span class="n">_Tp</span><span class="o">*</span> <span class="p">();</span>
    <span class="k">operator</span> <span class="k">const</span> <span class="n">_Tp</span><span class="o">*</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
<span class="k">protected</span><span class="o">:</span>
    <span class="c1">// the encapsulated object pointer</span>
    <span class="n">_Tp</span><span class="o">*</span> <span class="n">obj</span><span class="p">;</span>
    <span class="c1">// the associated reference counter</span>
    <span class="kt">int</span><span class="o">*</span> <span class="n">refcount</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
<p>The <code class="docutils literal"><span class="pre">Ptr&lt;_Tp&gt;</span></code> class is a template class that wraps pointers of the corresponding type. It is
similar to <code class="docutils literal"><span class="pre">shared_ptr</span></code> that is part of the Boost library
(<a class="reference external" href="http://www.boost.org/doc/libs/1_40_0/libs/smart_ptr/shared_ptr.htm">http://www.boost.org/doc/libs/1_40_0/libs/smart_ptr/shared_ptr.htm</a>) and also part of the
<a class="reference external" href="http://en.wikipedia.org/wiki/C++0x">C++0x</a> standard.</p>
<p>This class provides the following options:</p>
<ul class="simple">
<li>Default constructor, copy constructor, and assignment operator for an arbitrary C++ class
or a C structure. For some objects, like files, windows, mutexes, sockets, and others, a copy
constructor or an assignment operator are difficult to define. For some other objects, like
complex classifiers in OpenCV, copy constructors are absent and not easy to implement. Finally,
some of complex OpenCV and your own data structures may be written in C.
However, copy constructors and default constructors can simplify programming a lot.Besides,
they are often required (for example, by STL containers). By wrapping a pointer to such a
complex object <code class="docutils literal"><span class="pre">TObj</span></code> to <code class="docutils literal"><span class="pre">Ptr&lt;TObj&gt;</span></code>, you automatically get all of the necessary
constructors and the assignment operator.</li>
<li><em>O(1)</em> complexity of the above-mentioned operations. While some structures, like <code class="docutils literal"><span class="pre">std::vector</span></code>,
provide a copy constructor and an assignment operator, the operations may take a considerable
amount of time if the data structures are large. But if the structures are put into <code class="docutils literal"><span class="pre">Ptr&lt;&gt;</span></code>,
the overhead is small and independent of the data size.</li>
<li>Automatic destruction, even for C structures. See the example below with <code class="docutils literal"><span class="pre">FILE*</span></code>.</li>
<li>Heterogeneous collections of objects. The standard STL and most other C++ and OpenCV containers
can store only objects of the same type and the same size. The classical solution to store objects
of different types in the same container is to store pointers to the base class <code class="docutils literal"><span class="pre">base_class_t*</span></code>
instead but then you loose the automatic memory management. Again, by using <code class="docutils literal"><span class="pre">Ptr&lt;base_class_t&gt;()</span></code>
instead of the raw pointers, you can solve the problem.</li>
</ul>
<p>The <code class="docutils literal"><span class="pre">Ptr</span></code> class treats the wrapped object as a black box. The reference counter is allocated and
managed separately. The only thing the pointer class needs to know about the object is how to
deallocate it. This knowledge is encapsulated in the <code class="docutils literal"><span class="pre">Ptr::delete_obj()</span></code> method that is called when
the reference counter becomes 0. If the object is a C++ class instance, no additional coding is
needed, because the default implementation of this method calls <code class="docutils literal"><span class="pre">delete</span> <span class="pre">obj;</span></code>. However, if the
object is deallocated in a different way, the specialized method should be created. For example,
if you want to wrap <code class="docutils literal"><span class="pre">FILE</span></code>, the <code class="docutils literal"><span class="pre">delete_obj</span></code> may be implemented as follows:</p>
<div class="highlight-cpp"><div class="highlight"><pre><span class="k">template</span><span class="o">&lt;&gt;</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="n">Ptr</span><span class="o">&lt;</span><span class="kt">FILE</span><span class="o">&gt;::</span><span class="n">delete_obj</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">fclose</span><span class="p">(</span><span class="n">obj</span><span class="p">);</span> <span class="c1">// no need to clear the pointer afterwards,</span>
                 <span class="c1">// it is done externally.</span>
<span class="p">}</span>
<span class="p">...</span>

<span class="c1">// now use it:</span>
<span class="n">Ptr</span><span class="o">&lt;</span><span class="kt">FILE</span><span class="o">&gt;</span> <span class="n">f</span><span class="p">(</span><span class="n">fopen</span><span class="p">(</span><span class="s">&quot;myfile.txt&quot;</span><span class="p">,</span> <span class="s">&quot;r&quot;</span><span class="p">));</span>
<span class="k">if</span><span class="p">(</span><span class="n">f</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span>
    <span class="k">throw</span> <span class="p">...;</span>
<span class="n">fprintf</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="p">....);</span>
<span class="p">...</span>
<span class="c1">// the file will be closed automatically by the Ptr&lt;FILE&gt; destructor.</span>
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The reference increment/decrement operations are implemented as atomic operations,
and therefore it is normally safe to use the classes in multi-threaded applications.
The same is true for <a class="reference internal" href="#Mat" title="class Mat"><code class="xref ocv ocv-class docutils literal"><span class="pre">Mat</span></code></a> and other C++ OpenCV classes that operate on
the reference counters.</p>
</div>
</div>
<div class="section" id="ptr-ptr">
<h2>Ptr::Ptr<a class="headerlink" href="#ptr-ptr" title="Permalink to this headline">¶</a></h2>
<p>Various Ptr constructors.</p>
<dl class="function">
<dt id="Ptr::Ptr()">
<strong>C++:</strong><code class="descname"> </code> <code class="descclassname">Ptr::</code><code class="descname">Ptr</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#Ptr::Ptr()" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="Ptr::Ptr(_Tp* _obj)">
<strong>C++:</strong><code class="descname"> </code> <code class="descclassname">Ptr::</code><code class="descname">Ptr</code><span class="sig-paren">(</span>_Tp* <strong>_obj</strong><span class="sig-paren">)</span><a class="headerlink" href="#Ptr::Ptr(_Tp* _obj)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="Ptr::Ptr(const Ptr&amp; ptr)">
<strong>C++:</strong><code class="descname"> </code> <code class="descclassname">Ptr::</code><code class="descname">Ptr</code><span class="sig-paren">(</span>const Ptr&amp; <strong>ptr</strong><span class="sig-paren">)</span><a class="headerlink" href="#Ptr::Ptr(const Ptr& ptr)" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>_obj</strong> &#8211; Object for copy.</li>
<li><strong>ptr</strong> &#8211; Object for copy.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="id2">
<h2>Ptr::~Ptr<a class="headerlink" href="#id2" title="Permalink to this headline">¶</a></h2>
<p>The Ptr destructor.</p>
<dl class="function">
<dt id="Ptr::~Ptr()">
<strong>C++:</strong><code class="descname"> </code> <code class="descclassname">Ptr::</code><code class="descname">~Ptr</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#Ptr::~Ptr()" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</div>
<div class="section" id="ptr-operator">
<h2>Ptr::operator =<a class="headerlink" href="#ptr-operator" title="Permalink to this headline">¶</a></h2>
<p>Assignment operator.</p>
<dl class="function">
<dt id="Ptr&amp; Ptr::operator = (const Ptr&amp; ptr)">
<strong>C++:</strong><code class="descname"> </code>Ptr&amp; <code class="descclassname">Ptr::</code><code class="descname">operator=</code><span class="sig-paren">(</span>const Ptr&amp; <strong>ptr</strong><span class="sig-paren">)</span><a class="headerlink" href="#Ptr& Ptr::operator = (const Ptr& ptr)" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>ptr</strong> &#8211; Object for assignment.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<p>Decrements own reference counter (with <code class="docutils literal"><span class="pre">release()</span></code>) and increments ptr&#8217;s reference counter.</p>
</div>
<div class="section" id="ptr-addref">
<h2>Ptr::addref<a class="headerlink" href="#ptr-addref" title="Permalink to this headline">¶</a></h2>
<p>Increments reference counter.</p>
<dl class="function">
<dt id="void Ptr::addref()">
<strong>C++:</strong><code class="descname"> </code>void <code class="descclassname">Ptr::</code><code class="descname">addref</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#void Ptr::addref()" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</div>
<div class="section" id="ptr-release">
<h2>Ptr::release<a class="headerlink" href="#ptr-release" title="Permalink to this headline">¶</a></h2>
<p>Decrements reference counter; when it becomes 0, <code class="docutils literal"><span class="pre">delete_obj()</span></code> is called.</p>
<dl class="function">
<dt id="void Ptr::release()">
<strong>C++:</strong><code class="descname"> </code>void <code class="descclassname">Ptr::</code><code class="descname">release</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#void Ptr::release()" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</div>
<div class="section" id="ptr-delete-obj">
<h2>Ptr::delete_obj<a class="headerlink" href="#ptr-delete-obj" title="Permalink to this headline">¶</a></h2>
<p>User-specified custom object deletion operation. By default, <code class="docutils literal"><span class="pre">delete</span> <span class="pre">obj;</span></code> is called.</p>
<dl class="function">
<dt id="void Ptr::delete_obj()">
<strong>C++:</strong><code class="descname"> </code>void <code class="descclassname">Ptr::</code><code class="descname">delete_obj</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#void Ptr::delete_obj()" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</div>
<div class="section" id="ptr-empty">
<h2>Ptr::empty<a class="headerlink" href="#ptr-empty" title="Permalink to this headline">¶</a></h2>
<p>Returns true if obj == 0;</p>
<p>bool empty() const;</p>
</div>
<div class="section" id="id3">
<h2>Ptr::operator -&gt;<a class="headerlink" href="#id3" title="Permalink to this headline">¶</a></h2>
<p>Provide access to the object fields and methods.</p>
<dl class="function">
<dt id="template&lt;typename _Tp&gt; _Tp* Ptr::operator -&gt; ()">
<strong>C++:</strong><code class="descname"> </code>template&lt;typename _Tp&gt; _Tp* <code class="descclassname">Ptr::</code><code class="descname">operator-&gt;</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#template<typename _Tp> _Tp* Ptr::operator -> ()" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="template&lt;typename _Tp&gt; const _Tp* Ptr::operator -&gt; () const">
<strong>C++:</strong><code class="descname"> </code>template&lt;typename _Tp&gt; const _Tp* <code class="descclassname">Ptr::</code><code class="descname">operator-&gt;</code><span class="sig-paren">(</span><span class="sig-paren">)</span><code class="descclassname"> const</code><a class="headerlink" href="#template<typename _Tp> const _Tp* Ptr::operator -> () const" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</div>
<div class="section" id="ptr-operator-tp">
<h2>Ptr::operator _Tp*<a class="headerlink" href="#ptr-operator-tp" title="Permalink to this headline">¶</a></h2>
<p>Returns the underlying object pointer. Thanks to the methods, the <code class="docutils literal"><span class="pre">Ptr&lt;_Tp&gt;</span></code> can be used instead
of <code class="docutils literal"><span class="pre">_Tp*</span></code>.</p>
<dl class="function">
<dt id="template&lt;typename _Tp&gt; Ptr::operator _Tp* ()">
<strong>C++:</strong><code class="descname"> </code> <code class="descname">template&lt;typename _Tp&gt; Ptr::operator _Tp*</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#template<typename _Tp> Ptr::operator _Tp* ()" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="template&lt;typename _Tp&gt; Ptr::operator const _Tp*() const">
<strong>C++:</strong><code class="descname"> </code> <code class="descname">template&lt;typename _Tp&gt; Ptr::operator const _Tp*</code><span class="sig-paren">(</span><span class="sig-paren">)</span><code class="descclassname"> const</code><a class="headerlink" href="#template<typename _Tp> Ptr::operator const _Tp*() const" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</div>
<div class="section" id="mat">
<h2>Mat<a class="headerlink" href="#mat" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="Mat">
<em class="property">class </em><code class="descname">Mat</code><a class="headerlink" href="#Mat" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p>OpenCV C++ n-dimensional dense array class</p>
<div class="highlight-cpp"><div class="highlight"><pre><span class="k">class</span> <span class="nc">CV_EXPORTS</span> <span class="n">Mat</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="c1">// ... a lot of methods ...</span>
    <span class="p">...</span>

    <span class="cm">/*! includes several bit-fields:</span>
<span class="cm">         - the magic signature</span>
<span class="cm">         - continuity flag</span>
<span class="cm">         - depth</span>
<span class="cm">         - number of channels</span>
<span class="cm">     */</span>
    <span class="kt">int</span> <span class="n">flags</span><span class="p">;</span>
    <span class="c1">//! the array dimensionality, &gt;= 2</span>
    <span class="kt">int</span> <span class="n">dims</span><span class="p">;</span>
    <span class="c1">//! the number of rows and columns or (-1, -1) when the array has more than 2 dimensions</span>
    <span class="kt">int</span> <span class="n">rows</span><span class="p">,</span> <span class="n">cols</span><span class="p">;</span>
    <span class="c1">//! pointer to the data</span>
    <span class="n">uchar</span><span class="o">*</span> <span class="n">data</span><span class="p">;</span>

    <span class="c1">//! pointer to the reference counter;</span>
    <span class="c1">// when array points to user-allocated data, the pointer is NULL</span>
    <span class="kt">int</span><span class="o">*</span> <span class="n">refcount</span><span class="p">;</span>

    <span class="c1">// other members</span>
    <span class="p">...</span>
<span class="p">};</span>
</pre></div>
</div>
<p>The class <code class="docutils literal"><span class="pre">Mat</span></code> represents an n-dimensional dense numerical single-channel or multi-channel array. It can be used to store real or complex-valued vectors and matrices, grayscale or color images, voxel volumes, vector fields, point clouds, tensors, histograms (though, very high-dimensional histograms may be better stored in a <code class="docutils literal"><span class="pre">SparseMat</span></code> ). The data layout of the array
<img class="math" src="../../../_images/math/336950fdbecc1771997c5eb48994a4b7056f3b81.png" alt="M"/> is defined by the array <code class="docutils literal"><span class="pre">M.step[]</span></code>, so that the address of element
<img class="math" src="../../../_images/math/c0d5a8ad7b449b96f27970b6fc676b5f57e5e4d7.png" alt="(i_0,...,i_{M.dims-1})"/>, where
<img class="math" src="../../../_images/math/0a2f9d643bf7d178dd17f0205812cb00370fc812.png" alt="0\leq i_k&lt;M.size[k]"/>, is computed as:</p>
<div class="math">
<p><img src="../../../_images/math/02e09c666c056a455711d9780308622713b19564.png" alt="addr(M_{i_0,...,i_{M.dims-1}}) = M.data + M.step[0]*i_0 + M.step[1]*i_1 + ... + M.step[M.dims-1]*i_{M.dims-1}"/></p>
</div><p>In case of a 2-dimensional array, the above formula is reduced to:</p>
<div class="math">
<p><img src="../../../_images/math/17192416401bd8aab16de64c8467641e39f972c7.png" alt="addr(M_{i,j}) = M.data + M.step[0]*i + M.step[1]*j"/></p>
</div><p>Note that <code class="docutils literal"><span class="pre">M.step[i]</span> <span class="pre">&gt;=</span> <span class="pre">M.step[i+1]</span></code> (in fact, <code class="docutils literal"><span class="pre">M.step[i]</span> <span class="pre">&gt;=</span> <span class="pre">M.step[i+1]*M.size[i+1]</span></code> ). This means that 2-dimensional matrices are stored row-by-row, 3-dimensional matrices are stored plane-by-plane, and so on. <code class="docutils literal"><span class="pre">M.step[M.dims-1]</span></code> is minimal and always equal to the element size <code class="docutils literal"><span class="pre">M.elemSize()</span></code> .</p>
<p>So, the data layout in <code class="docutils literal"><span class="pre">Mat</span></code> is fully compatible with <code class="docutils literal"><span class="pre">CvMat</span></code>, <code class="docutils literal"><span class="pre">IplImage</span></code>, and <code class="docutils literal"><span class="pre">CvMatND</span></code> types from OpenCV 1.x. It is also compatible with the majority of dense array types from the standard toolkits and SDKs, such as Numpy (ndarray), Win32 (independent device bitmaps), and others, that is, with any array that uses <em>steps</em> (or <em>strides</em>) to compute the position of a pixel. Due to this compatibility, it is possible to make a <code class="docutils literal"><span class="pre">Mat</span></code> header for user-allocated data and process it in-place using OpenCV functions.</p>
<p>There are many different ways to create a <code class="docutils literal"><span class="pre">Mat</span></code> object. The most popular options are listed below:</p>
<ul>
<li><p class="first">Use the <code class="docutils literal"><span class="pre">create(nrows,</span> <span class="pre">ncols,</span> <span class="pre">type)</span></code>   method or the similar <code class="docutils literal"><span class="pre">Mat(nrows,</span> <span class="pre">ncols,</span> <span class="pre">type[,</span> <span class="pre">fillValue])</span></code>     constructor. A new array of the specified size and type is allocated. <code class="docutils literal"><span class="pre">type</span></code>     has the same meaning as in the <code class="docutils literal"><span class="pre">cvCreateMat</span></code>     method.
For example, <code class="docutils literal"><span class="pre">CV_8UC1</span></code>     means a 8-bit single-channel array, <code class="docutils literal"><span class="pre">CV_32FC2</span></code>     means a 2-channel (complex) floating-point array, and so on.</p>
<div class="highlight-cpp"><div class="highlight"><pre><span class="c1">// make a 7x7 complex matrix filled with 1+3j.</span>
<span class="n">Mat</span> <span class="nf">M</span><span class="p">(</span><span class="mi">7</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="n">CV_32FC2</span><span class="p">,</span><span class="n">Scalar</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">));</span>
<span class="c1">// and now turn M to a 100x60 15-channel 8-bit matrix.</span>
<span class="c1">// The old content will be deallocated</span>
<span class="n">M</span><span class="p">.</span><span class="n">create</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span><span class="mi">60</span><span class="p">,</span><span class="n">CV_8UC</span><span class="p">(</span><span class="mi">15</span><span class="p">));</span>
</pre></div>
</div>
<p>As noted in the introduction to this chapter, <code class="docutils literal"><span class="pre">create()</span></code> allocates only  a new array when the shape or type of the current array are different from the specified ones.</p>
</li>
<li><p class="first">Create a multi-dimensional array:</p>
<div class="highlight-cpp"><div class="highlight"><pre><span class="c1">// create a 100x100x100 8-bit array</span>
<span class="kt">int</span> <span class="n">sz</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">100</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">100</span><span class="p">};</span>
<span class="n">Mat</span> <span class="nf">bigCube</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">sz</span><span class="p">,</span> <span class="n">CV_8U</span><span class="p">,</span> <span class="n">Scalar</span><span class="o">::</span><span class="n">all</span><span class="p">(</span><span class="mi">0</span><span class="p">));</span>
</pre></div>
</div>
<p>It passes the number of dimensions =1 to the <code class="docutils literal"><span class="pre">Mat</span></code> constructor but the created array will be 2-dimensional with the number of columns set to 1. So, <code class="docutils literal"><span class="pre">Mat::dims</span></code>     is always &gt;= 2 (can also be 0 when the array is empty).</p>
</li>
<li><p class="first">Use a copy constructor or assignment operator where there can be an array or expression on the right side (see below). As noted in the introduction, the array assignment is an O(1) operation because it only copies the header and increases the reference counter. The <code class="docutils literal"><span class="pre">Mat::clone()</span></code>     method can be used to get a full (deep) copy of the array when you need it.</p>
</li>
<li><p class="first">Construct a header for a part of another array. It can be a single row, single column, several rows, several columns, rectangular region in the array (called a <em>minor</em> in algebra) or a diagonal. Such operations are also O(1) because the new header references the same data. You can actually modify a part of the array using this feature, for example:</p>
<div class="highlight-cpp"><div class="highlight"><pre><span class="c1">// add the 5-th row, multiplied by 3 to the 3rd row</span>
<span class="n">M</span><span class="p">.</span><span class="n">row</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span> <span class="o">=</span> <span class="n">M</span><span class="p">.</span><span class="n">row</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span> <span class="o">+</span> <span class="n">M</span><span class="p">.</span><span class="n">row</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span><span class="o">*</span><span class="mi">3</span><span class="p">;</span>

<span class="c1">// now copy the 7-th column to the 1-st column</span>
<span class="c1">// M.col(1) = M.col(7); // this will not work</span>
<span class="n">Mat</span> <span class="n">M1</span> <span class="o">=</span> <span class="n">M</span><span class="p">.</span><span class="n">col</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
<span class="n">M</span><span class="p">.</span><span class="n">col</span><span class="p">(</span><span class="mi">7</span><span class="p">).</span><span class="n">copyTo</span><span class="p">(</span><span class="n">M1</span><span class="p">);</span>

<span class="c1">// create a new 320x240 image</span>
<span class="n">Mat</span> <span class="nf">img</span><span class="p">(</span><span class="n">Size</span><span class="p">(</span><span class="mi">320</span><span class="p">,</span><span class="mi">240</span><span class="p">),</span><span class="n">CV_8UC3</span><span class="p">);</span>
<span class="c1">// select a ROI</span>
<span class="n">Mat</span> <span class="nf">roi</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">Rect</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="mi">10</span><span class="p">,</span><span class="mi">100</span><span class="p">,</span><span class="mi">100</span><span class="p">));</span>
<span class="c1">// fill the ROI with (0,255,0) (which is green in RGB space);</span>
<span class="c1">// the original 320x240 image will be modified</span>
<span class="n">roi</span> <span class="o">=</span> <span class="n">Scalar</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">255</span><span class="p">,</span><span class="mi">0</span><span class="p">);</span>
</pre></div>
</div>
<p>Due to the additional <code class="docutils literal"><span class="pre">datastart</span></code> and <code class="docutils literal"><span class="pre">dataend</span></code> members, it is possible to compute a relative sub-array position in the main <em>container</em> array using <code class="docutils literal"><span class="pre">locateROI()</span></code>:</p>
<div class="highlight-cpp"><div class="highlight"><pre><span class="n">Mat</span> <span class="n">A</span> <span class="o">=</span> <span class="n">Mat</span><span class="o">::</span><span class="n">eye</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="n">CV_32S</span><span class="p">);</span>
<span class="c1">// extracts A columns, 1 (inclusive) to 3 (exclusive).</span>
<span class="n">Mat</span> <span class="n">B</span> <span class="o">=</span> <span class="n">A</span><span class="p">(</span><span class="n">Range</span><span class="o">::</span><span class="n">all</span><span class="p">(),</span> <span class="n">Range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">));</span>
<span class="c1">// extracts B rows, 5 (inclusive) to 9 (exclusive).</span>
<span class="c1">// that is, C ~ A(Range(5, 9), Range(1, 3))</span>
<span class="n">Mat</span> <span class="n">C</span> <span class="o">=</span> <span class="n">B</span><span class="p">(</span><span class="n">Range</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">9</span><span class="p">),</span> <span class="n">Range</span><span class="o">::</span><span class="n">all</span><span class="p">());</span>
<span class="n">Size</span> <span class="n">size</span><span class="p">;</span> <span class="n">Point</span> <span class="n">ofs</span><span class="p">;</span>
<span class="n">C</span><span class="p">.</span><span class="n">locateROI</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="n">ofs</span><span class="p">);</span>
<span class="c1">// size will be (width=10,height=10) and the ofs will be (x=1, y=5)</span>
</pre></div>
</div>
<p>As in case of whole matrices, if you need a deep copy, use the <code class="docutils literal"><span class="pre">clone()</span></code> method of the extracted sub-matrices.</p>
</li>
<li><p class="first">Make a header for user-allocated data. It can be useful to do the following:</p>
<ol class="arabic">
<li><p class="first">Process &#8220;foreign&#8221; data using OpenCV (for example, when you implement a DirectShow* filter or a processing module for <code class="docutils literal"><span class="pre">gstreamer</span></code>, and so on). For example:</p>
<div class="highlight-cpp"><div class="highlight"><pre><span class="kt">void</span> <span class="nf">process_video_frame</span><span class="p">(</span><span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">char</span><span class="o">*</span> <span class="n">pixels</span><span class="p">,</span>
                         <span class="kt">int</span> <span class="n">width</span><span class="p">,</span> <span class="kt">int</span> <span class="n">height</span><span class="p">,</span> <span class="kt">int</span> <span class="n">step</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">Mat</span> <span class="n">img</span><span class="p">(</span><span class="n">height</span><span class="p">,</span> <span class="n">width</span><span class="p">,</span> <span class="n">CV_8UC3</span><span class="p">,</span> <span class="n">pixels</span><span class="p">,</span> <span class="n">step</span><span class="p">);</span>
    <span class="n">GaussianBlur</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">img</span><span class="p">,</span> <span class="n">Size</span><span class="p">(</span><span class="mi">7</span><span class="p">,</span><span class="mi">7</span><span class="p">),</span> <span class="mf">1.5</span><span class="p">,</span> <span class="mf">1.5</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
</li>
<li><p class="first">Quickly initialize small matrices and/or get a super-fast element access.</p>
<div class="highlight-cpp"><div class="highlight"><pre><span class="kt">double</span> <span class="n">m</span><span class="p">[</span><span class="mi">3</span><span class="p">][</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="p">{{</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">},</span> <span class="p">{</span><span class="n">d</span><span class="p">,</span> <span class="n">e</span><span class="p">,</span> <span class="n">f</span><span class="p">},</span> <span class="p">{</span><span class="n">g</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="n">i</span><span class="p">}};</span>
<span class="n">Mat</span> <span class="n">M</span> <span class="o">=</span> <span class="n">Mat</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="n">CV_64F</span><span class="p">,</span> <span class="n">m</span><span class="p">).</span><span class="n">inv</span><span class="p">();</span>
</pre></div>
</div>
</li>
</ol>
<p>Partial yet very common cases of this <em>user-allocated data</em> case are conversions from <code class="docutils literal"><span class="pre">CvMat</span></code> and <code class="docutils literal"><span class="pre">IplImage</span></code> to <code class="docutils literal"><span class="pre">Mat</span></code>. For this purpose, there are special constructors taking pointers to <code class="docutils literal"><span class="pre">CvMat</span></code>     or <code class="docutils literal"><span class="pre">IplImage</span></code> and the optional flag indicating whether to copy the data or not.</p>
<blockquote>
<div><p>Backward conversion from <code class="docutils literal"><span class="pre">Mat</span></code> to <code class="docutils literal"><span class="pre">CvMat</span></code> or <code class="docutils literal"><span class="pre">IplImage</span></code> is provided via cast operators <code class="docutils literal"><span class="pre">Mat::operator</span> <span class="pre">CvMat()</span> <span class="pre">const</span></code> and <code class="docutils literal"><span class="pre">Mat::operator</span> <span class="pre">IplImage()</span></code>. The operators do NOT copy the data.</p>
</div></blockquote>
<div class="highlight-cpp"><div class="highlight"><pre><span class="n">IplImage</span><span class="o">*</span> <span class="n">img</span> <span class="o">=</span> <span class="n">cvLoadImage</span><span class="p">(</span><span class="s">&quot;greatwave.jpg&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
<span class="n">Mat</span> <span class="nf">mtx</span><span class="p">(</span><span class="n">img</span><span class="p">);</span> <span class="c1">// convert IplImage* -&gt; Mat</span>
<span class="n">CvMat</span> <span class="n">oldmat</span> <span class="o">=</span> <span class="n">mtx</span><span class="p">;</span> <span class="c1">// convert Mat -&gt; CvMat</span>
<span class="n">CV_Assert</span><span class="p">(</span><span class="n">oldmat</span><span class="p">.</span><span class="n">cols</span> <span class="o">==</span> <span class="n">img</span><span class="o">-&gt;</span><span class="n">width</span> <span class="o">&amp;&amp;</span> <span class="n">oldmat</span><span class="p">.</span><span class="n">rows</span> <span class="o">==</span> <span class="n">img</span><span class="o">-&gt;</span><span class="n">height</span> <span class="o">&amp;&amp;</span>
    <span class="n">oldmat</span><span class="p">.</span><span class="n">data</span><span class="p">.</span><span class="n">ptr</span> <span class="o">==</span> <span class="p">(</span><span class="n">uchar</span><span class="o">*</span><span class="p">)</span><span class="n">img</span><span class="o">-&gt;</span><span class="n">imageData</span> <span class="o">&amp;&amp;</span> <span class="n">oldmat</span><span class="p">.</span><span class="n">step</span> <span class="o">==</span> <span class="n">img</span><span class="o">-&gt;</span><span class="n">widthStep</span><span class="p">);</span>
</pre></div>
</div>
</li>
<li><p class="first">Use MATLAB-style array initializers, <code class="docutils literal"><span class="pre">zeros(),</span> <span class="pre">ones(),</span> <span class="pre">eye()</span></code>, for example:</p>
<div class="highlight-cpp"><div class="highlight"><pre><span class="c1">// create a double-precision identity martix and add it to M.</span>
<span class="n">M</span> <span class="o">+=</span> <span class="n">Mat</span><span class="o">::</span><span class="n">eye</span><span class="p">(</span><span class="n">M</span><span class="p">.</span><span class="n">rows</span><span class="p">,</span> <span class="n">M</span><span class="p">.</span><span class="n">cols</span><span class="p">,</span> <span class="n">CV_64F</span><span class="p">);</span>
</pre></div>
</div>
</li>
<li><p class="first">Use a comma-separated initializer:</p>
<div class="highlight-cpp"><div class="highlight"><pre><span class="c1">// create a 3x3 double-precision identity matrix</span>
<span class="n">Mat</span> <span class="n">M</span> <span class="o">=</span> <span class="p">(</span><span class="n">Mat_</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
</pre></div>
</div>
<p>With this approach, you first call a constructor of the <a class="reference internal" href="#Mat_" title="class Mat_"><code class="xref ocv ocv-class docutils literal"><span class="pre">Mat_</span></code></a>  class with the proper parameters, and then you just put <code class="docutils literal"><span class="pre">&lt;&lt;</span></code>     operator followed by comma-separated values that can be constants, variables, expressions, and so on. Also, note the extra parentheses required to avoid compilation errors.</p>
</li>
</ul>
<p>Once the array is created, it is automatically managed via a reference-counting mechanism. If the array header is built on top of user-allocated data, you should handle the data by yourself.
The array data is deallocated when no one points to it. If you want to release the data pointed by a array header before the array destructor is called, use <code class="docutils literal"><span class="pre">Mat::release()</span></code> .</p>
<p>The next important thing to learn about the array class is element access. This manual already described how to compute an address of each array element. Normally, you are not required to use the formula directly in the code. If you know the array element type (which can be retrieved using the method <code class="docutils literal"><span class="pre">Mat::type()</span></code> ), you can access the element
<img class="math" src="../../../_images/math/07c5e1d5bb944623924cbae88bd5261eb9930011.png" alt="M_{ij}"/> of a 2-dimensional array as:</p>
<div class="highlight-cpp"><div class="highlight"><pre><span class="n">M</span><span class="p">.</span><span class="n">at</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">)</span> <span class="o">+=</span> <span class="mf">1.f</span><span class="p">;</span>
</pre></div>
</div>
<p>assuming that M is a double-precision floating-point array. There are several variants of the method <code class="docutils literal"><span class="pre">at</span></code> for a different number of dimensions.</p>
<p>If you need to process a whole row of a 2D array, the most efficient way is to get the pointer to the row first, and then just use the plain C operator <code class="docutils literal"><span class="pre">[]</span></code> :</p>
<div class="highlight-cpp"><div class="highlight"><pre><span class="c1">// compute sum of positive matrix elements</span>
<span class="c1">// (assuming that M isa double-precision matrix)</span>
<span class="kt">double</span> <span class="n">sum</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
<span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">M</span><span class="p">.</span><span class="n">rows</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">const</span> <span class="kt">double</span><span class="o">*</span> <span class="n">Mi</span> <span class="o">=</span> <span class="n">M</span><span class="p">.</span><span class="n">ptr</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">M</span><span class="p">.</span><span class="n">cols</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span>
        <span class="n">sum</span> <span class="o">+=</span> <span class="n">std</span><span class="o">::</span><span class="n">max</span><span class="p">(</span><span class="n">Mi</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="mf">0.</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Some operations, like the one above, do not actually depend on the array shape. They just process elements of an array one by one (or elements from multiple arrays that have the same coordinates, for example, array addition). Such operations are called <em>element-wise</em>. It makes sense to check whether all the input/output arrays are continuous, namely, have no gaps at the end of each row. If yes, process them as a long single row:</p>
<div class="highlight-cpp"><div class="highlight"><pre><span class="c1">// compute the sum of positive matrix elements, optimized variant</span>
<span class="kt">double</span> <span class="n">sum</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">cols</span> <span class="o">=</span> <span class="n">M</span><span class="p">.</span><span class="n">cols</span><span class="p">,</span> <span class="n">rows</span> <span class="o">=</span> <span class="n">M</span><span class="p">.</span><span class="n">rows</span><span class="p">;</span>
<span class="k">if</span><span class="p">(</span><span class="n">M</span><span class="p">.</span><span class="n">isContinuous</span><span class="p">())</span>
<span class="p">{</span>
    <span class="n">cols</span> <span class="o">*=</span> <span class="n">rows</span><span class="p">;</span>
    <span class="n">rows</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">rows</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">const</span> <span class="kt">double</span><span class="o">*</span> <span class="n">Mi</span> <span class="o">=</span> <span class="n">M</span><span class="p">.</span><span class="n">ptr</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">cols</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span>
        <span class="n">sum</span> <span class="o">+=</span> <span class="n">std</span><span class="o">::</span><span class="n">max</span><span class="p">(</span><span class="n">Mi</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="mf">0.</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>In case of the continuous matrix, the outer loop body is executed just once. So, the overhead is smaller, which is especially noticeable in case of small matrices.</p>
<p>Finally, there are STL-style iterators that are smart enough to skip gaps between successive rows:</p>
<div class="highlight-cpp"><div class="highlight"><pre><span class="c1">// compute sum of positive matrix elements, iterator-based variant</span>
<span class="kt">double</span> <span class="n">sum</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
<span class="n">MatConstIterator_</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span> <span class="n">it</span> <span class="o">=</span> <span class="n">M</span><span class="p">.</span><span class="n">begin</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="p">(),</span> <span class="n">it_end</span> <span class="o">=</span> <span class="n">M</span><span class="p">.</span><span class="n">end</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="p">();</span>
<span class="k">for</span><span class="p">(;</span> <span class="n">it</span> <span class="o">!=</span> <span class="n">it_end</span><span class="p">;</span> <span class="o">++</span><span class="n">it</span><span class="p">)</span>
    <span class="n">sum</span> <span class="o">+=</span> <span class="n">std</span><span class="o">::</span><span class="n">max</span><span class="p">(</span><span class="o">*</span><span class="n">it</span><span class="p">,</span> <span class="mf">0.</span><span class="p">);</span>
</pre></div>
</div>
<p>The matrix iterators are random-access iterators, so they can be passed to any STL algorithm, including <code class="docutils literal"><span class="pre">std::sort()</span></code> .</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<ul class="last simple">
<li>An example demonstrating the serial out capabilities of cv::Mat can be found at opencv_source_code/samples/cpp/cout_mat.cpp</li>
</ul>
</div>
</div>
<div class="section" id="matrix-expressions">
<span id="matrixexpressions"></span><h2>Matrix Expressions<a class="headerlink" href="#matrix-expressions" title="Permalink to this headline">¶</a></h2>
<p>This is a list of implemented matrix operations that can be combined in arbitrary complex expressions
(here <code class="docutils literal"><span class="pre">A</span></code>, <code class="docutils literal"><span class="pre">B</span></code> stand for matrices ( <code class="docutils literal"><span class="pre">Mat</span></code> ), <code class="docutils literal"><span class="pre">s</span></code> for a scalar ( <code class="docutils literal"><span class="pre">Scalar</span></code> ),
<code class="docutils literal"><span class="pre">alpha</span></code> for a real-valued scalar ( <code class="docutils literal"><span class="pre">double</span></code> )):</p>
<ul>
<li><p class="first">Addition, subtraction, negation:
<code class="docutils literal"><span class="pre">A+B,</span> <span class="pre">A-B,</span> <span class="pre">A+s,</span> <span class="pre">A-s,</span> <span class="pre">s+A,</span> <span class="pre">s-A,</span> <span class="pre">-A</span></code></p>
</li>
<li><p class="first">Scaling:
<code class="docutils literal"><span class="pre">A*alpha</span></code></p>
</li>
<li><p class="first">Per-element multiplication and division:
<code class="docutils literal"><span class="pre">A.mul(B),</span> <span class="pre">A/B,</span> <span class="pre">alpha/A</span></code></p>
</li>
<li><p class="first">Matrix multiplication:
<code class="docutils literal"><span class="pre">A*B</span></code></p>
</li>
<li><p class="first">Transposition:
<code class="docutils literal"><span class="pre">A.t()</span></code> (means <code class="docutils literal"><span class="pre">A</span></code><sup>T</sup>)</p>
</li>
<li><p class="first">Matrix inversion and pseudo-inversion, solving linear systems and least-squares problems:</p>
<p><code class="docutils literal"><span class="pre">A.inv([method])</span></code> (~ <code class="docutils literal"><span class="pre">A</span></code><sup>-1</sup>) <code class="docutils literal"><span class="pre">,</span>&nbsp;&nbsp; <span class="pre">A.inv([method])*B</span></code> (~ <code class="docutils literal"><span class="pre">X:</span> <span class="pre">AX=B</span></code>)</p>
</li>
<li><p class="first">Comparison:
<code class="docutils literal"><span class="pre">A</span> <span class="pre">cmpop</span> <span class="pre">B,</span> <span class="pre">A</span> <span class="pre">cmpop</span> <span class="pre">alpha,</span> <span class="pre">alpha</span> <span class="pre">cmpop</span> <span class="pre">A</span></code>, where <code class="docutils literal"><span class="pre">cmpop</span></code> is one of <code class="docutils literal"><span class="pre">:</span>&nbsp; <span class="pre">&gt;,</span> <span class="pre">&gt;=,</span> <span class="pre">==,</span> <span class="pre">!=,</span> <span class="pre">&lt;=,</span> <span class="pre">&lt;</span></code>. The result of comparison is an 8-bit single channel mask whose elements are set to 255 (if the particular element or pair of elements satisfy the condition) or 0.</p>
</li>
<li><p class="first">Bitwise logical operations: <code class="docutils literal"><span class="pre">A</span> <span class="pre">logicop</span> <span class="pre">B,</span> <span class="pre">A</span> <span class="pre">logicop</span> <span class="pre">s,</span> <span class="pre">s</span> <span class="pre">logicop</span> <span class="pre">A,</span> <span class="pre">~A</span></code>, where <code class="docutils literal"><span class="pre">logicop</span></code> is one of <code class="docutils literal"><span class="pre">:</span>&nbsp; <span class="pre">&amp;,</span> <span class="pre">|,</span> <span class="pre">^</span></code>.</p>
</li>
<li><p class="first">Element-wise minimum and maximum:
<code class="docutils literal"><span class="pre">min(A,</span> <span class="pre">B),</span> <span class="pre">min(A,</span> <span class="pre">alpha),</span> <span class="pre">max(A,</span> <span class="pre">B),</span> <span class="pre">max(A,</span> <span class="pre">alpha)</span></code></p>
</li>
<li><p class="first">Element-wise absolute value:
<code class="docutils literal"><span class="pre">abs(A)</span></code></p>
</li>
<li><p class="first">Cross-product, dot-product:
<code class="docutils literal"><span class="pre">A.cross(B)</span></code>
<code class="docutils literal"><span class="pre">A.dot(B)</span></code></p>
</li>
<li><p class="first">Any function of matrix or matrices and scalars that returns a matrix or a scalar, such as <code class="docutils literal"><span class="pre">norm</span></code>, <code class="docutils literal"><span class="pre">mean</span></code>, <code class="docutils literal"><span class="pre">sum</span></code>, <code class="docutils literal"><span class="pre">countNonZero</span></code>, <code class="docutils literal"><span class="pre">trace</span></code>, <code class="docutils literal"><span class="pre">determinant</span></code>, <code class="docutils literal"><span class="pre">repeat</span></code>, and others.</p>
</li>
<li><p class="first">Matrix initializers ( <code class="docutils literal"><span class="pre">Mat::eye(),</span> <span class="pre">Mat::zeros(),</span> <span class="pre">Mat::ones()</span></code> ), matrix comma-separated initializers, matrix constructors and operators that extract sub-matrices (see <a class="reference internal" href="#Mat" title="class Mat"><code class="xref ocv ocv-class docutils literal"><span class="pre">Mat</span></code></a> description).</p>
</li>
<li><p class="first"><code class="docutils literal"><span class="pre">Mat_&lt;destination_type&gt;()</span></code> constructors to cast the result to the proper type.</p>
</li>
</ul>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Comma-separated initializers and probably some other operations may require additional explicit <code class="docutils literal"><span class="pre">Mat()</span></code> or <code class="docutils literal"><span class="pre">Mat_&lt;T&gt;()</span></code> constructor calls to resolve a possible ambiguity.</p>
</div>
<p>Here are examples of matrix expressions:</p>
<div class="highlight-cpp"><div class="highlight"><pre><span class="c1">// compute pseudo-inverse of A, equivalent to A.inv(DECOMP_SVD)</span>
<span class="n">SVD</span> <span class="nf">svd</span><span class="p">(</span><span class="n">A</span><span class="p">);</span>
<span class="n">Mat</span> <span class="n">pinvA</span> <span class="o">=</span> <span class="n">svd</span><span class="p">.</span><span class="n">vt</span><span class="p">.</span><span class="n">t</span><span class="p">()</span><span class="o">*</span><span class="n">Mat</span><span class="o">::</span><span class="n">diag</span><span class="p">(</span><span class="mf">1.</span><span class="o">/</span><span class="n">svd</span><span class="p">.</span><span class="n">w</span><span class="p">)</span><span class="o">*</span><span class="n">svd</span><span class="p">.</span><span class="n">u</span><span class="p">.</span><span class="n">t</span><span class="p">();</span>

<span class="c1">// compute the new vector of parameters in the Levenberg-Marquardt algorithm</span>
<span class="n">x</span> <span class="o">-=</span> <span class="p">(</span><span class="n">A</span><span class="p">.</span><span class="n">t</span><span class="p">()</span><span class="o">*</span><span class="n">A</span> <span class="o">+</span> <span class="n">lambda</span><span class="o">*</span><span class="n">Mat</span><span class="o">::</span><span class="n">eye</span><span class="p">(</span><span class="n">A</span><span class="p">.</span><span class="n">cols</span><span class="p">,</span><span class="n">A</span><span class="p">.</span><span class="n">cols</span><span class="p">,</span><span class="n">A</span><span class="p">.</span><span class="n">type</span><span class="p">())).</span><span class="n">inv</span><span class="p">(</span><span class="n">DECOMP_CHOLESKY</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">A</span><span class="p">.</span><span class="n">t</span><span class="p">()</span><span class="o">*</span><span class="n">err</span><span class="p">);</span>

<span class="c1">// sharpen image using &quot;unsharp mask&quot; algorithm</span>
<span class="n">Mat</span> <span class="n">blurred</span><span class="p">;</span> <span class="kt">double</span> <span class="n">sigma</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">threshold</span> <span class="o">=</span> <span class="mi">5</span><span class="p">,</span> <span class="n">amount</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="n">GaussianBlur</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">blurred</span><span class="p">,</span> <span class="n">Size</span><span class="p">(),</span> <span class="n">sigma</span><span class="p">,</span> <span class="n">sigma</span><span class="p">);</span>
<span class="n">Mat</span> <span class="n">lowConstrastMask</span> <span class="o">=</span> <span class="n">abs</span><span class="p">(</span><span class="n">img</span> <span class="o">-</span> <span class="n">blurred</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">threshold</span><span class="p">;</span>
<span class="n">Mat</span> <span class="n">sharpened</span> <span class="o">=</span> <span class="n">img</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="n">amount</span><span class="p">)</span> <span class="o">+</span> <span class="n">blurred</span><span class="o">*</span><span class="p">(</span><span class="o">-</span><span class="n">amount</span><span class="p">);</span>
<span class="n">img</span><span class="p">.</span><span class="n">copyTo</span><span class="p">(</span><span class="n">sharpened</span><span class="p">,</span> <span class="n">lowContrastMask</span><span class="p">);</span>
</pre></div>
</div>
<p>Below is the formal description of the <code class="docutils literal"><span class="pre">Mat</span></code> methods.</p>
</div>
<div class="section" id="mat-mat">
<h2>Mat::Mat<a class="headerlink" href="#mat-mat" title="Permalink to this headline">¶</a></h2>
<p>Various Mat constructors</p>
<dl class="function">
<dt id="Mat::Mat()">
<strong>C++:</strong><code class="descname"> </code> <code class="descclassname">Mat::</code><code class="descname">Mat</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#Mat::Mat()" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="Mat::Mat(int rows, int cols, int type)">
<strong>C++:</strong><code class="descname"> </code> <code class="descclassname">Mat::</code><code class="descname">Mat</code><span class="sig-paren">(</span>int <strong>rows</strong>, int <strong>cols</strong>, int <strong>type</strong><span class="sig-paren">)</span><a class="headerlink" href="#Mat::Mat(int rows, int cols, int type)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="Mat::Mat(Size size, int type)">
<strong>C++:</strong><code class="descname"> </code> <code class="descclassname">Mat::</code><code class="descname">Mat</code><span class="sig-paren">(</span>Size <strong>size</strong>, int <strong>type</strong><span class="sig-paren">)</span><a class="headerlink" href="#Mat::Mat(Size size, int type)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="Mat::Mat(int rows, int cols, int type, const Scalar&amp; s)">
<strong>C++:</strong><code class="descname"> </code> <code class="descclassname">Mat::</code><code class="descname">Mat</code><span class="sig-paren">(</span>int <strong>rows</strong>, int <strong>cols</strong>, int <strong>type</strong>, const Scalar&amp; <strong>s</strong><span class="sig-paren">)</span><a class="headerlink" href="#Mat::Mat(int rows, int cols, int type, const Scalar& s)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="Mat::Mat(Size size, int type, const Scalar&amp; s)">
<strong>C++:</strong><code class="descname"> </code> <code class="descclassname">Mat::</code><code class="descname">Mat</code><span class="sig-paren">(</span>Size <strong>size</strong>, int <strong>type</strong>, const Scalar&amp; <strong>s</strong><span class="sig-paren">)</span><a class="headerlink" href="#Mat::Mat(Size size, int type, const Scalar& s)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="Mat::Mat(const Mat&amp; m)">
<strong>C++:</strong><code class="descname"> </code> <code class="descclassname">Mat::</code><code class="descname">Mat</code><span class="sig-paren">(</span>const Mat&amp; <strong>m</strong><span class="sig-paren">)</span><a class="headerlink" href="#Mat::Mat(const Mat& m)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="Mat::Mat(int rows, int cols, int type, void* data, size_t step)">
<strong>C++:</strong><code class="descname"> </code> <code class="descclassname">Mat::</code><code class="descname">Mat</code><span class="sig-paren">(</span>int <strong>rows</strong>, int <strong>cols</strong>, int <strong>type</strong>, void* <strong>data</strong>, size_t <strong>step</strong>=AUTO_STEP<span class="sig-paren">)</span><a class="headerlink" href="#Mat::Mat(int rows, int cols, int type, void* data, size_t step)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="Mat::Mat(Size size, int type, void* data, size_t step)">
<strong>C++:</strong><code class="descname"> </code> <code class="descclassname">Mat::</code><code class="descname">Mat</code><span class="sig-paren">(</span>Size <strong>size</strong>, int <strong>type</strong>, void* <strong>data</strong>, size_t <strong>step</strong>=AUTO_STEP<span class="sig-paren">)</span><a class="headerlink" href="#Mat::Mat(Size size, int type, void* data, size_t step)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="Mat::Mat(const Mat&amp; m, const Range&amp; rowRange, const Range&amp; colRange)">
<strong>C++:</strong><code class="descname"> </code> <code class="descclassname">Mat::</code><code class="descname">Mat</code><span class="sig-paren">(</span>const Mat&amp; <strong>m</strong>, const Range&amp; <strong>rowRange</strong>, const Range&amp; <strong>colRange</strong>=Range::all() <span class="sig-paren">)</span><a class="headerlink" href="#Mat::Mat(const Mat& m, const Range& rowRange, const Range& colRange)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="Mat::Mat(const Mat&amp; m, const Rect&amp; roi)">
<strong>C++:</strong><code class="descname"> </code> <code class="descclassname">Mat::</code><code class="descname">Mat</code><span class="sig-paren">(</span>const Mat&amp; <strong>m</strong>, const Rect&amp; <strong>roi</strong><span class="sig-paren">)</span><a class="headerlink" href="#Mat::Mat(const Mat& m, const Rect& roi)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="Mat::Mat(const CvMat* m, bool copyData)">
<strong>C++:</strong><code class="descname"> </code> <code class="descclassname">Mat::</code><code class="descname">Mat</code><span class="sig-paren">(</span>const CvMat* <strong>m</strong>, bool <strong>copyData</strong>=false<span class="sig-paren">)</span><a class="headerlink" href="#Mat::Mat(const CvMat* m, bool copyData)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="Mat::Mat(const IplImage* img, bool copyData)">
<strong>C++:</strong><code class="descname"> </code> <code class="descclassname">Mat::</code><code class="descname">Mat</code><span class="sig-paren">(</span>const IplImage* <strong>img</strong>, bool <strong>copyData</strong>=false<span class="sig-paren">)</span><a class="headerlink" href="#Mat::Mat(const IplImage* img, bool copyData)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="template&lt;typename T, int n&gt; explicit Mat::Mat(const Vec&lt;T, n&gt;&amp; vec, bool copyData)">
<strong>C++:</strong><code class="descname"> </code>template&lt;typename T, int n&gt; explicit <code class="descclassname">Mat::</code><code class="descname">Mat</code><span class="sig-paren">(</span>const Vec&lt;T, n&gt;&amp; <strong>vec</strong>, bool <strong>copyData</strong>=true<span class="sig-paren">)</span><a class="headerlink" href="#template<typename T, int n> explicit Mat::Mat(const Vec<T, n>& vec, bool copyData)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="template&lt;typename T, int m, int n&gt; explicit Mat::Mat(const Matx&lt;T, m, n&gt;&amp; vec, bool copyData)">
<strong>C++:</strong><code class="descname"> </code>template&lt;typename T, int m, int n&gt; explicit <code class="descclassname">Mat::</code><code class="descname">Mat</code><span class="sig-paren">(</span>const Matx&lt;T, m, n&gt;&amp; <strong>vec</strong>, bool <strong>copyData</strong>=true<span class="sig-paren">)</span><a class="headerlink" href="#template<typename T, int m, int n> explicit Mat::Mat(const Matx<T, m, n>& vec, bool copyData)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="template&lt;typename T&gt; explicit Mat::Mat(const vector&lt;T&gt;&amp; vec, bool copyData)">
<strong>C++:</strong><code class="descname"> </code>template&lt;typename T&gt; explicit <code class="descclassname">Mat::</code><code class="descname">Mat</code><span class="sig-paren">(</span>const vector&lt;T&gt;&amp; <strong>vec</strong>, bool <strong>copyData</strong>=false<span class="sig-paren">)</span><a class="headerlink" href="#template<typename T> explicit Mat::Mat(const vector<T>& vec, bool copyData)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="Mat::Mat(int ndims, const int* sizes, int type)">
<strong>C++:</strong><code class="descname"> </code> <code class="descclassname">Mat::</code><code class="descname">Mat</code><span class="sig-paren">(</span>int <strong>ndims</strong>, const int* <strong>sizes</strong>, int <strong>type</strong><span class="sig-paren">)</span><a class="headerlink" href="#Mat::Mat(int ndims, const int* sizes, int type)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="Mat::Mat(int ndims, const int* sizes, int type, const Scalar&amp; s)">
<strong>C++:</strong><code class="descname"> </code> <code class="descclassname">Mat::</code><code class="descname">Mat</code><span class="sig-paren">(</span>int <strong>ndims</strong>, const int* <strong>sizes</strong>, int <strong>type</strong>, const Scalar&amp; <strong>s</strong><span class="sig-paren">)</span><a class="headerlink" href="#Mat::Mat(int ndims, const int* sizes, int type, const Scalar& s)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="Mat::Mat(int ndims, const int* sizes, int type, void* data, const size_t* steps)">
<strong>C++:</strong><code class="descname"> </code> <code class="descclassname">Mat::</code><code class="descname">Mat</code><span class="sig-paren">(</span>int <strong>ndims</strong>, const int* <strong>sizes</strong>, int <strong>type</strong>, void* <strong>data</strong>, const size_t* <strong>steps</strong>=0<span class="sig-paren">)</span><a class="headerlink" href="#Mat::Mat(int ndims, const int* sizes, int type, void* data, const size_t* steps)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="Mat::Mat(const Mat&amp; m, const Range* ranges)">
<strong>C++:</strong><code class="descname"> </code> <code class="descclassname">Mat::</code><code class="descname">Mat</code><span class="sig-paren">(</span>const Mat&amp; <strong>m</strong>, const Range* <strong>ranges</strong><span class="sig-paren">)</span><a class="headerlink" href="#Mat::Mat(const Mat& m, const Range* ranges)" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>ndims</strong> &#8211; Array dimensionality.</li>
<li><strong>rows</strong> &#8211; Number of rows in a 2D array.</li>
<li><strong>cols</strong> &#8211; Number of columns in a 2D array.</li>
<li><strong>roi</strong> &#8211; Region of interest.</li>
<li><strong>size</strong> &#8211; 2D array size:  <code class="docutils literal"><span class="pre">Size(cols,</span> <span class="pre">rows)</span></code> . In the  <code class="docutils literal"><span class="pre">Size()</span></code>  constructor, the number of rows and the number of columns go in the reverse order.</li>
<li><strong>sizes</strong> &#8211; Array of integers specifying an n-dimensional array shape.</li>
<li><strong>type</strong> &#8211; Array type. Use  <code class="docutils literal"><span class="pre">CV_8UC1,</span> <span class="pre">...,</span> <span class="pre">CV_64FC4</span></code>  to create 1-4 channel matrices, or  <code class="docutils literal"><span class="pre">CV_8UC(n),</span> <span class="pre">...,</span> <span class="pre">CV_64FC(n)</span></code>  to create multi-channel (up to  <code class="docutils literal"><span class="pre">CV_CN_MAX</span></code>  channels) matrices.</li>
<li><strong>s</strong> &#8211; An optional value to initialize each matrix element with. To set all the matrix elements to the particular value after the construction, use the assignment operator  <code class="docutils literal"><span class="pre">Mat::operator=(const</span> <span class="pre">Scalar&amp;</span> <span class="pre">value)</span></code> .</li>
<li><strong>data</strong> &#8211; Pointer to the user data. Matrix constructors that take  <code class="docutils literal"><span class="pre">data</span></code>  and  <code class="docutils literal"><span class="pre">step</span></code>  parameters do not allocate matrix data. Instead, they just initialize the matrix header that points to the specified data, which means that no data is copied. This operation is very efficient and can be used to process external data using OpenCV functions. The external data is not automatically deallocated, so you should take care of it.</li>
<li><strong>step</strong> &#8211; Number of bytes each matrix row occupies. The value should include the padding bytes at the end of each row, if any. If the parameter is missing (set to  <code class="docutils literal"><span class="pre">AUTO_STEP</span></code> ), no padding is assumed and the actual step is calculated as  <code class="docutils literal"><span class="pre">cols*elemSize()</span></code> . See  <a class="reference internal" href="#size_t Mat::elemSize() const" title="size_t Mat::elemSize() const"><code class="xref ocv ocv-func docutils literal"><span class="pre">Mat::elemSize()</span></code></a> .</li>
<li><strong>steps</strong> &#8211; Array of  <code class="docutils literal"><span class="pre">ndims-1</span></code>  steps in case of a multi-dimensional array (the last step is always set to the element size). If not specified, the matrix is assumed to be continuous.</li>
<li><strong>m</strong> &#8211; Array that (as a whole or partly) is assigned to the constructed matrix. No data is copied by these constructors. Instead, the header pointing to  <code class="docutils literal"><span class="pre">m</span></code>  data or its sub-array is constructed and associated with it. The reference counter, if any, is incremented. So, when you modify the matrix formed using such a constructor, you also modify the corresponding elements of  <code class="docutils literal"><span class="pre">m</span></code> . If you want to have an independent copy of the sub-array, use  <code class="docutils literal"><span class="pre">Mat::clone()</span></code> .</li>
<li><strong>img</strong> &#8211; Pointer to the old-style  <code class="docutils literal"><span class="pre">IplImage</span></code>  image structure. By default, the data is shared between the original image and the new matrix. But when  <code class="docutils literal"><span class="pre">copyData</span></code>  is set, the full copy of the image data is created.</li>
<li><strong>vec</strong> &#8211; STL vector whose elements form the matrix. The matrix has a single column and the number of rows equal to the number of vector elements. Type of the matrix matches the type of vector elements. The constructor can handle arbitrary types, for which there is a properly declared  <a class="reference internal" href="#DataType" title="class DataType"><code class="xref ocv ocv-class docutils literal"><span class="pre">DataType</span></code></a> . This means that the vector elements must be primitive numbers or uni-type numerical tuples of numbers. Mixed-type structures are not supported. The corresponding constructor is explicit. Since STL vectors are not automatically converted to  <code class="docutils literal"><span class="pre">Mat</span></code>  instances, you should write  <code class="docutils literal"><span class="pre">Mat(vec)</span></code>  explicitly. Unless you copy the data into the matrix ( <code class="docutils literal"><span class="pre">copyData=true</span></code> ), no new elements will be added to the vector because it can potentially yield vector data reallocation, and, thus, the matrix data pointer will be invalid.</li>
<li><strong>copyData</strong> &#8211; Flag to specify whether the underlying data of the STL vector or the old-style  <code class="docutils literal"><span class="pre">CvMat</span></code>  or  <code class="docutils literal"><span class="pre">IplImage</span></code>  should be copied to (<code class="docutils literal"><span class="pre">true</span></code>) or shared with (<code class="docutils literal"><span class="pre">false</span></code>) the newly constructed matrix. When the data is copied, the allocated buffer is managed using  <code class="docutils literal"><span class="pre">Mat</span></code> reference counting mechanism. While the data is shared, the reference counter is NULL, and you should not deallocate the data until the matrix is not destructed.</li>
<li><strong>rowRange</strong> &#8211; Range of the  <code class="docutils literal"><span class="pre">m</span></code> rows to take. As usual, the range start is inclusive and the range end is exclusive. Use  <code class="docutils literal"><span class="pre">Range::all()</span></code>  to take all the rows.</li>
<li><strong>colRange</strong> &#8211; Range of the  <code class="docutils literal"><span class="pre">m</span></code> columns to take. Use  <code class="docutils literal"><span class="pre">Range::all()</span></code>  to take all the columns.</li>
<li><strong>ranges</strong> &#8211; Array of selected ranges of  <code class="docutils literal"><span class="pre">m</span></code>  along each dimensionality.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<p>These are various constructors that form a matrix. As noted in the <a class="reference internal" href="intro.html#automaticallocation"><span>Automatic Allocation of the Output Data</span></a>,
often the default constructor is enough, and the proper matrix will be allocated by an OpenCV function. The constructed matrix can further be assigned to another matrix or matrix expression or can be allocated with
<a class="reference internal" href="#void Mat::create(int rows, int cols, int type)" title="void Mat::create(int rows, int cols, int type)"><code class="xref ocv ocv-func docutils literal"><span class="pre">Mat::create()</span></code></a> . In the former case, the old content is de-referenced.</p>
</div>
<div class="section" id="id4">
<h2>Mat::~Mat<a class="headerlink" href="#id4" title="Permalink to this headline">¶</a></h2>
<p>The Mat destructor.</p>
<dl class="function">
<dt id="Mat::~Mat()">
<strong>C++:</strong><code class="descname"> </code> <code class="descclassname">Mat::</code><code class="descname">~Mat</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#Mat::~Mat()" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p>The matrix destructor calls <a class="reference internal" href="#void Mat::release()" title="void Mat::release()"><code class="xref ocv ocv-func docutils literal"><span class="pre">Mat::release()</span></code></a> .</p>
</div>
<div class="section" id="mat-operator">
<h2>Mat::operator =<a class="headerlink" href="#mat-operator" title="Permalink to this headline">¶</a></h2>
<p>Provides matrix assignment operators.</p>
<dl class="function">
<dt id="Mat&amp; Mat::operator = (const Mat&amp; m)">
<strong>C++:</strong><code class="descname"> </code>Mat&amp; <code class="descclassname">Mat::</code><code class="descname">operator=</code><span class="sig-paren">(</span>const Mat&amp; <strong>m</strong><span class="sig-paren">)</span><a class="headerlink" href="#Mat& Mat::operator = (const Mat& m)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="Mat&amp; Mat::operator =(const MatExpr&amp; expr)">
<strong>C++:</strong><code class="descname"> </code>Mat&amp; <code class="descclassname">Mat::</code><code class="descname">operator=</code><span class="sig-paren">(</span>const MatExpr&amp; <strong>expr</strong><span class="sig-paren">)</span><a class="headerlink" href="#Mat& Mat::operator =(const MatExpr& expr)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="Mat&amp; Mat::operator = (const Scalar&amp; s)">
<strong>C++:</strong><code class="descname"> </code>Mat&amp; <code class="descclassname">Mat::</code><code class="descname">operator=</code><span class="sig-paren">(</span>const Scalar&amp; <strong>s</strong><span class="sig-paren">)</span><a class="headerlink" href="#Mat& Mat::operator = (const Scalar& s)" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>m</strong> &#8211; Assigned, right-hand-side matrix. Matrix assignment is an O(1) operation. This means that no data is copied but the data is shared and the reference counter, if any, is incremented. Before assigning new data, the old data is de-referenced via  <a class="reference internal" href="#void Mat::release()" title="void Mat::release()"><code class="xref ocv ocv-func docutils literal"><span class="pre">Mat::release()</span></code></a> .</li>
<li><strong>expr</strong> &#8211; Assigned matrix expression object. As opposite to the first form of the assignment operation, the second form can reuse already allocated matrix if it has the right size and type to fit the matrix expression result. It is automatically handled by the real function that the matrix expressions is expanded to. For example,  <code class="docutils literal"><span class="pre">C=A+B</span></code>  is expanded to  <code class="docutils literal"><span class="pre">add(A,</span> <span class="pre">B,</span> <span class="pre">C)</span></code>, and  <code class="xref py py-func docutils literal"><span class="pre">add()</span></code>  takes care of automatic  <code class="docutils literal"><span class="pre">C</span></code>  reallocation.</li>
<li><strong>s</strong> &#8211; Scalar assigned to each matrix element. The matrix size or type is not changed.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<p>These are available assignment operators. Since they all are very different, make sure to read the operator parameters description.</p>
</div>
<div class="section" id="mat-row">
<h2>Mat::row<a class="headerlink" href="#mat-row" title="Permalink to this headline">¶</a></h2>
<p>Creates a matrix header for the specified matrix row.</p>
<dl class="function">
<dt id="Mat Mat::row(int y) const">
<strong>C++:</strong><code class="descname"> </code>Mat <code class="descclassname">Mat::</code><code class="descname">row</code><span class="sig-paren">(</span>int <strong>y</strong><span class="sig-paren">)</span><code class="descclassname"> const</code><a class="headerlink" href="#Mat Mat::row(int y) const" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>y</strong> &#8211; A 0-based row index.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<p>The method makes a new header for the specified matrix row and returns it. This is an O(1) operation, regardless of the matrix size. The underlying data of the new matrix is shared with the original matrix. Here is the example of one of the classical basic matrix processing operations, <code class="docutils literal"><span class="pre">axpy</span></code>, used by LU and many other algorithms:</p>
<div class="highlight-cpp"><div class="highlight"><pre><span class="kr">inline</span> <span class="kt">void</span> <span class="nf">matrix_axpy</span><span class="p">(</span><span class="n">Mat</span><span class="o">&amp;</span> <span class="n">A</span><span class="p">,</span> <span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="kt">int</span> <span class="n">j</span><span class="p">,</span> <span class="kt">double</span> <span class="n">alpha</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">A</span><span class="p">.</span><span class="n">row</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">+=</span> <span class="n">A</span><span class="p">.</span><span class="n">row</span><span class="p">(</span><span class="n">j</span><span class="p">)</span><span class="o">*</span><span class="n">alpha</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>In the current implementation, the following code does not work as expected:</p>
<div class="highlight-cpp"><div class="highlight"><pre><span class="n">Mat</span> <span class="n">A</span><span class="p">;</span>
<span class="p">...</span>
<span class="n">A</span><span class="p">.</span><span class="n">row</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">=</span> <span class="n">A</span><span class="p">.</span><span class="n">row</span><span class="p">(</span><span class="n">j</span><span class="p">);</span> <span class="c1">// will not work</span>
</pre></div>
</div>
<p>This happens because <code class="docutils literal"><span class="pre">A.row(i)</span></code> forms a temporary header that is further assigned to another header. Remember that each of these operations is O(1), that is, no data is copied. Thus, the above assignment is not true if you may have expected the j-th row to be copied to the i-th row. To achieve that, you should either turn this simple assignment into an expression or use the <a class="reference internal" href="#void Mat::copyTo(OutputArray m) const" title="void Mat::copyTo(OutputArray m) const"><code class="xref ocv ocv-func docutils literal"><span class="pre">Mat::copyTo()</span></code></a> method:</p>
<div class="last highlight-cpp"><div class="highlight"><pre><span class="n">Mat</span> <span class="n">A</span><span class="p">;</span>
<span class="p">...</span>
<span class="c1">// works, but looks a bit obscure.</span>
<span class="n">A</span><span class="p">.</span><span class="n">row</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">=</span> <span class="n">A</span><span class="p">.</span><span class="n">row</span><span class="p">(</span><span class="n">j</span><span class="p">)</span> <span class="o">+</span> <span class="mi">0</span><span class="p">;</span>

<span class="c1">// this is a bit longer, but the recommended method.</span>
<span class="n">A</span><span class="p">.</span><span class="n">row</span><span class="p">(</span><span class="n">j</span><span class="p">).</span><span class="n">copyTo</span><span class="p">(</span><span class="n">A</span><span class="p">.</span><span class="n">row</span><span class="p">(</span><span class="n">i</span><span class="p">));</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="mat-col">
<h2>Mat::col<a class="headerlink" href="#mat-col" title="Permalink to this headline">¶</a></h2>
<p>Creates a matrix header for the specified matrix column.</p>
<dl class="function">
<dt id="Mat Mat::col(int x) const">
<strong>C++:</strong><code class="descname"> </code>Mat <code class="descclassname">Mat::</code><code class="descname">col</code><span class="sig-paren">(</span>int <strong>x</strong><span class="sig-paren">)</span><code class="descclassname"> const</code><a class="headerlink" href="#Mat Mat::col(int x) const" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>x</strong> &#8211; A 0-based column index.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<p>The method makes a new header for the specified matrix column and returns it. This is an O(1) operation, regardless of the matrix size. The underlying data of the new matrix is shared with the original matrix. See also the
<a class="reference internal" href="#Mat Mat::row(int y) const" title="Mat Mat::row(int y) const"><code class="xref ocv ocv-func docutils literal"><span class="pre">Mat::row()</span></code></a> description.</p>
</div>
<div class="section" id="mat-rowrange">
<h2>Mat::rowRange<a class="headerlink" href="#mat-rowrange" title="Permalink to this headline">¶</a></h2>
<p>Creates a matrix header for the specified row span.</p>
<dl class="function">
<dt id="Mat Mat::rowRange(int startrow, int endrow) const">
<strong>C++:</strong><code class="descname"> </code>Mat <code class="descclassname">Mat::</code><code class="descname">rowRange</code><span class="sig-paren">(</span>int <strong>startrow</strong>, int <strong>endrow</strong><span class="sig-paren">)</span><code class="descclassname"> const</code><a class="headerlink" href="#Mat Mat::rowRange(int startrow, int endrow) const" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="Mat Mat::rowRange(const Range&amp; r) const">
<strong>C++:</strong><code class="descname"> </code>Mat <code class="descclassname">Mat::</code><code class="descname">rowRange</code><span class="sig-paren">(</span>const Range&amp; <strong>r</strong><span class="sig-paren">)</span><code class="descclassname"> const</code><a class="headerlink" href="#Mat Mat::rowRange(const Range& r) const" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>startrow</strong> &#8211; An inclusive 0-based start index of the row span.</li>
<li><strong>endrow</strong> &#8211; An exclusive 0-based ending index of the row span.</li>
<li><strong>r</strong> &#8211; <a class="reference internal" href="#Range" title="class Range"><code class="xref ocv ocv-class docutils literal"><span class="pre">Range</span></code></a> structure containing both the start and the end indices.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<p>The method makes a new header for the specified row span of the matrix. Similarly to
<a class="reference internal" href="#Mat Mat::row(int y) const" title="Mat Mat::row(int y) const"><code class="xref ocv ocv-func docutils literal"><span class="pre">Mat::row()</span></code></a> and
<a class="reference internal" href="#Mat Mat::col(int x) const" title="Mat Mat::col(int x) const"><code class="xref ocv ocv-func docutils literal"><span class="pre">Mat::col()</span></code></a> , this is an O(1) operation.</p>
</div>
<div class="section" id="mat-colrange">
<h2>Mat::colRange<a class="headerlink" href="#mat-colrange" title="Permalink to this headline">¶</a></h2>
<p>Creates a matrix header for the specified column span.</p>
<dl class="function">
<dt id="Mat Mat::colRange(int startcol, int endcol) const">
<strong>C++:</strong><code class="descname"> </code>Mat <code class="descclassname">Mat::</code><code class="descname">colRange</code><span class="sig-paren">(</span>int <strong>startcol</strong>, int <strong>endcol</strong><span class="sig-paren">)</span><code class="descclassname"> const</code><a class="headerlink" href="#Mat Mat::colRange(int startcol, int endcol) const" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="Mat Mat::colRange(const Range&amp; r) const">
<strong>C++:</strong><code class="descname"> </code>Mat <code class="descclassname">Mat::</code><code class="descname">colRange</code><span class="sig-paren">(</span>const Range&amp; <strong>r</strong><span class="sig-paren">)</span><code class="descclassname"> const</code><a class="headerlink" href="#Mat Mat::colRange(const Range& r) const" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>startcol</strong> &#8211; An inclusive 0-based start index of the column span.</li>
<li><strong>endcol</strong> &#8211; An exclusive 0-based ending index of the column span.</li>
<li><strong>r</strong> &#8211; <a class="reference internal" href="#Range" title="class Range"><code class="xref ocv ocv-class docutils literal"><span class="pre">Range</span></code></a>  structure containing both the start and the end indices.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<p>The method makes a new header for the specified column span of the matrix. Similarly to
<a class="reference internal" href="#Mat Mat::row(int y) const" title="Mat Mat::row(int y) const"><code class="xref ocv ocv-func docutils literal"><span class="pre">Mat::row()</span></code></a> and
<a class="reference internal" href="#Mat Mat::col(int x) const" title="Mat Mat::col(int x) const"><code class="xref ocv ocv-func docutils literal"><span class="pre">Mat::col()</span></code></a> , this is an O(1) operation.</p>
</div>
<div class="section" id="mat-diag">
<h2>Mat::diag<a class="headerlink" href="#mat-diag" title="Permalink to this headline">¶</a></h2>
<p>Extracts a diagonal from a matrix, or creates a diagonal matrix.</p>
<dl class="function">
<dt id="Mat Mat::diag(int d) const">
<strong>C++:</strong><code class="descname"> </code>Mat <code class="descclassname">Mat::</code><code class="descname">diag</code><span class="sig-paren">(</span>int <strong>d</strong>=0 <span class="sig-paren">)</span><code class="descclassname"> const</code><a class="headerlink" href="#Mat Mat::diag(int d) const" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="static Mat Mat::diag(const Mat&amp; d)">
<strong>C++:</strong><code class="descname"> </code><em class="property">static</em> Mat <code class="descclassname">Mat::</code><code class="descname">diag</code><span class="sig-paren">(</span>const Mat&amp; <strong>d</strong><span class="sig-paren">)</span><a class="headerlink" href="#static Mat Mat::diag(const Mat& d)" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>d</strong> &#8211; <p>Single-column matrix that forms a diagonal matrix or index of the diagonal, with the following values:</p>
<ul>
<li><strong>d=0</strong> is the main diagonal.</li>
<li><strong>d&gt;0</strong> is a diagonal from the lower half. For example,  <code class="docutils literal"><span class="pre">d=1</span></code>  means the diagonal is set immediately below the main one.</li>
<li><strong>d&lt;0</strong> is a diagonal from the upper half. For example,  <code class="docutils literal"><span class="pre">d=1</span></code>  means the diagonal is set immediately above the main one.</li>
</ul>
</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<p>The method makes a new header for the specified matrix diagonal. The new matrix is represented as a single-column matrix. Similarly to
<a class="reference internal" href="#Mat Mat::row(int y) const" title="Mat Mat::row(int y) const"><code class="xref ocv ocv-func docutils literal"><span class="pre">Mat::row()</span></code></a> and
<a class="reference internal" href="#Mat Mat::col(int x) const" title="Mat Mat::col(int x) const"><code class="xref ocv ocv-func docutils literal"><span class="pre">Mat::col()</span></code></a> , this is an O(1) operation.</p>
</div>
<div class="section" id="mat-clone">
<h2>Mat::clone<a class="headerlink" href="#mat-clone" title="Permalink to this headline">¶</a></h2>
<p>Creates a full copy of the array and the underlying data.</p>
<dl class="function">
<dt id="Mat Mat::clone() const">
<strong>C++:</strong><code class="descname"> </code>Mat <code class="descclassname">Mat::</code><code class="descname">clone</code><span class="sig-paren">(</span><span class="sig-paren">)</span><code class="descclassname"> const</code><a class="headerlink" href="#Mat Mat::clone() const" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p>The method creates a full copy of the array. The original <code class="docutils literal"><span class="pre">step[]</span></code> is not taken into account. So, the array copy is a continuous array occupying <code class="docutils literal"><span class="pre">total()*elemSize()</span></code> bytes.</p>
</div>
<div class="section" id="mat-copyto">
<h2>Mat::copyTo<a class="headerlink" href="#mat-copyto" title="Permalink to this headline">¶</a></h2>
<p>Copies the matrix to another one.</p>
<dl class="function">
<dt id="void Mat::copyTo(OutputArray m) const">
<strong>C++:</strong><code class="descname"> </code>void <code class="descclassname">Mat::</code><code class="descname">copyTo</code><span class="sig-paren">(</span>OutputArray <strong>m</strong><span class="sig-paren">)</span><code class="descclassname"> const</code><a class="headerlink" href="#void Mat::copyTo(OutputArray m) const" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="void Mat::copyTo(OutputArray m, InputArray mask) const">
<strong>C++:</strong><code class="descname"> </code>void <code class="descclassname">Mat::</code><code class="descname">copyTo</code><span class="sig-paren">(</span>OutputArray <strong>m</strong>, InputArray <strong>mask</strong><span class="sig-paren">)</span><code class="descclassname"> const</code><a class="headerlink" href="#void Mat::copyTo(OutputArray m, InputArray mask) const" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>m</strong> &#8211; Destination matrix. If it does not have a proper size or type before the operation, it is reallocated.</li>
<li><strong>mask</strong> &#8211; Operation mask. Its non-zero elements indicate which matrix elements need to be copied. Keep in mind that the mask needs to be of type CV_8U and can have 1 or multiple channels.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<p>The method copies the matrix data to another matrix. Before copying the data, the method invokes</p>
<div class="highlight-cpp"><div class="highlight"><pre><span class="n">m</span><span class="p">.</span><span class="n">create</span><span class="p">(</span><span class="k">this</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">(),</span> <span class="k">this</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">());</span>
</pre></div>
</div>
<p>so that the destination matrix is reallocated if needed. While <code class="docutils literal"><span class="pre">m.copyTo(m);</span></code> works flawlessly, the function does not handle the case of a partial overlap between the source and the destination matrices.</p>
<p>When the operation mask is specified, if the <code class="docutils literal"><span class="pre">Mat::create</span></code> call shown above reallocates the matrix, the newly allocated matrix is initialized with all zeros before copying the data.</p>
</div>
<div class="section" id="mat-convertto">
<span id="id5"></span><h2>Mat::convertTo<a class="headerlink" href="#mat-convertto" title="Permalink to this headline">¶</a></h2>
<p>Converts an array to another data type with optional scaling.</p>
<dl class="function">
<dt id="void Mat::convertTo(OutputArray m, int rtype, double alpha, double beta) const">
<strong>C++:</strong><code class="descname"> </code>void <code class="descclassname">Mat::</code><code class="descname">convertTo</code><span class="sig-paren">(</span>OutputArray <strong>m</strong>, int <strong>rtype</strong>, double <strong>alpha</strong>=1, double <strong>beta</strong>=0 <span class="sig-paren">)</span><code class="descclassname"> const</code><a class="headerlink" href="#void Mat::convertTo(OutputArray m, int rtype, double alpha, double beta) const" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>m</strong> &#8211; output matrix; if it does not have a proper size or type before the operation, it is reallocated.</li>
<li><strong>rtype</strong> &#8211; desired output matrix type or, rather, the depth since the number of channels are the same as the input has; if <code class="docutils literal"><span class="pre">rtype</span></code>  is negative, the output matrix will have the same type as the input.</li>
<li><strong>alpha</strong> &#8211; optional scale factor.</li>
<li><strong>beta</strong> &#8211; optional delta added to the scaled values.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<p>The method converts source pixel values to the target data type. <code class="docutils literal"><span class="pre">saturate_cast&lt;&gt;</span></code> is applied at the end to avoid possible overflows:</p>
<div class="math">
<p><img src="../../../_images/math/7aea83a3c27c88e825297d11ed9b4b0f16ca3b08.png" alt="m(x,y) = saturate \_ cast&lt;rType&gt;( \alpha (*this)(x,y) +  \beta )"/></p>
</div></div>
<div class="section" id="mat-assignto">
<h2>Mat::assignTo<a class="headerlink" href="#mat-assignto" title="Permalink to this headline">¶</a></h2>
<p>Provides a functional form of <code class="docutils literal"><span class="pre">convertTo</span></code>.</p>
<dl class="function">
<dt id="void Mat::assignTo(Mat&amp; m, int type) const">
<strong>C++:</strong><code class="descname"> </code>void <code class="descclassname">Mat::</code><code class="descname">assignTo</code><span class="sig-paren">(</span>Mat&amp; <strong>m</strong>, int <strong>type</strong>=-1 <span class="sig-paren">)</span><code class="descclassname"> const</code><a class="headerlink" href="#void Mat::assignTo(Mat& m, int type) const" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>m</strong> &#8211; Destination array.</li>
<li><strong>type</strong> &#8211; Desired destination array depth (or -1 if it should be the same as the source type).</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<p>This is an internally used method called by the
<a class="reference internal" href="#matrixexpressions"><span>Matrix Expressions</span></a> engine.</p>
</div>
<div class="section" id="mat-setto">
<h2>Mat::setTo<a class="headerlink" href="#mat-setto" title="Permalink to this headline">¶</a></h2>
<p>Sets all or some of the array elements to the specified value.</p>
<dl class="function">
<dt id="Mat&amp; Mat::setTo(InputArray value, InputArray mask)">
<strong>C++:</strong><code class="descname"> </code>Mat&amp; <code class="descclassname">Mat::</code><code class="descname">setTo</code><span class="sig-paren">(</span>InputArray <strong>value</strong>, InputArray <strong>mask</strong>=noArray() <span class="sig-paren">)</span><a class="headerlink" href="#Mat& Mat::setTo(InputArray value, InputArray mask)" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>value</strong> &#8211; Assigned scalar converted to the actual array type.</li>
<li><strong>mask</strong> &#8211; Operation mask of the same size as  <code class="docutils literal"><span class="pre">*this</span></code>. This is an advanced variant of the <code class="docutils literal"><span class="pre">Mat::operator=(const</span> <span class="pre">Scalar&amp;</span> <span class="pre">s)</span></code> operator.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="mat-reshape">
<h2>Mat::reshape<a class="headerlink" href="#mat-reshape" title="Permalink to this headline">¶</a></h2>
<p>Changes the shape and/or the number of channels of a 2D matrix without copying the data.</p>
<dl class="function">
<dt id="Mat Mat::reshape(int cn, int rows) const">
<strong>C++:</strong><code class="descname"> </code>Mat <code class="descclassname">Mat::</code><code class="descname">reshape</code><span class="sig-paren">(</span>int <strong>cn</strong>, int <strong>rows</strong>=0<span class="sig-paren">)</span><code class="descclassname"> const</code><a class="headerlink" href="#Mat Mat::reshape(int cn, int rows) const" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>cn</strong> &#8211; New number of channels. If the parameter is 0, the number of channels remains the same.</li>
<li><strong>rows</strong> &#8211; New number of rows. If the parameter is 0, the number of rows remains the same.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<p>The method makes a new matrix header for <code class="docutils literal"><span class="pre">*this</span></code> elements. The new matrix may have a different size and/or different number of channels. Any combination is possible if:</p>
<ul class="simple">
<li>No extra elements are included into the new matrix and no elements are excluded. Consequently, the product <code class="docutils literal"><span class="pre">rows*cols*channels()</span></code>     must stay the same after the transformation.</li>
<li>No data is copied. That is, this is an O(1) operation. Consequently, if you change the number of rows, or the operation changes the indices of elements row  in some other way, the matrix must be continuous. See
<a class="reference internal" href="#bool Mat::isContinuous() const" title="bool Mat::isContinuous() const"><code class="xref ocv ocv-func docutils literal"><span class="pre">Mat::isContinuous()</span></code></a> .</li>
</ul>
<p>For example, if there is a set of 3D points stored as an STL vector, and you want to represent the points as a <code class="docutils literal"><span class="pre">3xN</span></code> matrix, do the following:</p>
<div class="highlight-cpp"><div class="highlight"><pre><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Point3f</span><span class="o">&gt;</span> <span class="n">vec</span><span class="p">;</span>
<span class="p">...</span>

<span class="n">Mat</span> <span class="n">pointMat</span> <span class="o">=</span> <span class="n">Mat</span><span class="p">(</span><span class="n">vec</span><span class="p">).</span> <span class="c1">// convert vector to Mat, O(1) operation</span>
                  <span class="n">reshape</span><span class="p">(</span><span class="mi">1</span><span class="p">).</span> <span class="c1">// make Nx3 1-channel matrix out of Nx1 3-channel.</span>
                              <span class="c1">// Also, an O(1) operation</span>
                     <span class="n">t</span><span class="p">();</span> <span class="c1">// finally, transpose the Nx3 matrix.</span>
                          <span class="c1">// This involves copying all the elements</span>
</pre></div>
</div>
</div>
<div class="section" id="mat-t">
<h2>Mat::t<a class="headerlink" href="#mat-t" title="Permalink to this headline">¶</a></h2>
<p>Transposes a matrix.</p>
<dl class="function">
<dt id="MatExpr Mat::t() const">
<strong>C++:</strong><code class="descname"> </code>MatExpr <code class="descclassname">Mat::</code><code class="descname">t</code><span class="sig-paren">(</span><span class="sig-paren">)</span><code class="descclassname"> const</code><a class="headerlink" href="#MatExpr Mat::t() const" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p>The method performs matrix transposition by means of matrix expressions. It does not perform the actual transposition but returns a temporary matrix transposition object that can be further used as a part of more complex matrix expressions or can be assigned to a matrix:</p>
<div class="highlight-cpp"><div class="highlight"><pre><span class="n">Mat</span> <span class="n">A1</span> <span class="o">=</span> <span class="n">A</span> <span class="o">+</span> <span class="n">Mat</span><span class="o">::</span><span class="n">eye</span><span class="p">(</span><span class="n">A</span><span class="p">.</span><span class="n">size</span><span class="p">(),</span> <span class="n">A</span><span class="p">.</span><span class="n">type</span><span class="p">())</span><span class="o">*</span><span class="n">lambda</span><span class="p">;</span>
<span class="n">Mat</span> <span class="n">C</span> <span class="o">=</span> <span class="n">A1</span><span class="p">.</span><span class="n">t</span><span class="p">()</span><span class="o">*</span><span class="n">A1</span><span class="p">;</span> <span class="c1">// compute (A + lambda*I)^t * (A + lamda*I)</span>
</pre></div>
</div>
</div>
<div class="section" id="mat-inv">
<h2>Mat::inv<a class="headerlink" href="#mat-inv" title="Permalink to this headline">¶</a></h2>
<p>Inverses a matrix.</p>
<dl class="function">
<dt id="MatExpr Mat::inv(int method) const">
<strong>C++:</strong><code class="descname"> </code>MatExpr <code class="descclassname">Mat::</code><code class="descname">inv</code><span class="sig-paren">(</span>int <strong>method</strong>=DECOMP_LU<span class="sig-paren">)</span><code class="descclassname"> const</code><a class="headerlink" href="#MatExpr Mat::inv(int method) const" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>method</strong> &#8211; <p>Matrix inversion method. Possible values are the following:</p>
<ul>
<li><strong>DECOMP_LU</strong> is the LU decomposition. The matrix must be non-singular.</li>
<li><strong>DECOMP_CHOLESKY</strong> is the Cholesky  <img class="math" src="../../../_images/math/754e16c98cd94dd29be8a3ca818de83fcc0dd0b8.png" alt="LL^T"/>  decomposition for symmetrical positively defined matrices only. This type is about twice faster than LU on big matrices.</li>
<li><strong>DECOMP_SVD</strong> is the SVD decomposition. If the matrix is singular or even non-square, the pseudo inversion is computed.</li>
</ul>
</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<p>The method performs a matrix inversion by means of matrix expressions. This means that a temporary matrix inversion object is returned by the method and can be used further as a part of more complex matrix expressions or can be assigned to a matrix.</p>
</div>
<div class="section" id="mat-mul">
<h2>Mat::mul<a class="headerlink" href="#mat-mul" title="Permalink to this headline">¶</a></h2>
<p>Performs an element-wise multiplication or division of the two matrices.</p>
<dl class="function">
<dt id="MatExpr Mat::mul(InputArray m, double scale) const">
<strong>C++:</strong><code class="descname"> </code>MatExpr <code class="descclassname">Mat::</code><code class="descname">mul</code><span class="sig-paren">(</span>InputArray <strong>m</strong>, double <strong>scale</strong>=1<span class="sig-paren">)</span><code class="descclassname"> const</code><a class="headerlink" href="#MatExpr Mat::mul(InputArray m, double scale) const" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>m</strong> &#8211; Another array of the same type and the same size as <code class="docutils literal"><span class="pre">*this</span></code>, or a matrix expression.</li>
<li><strong>scale</strong> &#8211; Optional scale factor.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<p>The method returns a temporary object encoding per-element array multiplication, with optional scale. Note that this is not a matrix multiplication that corresponds to a simpler &#8220;*&#8221; operator.</p>
<p>Example:</p>
<div class="highlight-cpp"><div class="highlight"><pre><span class="n">Mat</span> <span class="n">C</span> <span class="o">=</span> <span class="n">A</span><span class="p">.</span><span class="n">mul</span><span class="p">(</span><span class="mi">5</span><span class="o">/</span><span class="n">B</span><span class="p">);</span> <span class="c1">// equivalent to divide(A, B, C, 5)</span>
</pre></div>
</div>
</div>
<div class="section" id="mat-cross">
<h2>Mat::cross<a class="headerlink" href="#mat-cross" title="Permalink to this headline">¶</a></h2>
<p>Computes a cross-product of two 3-element vectors.</p>
<dl class="function">
<dt id="Mat Mat::cross(InputArray m) const">
<strong>C++:</strong><code class="descname"> </code>Mat <code class="descclassname">Mat::</code><code class="descname">cross</code><span class="sig-paren">(</span>InputArray <strong>m</strong><span class="sig-paren">)</span><code class="descclassname"> const</code><a class="headerlink" href="#Mat Mat::cross(InputArray m) const" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>m</strong> &#8211; Another cross-product operand.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<p>The method computes a cross-product of two 3-element vectors. The vectors must be 3-element floating-point vectors of the same shape and size. The result is another 3-element vector of the same shape and type as operands.</p>
</div>
<div class="section" id="mat-dot">
<h2>Mat::dot<a class="headerlink" href="#mat-dot" title="Permalink to this headline">¶</a></h2>
<p>Computes a dot-product of two vectors.</p>
<dl class="function">
<dt id="double Mat::dot(InputArray m) const">
<strong>C++:</strong><code class="descname"> </code>double <code class="descclassname">Mat::</code><code class="descname">dot</code><span class="sig-paren">(</span>InputArray <strong>m</strong><span class="sig-paren">)</span><code class="descclassname"> const</code><a class="headerlink" href="#double Mat::dot(InputArray m) const" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>m</strong> &#8211; another dot-product operand.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<p>The method computes a dot-product of two matrices. If the matrices are not single-column or single-row vectors, the top-to-bottom left-to-right scan ordering is used to treat them as 1D vectors. The vectors must have the same size and type. If the matrices have more than one channel, the dot products from all the channels are summed together.</p>
</div>
<div class="section" id="mat-zeros">
<h2>Mat::zeros<a class="headerlink" href="#mat-zeros" title="Permalink to this headline">¶</a></h2>
<p>Returns a zero array of the specified size and type.</p>
<dl class="function">
<dt id="static MatExpr Mat::zeros(int rows, int cols, int type)">
<strong>C++:</strong><code class="descname"> </code><em class="property">static</em> MatExpr <code class="descclassname">Mat::</code><code class="descname">zeros</code><span class="sig-paren">(</span>int <strong>rows</strong>, int <strong>cols</strong>, int <strong>type</strong><span class="sig-paren">)</span><a class="headerlink" href="#static MatExpr Mat::zeros(int rows, int cols, int type)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="static MatExpr Mat::zeros(Size size, int type)">
<strong>C++:</strong><code class="descname"> </code><em class="property">static</em> MatExpr <code class="descclassname">Mat::</code><code class="descname">zeros</code><span class="sig-paren">(</span>Size <strong>size</strong>, int <strong>type</strong><span class="sig-paren">)</span><a class="headerlink" href="#static MatExpr Mat::zeros(Size size, int type)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="static MatExpr Mat::zeros(int ndims, const int* sz, int type)">
<strong>C++:</strong><code class="descname"> </code><em class="property">static</em> MatExpr <code class="descclassname">Mat::</code><code class="descname">zeros</code><span class="sig-paren">(</span>int <strong>ndims</strong>, const int* <strong>sz</strong>, int <strong>type</strong><span class="sig-paren">)</span><a class="headerlink" href="#static MatExpr Mat::zeros(int ndims, const int* sz, int type)" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>ndims</strong> &#8211; Array dimensionality.</li>
<li><strong>rows</strong> &#8211; Number of rows.</li>
<li><strong>cols</strong> &#8211; Number of columns.</li>
<li><strong>size</strong> &#8211; Alternative to the matrix size specification <code class="docutils literal"><span class="pre">Size(cols,</span> <span class="pre">rows)</span></code>  .</li>
<li><strong>sz</strong> &#8211; Array of integers specifying the array shape.</li>
<li><strong>type</strong> &#8211; Created matrix type.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<p>The method returns a Matlab-style zero array initializer. It can be used to quickly form a constant array as a function parameter, part of a matrix expression, or as a matrix initializer.</p>
<div class="highlight-cpp"><div class="highlight"><pre><span class="n">Mat</span> <span class="n">A</span><span class="p">;</span>
<span class="n">A</span> <span class="o">=</span> <span class="n">Mat</span><span class="o">::</span><span class="n">zeros</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="n">CV_32F</span><span class="p">);</span>
</pre></div>
</div>
<p>In the example above, a new matrix is allocated only if <code class="docutils literal"><span class="pre">A</span></code> is not a 3x3 floating-point matrix. Otherwise, the existing matrix <code class="docutils literal"><span class="pre">A</span></code> is filled with zeros.</p>
</div>
<div class="section" id="mat-ones">
<h2>Mat::ones<a class="headerlink" href="#mat-ones" title="Permalink to this headline">¶</a></h2>
<p>Returns an array of all 1&#8217;s of the specified size and type.</p>
<dl class="function">
<dt id="static MatExpr Mat::ones(int rows, int cols, int type)">
<strong>C++:</strong><code class="descname"> </code><em class="property">static</em> MatExpr <code class="descclassname">Mat::</code><code class="descname">ones</code><span class="sig-paren">(</span>int <strong>rows</strong>, int <strong>cols</strong>, int <strong>type</strong><span class="sig-paren">)</span><a class="headerlink" href="#static MatExpr Mat::ones(int rows, int cols, int type)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="static MatExpr Mat::ones(Size size, int type)">
<strong>C++:</strong><code class="descname"> </code><em class="property">static</em> MatExpr <code class="descclassname">Mat::</code><code class="descname">ones</code><span class="sig-paren">(</span>Size <strong>size</strong>, int <strong>type</strong><span class="sig-paren">)</span><a class="headerlink" href="#static MatExpr Mat::ones(Size size, int type)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="static MatExpr Mat::ones(int ndims, const int* sz, int type)">
<strong>C++:</strong><code class="descname"> </code><em class="property">static</em> MatExpr <code class="descclassname">Mat::</code><code class="descname">ones</code><span class="sig-paren">(</span>int <strong>ndims</strong>, const int* <strong>sz</strong>, int <strong>type</strong><span class="sig-paren">)</span><a class="headerlink" href="#static MatExpr Mat::ones(int ndims, const int* sz, int type)" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>ndims</strong> &#8211; Array dimensionality.</li>
<li><strong>rows</strong> &#8211; Number of rows.</li>
<li><strong>cols</strong> &#8211; Number of columns.</li>
<li><strong>size</strong> &#8211; Alternative to the matrix size specification  <code class="docutils literal"><span class="pre">Size(cols,</span> <span class="pre">rows)</span></code>  .</li>
<li><strong>sz</strong> &#8211; Array of integers specifying the array shape.</li>
<li><strong>type</strong> &#8211; Created matrix type.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<p>The method returns a Matlab-style 1&#8217;s array initializer, similarly to
<a class="reference internal" href="#static MatExpr Mat::zeros(int rows, int cols, int type)" title="static MatExpr Mat::zeros(int rows, int cols, int type)"><code class="xref ocv ocv-func docutils literal"><span class="pre">Mat::zeros()</span></code></a>. Note that using this method you can initialize an array with an arbitrary value, using the following Matlab idiom:</p>
<div class="highlight-cpp"><div class="highlight"><pre><span class="n">Mat</span> <span class="n">A</span> <span class="o">=</span> <span class="n">Mat</span><span class="o">::</span><span class="n">ones</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="n">CV_8U</span><span class="p">)</span><span class="o">*</span><span class="mi">3</span><span class="p">;</span> <span class="c1">// make 100x100 matrix filled with 3.</span>
</pre></div>
</div>
<p>The above operation does not form a 100x100 matrix of 1&#8217;s and then multiply it by 3. Instead, it just remembers the scale factor (3 in this case) and use it when actually invoking the matrix initializer.</p>
</div>
<div class="section" id="mat-eye">
<h2>Mat::eye<a class="headerlink" href="#mat-eye" title="Permalink to this headline">¶</a></h2>
<p>Returns an identity matrix of the specified size and type.</p>
<dl class="function">
<dt id="static MatExpr Mat::eye(int rows, int cols, int type)">
<strong>C++:</strong><code class="descname"> </code><em class="property">static</em> MatExpr <code class="descclassname">Mat::</code><code class="descname">eye</code><span class="sig-paren">(</span>int <strong>rows</strong>, int <strong>cols</strong>, int <strong>type</strong><span class="sig-paren">)</span><a class="headerlink" href="#static MatExpr Mat::eye(int rows, int cols, int type)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="static MatExpr Mat::eye(Size size, int type)">
<strong>C++:</strong><code class="descname"> </code><em class="property">static</em> MatExpr <code class="descclassname">Mat::</code><code class="descname">eye</code><span class="sig-paren">(</span>Size <strong>size</strong>, int <strong>type</strong><span class="sig-paren">)</span><a class="headerlink" href="#static MatExpr Mat::eye(Size size, int type)" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>rows</strong> &#8211; Number of rows.</li>
<li><strong>cols</strong> &#8211; Number of columns.</li>
<li><strong>size</strong> &#8211; Alternative matrix size specification as  <code class="docutils literal"><span class="pre">Size(cols,</span> <span class="pre">rows)</span></code> .</li>
<li><strong>type</strong> &#8211; Created matrix type.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<p>The method returns a Matlab-style identity matrix initializer, similarly to
<a class="reference internal" href="#static MatExpr Mat::zeros(int rows, int cols, int type)" title="static MatExpr Mat::zeros(int rows, int cols, int type)"><code class="xref ocv ocv-func docutils literal"><span class="pre">Mat::zeros()</span></code></a>. Similarly to
<a class="reference internal" href="#static MatExpr Mat::ones(int rows, int cols, int type)" title="static MatExpr Mat::ones(int rows, int cols, int type)"><code class="xref ocv ocv-func docutils literal"><span class="pre">Mat::ones()</span></code></a>, you can use a scale operation to create a scaled identity matrix efficiently:</p>
<div class="highlight-cpp"><div class="highlight"><pre><span class="c1">// make a 4x4 diagonal matrix with 0.1&#39;s on the diagonal.</span>
<span class="n">Mat</span> <span class="n">A</span> <span class="o">=</span> <span class="n">Mat</span><span class="o">::</span><span class="n">eye</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="n">CV_32F</span><span class="p">)</span><span class="o">*</span><span class="mf">0.1</span><span class="p">;</span>
</pre></div>
</div>
</div>
<div class="section" id="mat-create">
<h2>Mat::create<a class="headerlink" href="#mat-create" title="Permalink to this headline">¶</a></h2>
<p>Allocates new array data if needed.</p>
<dl class="function">
<dt id="void Mat::create(int rows, int cols, int type)">
<strong>C++:</strong><code class="descname"> </code>void <code class="descclassname">Mat::</code><code class="descname">create</code><span class="sig-paren">(</span>int <strong>rows</strong>, int <strong>cols</strong>, int <strong>type</strong><span class="sig-paren">)</span><a class="headerlink" href="#void Mat::create(int rows, int cols, int type)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="void Mat::create(Size size, int type)">
<strong>C++:</strong><code class="descname"> </code>void <code class="descclassname">Mat::</code><code class="descname">create</code><span class="sig-paren">(</span>Size <strong>size</strong>, int <strong>type</strong><span class="sig-paren">)</span><a class="headerlink" href="#void Mat::create(Size size, int type)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="void Mat::create(int ndims, const int* sizes, int type)">
<strong>C++:</strong><code class="descname"> </code>void <code class="descclassname">Mat::</code><code class="descname">create</code><span class="sig-paren">(</span>int <strong>ndims</strong>, const int* <strong>sizes</strong>, int <strong>type</strong><span class="sig-paren">)</span><a class="headerlink" href="#void Mat::create(int ndims, const int* sizes, int type)" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>ndims</strong> &#8211; New array dimensionality.</li>
<li><strong>rows</strong> &#8211; New number of rows.</li>
<li><strong>cols</strong> &#8211; New number of columns.</li>
<li><strong>size</strong> &#8211; Alternative new matrix size specification:  <code class="docutils literal"><span class="pre">Size(cols,</span> <span class="pre">rows)</span></code></li>
<li><strong>sizes</strong> &#8211; Array of integers specifying a new array shape.</li>
<li><strong>type</strong> &#8211; New matrix type.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<p>This is one of the key <code class="docutils literal"><span class="pre">Mat</span></code> methods. Most new-style OpenCV functions and methods that produce arrays call this method for each output array. The method uses the following algorithm:</p>
<ol class="arabic simple">
<li>If the current array shape and the type match the new ones, return immediately. Otherwise, de-reference the previous data by calling
<a class="reference internal" href="#void Mat::release()" title="void Mat::release()"><code class="xref ocv ocv-func docutils literal"><span class="pre">Mat::release()</span></code></a>.</li>
<li>Initialize the new header.</li>
<li>Allocate the new data of <code class="docutils literal"><span class="pre">total()*elemSize()</span></code>     bytes.</li>
<li>Allocate the new, associated with the data, reference counter and set it to 1.</li>
</ol>
<p>Such a scheme makes the memory management robust and efficient at the same time and helps avoid extra typing for you. This means that usually there is no need to explicitly allocate output arrays. That is, instead of writing:</p>
<div class="highlight-cpp"><div class="highlight"><pre><span class="n">Mat</span> <span class="n">color</span><span class="p">;</span>
<span class="p">...</span>
<span class="n">Mat</span> <span class="n">gray</span><span class="p">(</span><span class="n">color</span><span class="p">.</span><span class="n">rows</span><span class="p">,</span> <span class="n">color</span><span class="p">.</span><span class="n">cols</span><span class="p">,</span> <span class="n">color</span><span class="p">.</span><span class="n">depth</span><span class="p">());</span>
<span class="n">cvtColor</span><span class="p">(</span><span class="n">color</span><span class="p">,</span> <span class="n">gray</span><span class="p">,</span> <span class="n">CV_BGR2GRAY</span><span class="p">);</span>
</pre></div>
</div>
<p>you can simply write:</p>
<div class="highlight-cpp"><div class="highlight"><pre><span class="n">Mat</span> <span class="n">color</span><span class="p">;</span>
<span class="p">...</span>
<span class="n">Mat</span> <span class="n">gray</span><span class="p">;</span>
<span class="n">cvtColor</span><span class="p">(</span><span class="n">color</span><span class="p">,</span> <span class="n">gray</span><span class="p">,</span> <span class="n">CV_BGR2GRAY</span><span class="p">);</span>
</pre></div>
</div>
<p>because <code class="docutils literal"><span class="pre">cvtColor</span></code> , as well as the most of OpenCV functions, calls <code class="docutils literal"><span class="pre">Mat::create()</span></code> for the output array internally.</p>
</div>
<div class="section" id="mat-addref">
<h2>Mat::addref<a class="headerlink" href="#mat-addref" title="Permalink to this headline">¶</a></h2>
<p>Increments the reference counter.</p>
<dl class="function">
<dt id="void Mat::addref()">
<strong>C++:</strong><code class="descname"> </code>void <code class="descclassname">Mat::</code><code class="descname">addref</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#void Mat::addref()" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p>The method increments the reference counter associated with the matrix data. If the matrix header points to an external data set (see
<a class="reference internal" href="#Mat::Mat()" title="Mat::Mat()"><code class="xref ocv ocv-func docutils literal"><span class="pre">Mat::Mat()</span></code></a> ), the reference counter is NULL, and the method has no effect in this case. Normally, to avoid memory leaks, the method should not be called explicitly. It is called implicitly by the matrix assignment operator. The reference counter increment is an atomic operation on the platforms that support it. Thus, it is safe to operate on the same matrices asynchronously in different threads.</p>
</div>
<div class="section" id="mat-release">
<h2>Mat::release<a class="headerlink" href="#mat-release" title="Permalink to this headline">¶</a></h2>
<p>Decrements the reference counter and deallocates the matrix if needed.</p>
<dl class="function">
<dt id="void Mat::release()">
<strong>C++:</strong><code class="descname"> </code>void <code class="descclassname">Mat::</code><code class="descname">release</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#void Mat::release()" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p>The method decrements the reference counter associated with the matrix data. When the reference counter reaches 0, the matrix data is deallocated and the data and the reference counter pointers are set to NULL&#8217;s. If the matrix header points to an external data set (see
<a class="reference internal" href="#Mat::Mat()" title="Mat::Mat()"><code class="xref ocv ocv-func docutils literal"><span class="pre">Mat::Mat()</span></code></a> ), the reference counter is NULL, and the method has no effect in this case.</p>
<p>This method can be called manually to force the matrix data deallocation. But since this method is automatically called in the destructor, or by any other method that changes the data pointer, it is usually not needed. The reference counter decrement and check for 0 is an atomic operation on the platforms that support it. Thus, it is safe to operate on the same matrices asynchronously in different threads.</p>
</div>
<div class="section" id="mat-resize">
<h2>Mat::resize<a class="headerlink" href="#mat-resize" title="Permalink to this headline">¶</a></h2>
<p>Changes the number of matrix rows.</p>
<dl class="function">
<dt id="void Mat::resize(size_t sz)">
<strong>C++:</strong><code class="descname"> </code>void <code class="descclassname">Mat::</code><code class="descname">resize</code><span class="sig-paren">(</span>size_t <strong>sz</strong><span class="sig-paren">)</span><a class="headerlink" href="#void Mat::resize(size_t sz)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="void Mat::resize(size_t sz, const Scalar&amp; s)">
<strong>C++:</strong><code class="descname"> </code>void <code class="descclassname">Mat::</code><code class="descname">resize</code><span class="sig-paren">(</span>size_t <strong>sz</strong>, const Scalar&amp; <strong>s</strong><span class="sig-paren">)</span><a class="headerlink" href="#void Mat::resize(size_t sz, const Scalar& s)" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>sz</strong> &#8211; New number of rows.</li>
<li><strong>s</strong> &#8211; Value assigned to the newly added elements.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<p>The methods change the number of matrix rows. If the matrix is reallocated, the first <code class="docutils literal"><span class="pre">min(Mat::rows,</span> <span class="pre">sz)</span></code> rows are preserved. The methods emulate the corresponding methods of the STL vector class.</p>
</div>
<div class="section" id="mat-reserve">
<h2>Mat::reserve<a class="headerlink" href="#mat-reserve" title="Permalink to this headline">¶</a></h2>
<p>Reserves space for the certain number of rows.</p>
<dl class="function">
<dt id="void Mat::reserve(size_t sz)">
<strong>C++:</strong><code class="descname"> </code>void <code class="descclassname">Mat::</code><code class="descname">reserve</code><span class="sig-paren">(</span>size_t <strong>sz</strong><span class="sig-paren">)</span><a class="headerlink" href="#void Mat::reserve(size_t sz)" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>sz</strong> &#8211; Number of rows.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<p>The method reserves space for <code class="docutils literal"><span class="pre">sz</span></code> rows. If the matrix already has enough space to store <code class="docutils literal"><span class="pre">sz</span></code> rows, nothing happens. If the matrix is reallocated, the first <code class="docutils literal"><span class="pre">Mat::rows</span></code> rows are preserved. The method emulates the corresponding method of the STL vector class.</p>
</div>
<div class="section" id="mat-push-back">
<h2>Mat::push_back<a class="headerlink" href="#mat-push-back" title="Permalink to this headline">¶</a></h2>
<p>Adds elements to the bottom of the matrix.</p>
<dl class="function">
<dt id="template&lt;typename T&gt; void Mat::push_back(const T&amp; elem)">
<strong>C++:</strong><code class="descname"> </code>template&lt;typename T&gt; void <code class="descclassname">Mat::</code><code class="descname">push_back</code><span class="sig-paren">(</span>const T&amp; <strong>elem</strong><span class="sig-paren">)</span><a class="headerlink" href="#template<typename T> void Mat::push_back(const T& elem)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="void Mat::push_back(const Mat&amp; m)">
<strong>C++:</strong><code class="descname"> </code>void <code class="descclassname">Mat::</code><code class="descname">push_back</code><span class="sig-paren">(</span>const Mat&amp; <strong>m</strong><span class="sig-paren">)</span><a class="headerlink" href="#void Mat::push_back(const Mat& m)" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>elem</strong> &#8211; Added element(s).</li>
<li><strong>m</strong> &#8211; Added line(s).</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<p>The methods add one or more elements to the bottom of the matrix. They emulate the corresponding method of the STL vector class. When <code class="docutils literal"><span class="pre">elem</span></code> is <code class="docutils literal"><span class="pre">Mat</span></code> , its type and the number of columns must be the same as in the container matrix.</p>
</div>
<div class="section" id="mat-pop-back">
<h2>Mat::pop_back<a class="headerlink" href="#mat-pop-back" title="Permalink to this headline">¶</a></h2>
<p>Removes elements from the bottom of the matrix.</p>
<dl class="function">
<dt id="template&lt;typename T&gt; void Mat::pop_back(size_t nelems)">
<strong>C++:</strong><code class="descname"> </code>template&lt;typename T&gt; void <code class="descclassname">Mat::</code><code class="descname">pop_back</code><span class="sig-paren">(</span>size_t <strong>nelems</strong>=1<span class="sig-paren">)</span><a class="headerlink" href="#template<typename T> void Mat::pop_back(size_t nelems)" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>nelems</strong> &#8211; Number of removed rows. If it is greater than the total number of rows, an exception is thrown.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<p>The method removes one or more rows from the bottom of the matrix.</p>
</div>
<div class="section" id="mat-locateroi">
<h2>Mat::locateROI<a class="headerlink" href="#mat-locateroi" title="Permalink to this headline">¶</a></h2>
<p>Locates the matrix header within a parent matrix.</p>
<dl class="function">
<dt id="void Mat::locateROI(Size&amp; wholeSize, Point&amp; ofs) const">
<strong>C++:</strong><code class="descname"> </code>void <code class="descclassname">Mat::</code><code class="descname">locateROI</code><span class="sig-paren">(</span>Size&amp; <strong>wholeSize</strong>, Point&amp; <strong>ofs</strong><span class="sig-paren">)</span><code class="descclassname"> const</code><a class="headerlink" href="#void Mat::locateROI(Size& wholeSize, Point& ofs) const" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>wholeSize</strong> &#8211; Output parameter that contains the size of the whole matrix containing <code class="docutils literal"><span class="pre">*this</span></code> as a part.</li>
<li><strong>ofs</strong> &#8211; Output parameter that contains an offset of  <code class="docutils literal"><span class="pre">*this</span></code>  inside the whole matrix.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<p>After you extracted a submatrix from a matrix using
<a class="reference internal" href="#Mat Mat::row(int y) const" title="Mat Mat::row(int y) const"><code class="xref ocv ocv-func docutils literal"><span class="pre">Mat::row()</span></code></a>,
<a class="reference internal" href="#Mat Mat::col(int x) const" title="Mat Mat::col(int x) const"><code class="xref ocv ocv-func docutils literal"><span class="pre">Mat::col()</span></code></a>,
<a class="reference internal" href="#Mat Mat::rowRange(int startrow, int endrow) const" title="Mat Mat::rowRange(int startrow, int endrow) const"><code class="xref ocv ocv-func docutils literal"><span class="pre">Mat::rowRange()</span></code></a>,
<a class="reference internal" href="#Mat Mat::colRange(int startcol, int endcol) const" title="Mat Mat::colRange(int startcol, int endcol) const"><code class="xref ocv ocv-func docutils literal"><span class="pre">Mat::colRange()</span></code></a> , and others, the resultant submatrix points just to the part of the original big matrix. However, each submatrix contains information (represented by <code class="docutils literal"><span class="pre">datastart</span></code> and <code class="docutils literal"><span class="pre">dataend</span></code> fields) that helps reconstruct the original matrix size and the position of the extracted submatrix within the original matrix. The method <code class="docutils literal"><span class="pre">locateROI</span></code> does exactly that.</p>
</div>
<div class="section" id="mat-adjustroi">
<h2>Mat::adjustROI<a class="headerlink" href="#mat-adjustroi" title="Permalink to this headline">¶</a></h2>
<p>Adjusts a submatrix size and position within the parent matrix.</p>
<dl class="function">
<dt id="Mat&amp; Mat::adjustROI(int dtop, int dbottom, int dleft, int dright)">
<strong>C++:</strong><code class="descname"> </code>Mat&amp; <code class="descclassname">Mat::</code><code class="descname">adjustROI</code><span class="sig-paren">(</span>int <strong>dtop</strong>, int <strong>dbottom</strong>, int <strong>dleft</strong>, int <strong>dright</strong><span class="sig-paren">)</span><a class="headerlink" href="#Mat& Mat::adjustROI(int dtop, int dbottom, int dleft, int dright)" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>dtop</strong> &#8211; Shift of the top submatrix boundary upwards.</li>
<li><strong>dbottom</strong> &#8211; Shift of the bottom submatrix boundary downwards.</li>
<li><strong>dleft</strong> &#8211; Shift of the left submatrix boundary to the left.</li>
<li><strong>dright</strong> &#8211; Shift of the right submatrix boundary to the right.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<p>The method is complimentary to
<a class="reference internal" href="#void Mat::locateROI(Size&amp; wholeSize, Point&amp; ofs) const" title="void Mat::locateROI(Size&amp; wholeSize, Point&amp; ofs) const"><code class="xref ocv ocv-func docutils literal"><span class="pre">Mat::locateROI()</span></code></a> . The typical use of these functions is to determine the submatrix position within the parent matrix and then shift the position somehow. Typically, it can be required for filtering operations when pixels outside of the ROI should be taken into account. When all the method parameters are positive, the ROI needs to grow in all directions by the specified amount, for example:</p>
<div class="highlight-cpp"><div class="highlight"><pre><span class="n">A</span><span class="p">.</span><span class="n">adjustROI</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
</pre></div>
</div>
<p>In this example, the matrix size is increased by 4 elements in each direction. The matrix is shifted by 2 elements to the left and 2 elements up, which brings in all the necessary pixels for the filtering with the 5x5 kernel.</p>
<p><code class="docutils literal"><span class="pre">adjustROI</span></code> forces the adjusted ROI to be inside of the parent matrix that is boundaries of the adjusted ROI are constrained by boundaries of the parent matrix. For example, if the submatrix <code class="docutils literal"><span class="pre">A</span></code> is located in the first row of a parent matrix and you called <code class="docutils literal"><span class="pre">A.adjustROI(2,</span> <span class="pre">2,</span> <span class="pre">2,</span> <span class="pre">2)</span></code> then <code class="docutils literal"><span class="pre">A</span></code> will not be increased in the upward direction.</p>
<p>The function is used internally by the OpenCV filtering functions, like
<a class="reference internal" href="../../imgproc/doc/filtering.html#void filter2D(InputArray src, OutputArray dst, int ddepth, InputArray kernel, Point anchor, double delta, int borderType)" title="void filter2D(InputArray src, OutputArray dst, int ddepth, InputArray kernel, Point anchor, double delta, int borderType)"><code class="xref ocv ocv-func docutils literal"><span class="pre">filter2D()</span></code></a> , morphological operations, and so on.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="../../imgproc/doc/filtering.html#void copyMakeBorder(InputArray src, OutputArray dst, int top, int bottom, int left, int right, int borderType, const Scalar&amp; value)" title="void copyMakeBorder(InputArray src, OutputArray dst, int top, int bottom, int left, int right, int borderType, const Scalar&amp; value)"><code class="xref ocv ocv-func docutils literal"><span class="pre">copyMakeBorder()</span></code></a></p>
</div>
</div>
<div class="section" id="id6">
<h2>Mat::operator()<a class="headerlink" href="#id6" title="Permalink to this headline">¶</a></h2>
<p>Extracts a rectangular submatrix.</p>
<dl class="function">
<dt id="Mat Mat::operator()(Range rowRange, Range colRange) const">
<strong>C++:</strong><code class="descname"> </code>Mat <code class="descclassname">Mat::</code><code class="descname">operator()</code><span class="sig-paren">(</span>Range <strong>rowRange</strong>, Range <strong>colRange</strong><span class="sig-paren">)</span><code class="descclassname"> const</code><a class="headerlink" href="#Mat Mat::operator()(Range rowRange, Range colRange) const" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="Mat Mat::operator()(const Rect&amp; roi) const">
<strong>C++:</strong><code class="descname"> </code>Mat <code class="descclassname">Mat::</code><code class="descname">operator()</code><span class="sig-paren">(</span>const Rect&amp; <strong>roi</strong><span class="sig-paren">)</span><code class="descclassname"> const</code><a class="headerlink" href="#Mat Mat::operator()(const Rect& roi) const" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="Mat Mat::operator()(const Range* ranges) const">
<strong>C++:</strong><code class="descname"> </code>Mat <code class="descclassname">Mat::</code><code class="descname">operator()</code><span class="sig-paren">(</span>const Range* <strong>ranges</strong><span class="sig-paren">)</span><code class="descclassname"> const</code><a class="headerlink" href="#Mat Mat::operator()(const Range* ranges) const" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>rowRange</strong> &#8211; Start and end row of the extracted submatrix. The upper boundary is not included. To select all the rows, use <code class="docutils literal"><span class="pre">Range::all()</span></code>.</li>
<li><strong>colRange</strong> &#8211; Start and end column of the extracted submatrix. The upper boundary is not included. To select all the columns, use  <code class="docutils literal"><span class="pre">Range::all()</span></code>.</li>
<li><strong>roi</strong> &#8211; Extracted submatrix specified as a rectangle.</li>
<li><strong>ranges</strong> &#8211; Array of selected ranges along each array dimension.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<p>The operators make a new header for the specified sub-array of <code class="docutils literal"><span class="pre">*this</span></code> . They are the most generalized forms of
<a class="reference internal" href="#Mat Mat::row(int y) const" title="Mat Mat::row(int y) const"><code class="xref ocv ocv-func docutils literal"><span class="pre">Mat::row()</span></code></a>,
<a class="reference internal" href="#Mat Mat::col(int x) const" title="Mat Mat::col(int x) const"><code class="xref ocv ocv-func docutils literal"><span class="pre">Mat::col()</span></code></a>,
<a class="reference internal" href="#Mat Mat::rowRange(int startrow, int endrow) const" title="Mat Mat::rowRange(int startrow, int endrow) const"><code class="xref ocv ocv-func docutils literal"><span class="pre">Mat::rowRange()</span></code></a>, and
<a class="reference internal" href="#Mat Mat::colRange(int startcol, int endcol) const" title="Mat Mat::colRange(int startcol, int endcol) const"><code class="xref ocv ocv-func docutils literal"><span class="pre">Mat::colRange()</span></code></a> . For example, <code class="docutils literal"><span class="pre">A(Range(0,</span> <span class="pre">10),</span> <span class="pre">Range::all())</span></code> is equivalent to <code class="docutils literal"><span class="pre">A.rowRange(0,</span> <span class="pre">10)</span></code> . Similarly to all of the above, the operators are O(1) operations, that is, no matrix data is copied.</p>
</div>
<div class="section" id="mat-operator-cvmat">
<h2>Mat::operator CvMat<a class="headerlink" href="#mat-operator-cvmat" title="Permalink to this headline">¶</a></h2>
<p>Creates the <code class="docutils literal"><span class="pre">CvMat</span></code> header for the matrix.</p>
<dl class="function">
<dt id="Mat::operator CvMat() const">
<strong>C++:</strong><code class="descname"> </code> <code class="descclassname">Mat::</code><code class="descname">operator</code> CvMat<span class="sig-paren">(</span><span class="sig-paren">)</span><code class="descclassname"> const</code><a class="headerlink" href="#Mat::operator CvMat() const" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p>The operator creates the <code class="docutils literal"><span class="pre">CvMat</span></code> header for the matrix without copying the underlying data. The reference counter is not taken into account by this operation. Thus, you should make sure than the original matrix is not deallocated while the <code class="docutils literal"><span class="pre">CvMat</span></code> header is used. The operator is useful for intermixing the new and the old OpenCV API&#8217;s, for example:</p>
<div class="highlight-cpp"><div class="highlight"><pre><span class="n">Mat</span> <span class="nf">img</span><span class="p">(</span><span class="n">Size</span><span class="p">(</span><span class="mi">320</span><span class="p">,</span> <span class="mi">240</span><span class="p">),</span> <span class="n">CV_8UC3</span><span class="p">);</span>
<span class="p">...</span>

<span class="n">CvMat</span> <span class="n">cvimg</span> <span class="o">=</span> <span class="n">img</span><span class="p">;</span>
<span class="n">mycvOldFunc</span><span class="p">(</span> <span class="o">&amp;</span><span class="n">cvimg</span><span class="p">,</span> <span class="p">...);</span>
</pre></div>
</div>
<p>where <code class="docutils literal"><span class="pre">mycvOldFunc</span></code> is a function written to work with OpenCV 1.x data structures.</p>
</div>
<div class="section" id="mat-operator-iplimage">
<h2>Mat::operator IplImage<a class="headerlink" href="#mat-operator-iplimage" title="Permalink to this headline">¶</a></h2>
<p>Creates the <code class="docutils literal"><span class="pre">IplImage</span></code> header for the matrix.</p>
<dl class="function">
<dt id="Mat::operator IplImage() const">
<strong>C++:</strong><code class="descname"> </code> <code class="descclassname">Mat::</code><code class="descname">operator</code> IplImage<span class="sig-paren">(</span><span class="sig-paren">)</span><code class="descclassname"> const</code><a class="headerlink" href="#Mat::operator IplImage() const" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p>The operator creates the <code class="docutils literal"><span class="pre">IplImage</span></code> header for the matrix without copying the underlying data. You should make sure than the original matrix is not deallocated while the <code class="docutils literal"><span class="pre">IplImage</span></code> header is used. Similarly to <code class="docutils literal"><span class="pre">Mat::operator</span> <span class="pre">CvMat</span></code> , the operator is useful for intermixing the new and the old OpenCV API&#8217;s.</p>
</div>
<div class="section" id="mat-total">
<h2>Mat::total<a class="headerlink" href="#mat-total" title="Permalink to this headline">¶</a></h2>
<p>Returns the total number of array elements.</p>
<dl class="function">
<dt id="size_t Mat::total() const">
<strong>C++:</strong><code class="descname"> </code>size_t <code class="descclassname">Mat::</code><code class="descname">total</code><span class="sig-paren">(</span><span class="sig-paren">)</span><code class="descclassname"> const</code><a class="headerlink" href="#size_t Mat::total() const" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p>The method returns the number of array elements (a number of pixels if the array represents an image).</p>
</div>
<div class="section" id="mat-iscontinuous">
<h2>Mat::isContinuous<a class="headerlink" href="#mat-iscontinuous" title="Permalink to this headline">¶</a></h2>
<p>Reports whether the matrix is continuous or not.</p>
<dl class="function">
<dt id="bool Mat::isContinuous() const">
<strong>C++:</strong><code class="descname"> </code>bool <code class="descclassname">Mat::</code><code class="descname">isContinuous</code><span class="sig-paren">(</span><span class="sig-paren">)</span><code class="descclassname"> const</code><a class="headerlink" href="#bool Mat::isContinuous() const" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p>The method returns <code class="docutils literal"><span class="pre">true</span></code> if the matrix elements are stored continuously without gaps at the end of each row. Otherwise, it returns <code class="docutils literal"><span class="pre">false</span></code>. Obviously, <code class="docutils literal"><span class="pre">1x1</span></code> or <code class="docutils literal"><span class="pre">1xN</span></code> matrices are always continuous. Matrices created with
<a class="reference internal" href="#void Mat::create(int rows, int cols, int type)" title="void Mat::create(int rows, int cols, int type)"><code class="xref ocv ocv-func docutils literal"><span class="pre">Mat::create()</span></code></a> are always continuous. But if you extract a part of the matrix using
<a class="reference internal" href="#Mat Mat::col(int x) const" title="Mat Mat::col(int x) const"><code class="xref ocv ocv-func docutils literal"><span class="pre">Mat::col()</span></code></a>,
<a class="reference internal" href="#Mat Mat::diag(int d) const" title="Mat Mat::diag(int d) const"><code class="xref ocv ocv-func docutils literal"><span class="pre">Mat::diag()</span></code></a> , and so on, or constructed a matrix header for externally allocated data, such matrices may no longer have this property.</p>
<p>The continuity flag is stored as a bit in the <code class="docutils literal"><span class="pre">Mat::flags</span></code> field and is computed automatically when you construct a matrix header. Thus, the continuity check is a very fast operation, though theoretically it could be done as follows:</p>
<div class="highlight-cpp"><div class="highlight"><pre><span class="c1">// alternative implementation of Mat::isContinuous()</span>
<span class="kt">bool</span> <span class="nf">myCheckMatContinuity</span><span class="p">(</span><span class="k">const</span> <span class="n">Mat</span><span class="o">&amp;</span> <span class="n">m</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">//return (m.flags &amp; Mat::CONTINUOUS_FLAG) != 0;</span>
    <span class="k">return</span> <span class="n">m</span><span class="p">.</span><span class="n">rows</span> <span class="o">==</span> <span class="mi">1</span> <span class="o">||</span> <span class="n">m</span><span class="p">.</span><span class="n">step</span> <span class="o">==</span> <span class="n">m</span><span class="p">.</span><span class="n">cols</span><span class="o">*</span><span class="n">m</span><span class="p">.</span><span class="n">elemSize</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The method is used in quite a few of OpenCV functions. The point is that element-wise operations (such as arithmetic and logical operations, math functions, alpha blending, color space transformations, and others) do not depend on the image geometry. Thus, if all the input and output arrays are continuous, the functions can process them as very long single-row vectors. The example below illustrates how an alpha-blending function can be implemented.</p>
<div class="highlight-cpp"><div class="highlight"><pre><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">alphaBlendRGBA</span><span class="p">(</span><span class="k">const</span> <span class="n">Mat</span><span class="o">&amp;</span> <span class="n">src1</span><span class="p">,</span> <span class="k">const</span> <span class="n">Mat</span><span class="o">&amp;</span> <span class="n">src2</span><span class="p">,</span> <span class="n">Mat</span><span class="o">&amp;</span> <span class="n">dst</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">const</span> <span class="kt">float</span> <span class="n">alpha_scale</span> <span class="o">=</span> <span class="p">(</span><span class="kt">float</span><span class="p">)</span><span class="n">std</span><span class="o">::</span><span class="n">numeric_limits</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">max</span><span class="p">(),</span>
                <span class="n">inv_scale</span> <span class="o">=</span> <span class="mf">1.f</span><span class="o">/</span><span class="n">alpha_scale</span><span class="p">;</span>

    <span class="n">CV_Assert</span><span class="p">(</span> <span class="n">src1</span><span class="p">.</span><span class="n">type</span><span class="p">()</span> <span class="o">==</span> <span class="n">src2</span><span class="p">.</span><span class="n">type</span><span class="p">()</span> <span class="o">&amp;&amp;</span>
               <span class="n">src1</span><span class="p">.</span><span class="n">type</span><span class="p">()</span> <span class="o">==</span> <span class="n">CV_MAKETYPE</span><span class="p">(</span><span class="n">DataType</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">depth</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
               <span class="n">src1</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">==</span> <span class="n">src2</span><span class="p">.</span><span class="n">size</span><span class="p">());</span>
    <span class="n">Size</span> <span class="n">size</span> <span class="o">=</span> <span class="n">src1</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
    <span class="n">dst</span><span class="p">.</span><span class="n">create</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="n">src1</span><span class="p">.</span><span class="n">type</span><span class="p">());</span>

    <span class="c1">// here is the idiom: check the arrays for continuity and,</span>
    <span class="c1">// if this is the case,</span>
    <span class="c1">// treat the arrays as 1D vectors</span>
    <span class="k">if</span><span class="p">(</span> <span class="n">src1</span><span class="p">.</span><span class="n">isContinuous</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="n">src2</span><span class="p">.</span><span class="n">isContinuous</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="n">dst</span><span class="p">.</span><span class="n">isContinuous</span><span class="p">()</span> <span class="p">)</span>
    <span class="p">{</span>
        <span class="n">size</span><span class="p">.</span><span class="n">width</span> <span class="o">*=</span> <span class="n">size</span><span class="p">.</span><span class="n">height</span><span class="p">;</span>
        <span class="n">size</span><span class="p">.</span><span class="n">height</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">size</span><span class="p">.</span><span class="n">width</span> <span class="o">*=</span> <span class="mi">4</span><span class="p">;</span>

    <span class="k">for</span><span class="p">(</span> <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">size</span><span class="p">.</span><span class="n">height</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span> <span class="p">)</span>
    <span class="p">{</span>
        <span class="c1">// when the arrays are continuous,</span>
        <span class="c1">// the outer loop is executed only once</span>
        <span class="k">const</span> <span class="n">T</span><span class="o">*</span> <span class="n">ptr1</span> <span class="o">=</span> <span class="n">src1</span><span class="p">.</span><span class="n">ptr</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
        <span class="k">const</span> <span class="n">T</span><span class="o">*</span> <span class="n">ptr2</span> <span class="o">=</span> <span class="n">src2</span><span class="p">.</span><span class="n">ptr</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
        <span class="n">T</span><span class="o">*</span> <span class="n">dptr</span> <span class="o">=</span> <span class="n">dst</span><span class="p">.</span><span class="n">ptr</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>

        <span class="k">for</span><span class="p">(</span> <span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">size</span><span class="p">.</span><span class="n">width</span><span class="p">;</span> <span class="n">j</span> <span class="o">+=</span> <span class="mi">4</span> <span class="p">)</span>
        <span class="p">{</span>
            <span class="kt">float</span> <span class="n">alpha</span> <span class="o">=</span> <span class="n">ptr1</span><span class="p">[</span><span class="n">j</span><span class="o">+</span><span class="mi">3</span><span class="p">]</span><span class="o">*</span><span class="n">inv_scale</span><span class="p">,</span> <span class="n">beta</span> <span class="o">=</span> <span class="n">ptr2</span><span class="p">[</span><span class="n">j</span><span class="o">+</span><span class="mi">3</span><span class="p">]</span><span class="o">*</span><span class="n">inv_scale</span><span class="p">;</span>
            <span class="n">dptr</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">saturate_cast</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">ptr1</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">*</span><span class="n">alpha</span> <span class="o">+</span> <span class="n">ptr2</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">*</span><span class="n">beta</span><span class="p">);</span>
            <span class="n">dptr</span><span class="p">[</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">saturate_cast</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">ptr1</span><span class="p">[</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">alpha</span> <span class="o">+</span> <span class="n">ptr2</span><span class="p">[</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">beta</span><span class="p">);</span>
            <span class="n">dptr</span><span class="p">[</span><span class="n">j</span><span class="o">+</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">saturate_cast</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">ptr1</span><span class="p">[</span><span class="n">j</span><span class="o">+</span><span class="mi">2</span><span class="p">]</span><span class="o">*</span><span class="n">alpha</span> <span class="o">+</span> <span class="n">ptr2</span><span class="p">[</span><span class="n">j</span><span class="o">+</span><span class="mi">2</span><span class="p">]</span><span class="o">*</span><span class="n">beta</span><span class="p">);</span>
            <span class="n">dptr</span><span class="p">[</span><span class="n">j</span><span class="o">+</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">saturate_cast</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">((</span><span class="mi">1</span> <span class="o">-</span> <span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">alpha</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">beta</span><span class="p">))</span><span class="o">*</span><span class="n">alpha_scale</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>This approach, while being very simple, can boost the performance of a simple element-operation by 10-20 percents, especially if the image is rather small and the operation is quite simple.</p>
<p>Another OpenCV idiom in this function, a call of
<a class="reference internal" href="#void Mat::create(int rows, int cols, int type)" title="void Mat::create(int rows, int cols, int type)"><code class="xref ocv ocv-func docutils literal"><span class="pre">Mat::create()</span></code></a> for the destination array, that allocates the destination array unless it already has the proper size and type. And while the newly allocated arrays are always continuous, you still need to check the destination array because <a class="reference internal" href="#void Mat::create(int rows, int cols, int type)" title="void Mat::create(int rows, int cols, int type)"><code class="xref ocv ocv-func docutils literal"><span class="pre">Mat::create()</span></code></a> does not always allocate a new matrix.</p>
</div>
<div class="section" id="mat-elemsize">
<h2>Mat::elemSize<a class="headerlink" href="#mat-elemsize" title="Permalink to this headline">¶</a></h2>
<p>Returns  the matrix element size in bytes.</p>
<dl class="function">
<dt id="size_t Mat::elemSize() const">
<strong>C++:</strong><code class="descname"> </code>size_t <code class="descclassname">Mat::</code><code class="descname">elemSize</code><span class="sig-paren">(</span><span class="sig-paren">)</span><code class="descclassname"> const</code><a class="headerlink" href="#size_t Mat::elemSize() const" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p>The method returns the matrix element size in bytes. For example, if the matrix type is <code class="docutils literal"><span class="pre">CV_16SC3</span></code> , the method returns <code class="docutils literal"><span class="pre">3*sizeof(short)</span></code> or 6.</p>
</div>
<div class="section" id="mat-elemsize1">
<h2>Mat::elemSize1<a class="headerlink" href="#mat-elemsize1" title="Permalink to this headline">¶</a></h2>
<p>Returns the size of each matrix element channel in bytes.</p>
<dl class="function">
<dt id="size_t Mat::elemSize1() const">
<strong>C++:</strong><code class="descname"> </code>size_t <code class="descclassname">Mat::</code><code class="descname">elemSize1</code><span class="sig-paren">(</span><span class="sig-paren">)</span><code class="descclassname"> const</code><a class="headerlink" href="#size_t Mat::elemSize1() const" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p>The method returns the matrix element channel size in bytes, that is, it ignores the number of channels. For example, if the matrix type is <code class="docutils literal"><span class="pre">CV_16SC3</span></code> , the method returns <code class="docutils literal"><span class="pre">sizeof(short)</span></code> or 2.</p>
</div>
<div class="section" id="mat-type">
<h2>Mat::type<a class="headerlink" href="#mat-type" title="Permalink to this headline">¶</a></h2>
<p>Returns the type of a matrix element.</p>
<dl class="function">
<dt id="int Mat::type() const">
<strong>C++:</strong><code class="descname"> </code>int <code class="descclassname">Mat::</code><code class="descname">type</code><span class="sig-paren">(</span><span class="sig-paren">)</span><code class="descclassname"> const</code><a class="headerlink" href="#int Mat::type() const" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p>The method returns a matrix element type. This is an identifier compatible with the <code class="docutils literal"><span class="pre">CvMat</span></code> type system, like <code class="docutils literal"><span class="pre">CV_16SC3</span></code> or 16-bit signed 3-channel array, and so on.</p>
</div>
<div class="section" id="mat-depth">
<h2>Mat::depth<a class="headerlink" href="#mat-depth" title="Permalink to this headline">¶</a></h2>
<p>Returns the depth of a matrix element.</p>
<dl class="function">
<dt id="int Mat::depth() const">
<strong>C++:</strong><code class="descname"> </code>int <code class="descclassname">Mat::</code><code class="descname">depth</code><span class="sig-paren">(</span><span class="sig-paren">)</span><code class="descclassname"> const</code><a class="headerlink" href="#int Mat::depth() const" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p>The method returns the identifier of the matrix element depth (the type of each individual channel). For example, for a 16-bit signed element array, the method returns <code class="docutils literal"><span class="pre">CV_16S</span></code> . A complete list of matrix types contains the following values:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">CV_8U</span></code>     - 8-bit unsigned integers ( <code class="docutils literal"><span class="pre">0..255</span></code>     )</li>
<li><code class="docutils literal"><span class="pre">CV_8S</span></code>     - 8-bit signed integers ( <code class="docutils literal"><span class="pre">-128..127</span></code>     )</li>
<li><code class="docutils literal"><span class="pre">CV_16U</span></code>     - 16-bit unsigned integers ( <code class="docutils literal"><span class="pre">0..65535</span></code>     )</li>
<li><code class="docutils literal"><span class="pre">CV_16S</span></code>     - 16-bit signed integers ( <code class="docutils literal"><span class="pre">-32768..32767</span></code>     )</li>
<li><code class="docutils literal"><span class="pre">CV_32S</span></code>     - 32-bit signed integers ( <code class="docutils literal"><span class="pre">-2147483648..2147483647</span></code>     )</li>
<li><code class="docutils literal"><span class="pre">CV_32F</span></code>     - 32-bit floating-point numbers ( <code class="docutils literal"><span class="pre">-FLT_MAX..FLT_MAX,</span> <span class="pre">INF,</span> <span class="pre">NAN</span></code>     )</li>
<li><code class="docutils literal"><span class="pre">CV_64F</span></code>     - 64-bit floating-point numbers ( <code class="docutils literal"><span class="pre">-DBL_MAX..DBL_MAX,</span> <span class="pre">INF,</span> <span class="pre">NAN</span></code>     )</li>
</ul>
</div>
<div class="section" id="mat-channels">
<h2>Mat::channels<a class="headerlink" href="#mat-channels" title="Permalink to this headline">¶</a></h2>
<p>Returns the number of matrix channels.</p>
<dl class="function">
<dt id="int Mat::channels() const">
<strong>C++:</strong><code class="descname"> </code>int <code class="descclassname">Mat::</code><code class="descname">channels</code><span class="sig-paren">(</span><span class="sig-paren">)</span><code class="descclassname"> const</code><a class="headerlink" href="#int Mat::channels() const" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p>The method returns the number of matrix channels.</p>
</div>
<div class="section" id="mat-step1">
<h2>Mat::step1<a class="headerlink" href="#mat-step1" title="Permalink to this headline">¶</a></h2>
<p>Returns a normalized step.</p>
<dl class="function">
<dt id="size_t Mat::step1(int i) const">
<strong>C++:</strong><code class="descname"> </code>size_t <code class="descclassname">Mat::</code><code class="descname">step1</code><span class="sig-paren">(</span>int <strong>i</strong>=0 <span class="sig-paren">)</span><code class="descclassname"> const</code><a class="headerlink" href="#size_t Mat::step1(int i) const" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p>The method returns a matrix step divided by
<a class="reference internal" href="#size_t Mat::elemSize1() const" title="size_t Mat::elemSize1() const"><code class="xref ocv ocv-func docutils literal"><span class="pre">Mat::elemSize1()</span></code></a> . It can be useful to quickly access an arbitrary matrix element.</p>
</div>
<div class="section" id="mat-size">
<h2>Mat::size<a class="headerlink" href="#mat-size" title="Permalink to this headline">¶</a></h2>
<p>Returns a matrix size.</p>
<dl class="function">
<dt id="Size Mat::size() const">
<strong>C++:</strong><code class="descname"> </code>Size <code class="descclassname">Mat::</code><code class="descname">size</code><span class="sig-paren">(</span><span class="sig-paren">)</span><code class="descclassname"> const</code><a class="headerlink" href="#Size Mat::size() const" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p>The method returns a matrix size: <code class="docutils literal"><span class="pre">Size(cols,</span> <span class="pre">rows)</span></code> . When the matrix is more than 2-dimensional, the returned size is (-1, -1).</p>
</div>
<div class="section" id="mat-empty">
<h2>Mat::empty<a class="headerlink" href="#mat-empty" title="Permalink to this headline">¶</a></h2>
<p>Returns <code class="docutils literal"><span class="pre">true</span></code> if the array has no elements.</p>
<dl class="function">
<dt id="bool Mat::empty() const">
<strong>C++:</strong><code class="descname"> </code>bool <code class="descclassname">Mat::</code><code class="descname">empty</code><span class="sig-paren">(</span><span class="sig-paren">)</span><code class="descclassname"> const</code><a class="headerlink" href="#bool Mat::empty() const" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p>The method returns <code class="docutils literal"><span class="pre">true</span></code> if <code class="docutils literal"><span class="pre">Mat::total()</span></code> is 0 or if <code class="docutils literal"><span class="pre">Mat::data</span></code> is NULL. Because of <code class="docutils literal"><span class="pre">pop_back()</span></code> and <code class="docutils literal"><span class="pre">resize()</span></code> methods <code class="docutils literal"><span class="pre">M.total()</span> <span class="pre">==</span> <span class="pre">0</span></code> does not imply that <code class="docutils literal"><span class="pre">M.data</span> <span class="pre">==</span> <span class="pre">NULL</span></code> .</p>
</div>
<div class="section" id="mat-ptr">
<h2>Mat::ptr<a class="headerlink" href="#mat-ptr" title="Permalink to this headline">¶</a></h2>
<p>Returns a pointer to the specified matrix row.</p>
<dl class="function">
<dt id="uchar* Mat::ptr(int i0)">
<strong>C++:</strong><code class="descname"> </code>uchar* <code class="descclassname">Mat::</code><code class="descname">ptr</code><span class="sig-paren">(</span>int <strong>i0</strong>=0<span class="sig-paren">)</span><a class="headerlink" href="#uchar* Mat::ptr(int i0)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="const uchar* Mat::ptr(int i0) const">
<strong>C++:</strong><code class="descname"> </code>const uchar* <code class="descclassname">Mat::</code><code class="descname">ptr</code><span class="sig-paren">(</span>int <strong>i0</strong>=0<span class="sig-paren">)</span><code class="descclassname"> const</code><a class="headerlink" href="#const uchar* Mat::ptr(int i0) const" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="template&lt;typename _Tp&gt; _Tp* Mat::ptr(int i0)">
<strong>C++:</strong><code class="descname"> </code>template&lt;typename _Tp&gt; _Tp* <code class="descclassname">Mat::</code><code class="descname">ptr</code><span class="sig-paren">(</span>int <strong>i0</strong>=0<span class="sig-paren">)</span><a class="headerlink" href="#template<typename _Tp> _Tp* Mat::ptr(int i0)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="template&lt;typename _Tp&gt; const _Tp* Mat::ptr(int i0) const">
<strong>C++:</strong><code class="descname"> </code>template&lt;typename _Tp&gt; const _Tp* <code class="descclassname">Mat::</code><code class="descname">ptr</code><span class="sig-paren">(</span>int <strong>i0</strong>=0<span class="sig-paren">)</span><code class="descclassname"> const</code><a class="headerlink" href="#template<typename _Tp> const _Tp* Mat::ptr(int i0) const" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>i0</strong> &#8211; A 0-based row index.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<p>The methods return <code class="docutils literal"><span class="pre">uchar*</span></code> or typed pointer to the specified matrix row. See the sample in
<a class="reference internal" href="#bool Mat::isContinuous() const" title="bool Mat::isContinuous() const"><code class="xref ocv ocv-func docutils literal"><span class="pre">Mat::isContinuous()</span></code></a> to know how to use these methods.</p>
</div>
<div class="section" id="mat-at">
<h2>Mat::at<a class="headerlink" href="#mat-at" title="Permalink to this headline">¶</a></h2>
<p>Returns a reference to the specified array element.</p>
<dl class="function">
<dt id="template&lt;typename T&gt; T&amp; Mat::at(int i) const">
<strong>C++:</strong><code class="descname"> </code>template&lt;typename T&gt; T&amp; <code class="descclassname">Mat::</code><code class="descname">at</code><span class="sig-paren">(</span>int <strong>i</strong><span class="sig-paren">)</span><code class="descclassname"> const</code><a class="headerlink" href="#template<typename T> T& Mat::at(int i) const" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="template&lt;typename T&gt; const T&amp; Mat::at(int i) const">
<strong>C++:</strong><code class="descname"> </code>template&lt;typename T&gt; const T&amp; <code class="descclassname">Mat::</code><code class="descname">at</code><span class="sig-paren">(</span>int <strong>i</strong><span class="sig-paren">)</span><code class="descclassname"> const</code><a class="headerlink" href="#template<typename T> const T& Mat::at(int i) const" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="template&lt;typename T&gt; T&amp; Mat::at(int i, int j)">
<strong>C++:</strong><code class="descname"> </code>template&lt;typename T&gt; T&amp; <code class="descclassname">Mat::</code><code class="descname">at</code><span class="sig-paren">(</span>int <strong>i</strong>, int <strong>j</strong><span class="sig-paren">)</span><a class="headerlink" href="#template<typename T> T& Mat::at(int i, int j)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="template&lt;typename T&gt; const T&amp; Mat::at(int i, int j) const">
<strong>C++:</strong><code class="descname"> </code>template&lt;typename T&gt; const T&amp; <code class="descclassname">Mat::</code><code class="descname">at</code><span class="sig-paren">(</span>int <strong>i</strong>, int <strong>j</strong><span class="sig-paren">)</span><code class="descclassname"> const</code><a class="headerlink" href="#template<typename T> const T& Mat::at(int i, int j) const" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="template&lt;typename T&gt; T&amp; Mat::at(Point pt)">
<strong>C++:</strong><code class="descname"> </code>template&lt;typename T&gt; T&amp; <code class="descclassname">Mat::</code><code class="descname">at</code><span class="sig-paren">(</span>Point <strong>pt</strong><span class="sig-paren">)</span><a class="headerlink" href="#template<typename T> T& Mat::at(Point pt)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="template&lt;typename T&gt; const T&amp; Mat::at(Point pt) const">
<strong>C++:</strong><code class="descname"> </code>template&lt;typename T&gt; const T&amp; <code class="descclassname">Mat::</code><code class="descname">at</code><span class="sig-paren">(</span>Point <strong>pt</strong><span class="sig-paren">)</span><code class="descclassname"> const</code><a class="headerlink" href="#template<typename T> const T& Mat::at(Point pt) const" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="template&lt;typename T&gt; T&amp; Mat::at(int i, int j, int k)">
<strong>C++:</strong><code class="descname"> </code>template&lt;typename T&gt; T&amp; <code class="descclassname">Mat::</code><code class="descname">at</code><span class="sig-paren">(</span>int <strong>i</strong>, int <strong>j</strong>, int <strong>k</strong><span class="sig-paren">)</span><a class="headerlink" href="#template<typename T> T& Mat::at(int i, int j, int k)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="template&lt;typename T&gt; const T&amp; Mat::at(int i, int j, int k) const">
<strong>C++:</strong><code class="descname"> </code>template&lt;typename T&gt; const T&amp; <code class="descclassname">Mat::</code><code class="descname">at</code><span class="sig-paren">(</span>int <strong>i</strong>, int <strong>j</strong>, int <strong>k</strong><span class="sig-paren">)</span><code class="descclassname"> const</code><a class="headerlink" href="#template<typename T> const T& Mat::at(int i, int j, int k) const" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="template&lt;typename T&gt; T&amp; Mat::at(const int* idx)">
<strong>C++:</strong><code class="descname"> </code>template&lt;typename T&gt; T&amp; <code class="descclassname">Mat::</code><code class="descname">at</code><span class="sig-paren">(</span>const int* <strong>idx</strong><span class="sig-paren">)</span><a class="headerlink" href="#template<typename T> T& Mat::at(const int* idx)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="template&lt;typename T&gt; const T&amp; Mat::at(const int* idx) const">
<strong>C++:</strong><code class="descname"> </code>template&lt;typename T&gt; const T&amp; <code class="descclassname">Mat::</code><code class="descname">at</code><span class="sig-paren">(</span>const int* <strong>idx</strong><span class="sig-paren">)</span><code class="descclassname"> const</code><a class="headerlink" href="#template<typename T> const T& Mat::at(const int* idx) const" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>i</strong> &#8211; Index along the dimension 0</li>
<li><strong>j</strong> &#8211; Index along the dimension 1</li>
<li><strong>k</strong> &#8211; Index along the dimension 2</li>
<li><strong>pt</strong> &#8211; Element position specified as  <code class="docutils literal"><span class="pre">Point(j,i)</span></code> .</li>
<li><strong>idx</strong> &#8211; Array of  <code class="docutils literal"><span class="pre">Mat::dims</span></code>  indices.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<p>The template methods return a reference to the specified array element. For the sake of higher performance, the index range checks are only performed in the Debug configuration.</p>
<p>Note that the variants with a single index (i) can be used to access elements of single-row or single-column 2-dimensional arrays. That is, if, for example, <code class="docutils literal"><span class="pre">A</span></code> is a <code class="docutils literal"><span class="pre">1</span> <span class="pre">x</span> <span class="pre">N</span></code> floating-point matrix and <code class="docutils literal"><span class="pre">B</span></code> is an <code class="docutils literal"><span class="pre">M</span> <span class="pre">x</span> <span class="pre">1</span></code> integer matrix, you can simply write <code class="docutils literal"><span class="pre">A.at&lt;float&gt;(k+4)</span></code> and <code class="docutils literal"><span class="pre">B.at&lt;int&gt;(2*i+1)</span></code> instead of <code class="docutils literal"><span class="pre">A.at&lt;float&gt;(0,k+4)</span></code> and <code class="docutils literal"><span class="pre">B.at&lt;int&gt;(2*i+1,0)</span></code> , respectively.</p>
<p>The example below initializes a Hilbert matrix:</p>
<div class="highlight-cpp"><div class="highlight"><pre><span class="n">Mat</span> <span class="nf">H</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="n">CV_64F</span><span class="p">);</span>
<span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">H</span><span class="p">.</span><span class="n">rows</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">H</span><span class="p">.</span><span class="n">cols</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span>
        <span class="n">H</span><span class="p">.</span><span class="n">at</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">)</span><span class="o">=</span><span class="mf">1.</span><span class="o">/</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span>
</pre></div>
</div>
</div>
<div class="section" id="mat-begin">
<h2>Mat::begin<a class="headerlink" href="#mat-begin" title="Permalink to this headline">¶</a></h2>
<p>Returns the matrix iterator and sets it to the first matrix element.</p>
<dl class="function">
<dt id="template&lt;typename _Tp&gt; MatIterator_&lt;_Tp&gt; Mat::begin()">
<strong>C++:</strong><code class="descname"> </code>template&lt;typename _Tp&gt; MatIterator_&lt;_Tp&gt; <code class="descclassname">Mat::</code><code class="descname">begin</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#template<typename _Tp> MatIterator_<_Tp> Mat::begin()" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="template&lt;typename _Tp&gt; MatConstIterator_&lt;_Tp&gt; Mat::begin() const">
<strong>C++:</strong><code class="descname"> </code>template&lt;typename _Tp&gt; MatConstIterator_&lt;_Tp&gt; <code class="descclassname">Mat::</code><code class="descname">begin</code><span class="sig-paren">(</span><span class="sig-paren">)</span><code class="descclassname"> const</code><a class="headerlink" href="#template<typename _Tp> MatConstIterator_<_Tp> Mat::begin() const" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p>The methods return the matrix read-only or read-write iterators. The use of matrix iterators is very similar to the use of bi-directional STL iterators. In the example below, the alpha blending function is rewritten using the matrix iterators:</p>
<div class="highlight-cpp"><div class="highlight"><pre><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">alphaBlendRGBA</span><span class="p">(</span><span class="k">const</span> <span class="n">Mat</span><span class="o">&amp;</span> <span class="n">src1</span><span class="p">,</span> <span class="k">const</span> <span class="n">Mat</span><span class="o">&amp;</span> <span class="n">src2</span><span class="p">,</span> <span class="n">Mat</span><span class="o">&amp;</span> <span class="n">dst</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">typedef</span> <span class="n">Vec</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">4</span><span class="o">&gt;</span> <span class="n">VT</span><span class="p">;</span>

    <span class="k">const</span> <span class="kt">float</span> <span class="n">alpha_scale</span> <span class="o">=</span> <span class="p">(</span><span class="kt">float</span><span class="p">)</span><span class="n">std</span><span class="o">::</span><span class="n">numeric_limits</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">max</span><span class="p">(),</span>
                <span class="n">inv_scale</span> <span class="o">=</span> <span class="mf">1.f</span><span class="o">/</span><span class="n">alpha_scale</span><span class="p">;</span>

    <span class="n">CV_Assert</span><span class="p">(</span> <span class="n">src1</span><span class="p">.</span><span class="n">type</span><span class="p">()</span> <span class="o">==</span> <span class="n">src2</span><span class="p">.</span><span class="n">type</span><span class="p">()</span> <span class="o">&amp;&amp;</span>
               <span class="n">src1</span><span class="p">.</span><span class="n">type</span><span class="p">()</span> <span class="o">==</span> <span class="n">DataType</span><span class="o">&lt;</span><span class="n">VT</span><span class="o">&gt;::</span><span class="n">type</span> <span class="o">&amp;&amp;</span>
               <span class="n">src1</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">==</span> <span class="n">src2</span><span class="p">.</span><span class="n">size</span><span class="p">());</span>
    <span class="n">Size</span> <span class="n">size</span> <span class="o">=</span> <span class="n">src1</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
    <span class="n">dst</span><span class="p">.</span><span class="n">create</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="n">src1</span><span class="p">.</span><span class="n">type</span><span class="p">());</span>

    <span class="n">MatConstIterator_</span><span class="o">&lt;</span><span class="n">VT</span><span class="o">&gt;</span> <span class="n">it1</span> <span class="o">=</span> <span class="n">src1</span><span class="p">.</span><span class="n">begin</span><span class="o">&lt;</span><span class="n">VT</span><span class="o">&gt;</span><span class="p">(),</span> <span class="n">it1_end</span> <span class="o">=</span> <span class="n">src1</span><span class="p">.</span><span class="n">end</span><span class="o">&lt;</span><span class="n">VT</span><span class="o">&gt;</span><span class="p">();</span>
    <span class="n">MatConstIterator_</span><span class="o">&lt;</span><span class="n">VT</span><span class="o">&gt;</span> <span class="n">it2</span> <span class="o">=</span> <span class="n">src2</span><span class="p">.</span><span class="n">begin</span><span class="o">&lt;</span><span class="n">VT</span><span class="o">&gt;</span><span class="p">();</span>
    <span class="n">MatIterator_</span><span class="o">&lt;</span><span class="n">VT</span><span class="o">&gt;</span> <span class="n">dst_it</span> <span class="o">=</span> <span class="n">dst</span><span class="p">.</span><span class="n">begin</span><span class="o">&lt;</span><span class="n">VT</span><span class="o">&gt;</span><span class="p">();</span>

    <span class="k">for</span><span class="p">(</span> <span class="p">;</span> <span class="n">it1</span> <span class="o">!=</span> <span class="n">it1_end</span><span class="p">;</span> <span class="o">++</span><span class="n">it1</span><span class="p">,</span> <span class="o">++</span><span class="n">it2</span><span class="p">,</span> <span class="o">++</span><span class="n">dst_it</span> <span class="p">)</span>
    <span class="p">{</span>
        <span class="n">VT</span> <span class="n">pix1</span> <span class="o">=</span> <span class="o">*</span><span class="n">it1</span><span class="p">,</span> <span class="n">pix2</span> <span class="o">=</span> <span class="o">*</span><span class="n">it2</span><span class="p">;</span>
        <span class="kt">float</span> <span class="n">alpha</span> <span class="o">=</span> <span class="n">pix1</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="o">*</span><span class="n">inv_scale</span><span class="p">,</span> <span class="n">beta</span> <span class="o">=</span> <span class="n">pix2</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="o">*</span><span class="n">inv_scale</span><span class="p">;</span>
        <span class="o">*</span><span class="n">dst_it</span> <span class="o">=</span> <span class="n">VT</span><span class="p">(</span><span class="n">saturate_cast</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">pix1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">alpha</span> <span class="o">+</span> <span class="n">pix2</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">beta</span><span class="p">),</span>
                     <span class="n">saturate_cast</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">pix1</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">alpha</span> <span class="o">+</span> <span class="n">pix2</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">beta</span><span class="p">),</span>
                     <span class="n">saturate_cast</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">pix1</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">*</span><span class="n">alpha</span> <span class="o">+</span> <span class="n">pix2</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">*</span><span class="n">beta</span><span class="p">),</span>
                     <span class="n">saturate_cast</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">((</span><span class="mi">1</span> <span class="o">-</span> <span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">alpha</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">beta</span><span class="p">))</span><span class="o">*</span><span class="n">alpha_scale</span><span class="p">));</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="mat-end">
<h2>Mat::end<a class="headerlink" href="#mat-end" title="Permalink to this headline">¶</a></h2>
<p>Returns the matrix iterator and sets it to the after-last matrix element.</p>
<dl class="function">
<dt id="template&lt;typename _Tp&gt; MatIterator_&lt;_Tp&gt; Mat::end()">
<strong>C++:</strong><code class="descname"> </code>template&lt;typename _Tp&gt; MatIterator_&lt;_Tp&gt; <code class="descclassname">Mat::</code><code class="descname">end</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#template<typename _Tp> MatIterator_<_Tp> Mat::end()" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="template&lt;typename _Tp&gt; MatConstIterator_&lt;_Tp&gt; Mat::end() const">
<strong>C++:</strong><code class="descname"> </code>template&lt;typename _Tp&gt; MatConstIterator_&lt;_Tp&gt; <code class="descclassname">Mat::</code><code class="descname">end</code><span class="sig-paren">(</span><span class="sig-paren">)</span><code class="descclassname"> const</code><a class="headerlink" href="#template<typename _Tp> MatConstIterator_<_Tp> Mat::end() const" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p>The methods return the matrix read-only or read-write iterators, set to the point following the last matrix element.</p>
</div>
<div class="section" id="id7">
<h2>Mat_<a class="headerlink" href="#id7" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="Mat_">
<em class="property">class </em><code class="descname">Mat_</code><a class="headerlink" href="#Mat_" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p>Template matrix class derived from
<a class="reference internal" href="#Mat" title="class Mat"><code class="xref ocv ocv-class docutils literal"><span class="pre">Mat</span></code></a> .</p>
<div class="highlight-cpp"><div class="highlight"><pre><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">_Tp</span><span class="o">&gt;</span> <span class="k">class</span> <span class="nc">Mat_</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Mat</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="c1">// ... some specific methods</span>
    <span class="c1">//         and</span>
    <span class="c1">// no new extra fields</span>
<span class="p">};</span>
</pre></div>
</div>
<p>The class <code class="docutils literal"><span class="pre">Mat_&lt;_Tp&gt;</span></code> is a &#8220;thin&#8221; template wrapper on top of the <code class="docutils literal"><span class="pre">Mat</span></code> class. It does not have any extra data fields. Nor this class nor <code class="docutils literal"><span class="pre">Mat</span></code> has any virtual methods. Thus, references or pointers to these two classes can be freely but carefully converted one to another. For example:</p>
<div class="highlight-cpp"><div class="highlight"><pre><span class="c1">// create a 100x100 8-bit matrix</span>
<span class="n">Mat</span> <span class="nf">M</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span><span class="mi">100</span><span class="p">,</span><span class="n">CV_8U</span><span class="p">);</span>
<span class="c1">// this will be compiled fine. no any data conversion will be done.</span>
<span class="n">Mat_</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;&amp;</span> <span class="n">M1</span> <span class="o">=</span> <span class="p">(</span><span class="n">Mat_</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;&amp;</span><span class="p">)</span><span class="n">M</span><span class="p">;</span>
<span class="c1">// the program is likely to crash at the statement below</span>
<span class="n">M1</span><span class="p">(</span><span class="mi">99</span><span class="p">,</span><span class="mi">99</span><span class="p">)</span> <span class="o">=</span> <span class="mf">1.f</span><span class="p">;</span>
</pre></div>
</div>
<p>While <code class="docutils literal"><span class="pre">Mat</span></code> is sufficient in most cases, <code class="docutils literal"><span class="pre">Mat_</span></code> can be more convenient if you use a lot of element access operations and if you know matrix type at the compilation time. Note that <code class="docutils literal"><span class="pre">Mat::at&lt;_Tp&gt;(int</span> <span class="pre">y,</span> <span class="pre">int</span> <span class="pre">x)</span></code> and <code class="docutils literal"><span class="pre">Mat_&lt;_Tp&gt;::operator</span> <span class="pre">()(int</span> <span class="pre">y,</span> <span class="pre">int</span> <span class="pre">x)</span></code> do absolutely the same and run at the same speed, but the latter is certainly shorter:</p>
<div class="highlight-cpp"><div class="highlight"><pre><span class="n">Mat_</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span> <span class="n">M</span><span class="p">(</span><span class="mi">20</span><span class="p">,</span><span class="mi">20</span><span class="p">);</span>
<span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">M</span><span class="p">.</span><span class="n">rows</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">M</span><span class="p">.</span><span class="n">cols</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span>
        <span class="n">M</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">)</span> <span class="o">=</span> <span class="mf">1.</span><span class="o">/</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span>
<span class="n">Mat</span> <span class="n">E</span><span class="p">,</span> <span class="n">V</span><span class="p">;</span>
<span class="n">eigen</span><span class="p">(</span><span class="n">M</span><span class="p">,</span><span class="n">E</span><span class="p">,</span><span class="n">V</span><span class="p">);</span>
<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">E</span><span class="p">.</span><span class="n">at</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span><span class="o">/</span><span class="n">E</span><span class="p">.</span><span class="n">at</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="p">(</span><span class="n">M</span><span class="p">.</span><span class="n">rows</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">);</span>
</pre></div>
</div>
<p>To use <code class="docutils literal"><span class="pre">Mat_</span></code> for multi-channel images/matrices, pass <code class="docutils literal"><span class="pre">Vec</span></code> as a <code class="docutils literal"><span class="pre">Mat_</span></code> parameter:</p>
<div class="highlight-cpp"><div class="highlight"><pre><span class="c1">// allocate a 320x240 color image and fill it with green (in RGB space)</span>
<span class="n">Mat_</span><span class="o">&lt;</span><span class="n">Vec3b</span><span class="o">&gt;</span> <span class="n">img</span><span class="p">(</span><span class="mi">240</span><span class="p">,</span> <span class="mi">320</span><span class="p">,</span> <span class="n">Vec3b</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">255</span><span class="p">,</span><span class="mi">0</span><span class="p">));</span>
<span class="c1">// now draw a diagonal white line</span>
<span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">100</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="n">img</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">i</span><span class="p">)</span><span class="o">=</span><span class="n">Vec3b</span><span class="p">(</span><span class="mi">255</span><span class="p">,</span><span class="mi">255</span><span class="p">,</span><span class="mi">255</span><span class="p">);</span>
<span class="c1">// and now scramble the 2nd (red) channel of each pixel</span>
<span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">img</span><span class="p">.</span><span class="n">rows</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">img</span><span class="p">.</span><span class="n">cols</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span>
        <span class="n">img</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">)[</span><span class="mi">2</span><span class="p">]</span> <span class="o">^=</span> <span class="p">(</span><span class="n">uchar</span><span class="p">)(</span><span class="n">i</span> <span class="o">^</span> <span class="n">j</span><span class="p">);</span>
</pre></div>
</div>
</div>
<div class="section" id="inputarray">
<h2>InputArray<a class="headerlink" href="#inputarray" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="InputArray">
<em class="property">class </em><code class="descname">InputArray</code><a class="headerlink" href="#InputArray" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p>This is the proxy class for passing read-only input arrays into OpenCV functions. It is defined as</p>
<div class="highlight-cpp"><div class="highlight"><pre><span class="k">typedef</span> <span class="k">const</span> <span class="n">_InputArray</span><span class="o">&amp;</span> <span class="n">InputArray</span><span class="p">;</span>
</pre></div>
</div>
<p>where <code class="docutils literal"><span class="pre">_InputArray</span></code> is a class that can be constructed from <code class="docutils literal"><span class="pre">Mat</span></code>, <code class="docutils literal"><span class="pre">Mat_&lt;T&gt;</span></code>, <code class="docutils literal"><span class="pre">Matx&lt;T,</span> <span class="pre">m,</span> <span class="pre">n&gt;</span></code>, <code class="docutils literal"><span class="pre">std::vector&lt;T&gt;</span></code>, <code class="docutils literal"><span class="pre">std::vector&lt;std::vector&lt;T&gt;</span> <span class="pre">&gt;</span></code> or <code class="docutils literal"><span class="pre">std::vector&lt;Mat&gt;</span></code>. It can also be constructed from a matrix expression.</p>
<p>Since this is mostly implementation-level class, and its interface may change in future versions, we do not describe it in details. There are a few key things, though, that should be kept in mind:</p>
<blockquote>
<div><ul class="simple">
<li>When you see in the reference manual or in OpenCV source code a function that takes <code class="docutils literal"><span class="pre">InputArray</span></code>, it means that you can actually pass <code class="docutils literal"><span class="pre">Mat</span></code>, <code class="docutils literal"><span class="pre">Matx</span></code>, <code class="docutils literal"><span class="pre">vector&lt;T&gt;</span></code> etc. (see above the complete list).</li>
<li>Optional input arguments: If some of the input arrays may be empty, pass <code class="docutils literal"><span class="pre">cv::noArray()</span></code> (or simply <code class="docutils literal"><span class="pre">cv::Mat()</span></code> as you probably did before).</li>
<li>The class is designed solely for passing parameters. That is, normally you <em>should not</em> declare class members, local and global variables of this type.</li>
<li>If you want to design your own function or a class method that can operate of arrays of multiple types, you can use <code class="docutils literal"><span class="pre">InputArray</span></code> (or <code class="docutils literal"><span class="pre">OutputArray</span></code>) for the respective parameters. Inside a function you should use <code class="docutils literal"><span class="pre">_InputArray::getMat()</span></code> method to construct a matrix header for the array (without copying data). <code class="docutils literal"><span class="pre">_InputArray::kind()</span></code> can be used to distinguish <code class="docutils literal"><span class="pre">Mat</span></code> from <code class="docutils literal"><span class="pre">vector&lt;&gt;</span></code> etc., but normally it is not needed.</li>
</ul>
</div></blockquote>
<p>Here is how you can use a function that takes <code class="docutils literal"><span class="pre">InputArray</span></code></p>
<div class="highlight-cpp"><div class="highlight"><pre><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Point2f</span><span class="o">&gt;</span> <span class="n">vec</span><span class="p">;</span>
<span class="c1">// points or a circle</span>
<span class="k">for</span><span class="p">(</span> <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">30</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span> <span class="p">)</span>
    <span class="n">vec</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">Point2f</span><span class="p">((</span><span class="kt">float</span><span class="p">)(</span><span class="mi">100</span> <span class="o">+</span> <span class="mi">30</span><span class="o">*</span><span class="n">cos</span><span class="p">(</span><span class="n">i</span><span class="o">*</span><span class="n">CV_PI</span><span class="o">*</span><span class="mi">2</span><span class="o">/</span><span class="mi">5</span><span class="p">)),</span>
                          <span class="p">(</span><span class="kt">float</span><span class="p">)(</span><span class="mi">100</span> <span class="o">-</span> <span class="mi">30</span><span class="o">*</span><span class="n">sin</span><span class="p">(</span><span class="n">i</span><span class="o">*</span><span class="n">CV_PI</span><span class="o">*</span><span class="mi">2</span><span class="o">/</span><span class="mi">5</span><span class="p">))));</span>
<span class="n">cv</span><span class="o">::</span><span class="n">transform</span><span class="p">(</span><span class="n">vec</span><span class="p">,</span> <span class="n">vec</span><span class="p">,</span> <span class="n">cv</span><span class="o">::</span><span class="n">Matx23f</span><span class="p">(</span><span class="mf">0.707</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.707</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mf">0.707</span><span class="p">,</span> <span class="mf">0.707</span><span class="p">,</span> <span class="mi">20</span><span class="p">));</span>
</pre></div>
</div>
<p>That is, we form an STL vector containing points, and apply in-place affine transformation to the vector using the 2x3 matrix created inline as <code class="docutils literal"><span class="pre">Matx&lt;float,</span> <span class="pre">2,</span> <span class="pre">3&gt;</span></code> instance.</p>
<p>Here is how such a function can be implemented (for simplicity, we implement a very specific case of it, according to the assertion statement inside)</p>
<div class="highlight-cpp"><div class="highlight"><pre><span class="kt">void</span> <span class="nf">myAffineTransform</span><span class="p">(</span><span class="n">InputArray</span> <span class="n">_src</span><span class="p">,</span> <span class="n">OutputArray</span> <span class="n">_dst</span><span class="p">,</span> <span class="n">InputArray</span> <span class="n">_m</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// get Mat headers for input arrays. This is O(1) operation,</span>
    <span class="c1">// unless _src and/or _m are matrix expressions.</span>
    <span class="n">Mat</span> <span class="n">src</span> <span class="o">=</span> <span class="n">_src</span><span class="p">.</span><span class="n">getMat</span><span class="p">(),</span> <span class="n">m</span> <span class="o">=</span> <span class="n">_m</span><span class="p">.</span><span class="n">getMat</span><span class="p">();</span>
    <span class="n">CV_Assert</span><span class="p">(</span> <span class="n">src</span><span class="p">.</span><span class="n">type</span><span class="p">()</span> <span class="o">==</span> <span class="n">CV_32FC2</span> <span class="o">&amp;&amp;</span> <span class="n">m</span><span class="p">.</span><span class="n">type</span><span class="p">()</span> <span class="o">==</span> <span class="n">CV_32F</span> <span class="o">&amp;&amp;</span> <span class="n">m</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">==</span> <span class="n">Size</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="p">);</span>

    <span class="c1">// [re]create the output array so that it has the proper size and type.</span>
    <span class="c1">// In case of Mat it calls Mat::create, in case of STL vector it calls vector::resize.</span>
    <span class="n">_dst</span><span class="p">.</span><span class="n">create</span><span class="p">(</span><span class="n">src</span><span class="p">.</span><span class="n">size</span><span class="p">(),</span> <span class="n">src</span><span class="p">.</span><span class="n">type</span><span class="p">());</span>
    <span class="n">Mat</span> <span class="n">dst</span> <span class="o">=</span> <span class="n">_dst</span><span class="p">.</span><span class="n">getMat</span><span class="p">();</span>

    <span class="k">for</span><span class="p">(</span> <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">src</span><span class="p">.</span><span class="n">rows</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span> <span class="p">)</span>
        <span class="k">for</span><span class="p">(</span> <span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">src</span><span class="p">.</span><span class="n">cols</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span> <span class="p">)</span>
        <span class="p">{</span>
            <span class="n">Point2f</span> <span class="n">pt</span> <span class="o">=</span> <span class="n">src</span><span class="p">.</span><span class="n">at</span><span class="o">&lt;</span><span class="n">Point2f</span><span class="o">&gt;</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">);</span>
            <span class="n">dst</span><span class="p">.</span><span class="n">at</span><span class="o">&lt;</span><span class="n">Point2f</span><span class="o">&gt;</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span> <span class="o">=</span> <span class="n">Point2f</span><span class="p">(</span><span class="n">m</span><span class="p">.</span><span class="n">at</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span><span class="o">*</span><span class="n">pt</span><span class="p">.</span><span class="n">x</span> <span class="o">+</span>
                                            <span class="n">m</span><span class="p">.</span><span class="n">at</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">pt</span><span class="p">.</span><span class="n">y</span> <span class="o">+</span>
                                            <span class="n">m</span><span class="p">.</span><span class="n">at</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span>
                                            <span class="n">m</span><span class="p">.</span><span class="n">at</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span><span class="o">*</span><span class="n">pt</span><span class="p">.</span><span class="n">x</span> <span class="o">+</span>
                                            <span class="n">m</span><span class="p">.</span><span class="n">at</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">pt</span><span class="p">.</span><span class="n">y</span> <span class="o">+</span>
                                            <span class="n">m</span><span class="p">.</span><span class="n">at</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">));</span>
        <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>There is another related type, <code class="docutils literal"><span class="pre">InputArrayOfArrays</span></code>, which is currently defined as a synonym for <code class="docutils literal"><span class="pre">InputArray</span></code>:</p>
<div class="highlight-cpp"><div class="highlight"><pre><span class="k">typedef</span> <span class="n">InputArray</span> <span class="n">InputArrayOfArrays</span><span class="p">;</span>
</pre></div>
</div>
<p>It denotes function arguments that are either vectors of vectors or vectors of matrices. A separate synonym is needed to generate Python/Java etc. wrappers properly. At the function implementation level their use is similar, but <code class="docutils literal"><span class="pre">_InputArray::getMat(idx)</span></code> should be used to get header for the idx-th component of the outer vector and <code class="docutils literal"><span class="pre">_InputArray::size().area()</span></code> should be used to find the number of components (vectors/matrices) of the outer vector.</p>
</div>
<div class="section" id="outputarray">
<h2>OutputArray<a class="headerlink" href="#outputarray" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="OutputArray : public InputArray">
<em class="property">class </em><code class="descname">OutputArray</code> : <em class="property">public</em> <code class="descname">InputArray</code><a class="headerlink" href="#OutputArray : public InputArray" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p>This type is very similar to <code class="docutils literal"><span class="pre">InputArray</span></code> except that it is used for input/output and output function parameters. Just like with <code class="docutils literal"><span class="pre">InputArray</span></code>, OpenCV users should not care about <code class="docutils literal"><span class="pre">OutputArray</span></code>, they just pass <code class="docutils literal"><span class="pre">Mat</span></code>, <code class="docutils literal"><span class="pre">vector&lt;T&gt;</span></code> etc. to the functions. The same limitation as for <code class="docutils literal"><span class="pre">InputArray</span></code>: <strong>Do not explicitly create OutputArray instances</strong> applies here too.</p>
<p>If you want to make your function polymorphic (i.e. accept different arrays as output parameters), it is also not very difficult. Take the sample above as the reference. Note that <code class="docutils literal"><span class="pre">_OutputArray::create()</span></code> needs to be called before <code class="docutils literal"><span class="pre">_OutputArray::getMat()</span></code>. This way you guarantee that the output array is properly allocated.</p>
<p>Optional output parameters. If you do not need certain output array to be computed and returned to you, pass <code class="docutils literal"><span class="pre">cv::noArray()</span></code>, just like you would in the case of optional input array. At the implementation level, use <code class="docutils literal"><span class="pre">_OutputArray::needed()</span></code> to check if certain output array needs to be computed or not.</p>
<p>There are several synonyms for <code class="docutils literal"><span class="pre">OutputArray</span></code> that are used to assist automatic Python/Java/... wrapper generators:</p>
<div class="highlight-cpp"><div class="highlight"><pre><span class="k">typedef</span> <span class="n">OutputArray</span> <span class="n">OutputArrayOfArrays</span><span class="p">;</span>
<span class="k">typedef</span> <span class="n">OutputArray</span> <span class="n">InputOutputArray</span><span class="p">;</span>
<span class="k">typedef</span> <span class="n">OutputArray</span> <span class="n">InputOutputArrayOfArrays</span><span class="p">;</span>
</pre></div>
</div>
</div>
<div class="section" id="narymatiterator">
<h2>NAryMatIterator<a class="headerlink" href="#narymatiterator" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="NAryMatIterator">
<em class="property">class </em><code class="descname">NAryMatIterator</code><a class="headerlink" href="#NAryMatIterator" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p>n-ary multi-dimensional array iterator.</p>
<div class="highlight-cpp"><div class="highlight"><pre><span class="k">class</span> <span class="nc">CV_EXPORTS</span> <span class="n">NAryMatIterator</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="c1">//! the default constructor</span>
    <span class="n">NAryMatIterator</span><span class="p">();</span>
    <span class="c1">//! the full constructor taking arbitrary number of n-dim matrices</span>
    <span class="n">NAryMatIterator</span><span class="p">(</span><span class="k">const</span> <span class="n">Mat</span><span class="o">**</span> <span class="n">arrays</span><span class="p">,</span> <span class="n">Mat</span><span class="o">*</span> <span class="n">planes</span><span class="p">,</span> <span class="kt">int</span> <span class="n">narrays</span><span class="o">=-</span><span class="mi">1</span><span class="p">);</span>
    <span class="c1">//! the separate iterator initialization method</span>
    <span class="kt">void</span> <span class="nf">init</span><span class="p">(</span><span class="k">const</span> <span class="n">Mat</span><span class="o">**</span> <span class="n">arrays</span><span class="p">,</span> <span class="n">Mat</span><span class="o">*</span> <span class="n">planes</span><span class="p">,</span> <span class="kt">int</span> <span class="n">narrays</span><span class="o">=-</span><span class="mi">1</span><span class="p">);</span>

    <span class="c1">//! proceeds to the next plane of every iterated matrix</span>
    <span class="n">NAryMatIterator</span><span class="o">&amp;</span> <span class="k">operator</span> <span class="o">++</span><span class="p">();</span>
    <span class="c1">//! proceeds to the next plane of every iterated matrix (postfix increment operator)</span>
    <span class="n">NAryMatIterator</span> <span class="k">operator</span> <span class="o">++</span><span class="p">(</span><span class="kt">int</span><span class="p">);</span>

    <span class="p">...</span>
    <span class="kt">int</span> <span class="n">nplanes</span><span class="p">;</span> <span class="c1">// the total number of planes</span>
<span class="p">};</span>
</pre></div>
</div>
<p>Use the class to implement unary, binary, and, generally, n-ary element-wise operations on multi-dimensional arrays. Some of the arguments of an n-ary function may be continuous arrays, some may be not. It is possible to use conventional
<code class="docutils literal"><span class="pre">MatIterator</span></code> &#8216;s for each array but incrementing all of the iterators after each small operations may be a big overhead. In this case consider using <code class="docutils literal"><span class="pre">NAryMatIterator</span></code> to iterate through several matrices simultaneously as long as they have the same geometry (dimensionality and all the dimension sizes are the same). It iterates through the slices (or planes), not the elements, where &#8220;slice&#8221; is a continuous part of the arrays. On each iteration <code class="docutils literal"><span class="pre">it.planes[0]</span></code>, <code class="docutils literal"><span class="pre">it.planes[1]</span></code> , ... will be the slices of the corresponding matrices.</p>
<p>The example below illustrates how you can compute a normalized and threshold 3D color histogram:</p>
<div class="highlight-cpp"><div class="highlight"><pre><span class="kt">void</span> <span class="nf">computeNormalizedColorHist</span><span class="p">(</span><span class="k">const</span> <span class="n">Mat</span><span class="o">&amp;</span> <span class="n">image</span><span class="p">,</span> <span class="n">Mat</span><span class="o">&amp;</span> <span class="n">hist</span><span class="p">,</span> <span class="kt">int</span> <span class="n">N</span><span class="p">,</span> <span class="kt">double</span> <span class="n">minProb</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">const</span> <span class="kt">int</span> <span class="n">histSize</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span><span class="n">N</span><span class="p">,</span> <span class="n">N</span><span class="p">,</span> <span class="n">N</span><span class="p">};</span>

    <span class="c1">// make sure that the histogram has a proper size and type</span>
    <span class="n">hist</span><span class="p">.</span><span class="n">create</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">histSize</span><span class="p">,</span> <span class="n">CV_32F</span><span class="p">);</span>

    <span class="c1">// and clear it</span>
    <span class="n">hist</span> <span class="o">=</span> <span class="n">Scalar</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>

    <span class="c1">// the loop below assumes that the image</span>
    <span class="c1">// is a 8-bit 3-channel. check it.</span>
    <span class="n">CV_Assert</span><span class="p">(</span><span class="n">image</span><span class="p">.</span><span class="n">type</span><span class="p">()</span> <span class="o">==</span> <span class="n">CV_8UC3</span><span class="p">);</span>
    <span class="n">MatConstIterator_</span><span class="o">&lt;</span><span class="n">Vec3b</span><span class="o">&gt;</span> <span class="n">it</span> <span class="o">=</span> <span class="n">image</span><span class="p">.</span><span class="n">begin</span><span class="o">&lt;</span><span class="n">Vec3b</span><span class="o">&gt;</span><span class="p">(),</span>
                             <span class="n">it_end</span> <span class="o">=</span> <span class="n">image</span><span class="p">.</span><span class="n">end</span><span class="o">&lt;</span><span class="n">Vec3b</span><span class="o">&gt;</span><span class="p">();</span>
    <span class="k">for</span><span class="p">(</span> <span class="p">;</span> <span class="n">it</span> <span class="o">!=</span> <span class="n">it_end</span><span class="p">;</span> <span class="o">++</span><span class="n">it</span> <span class="p">)</span>
    <span class="p">{</span>
        <span class="k">const</span> <span class="n">Vec3b</span><span class="o">&amp;</span> <span class="n">pix</span> <span class="o">=</span> <span class="o">*</span><span class="n">it</span><span class="p">;</span>
        <span class="n">hist</span><span class="p">.</span><span class="n">at</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span><span class="p">(</span><span class="n">pix</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">N</span><span class="o">/</span><span class="mi">256</span><span class="p">,</span> <span class="n">pix</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">N</span><span class="o">/</span><span class="mi">256</span><span class="p">,</span> <span class="n">pix</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">*</span><span class="n">N</span><span class="o">/</span><span class="mi">256</span><span class="p">)</span> <span class="o">+=</span> <span class="mf">1.f</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">minProb</span> <span class="o">*=</span> <span class="n">image</span><span class="p">.</span><span class="n">rows</span><span class="o">*</span><span class="n">image</span><span class="p">.</span><span class="n">cols</span><span class="p">;</span>

    <span class="c1">// intialize iterator (the style is different from STL).</span>
    <span class="c1">// after initialization the iterator will contain</span>
    <span class="c1">// the number of slices or planes the iterator will go through.</span>
    <span class="c1">// it simultaneously increments iterators for several matrices</span>
    <span class="c1">// supplied as a null terminated list of pointers</span>
    <span class="k">const</span> <span class="n">Mat</span><span class="o">*</span> <span class="n">arrays</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span><span class="o">&amp;</span><span class="n">hist</span><span class="p">,</span> <span class="mi">0</span><span class="p">};</span>
    <span class="n">Mat</span> <span class="n">planes</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
    <span class="n">NAryMatIterator</span> <span class="n">itNAry</span><span class="p">(</span><span class="n">arrays</span><span class="p">,</span> <span class="n">planes</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
    <span class="kt">double</span> <span class="n">s</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="c1">// iterate through the matrix. on each iteration</span>
    <span class="c1">// itNAry.planes[i] (of type Mat) will be set to the current plane</span>
    <span class="c1">// of the i-th n-dim matrix passed to the iterator constructor.</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">p</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">p</span> <span class="o">&lt;</span> <span class="n">itNAry</span><span class="p">.</span><span class="n">nplanes</span><span class="p">;</span> <span class="n">p</span><span class="o">++</span><span class="p">,</span> <span class="o">++</span><span class="n">itNAry</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">threshold</span><span class="p">(</span><span class="n">itNAry</span><span class="p">.</span><span class="n">planes</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">itNAry</span><span class="p">.</span><span class="n">planes</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">minProb</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">THRESH_TOZERO</span><span class="p">);</span>
        <span class="n">s</span> <span class="o">+=</span> <span class="n">sum</span><span class="p">(</span><span class="n">itNAry</span><span class="p">.</span><span class="n">planes</span><span class="p">[</span><span class="mi">0</span><span class="p">])[</span><span class="mi">0</span><span class="p">];</span>
    <span class="p">}</span>

    <span class="n">s</span> <span class="o">=</span> <span class="mf">1.</span><span class="o">/</span><span class="n">s</span><span class="p">;</span>
    <span class="n">itNAry</span> <span class="o">=</span> <span class="n">NAryMatIterator</span><span class="p">(</span><span class="n">arrays</span><span class="p">,</span> <span class="n">planes</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">p</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">p</span> <span class="o">&lt;</span> <span class="n">itNAry</span><span class="p">.</span><span class="n">nplanes</span><span class="p">;</span> <span class="n">p</span><span class="o">++</span><span class="p">,</span> <span class="o">++</span><span class="n">itNAry</span><span class="p">)</span>
        <span class="n">itNAry</span><span class="p">.</span><span class="n">planes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*=</span> <span class="n">s</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="sparsemat">
<h2>SparseMat<a class="headerlink" href="#sparsemat" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="SparseMat">
<em class="property">class </em><code class="descname">SparseMat</code><a class="headerlink" href="#SparseMat" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p>The class <code class="docutils literal"><span class="pre">SparseMat</span></code> represents multi-dimensional sparse numerical arrays. Such a sparse array can store elements of any type that
<a class="reference internal" href="#Mat" title="class Mat"><code class="xref ocv ocv-class docutils literal"><span class="pre">Mat</span></code></a> can store. <em>Sparse</em> means that only non-zero elements are stored (though, as a result of operations on a sparse matrix, some of its stored elements can actually become 0. It is up to you to detect such elements and delete them using <code class="docutils literal"><span class="pre">SparseMat::erase</span></code> ). The non-zero elements are stored in a hash table that grows when it is filled so that the search time is O(1) in average (regardless of whether element is there or not). Elements can be accessed using the following methods:</p>
<ul>
<li><p class="first">Query operations (<code class="docutils literal"><span class="pre">SparseMat::ptr</span></code> and the higher-level <code class="docutils literal"><span class="pre">SparseMat::ref</span></code>, <code class="docutils literal"><span class="pre">SparseMat::value</span></code> and <code class="docutils literal"><span class="pre">SparseMat::find</span></code>), for example:</p>
<div class="highlight-cpp"><div class="highlight"><pre><span class="k">const</span> <span class="kt">int</span> <span class="n">dims</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">size</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">};</span>
<span class="n">SparseMat</span> <span class="nf">sparse_mat</span><span class="p">(</span><span class="n">dims</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">CV_32F</span><span class="p">);</span>
<span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">1000</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">idx</span><span class="p">[</span><span class="n">dims</span><span class="p">];</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">k</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">k</span> <span class="o">&lt;</span> <span class="n">dims</span><span class="p">;</span> <span class="n">k</span><span class="o">++</span><span class="p">)</span>
        <span class="n">idx</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">rand</span><span class="p">()</span>
    <span class="n">sparse_mat</span><span class="p">.</span><span class="n">ref</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span> <span class="o">+=</span> <span class="mf">1.f</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</li>
<li><p class="first">Sparse matrix iterators. They are similar to <code class="docutils literal"><span class="pre">MatIterator</span></code> but different from <a class="reference internal" href="#NAryMatIterator" title="class NAryMatIterator"><code class="xref ocv ocv-class docutils literal"><span class="pre">NAryMatIterator</span></code></a>. That is, the iteration loop is familiar to STL users:</p>
<div class="highlight-cpp"><div class="highlight"><pre><span class="c1">// prints elements of a sparse floating-point matrix</span>
<span class="c1">// and the sum of elements.</span>
<span class="n">SparseMatConstIterator_</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span>
    <span class="n">it</span> <span class="o">=</span> <span class="n">sparse_mat</span><span class="p">.</span><span class="n">begin</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span><span class="p">(),</span>
    <span class="n">it_end</span> <span class="o">=</span> <span class="n">sparse_mat</span><span class="p">.</span><span class="n">end</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span><span class="p">();</span>
<span class="kt">double</span> <span class="n">s</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">dims</span> <span class="o">=</span> <span class="n">sparse_mat</span><span class="p">.</span><span class="n">dims</span><span class="p">();</span>
<span class="k">for</span><span class="p">(;</span> <span class="n">it</span> <span class="o">!=</span> <span class="n">it_end</span><span class="p">;</span> <span class="o">++</span><span class="n">it</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// print element indices and the element value</span>
    <span class="k">const</span> <span class="n">SparseMat</span><span class="o">::</span><span class="n">Node</span><span class="o">*</span> <span class="n">n</span> <span class="o">=</span> <span class="n">it</span><span class="p">.</span><span class="n">node</span><span class="p">();</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;(&quot;</span><span class="p">);</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">dims</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d%s&quot;</span><span class="p">,</span> <span class="n">n</span><span class="o">-&gt;</span><span class="n">idx</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">dims</span><span class="o">-</span><span class="mi">1</span> <span class="o">?</span> <span class="s">&quot;, &quot;</span> <span class="o">:</span> <span class="s">&quot;)&quot;</span><span class="p">);</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;: %g</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">it</span><span class="p">.</span><span class="n">value</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span><span class="p">());</span>
    <span class="n">s</span> <span class="o">+=</span> <span class="o">*</span><span class="n">it</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">printf</span><span class="p">(</span><span class="s">&quot;Element sum is %g</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">s</span><span class="p">);</span>
</pre></div>
</div>
<p>If you run this loop, you will notice that elements are not enumerated in a logical order (lexicographical, and so on). They come in the same order as they are stored in the hash table (semi-randomly). You may collect pointers to the nodes and sort them to get the proper ordering. Note, however, that pointers to the nodes may become invalid when you add more elements to the matrix. This may happen due to possible buffer reallocation.</p>
</li>
<li><p class="first">Combination of the above 2 methods when you need to process 2 or more sparse matrices simultaneously. For example, this is how you can compute unnormalized cross-correlation of the 2 floating-point sparse matrices:</p>
<div class="highlight-cpp"><div class="highlight"><pre><span class="kt">double</span> <span class="nf">cross_corr</span><span class="p">(</span><span class="k">const</span> <span class="n">SparseMat</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">SparseMat</span><span class="o">&amp;</span> <span class="n">b</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">const</span> <span class="n">SparseMat</span> <span class="o">*</span><span class="n">_a</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">,</span> <span class="o">*</span><span class="n">_b</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">b</span><span class="p">;</span>
    <span class="c1">// if b contains less elements than a,</span>
    <span class="c1">// it is faster to iterate through b</span>
    <span class="k">if</span><span class="p">(</span><span class="n">_a</span><span class="o">-&gt;</span><span class="n">nzcount</span><span class="p">()</span> <span class="o">&gt;</span> <span class="n">_b</span><span class="o">-&gt;</span><span class="n">nzcount</span><span class="p">())</span>
        <span class="n">std</span><span class="o">::</span><span class="n">swap</span><span class="p">(</span><span class="n">_a</span><span class="p">,</span> <span class="n">_b</span><span class="p">);</span>
    <span class="n">SparseMatConstIterator_</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span> <span class="n">it</span> <span class="o">=</span> <span class="n">_a</span><span class="o">-&gt;</span><span class="n">begin</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span><span class="p">(),</span>
                                   <span class="n">it_end</span> <span class="o">=</span> <span class="n">_a</span><span class="o">-&gt;</span><span class="n">end</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span><span class="p">();</span>
    <span class="kt">double</span> <span class="n">ccorr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">for</span><span class="p">(;</span> <span class="n">it</span> <span class="o">!=</span> <span class="n">it_end</span><span class="p">;</span> <span class="o">++</span><span class="n">it</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="c1">// take the next element from the first matrix</span>
        <span class="kt">float</span> <span class="n">avalue</span> <span class="o">=</span> <span class="o">*</span><span class="n">it</span><span class="p">;</span>
        <span class="k">const</span> <span class="n">Node</span><span class="o">*</span> <span class="n">anode</span> <span class="o">=</span> <span class="n">it</span><span class="p">.</span><span class="n">node</span><span class="p">();</span>
        <span class="c1">// and try to find an element with the same index in the second matrix.</span>
        <span class="c1">// since the hash value depends only on the element index,</span>
        <span class="c1">// reuse the hash value stored in the node</span>
        <span class="kt">float</span> <span class="n">bvalue</span> <span class="o">=</span> <span class="n">_b</span><span class="o">-&gt;</span><span class="n">value</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span><span class="p">(</span><span class="n">anode</span><span class="o">-&gt;</span><span class="n">idx</span><span class="p">,</span><span class="o">&amp;</span><span class="n">anode</span><span class="o">-&gt;</span><span class="n">hashval</span><span class="p">);</span>
        <span class="n">ccorr</span> <span class="o">+=</span> <span class="n">avalue</span><span class="o">*</span><span class="n">bvalue</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">ccorr</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</li>
</ul>
</div>
<div class="section" id="sparsemat-sparsemat">
<h2>SparseMat::SparseMat<a class="headerlink" href="#sparsemat-sparsemat" title="Permalink to this headline">¶</a></h2>
<p>Various SparseMat constructors.</p>
<dl class="function">
<dt id="SparseMat::SparseMat()">
<strong>C++:</strong><code class="descname"> </code> <code class="descclassname">SparseMat::</code><code class="descname">SparseMat</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#SparseMat::SparseMat()" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="SparseMat::SparseMat(int dims, const int* _sizes, int _type)">
<strong>C++:</strong><code class="descname"> </code> <code class="descclassname">SparseMat::</code><code class="descname">SparseMat</code><span class="sig-paren">(</span>int <strong>dims</strong>, const int* <strong>_sizes</strong>, int <strong>_type</strong><span class="sig-paren">)</span><a class="headerlink" href="#SparseMat::SparseMat(int dims, const int* _sizes, int _type)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="SparseMat::SparseMat(const SparseMat&amp; m)">
<strong>C++:</strong><code class="descname"> </code> <code class="descclassname">SparseMat::</code><code class="descname">SparseMat</code><span class="sig-paren">(</span>const SparseMat&amp; <strong>m</strong><span class="sig-paren">)</span><a class="headerlink" href="#SparseMat::SparseMat(const SparseMat& m)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="SparseMat::SparseMat(const Mat&amp; m)">
<strong>C++:</strong><code class="descname"> </code> <code class="descclassname">SparseMat::</code><code class="descname">SparseMat</code><span class="sig-paren">(</span>const Mat&amp; <strong>m</strong><span class="sig-paren">)</span><a class="headerlink" href="#SparseMat::SparseMat(const Mat& m)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="SparseMat::SparseMat(const CvSparseMat* m)">
<strong>C++:</strong><code class="descname"> </code> <code class="descclassname">SparseMat::</code><code class="descname">SparseMat</code><span class="sig-paren">(</span>const CvSparseMat* <strong>m</strong><span class="sig-paren">)</span><a class="headerlink" href="#SparseMat::SparseMat(const CvSparseMat* m)" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>m</strong> &#8211; Source matrix for copy constructor. If m is dense matrix (ocv:class:<cite>Mat</cite>) then it will be converted to sparse representation.</li>
<li><strong>dims</strong> &#8211; Array dimensionality.</li>
<li><strong>_sizes</strong> &#8211; Sparce matrix size on all dementions.</li>
<li><strong>_type</strong> &#8211; Sparse matrix data type.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="id8">
<h2>SparseMat::~SparseMat<a class="headerlink" href="#id8" title="Permalink to this headline">¶</a></h2>
<p>SparseMat object destructor.</p>
<dl class="function">
<dt id="SparseMat::~SparseMat()">
<strong>C++:</strong><code class="descname"> </code> <code class="descclassname">SparseMat::</code><code class="descname">~SparseMat</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#SparseMat::~SparseMat()" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</div>
<div class="section" id="sparsemat-operator">
<h2>SparseMat::operator=<a class="headerlink" href="#sparsemat-operator" title="Permalink to this headline">¶</a></h2>
<p>Provides sparse matrix assignment operators.</p>
<dl class="function">
<dt id="SparseMat&amp; SparseMat::operator = (const SparseMat&amp; m)">
<strong>C++:</strong><code class="descname"> </code>SparseMat&amp; <code class="descclassname">SparseMat::</code><code class="descname">operator=</code><span class="sig-paren">(</span>const SparseMat&amp; <strong>m</strong><span class="sig-paren">)</span><a class="headerlink" href="#SparseMat& SparseMat::operator = (const SparseMat& m)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="SparseMat&amp; SparseMat::operator = (const Mat&amp; m)">
<strong>C++:</strong><code class="descname"> </code>SparseMat&amp; <code class="descclassname">SparseMat::</code><code class="descname">operator=</code><span class="sig-paren">(</span>const Mat&amp; <strong>m</strong><span class="sig-paren">)</span><a class="headerlink" href="#SparseMat& SparseMat::operator = (const Mat& m)" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>m</strong> &#8211; Matrix for assignment.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<p>The last variant is equivalent to the corresponding constructor with try1d=false.</p>
</div>
<div class="section" id="sparsemat-clone">
<h2>SparseMat::clone<a class="headerlink" href="#sparsemat-clone" title="Permalink to this headline">¶</a></h2>
<p>Creates a full copy of the matrix.</p>
<dl class="function">
<dt id="SparseMat SparseMat::clone() const">
<strong>C++:</strong><code class="descname"> </code>SparseMat <code class="descclassname">SparseMat::</code><code class="descname">clone</code><span class="sig-paren">(</span><span class="sig-paren">)</span><code class="descclassname"> const</code><a class="headerlink" href="#SparseMat SparseMat::clone() const" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</div>
<div class="section" id="sparsemat-copyto">
<h2>SparseMat::copyTo<a class="headerlink" href="#sparsemat-copyto" title="Permalink to this headline">¶</a></h2>
<p>Copy all the data to the destination matrix.The destination will be reallocated if needed.</p>
<dl class="function">
<dt id="void SparseMat::copyTo(SparseMat&amp; m) const">
<strong>C++:</strong><code class="descname"> </code>void <code class="descclassname">SparseMat::</code><code class="descname">copyTo</code><span class="sig-paren">(</span>SparseMat&amp; <strong>m</strong><span class="sig-paren">)</span><code class="descclassname"> const</code><a class="headerlink" href="#void SparseMat::copyTo(SparseMat& m) const" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="void SparseMat::copyTo(Mat&amp; m) const">
<strong>C++:</strong><code class="descname"> </code>void <code class="descclassname">SparseMat::</code><code class="descname">copyTo</code><span class="sig-paren">(</span>Mat&amp; <strong>m</strong><span class="sig-paren">)</span><code class="descclassname"> const</code><a class="headerlink" href="#void SparseMat::copyTo(Mat& m) const" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>m</strong> &#8211; Target for copiing.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<p>The last variant converts 1D or 2D sparse matrix to dense 2D matrix. If the sparse matrix is 1D, the result will be a single-column matrix.</p>
</div>
<div class="section" id="sparcemat-convertto">
<h2>SparceMat::convertTo<a class="headerlink" href="#sparcemat-convertto" title="Permalink to this headline">¶</a></h2>
<p>Convert sparse matrix with possible type change and scaling.</p>
<dl class="function">
<dt id="void SparseMat::convertTo(SparseMat&amp; m, int rtype, double alpha) const">
<strong>C++:</strong><code class="descname"> </code>void <code class="descclassname">SparseMat::</code><code class="descname">convertTo</code><span class="sig-paren">(</span>SparseMat&amp; <strong>m</strong>, int <strong>rtype</strong>, double <strong>alpha</strong>=1 <span class="sig-paren">)</span><code class="descclassname"> const</code><a class="headerlink" href="#void SparseMat::convertTo(SparseMat& m, int rtype, double alpha) const" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="void SparseMat::convertTo(Mat&amp; m, int rtype, double alpha, double beta) const">
<strong>C++:</strong><code class="descname"> </code>void <code class="descclassname">SparseMat::</code><code class="descname">convertTo</code><span class="sig-paren">(</span>Mat&amp; <strong>m</strong>, int <strong>rtype</strong>, double <strong>alpha</strong>=1, double <strong>beta</strong>=0 <span class="sig-paren">)</span><code class="descclassname"> const</code><a class="headerlink" href="#void SparseMat::convertTo(Mat& m, int rtype, double alpha, double beta) const" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>m</strong> &#8211; Destination matrix.</li>
<li><strong>rtype</strong> &#8211; Destination matrix type.</li>
<li><strong>alpha</strong> &#8211; Conversion multiplier.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<p>The first version converts arbitrary sparse matrix to dense matrix and multiplies all the matrix elements by the specified scalar.
The second versiob converts sparse matrix to dense matrix with optional type conversion and scaling.
When rtype=-1, the destination element type will be the same as the sparse matrix element type.
Otherwise, rtype will specify the depth and the number of channels will remain the same as in the sparse matrix.</p>
</div>
<div class="section" id="sparsemat-create">
<h2>SparseMat:create<a class="headerlink" href="#sparsemat-create" title="Permalink to this headline">¶</a></h2>
<p>Reallocates sparse matrix. If it was already of the proper size and type, it is simply cleared with clear(), otherwise,
the old matrix is released (using release()) and the new one is allocated.</p>
<dl class="function">
<dt id="void SparseMat::create(int dims, const int* _sizes, int _type)">
<strong>C++:</strong><code class="descname"> </code>void <code class="descclassname">SparseMat::</code><code class="descname">create</code><span class="sig-paren">(</span>int <strong>dims</strong>, const int* <strong>_sizes</strong>, int <strong>_type</strong><span class="sig-paren">)</span><a class="headerlink" href="#void SparseMat::create(int dims, const int* _sizes, int _type)" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>dims</strong> &#8211; Array dimensionality.</li>
<li><strong>_sizes</strong> &#8211; Sparce matrix size on all dementions.</li>
<li><strong>_type</strong> &#8211; Sparse matrix data type.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="sparsemat-clear">
<h2>SparseMat::clear<a class="headerlink" href="#sparsemat-clear" title="Permalink to this headline">¶</a></h2>
<p>Sets all the matrix elements to 0, which means clearing the hash table.</p>
<dl class="function">
<dt id="void SparseMat::clear()">
<strong>C++:</strong><code class="descname"> </code>void <code class="descclassname">SparseMat::</code><code class="descname">clear</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#void SparseMat::clear()" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</div>
<div class="section" id="sparsemat-addref">
<h2>SparseMat::addref<a class="headerlink" href="#sparsemat-addref" title="Permalink to this headline">¶</a></h2>
<p>Manually increases reference counter to the header.</p>
<dl class="function">
<dt id="void SparseMat::addref()">
<strong>C++:</strong><code class="descname"> </code>void <code class="descclassname">SparseMat::</code><code class="descname">addref</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#void SparseMat::addref()" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</div>
<div class="section" id="sparsemat-release">
<h2>SparseMat::release<a class="headerlink" href="#sparsemat-release" title="Permalink to this headline">¶</a></h2>
<p>Decreses the header reference counter when it reaches 0. The header and all the underlying data are deallocated.</p>
<dl class="function">
<dt id="void SparseMat::release()">
<strong>C++:</strong><code class="descname"> </code>void <code class="descclassname">SparseMat::</code><code class="descname">release</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#void SparseMat::release()" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</div>
<div class="section" id="sparsemat-cvsparsemat">
<h2>SparseMat::CvSparseMat *<a class="headerlink" href="#sparsemat-cvsparsemat" title="Permalink to this headline">¶</a></h2>
<p>Converts sparse matrix to the old-style representation. All the elements are copied.</p>
<dl class="function">
<dt id="SparseMat::operator CvSparseMat*() const">
<strong>C++:</strong><code class="descname"> </code> <code class="descclassname">SparseMat::</code><code class="descname">operator</code> CvSparseMat*<span class="sig-paren">(</span><span class="sig-paren">)</span><code class="descclassname"> const</code><a class="headerlink" href="#SparseMat::operator CvSparseMat*() const" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</div>
<div class="section" id="sparsemat-elemsize">
<h2>SparseMat::elemSize<a class="headerlink" href="#sparsemat-elemsize" title="Permalink to this headline">¶</a></h2>
<p>Size of each element in bytes (the matrix nodes will be bigger because of element indices and other SparseMat::Node elements).</p>
<dl class="function">
<dt id="size_t SparseMat::elemSize() const">
<strong>C++:</strong><code class="descname"> </code>size_t <code class="descclassname">SparseMat::</code><code class="descname">elemSize</code><span class="sig-paren">(</span><span class="sig-paren">)</span><code class="descclassname"> const</code><a class="headerlink" href="#size_t SparseMat::elemSize() const" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</div>
<div class="section" id="sparsemat-elemsize1">
<h2>SparseMat::elemSize1<a class="headerlink" href="#sparsemat-elemsize1" title="Permalink to this headline">¶</a></h2>
<p>elemSize()/channels().</p>
<dl class="function">
<dt>
<strong>C++:</strong><code class="descname"> </code>size_t <code class="descclassname">SparseMat::</code><code class="descname">elemSize</code><span class="sig-paren">(</span><span class="sig-paren">)</span><code class="descclassname"> const</code></dt>
<dd></dd></dl>

</div>
<div class="section" id="sparsemat-type">
<h2>SparseMat::type<a class="headerlink" href="#sparsemat-type" title="Permalink to this headline">¶</a></h2>
<p>Returns the type of a matrix element.</p>
<dl class="function">
<dt id="int SparseMat::type() const">
<strong>C++:</strong><code class="descname"> </code>int <code class="descclassname">SparseMat::</code><code class="descname">type</code><span class="sig-paren">(</span><span class="sig-paren">)</span><code class="descclassname"> const</code><a class="headerlink" href="#int SparseMat::type() const" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p>The method returns a sparse matrix element type. This is an identifier compatible with the <code class="docutils literal"><span class="pre">CvMat</span></code> type system, like <code class="docutils literal"><span class="pre">CV_16SC3</span></code> or 16-bit signed 3-channel array, and so on.</p>
</div>
<div class="section" id="sparsemat-depth">
<h2>SparseMat::depth<a class="headerlink" href="#sparsemat-depth" title="Permalink to this headline">¶</a></h2>
<p>Returns the depth of a sparse matrix element.</p>
<dl class="function">
<dt id="int SparseMat::depth() const">
<strong>C++:</strong><code class="descname"> </code>int <code class="descclassname">SparseMat::</code><code class="descname">depth</code><span class="sig-paren">(</span><span class="sig-paren">)</span><code class="descclassname"> const</code><a class="headerlink" href="#int SparseMat::depth() const" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p>The method returns the identifier of the matrix element depth (the type of each individual channel). For example, for a 16-bit signed 3-channel array, the method returns <code class="docutils literal"><span class="pre">CV_16S</span></code></p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">CV_8U</span></code>     - 8-bit unsigned integers ( <code class="docutils literal"><span class="pre">0..255</span></code>     )</li>
<li><code class="docutils literal"><span class="pre">CV_8S</span></code>     - 8-bit signed integers ( <code class="docutils literal"><span class="pre">-128..127</span></code>     )</li>
<li><code class="docutils literal"><span class="pre">CV_16U</span></code>     - 16-bit unsigned integers ( <code class="docutils literal"><span class="pre">0..65535</span></code>     )</li>
<li><code class="docutils literal"><span class="pre">CV_16S</span></code>     - 16-bit signed integers ( <code class="docutils literal"><span class="pre">-32768..32767</span></code>     )</li>
<li><code class="docutils literal"><span class="pre">CV_32S</span></code>     - 32-bit signed integers ( <code class="docutils literal"><span class="pre">-2147483648..2147483647</span></code>     )</li>
<li><code class="docutils literal"><span class="pre">CV_32F</span></code>     - 32-bit floating-point numbers ( <code class="docutils literal"><span class="pre">-FLT_MAX..FLT_MAX,</span> <span class="pre">INF,</span> <span class="pre">NAN</span></code>     )</li>
<li><code class="docutils literal"><span class="pre">CV_64F</span></code>     - 64-bit floating-point numbers ( <code class="docutils literal"><span class="pre">-DBL_MAX..DBL_MAX,</span> <span class="pre">INF,</span> <span class="pre">NAN</span></code>     )</li>
</ul>
</div>
<div class="section" id="sparsemat-channels">
<h2>SparseMat::channels<a class="headerlink" href="#sparsemat-channels" title="Permalink to this headline">¶</a></h2>
<p>Returns the number of matrix channels.</p>
<dl class="function">
<dt id="int SparseMat::channels() const">
<strong>C++:</strong><code class="descname"> </code>int <code class="descclassname">SparseMat::</code><code class="descname">channels</code><span class="sig-paren">(</span><span class="sig-paren">)</span><code class="descclassname"> const</code><a class="headerlink" href="#int SparseMat::channels() const" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p>The method returns the number of matrix channels.</p>
</div>
<div class="section" id="sparsemat-size">
<h2>SparseMat::size<a class="headerlink" href="#sparsemat-size" title="Permalink to this headline">¶</a></h2>
<p>Returns the array of sizes or matrix size by i dimension and 0 if the matrix is not allocated.</p>
<dl class="function">
<dt id="const int* SparseMat::size() const">
<strong>C++:</strong><code class="descname"> </code>const int* <code class="descclassname">SparseMat::</code><code class="descname">size</code><span class="sig-paren">(</span><span class="sig-paren">)</span><code class="descclassname"> const</code><a class="headerlink" href="#const int* SparseMat::size() const" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="int SparseMat::size(int i) const">
<strong>C++:</strong><code class="descname"> </code>int <code class="descclassname">SparseMat::</code><code class="descname">size</code><span class="sig-paren">(</span>int <strong>i</strong><span class="sig-paren">)</span><code class="descclassname"> const</code><a class="headerlink" href="#int SparseMat::size(int i) const" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>i</strong> &#8211; Dimention index.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="sparsemat-dims">
<h2>SparseMat::dims<a class="headerlink" href="#sparsemat-dims" title="Permalink to this headline">¶</a></h2>
<p>Returns the matrix dimensionality.</p>
<dl class="function">
<dt id="int SparseMat::dims() const">
<strong>C++:</strong><code class="descname"> </code>int <code class="descclassname">SparseMat::</code><code class="descname">dims</code><span class="sig-paren">(</span><span class="sig-paren">)</span><code class="descclassname"> const</code><a class="headerlink" href="#int SparseMat::dims() const" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</div>
<div class="section" id="sparsemat-nzcount">
<h2>SparseMat::nzcount<a class="headerlink" href="#sparsemat-nzcount" title="Permalink to this headline">¶</a></h2>
<p>Returns the number of non-zero elements.</p>
<dl class="function">
<dt id="size_t SparseMat::nzcount() const">
<strong>C++:</strong><code class="descname"> </code>size_t <code class="descclassname">SparseMat::</code><code class="descname">nzcount</code><span class="sig-paren">(</span><span class="sig-paren">)</span><code class="descclassname"> const</code><a class="headerlink" href="#size_t SparseMat::nzcount() const" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</div>
<div class="section" id="sparsemat-hash">
<h2>SparseMat::hash<a class="headerlink" href="#sparsemat-hash" title="Permalink to this headline">¶</a></h2>
<p>Compute element hash value from the element indices.</p>
<dl class="function">
<dt id="size_t SparseMat::hash(int i0) const">
<strong>C++:</strong><code class="descname"> </code>size_t <code class="descclassname">SparseMat::</code><code class="descname">hash</code><span class="sig-paren">(</span>int <strong>i0</strong><span class="sig-paren">)</span><code class="descclassname"> const</code><a class="headerlink" href="#size_t SparseMat::hash(int i0) const" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="size_t SparseMat::hash(int i0, int i1) const">
<strong>C++:</strong><code class="descname"> </code>size_t <code class="descclassname">SparseMat::</code><code class="descname">hash</code><span class="sig-paren">(</span>int <strong>i0</strong>, int <strong>i1</strong><span class="sig-paren">)</span><code class="descclassname"> const</code><a class="headerlink" href="#size_t SparseMat::hash(int i0, int i1) const" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="size_t SparseMat::hash(int i0, int i1, int i2) const">
<strong>C++:</strong><code class="descname"> </code>size_t <code class="descclassname">SparseMat::</code><code class="descname">hash</code><span class="sig-paren">(</span>int <strong>i0</strong>, int <strong>i1</strong>, int <strong>i2</strong><span class="sig-paren">)</span><code class="descclassname"> const</code><a class="headerlink" href="#size_t SparseMat::hash(int i0, int i1, int i2) const" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="size_t SparseMat::hash(const int* idx) const">
<strong>C++:</strong><code class="descname"> </code>size_t <code class="descclassname">SparseMat::</code><code class="descname">hash</code><span class="sig-paren">(</span>const int* <strong>idx</strong><span class="sig-paren">)</span><code class="descclassname"> const</code><a class="headerlink" href="#size_t SparseMat::hash(const int* idx) const" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>i0</strong> &#8211; The first dimension index.</li>
<li><strong>i1</strong> &#8211; The second dimension index.</li>
<li><strong>i2</strong> &#8211; The third dimension index.</li>
<li><strong>idx</strong> &#8211; Array of element indices for multidimensional matices.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="sparsemat-ptr">
<h2>SparseMat::ptr<a class="headerlink" href="#sparsemat-ptr" title="Permalink to this headline">¶</a></h2>
<p>Low-level element-access functions, special variants for 1D, 2D, 3D cases, and the generic one for n-D case.</p>
<dl class="function">
<dt id="uchar* SparseMat::ptr(int i0, bool createMissing, size_t* hashval)">
<strong>C++:</strong><code class="descname"> </code>uchar* <code class="descclassname">SparseMat::</code><code class="descname">ptr</code><span class="sig-paren">(</span>int <strong>i0</strong>, bool <strong>createMissing</strong>, size_t* <strong>hashval</strong>=0<span class="sig-paren">)</span><a class="headerlink" href="#uchar* SparseMat::ptr(int i0, bool createMissing, size_t* hashval)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="uchar* SparseMat::ptr(int i0, int i1, bool createMissing, size_t* hashval)">
<strong>C++:</strong><code class="descname"> </code>uchar* <code class="descclassname">SparseMat::</code><code class="descname">ptr</code><span class="sig-paren">(</span>int <strong>i0</strong>, int <strong>i1</strong>, bool <strong>createMissing</strong>, size_t* <strong>hashval</strong>=0<span class="sig-paren">)</span><a class="headerlink" href="#uchar* SparseMat::ptr(int i0, int i1, bool createMissing, size_t* hashval)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="uchar* SparseMat::ptr(int i0, int i1, int i2, bool createMissing, size_t* hashval)">
<strong>C++:</strong><code class="descname"> </code>uchar* <code class="descclassname">SparseMat::</code><code class="descname">ptr</code><span class="sig-paren">(</span>int <strong>i0</strong>, int <strong>i1</strong>, int <strong>i2</strong>, bool <strong>createMissing</strong>, size_t* <strong>hashval</strong>=0<span class="sig-paren">)</span><a class="headerlink" href="#uchar* SparseMat::ptr(int i0, int i1, int i2, bool createMissing, size_t* hashval)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="uchar* SparseMat::ptr(const int* idx, bool createMissing, size_t* hashval)">
<strong>C++:</strong><code class="descname"> </code>uchar* <code class="descclassname">SparseMat::</code><code class="descname">ptr</code><span class="sig-paren">(</span>const int* <strong>idx</strong>, bool <strong>createMissing</strong>, size_t* <strong>hashval</strong>=0<span class="sig-paren">)</span><a class="headerlink" href="#uchar* SparseMat::ptr(const int* idx, bool createMissing, size_t* hashval)" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>i0</strong> &#8211; The first dimension index.</li>
<li><strong>i1</strong> &#8211; The second dimension index.</li>
<li><strong>i2</strong> &#8211; The third dimension index.</li>
<li><strong>idx</strong> &#8211; Array of element indices for multidimensional matices.</li>
<li><strong>createMissing</strong> &#8211; Create new element with 0 value if it does not exist in SparseMat.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<p>Return pointer to the matrix element. If the element is there (it is non-zero), the pointer to it is returned.
If it is not there and <code class="docutils literal"><span class="pre">createMissing=false</span></code>, NULL pointer is returned. If it is not there and <code class="docutils literal"><span class="pre">createMissing=true</span></code>,
the new elementis created and initialized with 0. Pointer to it is returned. If the optional hashval pointer is not <code class="docutils literal"><span class="pre">NULL</span></code>,
the element hash value is not computed but <code class="docutils literal"><span class="pre">hashval</span></code> is taken instead.</p>
</div>
<div class="section" id="sparsemat-erase">
<h2>SparseMat::erase<a class="headerlink" href="#sparsemat-erase" title="Permalink to this headline">¶</a></h2>
<p>Erase the specified matrix element. When there is no such an element, the methods do nothing.</p>
<dl class="function">
<dt id="void SparseMat::erase(int i0, int i1, size_t* hashval)">
<strong>C++:</strong><code class="descname"> </code>void <code class="descclassname">SparseMat::</code><code class="descname">erase</code><span class="sig-paren">(</span>int <strong>i0</strong>, int <strong>i1</strong>, size_t* <strong>hashval</strong>=0<span class="sig-paren">)</span><a class="headerlink" href="#void SparseMat::erase(int i0, int i1, size_t* hashval)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="void SparseMat::erase(int i0, int i1, int i2, size_t* hashval)">
<strong>C++:</strong><code class="descname"> </code>void <code class="descclassname">SparseMat::</code><code class="descname">erase</code><span class="sig-paren">(</span>int <strong>i0</strong>, int <strong>i1</strong>, int <strong>i2</strong>, size_t* <strong>hashval</strong>=0<span class="sig-paren">)</span><a class="headerlink" href="#void SparseMat::erase(int i0, int i1, int i2, size_t* hashval)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="void SparseMat::erase(const int* idx, size_t* hashval)">
<strong>C++:</strong><code class="descname"> </code>void <code class="descclassname">SparseMat::</code><code class="descname">erase</code><span class="sig-paren">(</span>const int* <strong>idx</strong>, size_t* <strong>hashval</strong>=0<span class="sig-paren">)</span><a class="headerlink" href="#void SparseMat::erase(const int* idx, size_t* hashval)" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>i0</strong> &#8211; The first dimension index.</li>
<li><strong>i1</strong> &#8211; The second dimension index.</li>
<li><strong>i2</strong> &#8211; The third dimension index.</li>
<li><strong>idx</strong> &#8211; Array of element indices for multidimensional matices.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="id9">
<h2>SparseMat_<a class="headerlink" href="#id9" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="SparseMat_">
<em class="property">class </em><code class="descname">SparseMat_</code><a class="headerlink" href="#SparseMat_" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p>Template sparse n-dimensional array class derived from
<a class="reference internal" href="#SparseMat" title="class SparseMat"><code class="xref ocv ocv-class docutils literal"><span class="pre">SparseMat</span></code></a></p>
<div class="highlight-cpp"><div class="highlight"><pre><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">_Tp</span><span class="o">&gt;</span> <span class="k">class</span> <span class="nc">SparseMat_</span> <span class="o">:</span> <span class="k">public</span> <span class="n">SparseMat</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="k">typedef</span> <span class="n">SparseMatIterator_</span><span class="o">&lt;</span><span class="n">_Tp</span><span class="o">&gt;</span> <span class="n">iterator</span><span class="p">;</span>
    <span class="k">typedef</span> <span class="n">SparseMatConstIterator_</span><span class="o">&lt;</span><span class="n">_Tp</span><span class="o">&gt;</span> <span class="n">const_iterator</span><span class="p">;</span>

    <span class="c1">// constructors;</span>
    <span class="c1">// the created matrix will have data type = DataType&lt;_Tp&gt;::type</span>
    <span class="n">SparseMat_</span><span class="p">();</span>
    <span class="n">SparseMat_</span><span class="p">(</span><span class="kt">int</span> <span class="n">dims</span><span class="p">,</span> <span class="k">const</span> <span class="kt">int</span><span class="o">*</span> <span class="n">_sizes</span><span class="p">);</span>
    <span class="n">SparseMat_</span><span class="p">(</span><span class="k">const</span> <span class="n">SparseMat</span><span class="o">&amp;</span> <span class="n">m</span><span class="p">);</span>
    <span class="n">SparseMat_</span><span class="p">(</span><span class="k">const</span> <span class="n">SparseMat_</span><span class="o">&amp;</span> <span class="n">m</span><span class="p">);</span>
    <span class="n">SparseMat_</span><span class="p">(</span><span class="k">const</span> <span class="n">Mat</span><span class="o">&amp;</span> <span class="n">m</span><span class="p">);</span>
    <span class="n">SparseMat_</span><span class="p">(</span><span class="k">const</span> <span class="n">CvSparseMat</span><span class="o">*</span> <span class="n">m</span><span class="p">);</span>
    <span class="c1">// assignment operators; data type conversion is done when necessary</span>
    <span class="n">SparseMat_</span><span class="o">&amp;</span> <span class="k">operator</span> <span class="o">=</span> <span class="p">(</span><span class="k">const</span> <span class="n">SparseMat</span><span class="o">&amp;</span> <span class="n">m</span><span class="p">);</span>
    <span class="n">SparseMat_</span><span class="o">&amp;</span> <span class="k">operator</span> <span class="o">=</span> <span class="p">(</span><span class="k">const</span> <span class="n">SparseMat_</span><span class="o">&amp;</span> <span class="n">m</span><span class="p">);</span>
    <span class="n">SparseMat_</span><span class="o">&amp;</span> <span class="k">operator</span> <span class="o">=</span> <span class="p">(</span><span class="k">const</span> <span class="n">Mat</span><span class="o">&amp;</span> <span class="n">m</span><span class="p">);</span>

    <span class="c1">// equivalent to the correspoding parent class methods</span>
    <span class="n">SparseMat_</span> <span class="nf">clone</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
    <span class="kt">void</span> <span class="nf">create</span><span class="p">(</span><span class="kt">int</span> <span class="n">dims</span><span class="p">,</span> <span class="k">const</span> <span class="kt">int</span><span class="o">*</span> <span class="n">_sizes</span><span class="p">);</span>
    <span class="k">operator</span> <span class="n">CvSparseMat</span><span class="o">*</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>

    <span class="c1">// overriden methods that do extra checks for the data type</span>
    <span class="kt">int</span> <span class="nf">type</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
    <span class="kt">int</span> <span class="nf">depth</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
    <span class="kt">int</span> <span class="nf">channels</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>

    <span class="c1">// more convenient element access operations.</span>
    <span class="c1">// ref() is retained (but &lt;_Tp&gt; specification is not needed anymore);</span>
    <span class="c1">// operator () is equivalent to SparseMat::value&lt;_Tp&gt;</span>
    <span class="n">_Tp</span><span class="o">&amp;</span> <span class="n">ref</span><span class="p">(</span><span class="kt">int</span> <span class="n">i0</span><span class="p">,</span> <span class="kt">size_t</span><span class="o">*</span> <span class="n">hashval</span><span class="o">=</span><span class="mi">0</span><span class="p">);</span>
    <span class="n">_Tp</span> <span class="nf">operator</span><span class="p">()(</span><span class="kt">int</span> <span class="n">i0</span><span class="p">,</span> <span class="kt">size_t</span><span class="o">*</span> <span class="n">hashval</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
    <span class="n">_Tp</span><span class="o">&amp;</span> <span class="n">ref</span><span class="p">(</span><span class="kt">int</span> <span class="n">i0</span><span class="p">,</span> <span class="kt">int</span> <span class="n">i1</span><span class="p">,</span> <span class="kt">size_t</span><span class="o">*</span> <span class="n">hashval</span><span class="o">=</span><span class="mi">0</span><span class="p">);</span>
    <span class="n">_Tp</span> <span class="nf">operator</span><span class="p">()(</span><span class="kt">int</span> <span class="n">i0</span><span class="p">,</span> <span class="kt">int</span> <span class="n">i1</span><span class="p">,</span> <span class="kt">size_t</span><span class="o">*</span> <span class="n">hashval</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
    <span class="n">_Tp</span><span class="o">&amp;</span> <span class="n">ref</span><span class="p">(</span><span class="kt">int</span> <span class="n">i0</span><span class="p">,</span> <span class="kt">int</span> <span class="n">i1</span><span class="p">,</span> <span class="kt">int</span> <span class="n">i2</span><span class="p">,</span> <span class="kt">size_t</span><span class="o">*</span> <span class="n">hashval</span><span class="o">=</span><span class="mi">0</span><span class="p">);</span>
    <span class="n">_Tp</span> <span class="nf">operator</span><span class="p">()(</span><span class="kt">int</span> <span class="n">i0</span><span class="p">,</span> <span class="kt">int</span> <span class="n">i1</span><span class="p">,</span> <span class="kt">int</span> <span class="n">i2</span><span class="p">,</span> <span class="kt">size_t</span><span class="o">*</span> <span class="n">hashval</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
    <span class="n">_Tp</span><span class="o">&amp;</span> <span class="n">ref</span><span class="p">(</span><span class="k">const</span> <span class="kt">int</span><span class="o">*</span> <span class="n">idx</span><span class="p">,</span> <span class="kt">size_t</span><span class="o">*</span> <span class="n">hashval</span><span class="o">=</span><span class="mi">0</span><span class="p">);</span>
    <span class="n">_Tp</span> <span class="nf">operator</span><span class="p">()(</span><span class="k">const</span> <span class="kt">int</span><span class="o">*</span> <span class="n">idx</span><span class="p">,</span> <span class="kt">size_t</span><span class="o">*</span> <span class="n">hashval</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>

    <span class="c1">// iterators</span>
    <span class="n">SparseMatIterator_</span><span class="o">&lt;</span><span class="n">_Tp</span><span class="o">&gt;</span> <span class="n">begin</span><span class="p">();</span>
    <span class="n">SparseMatConstIterator_</span><span class="o">&lt;</span><span class="n">_Tp</span><span class="o">&gt;</span> <span class="n">begin</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
    <span class="n">SparseMatIterator_</span><span class="o">&lt;</span><span class="n">_Tp</span><span class="o">&gt;</span> <span class="n">end</span><span class="p">();</span>
    <span class="n">SparseMatConstIterator_</span><span class="o">&lt;</span><span class="n">_Tp</span><span class="o">&gt;</span> <span class="n">end</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
<p><code class="docutils literal"><span class="pre">SparseMat_</span></code> is a thin wrapper on top of <a class="reference internal" href="#SparseMat" title="class SparseMat"><code class="xref ocv ocv-class docutils literal"><span class="pre">SparseMat</span></code></a> created in the same way as <code class="docutils literal"><span class="pre">Mat_</span></code> .
It simplifies notation of some operations.</p>
<div class="highlight-cpp"><div class="highlight"><pre><span class="kt">int</span> <span class="n">sz</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">10</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">30</span><span class="p">};</span>
<span class="n">SparseMat_</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span> <span class="n">M</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">sz</span><span class="p">);</span>
<span class="p">...</span>
<span class="n">M</span><span class="p">.</span><span class="n">ref</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span> <span class="o">=</span> <span class="n">M</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">)</span> <span class="o">+</span> <span class="n">M</span><span class="p">(</span><span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">9</span><span class="p">);</span>
</pre></div>
</div>
</div>
<div class="section" id="algorithm">
<h2>Algorithm<a class="headerlink" href="#algorithm" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="Algorithm">
<em class="property">class </em><code class="descname">Algorithm</code><a class="headerlink" href="#Algorithm" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<div class="highlight-cpp"><div class="highlight"><pre>class CV_EXPORTS_W Algorithm
{
public:
    Algorithm();
    virtual ~Algorithm();
    string name() const;

    template&lt;typename _Tp&gt; typename ParamType&lt;_Tp&gt;::member_type get(const string&amp; name) const;
    template&lt;typename _Tp&gt; typename ParamType&lt;_Tp&gt;::member_type get(const char* name) const;

    CV_WRAP int getInt(const string&amp; name) const;
    CV_WRAP double getDouble(const string&amp; name) const;
    CV_WRAP bool getBool(const string&amp; name) const;
    CV_WRAP string getString(const string&amp; name) const;
    CV_WRAP Mat getMat(const string&amp; name) const;
    CV_WRAP vector&lt;Mat&gt; getMatVector(const string&amp; name) const;
    CV_WRAP Ptr&lt;Algorithm&gt; getAlgorithm(const string&amp; name) const;

    void set(const string&amp; name, int value);
    void set(const string&amp; name, double value);
    void set(const string&amp; name, bool value);
    void set(const string&amp; name, const string&amp; value);
    void set(const string&amp; name, const Mat&amp; value);
    void set(const string&amp; name, const vector&lt;Mat&gt;&amp; value);
    void set(const string&amp; name, const Ptr&lt;Algorithm&gt;&amp; value);
    template&lt;typename _Tp&gt; void set(const string&amp; name, const Ptr&lt;_Tp&gt;&amp; value);

    CV_WRAP void setInt(const string&amp; name, int value);
    CV_WRAP void setDouble(const string&amp; name, double value);
    CV_WRAP void setBool(const string&amp; name, bool value);
    CV_WRAP void setString(const string&amp; name, const string&amp; value);
    CV_WRAP void setMat(const string&amp; name, const Mat&amp; value);
    CV_WRAP void setMatVector(const string&amp; name, const vector&lt;Mat&gt;&amp; value);
    CV_WRAP void setAlgorithm(const string&amp; name, const Ptr&lt;Algorithm&gt;&amp; value);
    template&lt;typename _Tp&gt; void setAlgorithm(const string&amp; name, const Ptr&lt;_Tp&gt;&amp; value);

    void set(const char* name, int value);
    void set(const char* name, double value);
    void set(const char* name, bool value);
    void set(const char* name, const string&amp; value);
    void set(const char* name, const Mat&amp; value);
    void set(const char* name, const vector&lt;Mat&gt;&amp; value);
    void set(const char* name, const Ptr&lt;Algorithm&gt;&amp; value);
    template&lt;typename _Tp&gt; void set(const char* name, const Ptr&lt;_Tp&gt;&amp; value);

    void setInt(const char* name, int value);
    void setDouble(const char* name, double value);
    void setBool(const char* name, bool value);
    void setString(const char* name, const string&amp; value);
    void setMat(const char* name, const Mat&amp; value);
    void setMatVector(const char* name, const vector&lt;Mat&gt;&amp; value);
    void setAlgorithm(const char* name, const Ptr&lt;Algorithm&gt;&amp; value);
    template&lt;typename _Tp&gt; void setAlgorithm(const char* name, const Ptr&lt;_Tp&gt;&amp; value);

    CV_WRAP string paramHelp(const string&amp; name) const;
    int paramType(const char* name) const;
    CV_WRAP int paramType(const string&amp; name) const;
    CV_WRAP void getParams(CV_OUT vector&lt;string&gt;&amp; names) const;


    virtual void write(FileStorage&amp; fs) const;
    virtual void read(const FileNode&amp; fn);

    typedef Algorithm* (*Constructor)(void);
    typedef int (Algorithm::*Getter)() const;
    typedef void (Algorithm::*Setter)(int);

    CV_WRAP static void getList(CV_OUT vector&lt;string&gt;&amp; algorithms);
    CV_WRAP static Ptr&lt;Algorithm&gt; _create(const string&amp; name);
    template&lt;typename _Tp&gt; static Ptr&lt;_Tp&gt; create(const string&amp; name);

    virtual AlgorithmInfo* info() const /* TODO: make it = 0;*/ { return 0; }
};
</pre></div>
</div>
<p>This is a base class for all more or less complex algorithms in OpenCV, especially for classes of algorithms, for which there can be multiple implementations. The examples are stereo correspondence (for which there are algorithms like block matching, semi-global block matching, graph-cut etc.), background subtraction (which can be done using mixture-of-gaussians models, codebook-based algorithm etc.), optical flow (block matching, Lucas-Kanade, Horn-Schunck etc.).</p>
<p>The class provides the following features for all derived classes:</p>
<blockquote>
<div><ul class="simple">
<li>so called &#8220;virtual constructor&#8221;. That is, each Algorithm derivative is registered at program start and you can get the list of registered algorithms and create instance of a particular algorithm by its name (see <code class="docutils literal"><span class="pre">Algorithm::create</span></code>). If you plan to add your own algorithms, it is good practice to add a unique prefix to your algorithms to distinguish them from other algorithms.</li>
<li>setting/retrieving algorithm parameters by name. If you used video capturing functionality from OpenCV highgui module, you are probably familar with <code class="docutils literal"><span class="pre">cvSetCaptureProperty()</span></code>, <code class="docutils literal"><span class="pre">cvGetCaptureProperty()</span></code>, <code class="docutils literal"><span class="pre">VideoCapture::set()</span></code> and <code class="docutils literal"><span class="pre">VideoCapture::get()</span></code>. <code class="docutils literal"><span class="pre">Algorithm</span></code> provides similar method where instead of integer id&#8217;s you specify the parameter names as text strings. See <code class="docutils literal"><span class="pre">Algorithm::set</span></code> and <code class="docutils literal"><span class="pre">Algorithm::get</span></code> for details.</li>
<li>reading and writing parameters from/to XML or YAML files. Every Algorithm derivative can store all its parameters and then read them back. There is no need to re-implement it each time.</li>
</ul>
</div></blockquote>
<p>Here is example of SIFT use in your application via Algorithm interface:</p>
<div class="highlight-cpp"><div class="highlight"><pre><span class="cp">#include</span> <span class="cpf">&quot;opencv2/opencv.hpp&quot;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&quot;opencv2/nonfree/nonfree.hpp&quot;</span><span class="cp"></span>

<span class="p">...</span>

<span class="n">initModule_nonfree</span><span class="p">();</span> <span class="c1">// to load SURF/SIFT etc.</span>

<span class="n">Ptr</span><span class="o">&lt;</span><span class="n">Feature2D</span><span class="o">&gt;</span> <span class="n">sift</span> <span class="o">=</span> <span class="n">Algorithm</span><span class="o">::</span><span class="n">create</span><span class="o">&lt;</span><span class="n">Feature2D</span><span class="o">&gt;</span><span class="p">(</span><span class="s">&quot;Feature2D.SIFT&quot;</span><span class="p">);</span>

<span class="n">FileStorage</span> <span class="nf">fs</span><span class="p">(</span><span class="s">&quot;sift_params.xml&quot;</span><span class="p">,</span> <span class="n">FileStorage</span><span class="o">::</span><span class="n">READ</span><span class="p">);</span>
<span class="k">if</span><span class="p">(</span> <span class="n">fs</span><span class="p">.</span><span class="n">isOpened</span><span class="p">()</span> <span class="p">)</span> <span class="c1">// if we have file with parameters, read them</span>
<span class="p">{</span>
    <span class="n">sift</span><span class="o">-&gt;</span><span class="n">read</span><span class="p">(</span><span class="n">fs</span><span class="p">[</span><span class="s">&quot;sift_params&quot;</span><span class="p">]);</span>
    <span class="n">fs</span><span class="p">.</span><span class="n">release</span><span class="p">();</span>
<span class="p">}</span>
<span class="k">else</span> <span class="c1">// else modify the parameters and store them; user can later edit the file to use different parameters</span>
<span class="p">{</span>
    <span class="n">sift</span><span class="o">-&gt;</span><span class="n">set</span><span class="p">(</span><span class="s">&quot;contrastThreshold&quot;</span><span class="p">,</span> <span class="mf">0.01f</span><span class="p">);</span> <span class="c1">// lower the contrast threshold, compared to the default value</span>

    <span class="p">{</span>
    <span class="n">WriteStructContext</span> <span class="n">ws</span><span class="p">(</span><span class="n">fs</span><span class="p">,</span> <span class="s">&quot;sift_params&quot;</span><span class="p">,</span> <span class="n">CV_NODE_MAP</span><span class="p">);</span>
    <span class="n">sift</span><span class="o">-&gt;</span><span class="n">write</span><span class="p">(</span><span class="n">fs</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="n">Mat</span> <span class="n">image</span> <span class="o">=</span> <span class="n">imread</span><span class="p">(</span><span class="s">&quot;myimage.png&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">descriptors</span><span class="p">;</span>
<span class="n">vector</span><span class="o">&lt;</span><span class="n">KeyPoint</span><span class="o">&gt;</span> <span class="n">keypoints</span><span class="p">;</span>
<span class="p">(</span><span class="o">*</span><span class="n">sift</span><span class="p">)(</span><span class="n">image</span><span class="p">,</span> <span class="n">noArray</span><span class="p">(),</span> <span class="n">keypoints</span><span class="p">,</span> <span class="n">descriptors</span><span class="p">);</span>
</pre></div>
</div>
</div>
<div class="section" id="algorithm-name">
<h2>Algorithm::name<a class="headerlink" href="#algorithm-name" title="Permalink to this headline">¶</a></h2>
<p>Returns the algorithm name</p>
<dl class="function">
<dt id="string Algorithm::name() const">
<strong>C++:</strong><code class="descname"> </code>string <code class="descclassname">Algorithm::</code><code class="descname">name</code><span class="sig-paren">(</span><span class="sig-paren">)</span><code class="descclassname"> const</code><a class="headerlink" href="#string Algorithm::name() const" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</div>
<div class="section" id="algorithm-get">
<h2>Algorithm::get<a class="headerlink" href="#algorithm-get" title="Permalink to this headline">¶</a></h2>
<p>Returns the algorithm parameter</p>
<dl class="function">
<dt id="template&lt;typename _Tp&gt; typename ParamType&lt;_Tp&gt;::member_type Algorithm::get(const string&amp; name) const">
<strong>C++:</strong><code class="descname"> </code>template&lt;typename _Tp&gt; typename ParamType&lt;_Tp&gt;::member_type <code class="descclassname">Algorithm::</code><code class="descname">get</code><span class="sig-paren">(</span>const string&amp; <strong>name</strong><span class="sig-paren">)</span><code class="descclassname"> const</code><a class="headerlink" href="#template<typename _Tp> typename ParamType<_Tp>::member_type Algorithm::get(const string& name) const" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>name</strong> &#8211; The parameter name.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<p>The method returns value of the particular parameter. Since the compiler can not deduce the type of the returned parameter, you should specify it explicitly in angle brackets. Here are the allowed forms of get:</p>
<blockquote>
<div><ul class="simple">
<li>myalgo.get&lt;int&gt;(&#8220;param_name&#8221;)</li>
<li>myalgo.get&lt;double&gt;(&#8220;param_name&#8221;)</li>
<li>myalgo.get&lt;bool&gt;(&#8220;param_name&#8221;)</li>
<li>myalgo.get&lt;string&gt;(&#8220;param_name&#8221;)</li>
<li>myalgo.get&lt;Mat&gt;(&#8220;param_name&#8221;)</li>
<li>myalgo.get&lt;vector&lt;Mat&gt; &gt;(&#8220;param_name&#8221;)</li>
<li>myalgo.get&lt;Algorithm&gt;(&#8220;param_name&#8221;) (it returns Ptr&lt;Algorithm&gt;).</li>
</ul>
</div></blockquote>
<p>In some cases the actual type of the parameter can be cast to the specified type, e.g. integer parameter can be cast to double, <code class="docutils literal"><span class="pre">bool</span></code> can be cast to <code class="docutils literal"><span class="pre">int</span></code>. But &#8220;dangerous&#8221; transformations (string&lt;-&gt;number, double-&gt;int, 1x1 Mat&lt;-&gt;number, ...) are not performed and the method will throw an exception. In the case of <code class="docutils literal"><span class="pre">Mat</span></code> or <code class="docutils literal"><span class="pre">vector&lt;Mat&gt;</span></code> parameters the method does not clone the matrix data, so do not modify the matrices. Use <code class="docutils literal"><span class="pre">Algorithm::set</span></code> instead - slower, but more safe.</p>
</div>
<div class="section" id="algorithm-set">
<h2>Algorithm::set<a class="headerlink" href="#algorithm-set" title="Permalink to this headline">¶</a></h2>
<p>Sets the algorithm parameter</p>
<dl class="function">
<dt id="void Algorithm::set(const string&amp; name, int value)">
<strong>C++:</strong><code class="descname"> </code>void <code class="descclassname">Algorithm::</code><code class="descname">set</code><span class="sig-paren">(</span>const string&amp; <strong>name</strong>, int <strong>value</strong><span class="sig-paren">)</span><a class="headerlink" href="#void Algorithm::set(const string& name, int value)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="void Algorithm::set(const string&amp; name, double value)">
<strong>C++:</strong><code class="descname"> </code>void <code class="descclassname">Algorithm::</code><code class="descname">set</code><span class="sig-paren">(</span>const string&amp; <strong>name</strong>, double <strong>value</strong><span class="sig-paren">)</span><a class="headerlink" href="#void Algorithm::set(const string& name, double value)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="void Algorithm::set(const string&amp; name, bool value)">
<strong>C++:</strong><code class="descname"> </code>void <code class="descclassname">Algorithm::</code><code class="descname">set</code><span class="sig-paren">(</span>const string&amp; <strong>name</strong>, bool <strong>value</strong><span class="sig-paren">)</span><a class="headerlink" href="#void Algorithm::set(const string& name, bool value)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="void Algorithm::set(const string&amp; name, const string&amp; value)">
<strong>C++:</strong><code class="descname"> </code>void <code class="descclassname">Algorithm::</code><code class="descname">set</code><span class="sig-paren">(</span>const string&amp; <strong>name</strong>, const string&amp; <strong>value</strong><span class="sig-paren">)</span><a class="headerlink" href="#void Algorithm::set(const string& name, const string& value)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="void Algorithm::set(const string&amp; name, const Mat&amp; value)">
<strong>C++:</strong><code class="descname"> </code>void <code class="descclassname">Algorithm::</code><code class="descname">set</code><span class="sig-paren">(</span>const string&amp; <strong>name</strong>, const Mat&amp; <strong>value</strong><span class="sig-paren">)</span><a class="headerlink" href="#void Algorithm::set(const string& name, const Mat& value)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="void Algorithm::set(const string&amp; name, const vector&lt;Mat&gt;&amp; value)">
<strong>C++:</strong><code class="descname"> </code>void <code class="descclassname">Algorithm::</code><code class="descname">set</code><span class="sig-paren">(</span>const string&amp; <strong>name</strong>, const vector&lt;Mat&gt;&amp; <strong>value</strong><span class="sig-paren">)</span><a class="headerlink" href="#void Algorithm::set(const string& name, const vector<Mat>& value)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="void Algorithm::set(const string&amp; name, const Ptr&lt;Algorithm&gt;&amp; value)">
<strong>C++:</strong><code class="descname"> </code>void <code class="descclassname">Algorithm::</code><code class="descname">set</code><span class="sig-paren">(</span>const string&amp; <strong>name</strong>, const Ptr&lt;Algorithm&gt;&amp; <strong>value</strong><span class="sig-paren">)</span><a class="headerlink" href="#void Algorithm::set(const string& name, const Ptr<Algorithm>& value)" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>name</strong> &#8211; The parameter name.</li>
<li><strong>value</strong> &#8211; The parameter value.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<p>The method sets value of the particular parameter. Some of the algorithm parameters may be declared as read-only. If you try to set such a parameter, you will get exception with the corresponding error message.</p>
</div>
<div class="section" id="algorithm-write">
<h2>Algorithm::write<a class="headerlink" href="#algorithm-write" title="Permalink to this headline">¶</a></h2>
<p>Stores algorithm parameters in a file storage</p>
<dl class="function">
<dt id="void Algorithm::write(FileStorage&amp; fs) const">
<strong>C++:</strong><code class="descname"> </code>void <code class="descclassname">Algorithm::</code><code class="descname">write</code><span class="sig-paren">(</span>FileStorage&amp; <strong>fs</strong><span class="sig-paren">)</span><code class="descclassname"> const</code><a class="headerlink" href="#void Algorithm::write(FileStorage& fs) const" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>fs</strong> &#8211; File storage.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<p>The method stores all the algorithm parameters (in alphabetic order) to the file storage. The method is virtual. If you define your own Algorithm derivative, your can override the method and store some extra information. However, it&#8217;s rarely needed. Here are some examples:</p>
<blockquote>
<div><ul class="simple">
<li>SIFT feature detector (from nonfree module). The class only stores algorithm parameters and no keypoints or their descriptors. Therefore, it&#8217;s enough to store the algorithm parameters, which is what <code class="docutils literal"><span class="pre">Algorithm::write()</span></code> does. Therefore, there is no dedicated <code class="docutils literal"><span class="pre">SIFT::write()</span></code>.</li>
<li>Background subtractor (from video module). It has the algorithm parameters and also it has the current background model. However, the background model is not stored. First, it&#8217;s rather big. Then, if you have stored the background model, it would likely become irrelevant on the next run (because of shifted camera, changed background, different lighting etc.). Therefore, <code class="docutils literal"><span class="pre">BackgroundSubtractorMOG</span></code> and <code class="docutils literal"><span class="pre">BackgroundSubtractorMOG2</span></code> also rely on the standard <code class="docutils literal"><span class="pre">Algorithm::write()</span></code> to store just the algorithm parameters.</li>
<li>Expectation Maximization (from ml module). The algorithm finds mixture of gaussians that approximates user data best of all. In this case the model may be re-used on the next run to test new data against the trained statistical model. So EM needs to store the model. However, since the model is described by a few parameters that are available as read-only algorithm parameters (i.e. they are available via <code class="docutils literal"><span class="pre">EM::get()</span></code>), EM also relies on <code class="docutils literal"><span class="pre">Algorithm::write()</span></code> to store both EM parameters and the model (represented by read-only algorithm parameters).</li>
</ul>
</div></blockquote>
</div>
<div class="section" id="algorithm-read">
<h2>Algorithm::read<a class="headerlink" href="#algorithm-read" title="Permalink to this headline">¶</a></h2>
<p>Reads algorithm parameters from a file storage</p>
<dl class="function">
<dt id="void Algorithm::read(const FileNode&amp; fn)">
<strong>C++:</strong><code class="descname"> </code>void <code class="descclassname">Algorithm::</code><code class="descname">read</code><span class="sig-paren">(</span>const FileNode&amp; <strong>fn</strong><span class="sig-paren">)</span><a class="headerlink" href="#void Algorithm::read(const FileNode& fn)" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>fn</strong> &#8211; File node of the file storage.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<p>The method reads all the algorithm parameters from the specified node of a file storage. Similarly to <code class="docutils literal"><span class="pre">Algorithm::write()</span></code>, if you implement an algorithm that needs to read some extra data and/or re-compute some internal data, you may override the method.</p>
</div>
<div class="section" id="algorithm-getlist">
<h2>Algorithm::getList<a class="headerlink" href="#algorithm-getlist" title="Permalink to this headline">¶</a></h2>
<p>Returns the list of registered algorithms</p>
<dl class="function">
<dt id="void Algorithm::getList(vector&lt;string&gt;&amp; algorithms)">
<strong>C++:</strong><code class="descname"> </code>void <code class="descclassname">Algorithm::</code><code class="descname">getList</code><span class="sig-paren">(</span>vector&lt;string&gt;&amp; <strong>algorithms</strong><span class="sig-paren">)</span><a class="headerlink" href="#void Algorithm::getList(vector<string>& algorithms)" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>algorithms</strong> &#8211; The output vector of algorithm names.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<p>This static method returns the list of registered algorithms in alphabetical order. Here is how to use it</p>
<div class="highlight-cpp"><div class="highlight"><pre><span class="n">vector</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">algorithms</span><span class="p">;</span>
<span class="n">Algorithm</span><span class="o">::</span><span class="n">getList</span><span class="p">(</span><span class="n">algorithms</span><span class="p">);</span>
<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Algorithms: &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">algorithms</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
<span class="k">for</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">algorithms</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">algorithms</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</pre></div>
</div>
</div>
<div class="section" id="algorithm-create">
<h2>Algorithm::create<a class="headerlink" href="#algorithm-create" title="Permalink to this headline">¶</a></h2>
<p>Creates algorithm instance by name</p>
<dl class="function">
<dt id="template&lt;typename _Tp&gt; Ptr&lt;_Tp&gt; Algorithm::create(const string&amp; name)">
<strong>C++:</strong><code class="descname"> </code>template&lt;typename _Tp&gt; Ptr&lt;_Tp&gt; <code class="descclassname">Algorithm::</code><code class="descname">create</code><span class="sig-paren">(</span>const string&amp; <strong>name</strong><span class="sig-paren">)</span><a class="headerlink" href="#template<typename _Tp> Ptr<_Tp> Algorithm::create(const string& name)" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>name</strong> &#8211; The algorithm name, one of the names returned by <code class="docutils literal"><span class="pre">Algorithm::getList()</span></code>.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<p>This static method creates a new instance of the specified algorithm. If there is no such algorithm, the method will silently return null pointer (that can be checked by <code class="docutils literal"><span class="pre">Ptr::empty()</span></code> method). Also, you should specify the particular <code class="docutils literal"><span class="pre">Algorithm</span></code> subclass as <code class="docutils literal"><span class="pre">_Tp</span></code> (or simply <code class="docutils literal"><span class="pre">Algorithm</span></code> if you do not know it at that point).</p>
<div class="highlight-cpp"><div class="highlight"><pre><span class="n">Ptr</span><span class="o">&lt;</span><span class="n">BackgroundSubtractor</span><span class="o">&gt;</span> <span class="n">bgfg</span> <span class="o">=</span> <span class="n">Algorithm</span><span class="o">::</span><span class="n">create</span><span class="o">&lt;</span><span class="n">BackgroundSubtractor</span><span class="o">&gt;</span><span class="p">(</span><span class="s">&quot;BackgroundSubtractor.MOG2&quot;</span><span class="p">);</span>
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This is important note about seemingly mysterious behavior of <code class="docutils literal"><span class="pre">Algorithm::create()</span></code> when it returns NULL while it should not. The reason is simple - <code class="docutils literal"><span class="pre">Algorithm::create()</span></code> resides in OpenCV`s core module and the algorithms are implemented in other modules. If you create algorithms dynamically, C++ linker may decide to throw away the modules where the actual algorithms are implemented, since you do not call any functions from the modules. To avoid this problem, you need to call <code class="docutils literal"><span class="pre">initModule_&lt;modulename&gt;();</span></code> somewhere in the beginning of the program before <code class="docutils literal"><span class="pre">Algorithm::create()</span></code>. For example, call <code class="docutils literal"><span class="pre">initModule_nonfree()</span></code> in order to use SURF/SIFT, call <code class="docutils literal"><span class="pre">initModule_ml()</span></code> to use expectation maximization etc.</p>
</div>
</div>
<div class="section" id="creating-own-algorithms">
<h2>Creating Own Algorithms<a class="headerlink" href="#creating-own-algorithms" title="Permalink to this headline">¶</a></h2>
<p>The above methods are usually enough for users. If you want to make your own algorithm, derived from <code class="docutils literal"><span class="pre">Algorithm</span></code>, you should basically follow a few conventions and add a little semi-standard piece of code to your class:</p>
<blockquote>
<div><ul class="simple">
<li>Make a class and specify <code class="docutils literal"><span class="pre">Algorithm</span></code> as its base class.</li>
<li>The algorithm parameters should be the class members. See <code class="docutils literal"><span class="pre">Algorithm::get()</span></code> for the list of possible types of the parameters.</li>
<li>Add public virtual method <code class="docutils literal"><span class="pre">AlgorithmInfo*</span> <span class="pre">info()</span> <span class="pre">const;</span></code> to your class.</li>
<li>Add constructor function, <code class="docutils literal"><span class="pre">AlgorithmInfo</span></code> instance and implement the <code class="docutils literal"><span class="pre">info()</span></code> method. The simplest way is to take <a class="reference external" href="https://github.com/opencv/opencv/tree/master/modules/ml/src/ml_init.cpp">https://github.com/opencv/opencv/tree/master/modules/ml/src/ml_init.cpp</a> as the reference and modify it according to the list of your parameters.</li>
<li>Add some public function (e.g. <code class="docutils literal"><span class="pre">initModule_&lt;mymodule&gt;()</span></code>) that calls info() of your algorithm and put it into the same source file as <code class="docutils literal"><span class="pre">info()</span></code> implementation. This is to force C++ linker to include this object file into the target application. See <code class="docutils literal"><span class="pre">Algorithm::create()</span></code> for details.</li>
</ul>
</div></blockquote>
</div>
</div>


          </div>
          <div class="feedback">
              <h2>Help and Feedback</h2>
              You did not find what you were looking for?
              <ul>
                  
                  
                  
                  <li>Ask a question on the <a href="http://answers.opencv.org">Q&A forum</a>.</li>
                  <li>If you think something is missing or wrong in the documentation,
                  please file a <a href="http://code.opencv.org">bug report</a>.</li>
              </ul>
          </div>
        </div>
      </div>

      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../../../index.html">
              <img class="logo" src="../../../_static/opencv-logo-white.png" alt="Logo"/>
            </a></p>
<div id="searchbox" style="display: none">
      <form class="search" action="../../../search.html" method="get">
      <input type="text" name="q" size="18" />
      <input type="submit" value="Search" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
      </p>
    </form>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
  <h3><a href="../../../index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Basic Structures</a><ul>
<li><a class="reference internal" href="#datatype">DataType</a></li>
<li><a class="reference internal" href="#point">Point_</a></li>
<li><a class="reference internal" href="#point3">Point3_</a></li>
<li><a class="reference internal" href="#size">Size_</a></li>
<li><a class="reference internal" href="#rect">Rect_</a></li>
<li><a class="reference internal" href="#rotatedrect">RotatedRect</a></li>
<li><a class="reference internal" href="#termcriteria">TermCriteria</a></li>
<li><a class="reference internal" href="#termcriteria-termcriteria">TermCriteria::TermCriteria</a></li>
<li><a class="reference internal" href="#termcriteria-operator-cvtermcriteria">TermCriteria::operator CvTermCriteria</a></li>
<li><a class="reference internal" href="#matx">Matx</a></li>
<li><a class="reference internal" href="#vec">Vec</a></li>
<li><a class="reference internal" href="#scalar">Scalar_</a></li>
<li><a class="reference internal" href="#range">Range</a></li>
<li><a class="reference internal" href="#ptr">Ptr</a></li>
<li><a class="reference internal" href="#ptr-ptr">Ptr::Ptr</a></li>
<li><a class="reference internal" href="#id2">Ptr::~Ptr</a></li>
<li><a class="reference internal" href="#ptr-operator">Ptr::operator =</a></li>
<li><a class="reference internal" href="#ptr-addref">Ptr::addref</a></li>
<li><a class="reference internal" href="#ptr-release">Ptr::release</a></li>
<li><a class="reference internal" href="#ptr-delete-obj">Ptr::delete_obj</a></li>
<li><a class="reference internal" href="#ptr-empty">Ptr::empty</a></li>
<li><a class="reference internal" href="#id3">Ptr::operator -&gt;</a></li>
<li><a class="reference internal" href="#ptr-operator-tp">Ptr::operator _Tp*</a></li>
<li><a class="reference internal" href="#mat">Mat</a></li>
<li><a class="reference internal" href="#matrix-expressions">Matrix Expressions</a></li>
<li><a class="reference internal" href="#mat-mat">Mat::Mat</a></li>
<li><a class="reference internal" href="#id4">Mat::~Mat</a></li>
<li><a class="reference internal" href="#mat-operator">Mat::operator =</a></li>
<li><a class="reference internal" href="#mat-row">Mat::row</a></li>
<li><a class="reference internal" href="#mat-col">Mat::col</a></li>
<li><a class="reference internal" href="#mat-rowrange">Mat::rowRange</a></li>
<li><a class="reference internal" href="#mat-colrange">Mat::colRange</a></li>
<li><a class="reference internal" href="#mat-diag">Mat::diag</a></li>
<li><a class="reference internal" href="#mat-clone">Mat::clone</a></li>
<li><a class="reference internal" href="#mat-copyto">Mat::copyTo</a></li>
<li><a class="reference internal" href="#mat-convertto">Mat::convertTo</a></li>
<li><a class="reference internal" href="#mat-assignto">Mat::assignTo</a></li>
<li><a class="reference internal" href="#mat-setto">Mat::setTo</a></li>
<li><a class="reference internal" href="#mat-reshape">Mat::reshape</a></li>
<li><a class="reference internal" href="#mat-t">Mat::t</a></li>
<li><a class="reference internal" href="#mat-inv">Mat::inv</a></li>
<li><a class="reference internal" href="#mat-mul">Mat::mul</a></li>
<li><a class="reference internal" href="#mat-cross">Mat::cross</a></li>
<li><a class="reference internal" href="#mat-dot">Mat::dot</a></li>
<li><a class="reference internal" href="#mat-zeros">Mat::zeros</a></li>
<li><a class="reference internal" href="#mat-ones">Mat::ones</a></li>
<li><a class="reference internal" href="#mat-eye">Mat::eye</a></li>
<li><a class="reference internal" href="#mat-create">Mat::create</a></li>
<li><a class="reference internal" href="#mat-addref">Mat::addref</a></li>
<li><a class="reference internal" href="#mat-release">Mat::release</a></li>
<li><a class="reference internal" href="#mat-resize">Mat::resize</a></li>
<li><a class="reference internal" href="#mat-reserve">Mat::reserve</a></li>
<li><a class="reference internal" href="#mat-push-back">Mat::push_back</a></li>
<li><a class="reference internal" href="#mat-pop-back">Mat::pop_back</a></li>
<li><a class="reference internal" href="#mat-locateroi">Mat::locateROI</a></li>
<li><a class="reference internal" href="#mat-adjustroi">Mat::adjustROI</a></li>
<li><a class="reference internal" href="#id6">Mat::operator()</a></li>
<li><a class="reference internal" href="#mat-operator-cvmat">Mat::operator CvMat</a></li>
<li><a class="reference internal" href="#mat-operator-iplimage">Mat::operator IplImage</a></li>
<li><a class="reference internal" href="#mat-total">Mat::total</a></li>
<li><a class="reference internal" href="#mat-iscontinuous">Mat::isContinuous</a></li>
<li><a class="reference internal" href="#mat-elemsize">Mat::elemSize</a></li>
<li><a class="reference internal" href="#mat-elemsize1">Mat::elemSize1</a></li>
<li><a class="reference internal" href="#mat-type">Mat::type</a></li>
<li><a class="reference internal" href="#mat-depth">Mat::depth</a></li>
<li><a class="reference internal" href="#mat-channels">Mat::channels</a></li>
<li><a class="reference internal" href="#mat-step1">Mat::step1</a></li>
<li><a class="reference internal" href="#mat-size">Mat::size</a></li>
<li><a class="reference internal" href="#mat-empty">Mat::empty</a></li>
<li><a class="reference internal" href="#mat-ptr">Mat::ptr</a></li>
<li><a class="reference internal" href="#mat-at">Mat::at</a></li>
<li><a class="reference internal" href="#mat-begin">Mat::begin</a></li>
<li><a class="reference internal" href="#mat-end">Mat::end</a></li>
<li><a class="reference internal" href="#id7">Mat_</a></li>
<li><a class="reference internal" href="#inputarray">InputArray</a></li>
<li><a class="reference internal" href="#outputarray">OutputArray</a></li>
<li><a class="reference internal" href="#narymatiterator">NAryMatIterator</a></li>
<li><a class="reference internal" href="#sparsemat">SparseMat</a></li>
<li><a class="reference internal" href="#sparsemat-sparsemat">SparseMat::SparseMat</a></li>
<li><a class="reference internal" href="#id8">SparseMat::~SparseMat</a></li>
<li><a class="reference internal" href="#sparsemat-operator">SparseMat::operator=</a></li>
<li><a class="reference internal" href="#sparsemat-clone">SparseMat::clone</a></li>
<li><a class="reference internal" href="#sparsemat-copyto">SparseMat::copyTo</a></li>
<li><a class="reference internal" href="#sparcemat-convertto">SparceMat::convertTo</a></li>
<li><a class="reference internal" href="#sparsemat-create">SparseMat:create</a></li>
<li><a class="reference internal" href="#sparsemat-clear">SparseMat::clear</a></li>
<li><a class="reference internal" href="#sparsemat-addref">SparseMat::addref</a></li>
<li><a class="reference internal" href="#sparsemat-release">SparseMat::release</a></li>
<li><a class="reference internal" href="#sparsemat-cvsparsemat">SparseMat::CvSparseMat *</a></li>
<li><a class="reference internal" href="#sparsemat-elemsize">SparseMat::elemSize</a></li>
<li><a class="reference internal" href="#sparsemat-elemsize1">SparseMat::elemSize1</a></li>
<li><a class="reference internal" href="#sparsemat-type">SparseMat::type</a></li>
<li><a class="reference internal" href="#sparsemat-depth">SparseMat::depth</a></li>
<li><a class="reference internal" href="#sparsemat-channels">SparseMat::channels</a></li>
<li><a class="reference internal" href="#sparsemat-size">SparseMat::size</a></li>
<li><a class="reference internal" href="#sparsemat-dims">SparseMat::dims</a></li>
<li><a class="reference internal" href="#sparsemat-nzcount">SparseMat::nzcount</a></li>
<li><a class="reference internal" href="#sparsemat-hash">SparseMat::hash</a></li>
<li><a class="reference internal" href="#sparsemat-ptr">SparseMat::ptr</a></li>
<li><a class="reference internal" href="#sparsemat-erase">SparseMat::erase</a></li>
<li><a class="reference internal" href="#id9">SparseMat_</a></li>
<li><a class="reference internal" href="#algorithm">Algorithm</a></li>
<li><a class="reference internal" href="#algorithm-name">Algorithm::name</a></li>
<li><a class="reference internal" href="#algorithm-get">Algorithm::get</a></li>
<li><a class="reference internal" href="#algorithm-set">Algorithm::set</a></li>
<li><a class="reference internal" href="#algorithm-write">Algorithm::write</a></li>
<li><a class="reference internal" href="#algorithm-read">Algorithm::read</a></li>
<li><a class="reference internal" href="#algorithm-getlist">Algorithm::getList</a></li>
<li><a class="reference internal" href="#algorithm-create">Algorithm::create</a></li>
<li><a class="reference internal" href="#creating-own-algorithms">Creating Own Algorithms</a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="core.html"
                        title="previous chapter">core. The Core Functionality</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="old_basic_structures.html"
                        title="next chapter">Basic C Structures and Operations</a></p>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../../../_sources/modules/core/doc/basic_structures.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="old_basic_structures.html" title="Basic C Structures and Operations"
             >next</a> |</li>
        <li class="right" >
          <a href="core.html" title="core. The Core Functionality"
             >previous</a> |</li>
        <li><a href="../../../index.html">OpenCV 2.4.13.7 documentation</a> &raquo;</li>
          <li><a href="../../refman.html" >OpenCV API Reference</a> &raquo;</li>
          <li><a href="core.html" >core. The Core Functionality</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2011-2014, opencv dev team.
      Last updated on Jul 12, 2018.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.3.6.
    </div>
  </body>
</html>
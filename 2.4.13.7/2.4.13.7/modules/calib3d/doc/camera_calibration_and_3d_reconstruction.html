<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<script type="text/javascript">

  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-33108845-1']);
  _gaq.push(['_setDomainName', 'opencv.org']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();

</script>

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Camera Calibration and 3D Reconstruction &mdash; OpenCV 2.4.13.7 documentation</title>
    <link rel="stylesheet" href="../../../_static/default.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../../',
        VERSION:     '2.4.13.7',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../../_static/doctools.js"></script>
    <link rel="top" title="OpenCV 2.4.13.7 documentation" href="../../../index.html" />
    <link rel="up" title="calib3d. Camera Calibration and 3D Reconstruction" href="calib3d.html" />
    <link rel="next" title="features2d. 2D Features Framework" href="../../features2d/doc/features2d.html" />
    <link rel="prev" title="calib3d. Camera Calibration and 3D Reconstruction" href="calib3d.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../features2d/doc/features2d.html" title="features2d. 2D Features Framework"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="calib3d.html" title="calib3d. Camera Calibration and 3D Reconstruction"
             accesskey="P">previous</a> |</li>
        <li><a href="../../../index.html">OpenCV 2.4.13.7 documentation</a> &raquo;</li>
          <li><a href="../../refman.html" >OpenCV API Reference</a> &raquo;</li>
          <li><a href="calib3d.html" accesskey="U">calib3d. Camera Calibration and 3D Reconstruction</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
  
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="camera-calibration-and-3d-reconstruction">
<h1>Camera Calibration and 3D Reconstruction<a class="headerlink" href="#camera-calibration-and-3d-reconstruction" title="Permalink to this headline">¶</a></h1>
<p>The functions in this section use a so-called pinhole camera model. In this model, a scene view is formed by projecting 3D points into the image plane
using a perspective transformation.</p>
<div class="math">
<p><img src="../../../_images/math/363c6d531e851a1eb934e7d6f875d593e2dc6f37.png" alt="s  \; m' = A [R|t] M'"/></p>
</div><p>or</p>
<div class="math">
<p><img src="../../../_images/math/803e522ec37bc5bc609c0ef08373a350a819fc15.png" alt="s  \vecthree{u}{v}{1} = \vecthreethree{f_x}{0}{c_x}{0}{f_y}{c_y}{0}{0}{1}
\begin{bmatrix}
r_{11} &amp; r_{12} &amp; r_{13} &amp; t_1  \\
r_{21} &amp; r_{22} &amp; r_{23} &amp; t_2  \\
r_{31} &amp; r_{32} &amp; r_{33} &amp; t_3
\end{bmatrix}
\begin{bmatrix}
X \\
Y \\
Z \\
1
\end{bmatrix}"/></p>
</div><p>where:</p>
<blockquote>
<div><ul class="simple">
<li><img class="math" src="../../../_images/math/0833ce84fc64962fec6e4416dde7fd4879186a96.png" alt="(X, Y, Z)"/> are the coordinates of a 3D point in the world coordinate space</li>
<li><img class="math" src="../../../_images/math/8a26bd6b76072e327e2462b2fe05546ba899e682.png" alt="(u, v)"/> are the coordinates of the projection point in pixels</li>
<li><img class="math" src="../../../_images/math/a4a22711db10ba4f6c1c70ad5f01fcc7f29a10ba.png" alt="A"/> is a camera matrix, or a matrix of intrinsic parameters</li>
<li><img class="math" src="../../../_images/math/48a7d669df1f15a8f8c44728809543114ce618f6.png" alt="(cx, cy)"/> is a principal point that is usually at the image center</li>
<li><img class="math" src="../../../_images/math/ec7ae7b879562c25d2732cdd63fd257748c99c44.png" alt="fx, fy"/> are the focal lengths expressed in pixel units.</li>
</ul>
</div></blockquote>
<p>Thus, if an image from the camera is
scaled by a factor, all of these parameters should
be scaled (multiplied/divided, respectively) by the same factor. The
matrix of intrinsic parameters does not depend on the scene viewed. So,
once estimated, it can be re-used as long as the focal length is fixed (in
case of zoom lens). The joint rotation-translation matrix
<img class="math" src="../../../_images/math/fad27ce6ccd005e429215a332c9d7a3a93c8246b.png" alt="[R|t]"/> is called a matrix of extrinsic parameters. It is used to describe the
camera motion around a static scene, or vice versa, rigid motion of an
object in front of a still camera. That is,
<img class="math" src="../../../_images/math/fad27ce6ccd005e429215a332c9d7a3a93c8246b.png" alt="[R|t]"/> translates
coordinates of a point
<img class="math" src="../../../_images/math/0833ce84fc64962fec6e4416dde7fd4879186a96.png" alt="(X, Y, Z)"/> to a coordinate system,
fixed with respect to the camera. The transformation above is equivalent
to the following (when
<img class="math" src="../../../_images/math/e73882d15bf9efc63f41f55a941bed1e26de7b43.png" alt="z \ne 0"/> ):</p>
<div class="math">
<p><img src="../../../_images/math/f51a5ba02487486308c29bef720f3186d18abac6.png" alt="\begin{array}{l}
\vecthree{x}{y}{z} = R  \vecthree{X}{Y}{Z} + t \\
x' = x/z \\
y' = y/z \\
u = f_x*x' + c_x \\
v = f_y*y' + c_y
\end{array}"/></p>
</div><p>The following figure illustrates the pinhole camera model.</p>
<img alt="../../../_images/pinhole_camera_model.png" class="align-center" src="../../../_images/pinhole_camera_model.png" />
<p>Real lenses usually have some distortion, mostly
radial distortion and slight tangential distortion. So, the above model
is extended as:</p>
<div class="math">
<p><img src="../../../_images/math/331ebcd980b851f25de1979ebb67a2fed1c8477e.png" alt="\begin{array}{l} \vecthree{x}{y}{z} = R  \vecthree{X}{Y}{Z} + t \\ x' = x/z \\ y' = y/z \\ x'' = x'  \frac{1 + k_1 r^2 + k_2 r^4 + k_3 r^6}{1 + k_4 r^2 + k_5 r^4 + k_6 r^6} + 2 p_1 x' y' + p_2(r^2 + 2 x'^2)  \\ y'' = y'  \frac{1 + k_1 r^2 + k_2 r^4 + k_3 r^6}{1 + k_4 r^2 + k_5 r^4 + k_6 r^6} + p_1 (r^2 + 2 y'^2) + 2 p_2 x' y'  \\ \text{where} \quad r^2 = x'^2 + y'^2  \\ u = f_x*x'' + c_x \\ v = f_y*y'' + c_y \end{array}"/></p>
</div><p><img class="math" src="../../../_images/math/ecb751e386c5247c2e8937dd4f8ce245db3d4eb8.png" alt="k_1"/>,
<img class="math" src="../../../_images/math/a870e4d5b8248cb2cfd261668331debca4af41f9.png" alt="k_2"/>,
<img class="math" src="../../../_images/math/3899578ed5a644878e614d918b65c9821a400ea2.png" alt="k_3"/>,
<img class="math" src="../../../_images/math/8f99a628549ddebf37b8e906a6f76cd6ae5dea04.png" alt="k_4"/>,
<img class="math" src="../../../_images/math/4e76044e948a886548a2f14dda836e416b71dd0c.png" alt="k_5"/>, and
<img class="math" src="../../../_images/math/53219cf4960118e7f58a81ad421000da0947bb52.png" alt="k_6"/> are radial distortion coefficients.
<img class="math" src="../../../_images/math/d405fc06c6077f83cc84c5e3ba41962fc5dede4c.png" alt="p_1"/> and
<img class="math" src="../../../_images/math/a7c121ed51d0825b1c4a6cea032e76438d856c2d.png" alt="p_2"/> are tangential distortion coefficients.
Higher-order coefficients are not considered in OpenCV.</p>
<p>The next figure shows two common types of radial distortion: barrel distortion (typically <img class="math" src="../../../_images/math/97516c7f60c94f20f186254a5599de20298255ff.png" alt="k_1 &gt; 0"/> and pincushion distortion (typically <img class="math" src="../../../_images/math/d3f22fdba89f6c413fe7d39ee9f6e202aceead90.png" alt="k_1 &lt; 0"/>).</p>
<img alt="../../../_images/distortion_examples.png" class="align-center" src="../../../_images/distortion_examples.png" />
<p>In the functions below the coefficients are passed or returned as</p>
<div class="math">
<p><img src="../../../_images/math/c4c47b9554bab572f9e3ea8d7b0be7eeb8b7c6e5.png" alt="(k_1, k_2, p_1, p_2[, k_3[, k_4, k_5, k_6]])"/></p>
</div><p>vector. That is, if the vector contains four elements, it means that
<img class="math" src="../../../_images/math/ea09a6f0dd634e03a2d530f14ea492e8ab0ddc17.png" alt="k_3=0"/> .
The distortion coefficients do not depend on the scene viewed. Thus, they also belong to the intrinsic camera parameters. And they remain the same regardless of the captured image resolution.
If, for example, a camera has been calibrated on images of
<code class="docutils literal"><span class="pre">320</span> <span class="pre">x</span> <span class="pre">240</span></code> resolution, absolutely the same distortion coefficients can
be used for <code class="docutils literal"><span class="pre">640</span> <span class="pre">x</span> <span class="pre">480</span></code> images from the same camera while
<img class="math" src="../../../_images/math/90cbff5be10b7d5d6a3ec6cabfe05e306e99ac1c.png" alt="f_x"/>,
<img class="math" src="../../../_images/math/0a9dfcd96704b05afe921dcabeefcd77bfdbd863.png" alt="f_y"/>,
<img class="math" src="../../../_images/math/9b3b5249a3d76623dfc49952e7b1d24fe8c7942f.png" alt="c_x"/>, and
<img class="math" src="../../../_images/math/690b7a0c20d6a00f67e5c16ca5dcab66d7969184.png" alt="c_y"/> need to be scaled appropriately.</p>
<p>The functions below use the above model to do the following:</p>
<blockquote>
<div><ul class="simple">
<li>Project 3D points to the image plane given intrinsic and extrinsic parameters.</li>
<li>Compute extrinsic parameters given intrinsic parameters, a few 3D points, and their projections.</li>
<li>Estimate intrinsic and extrinsic camera parameters from several views of a known calibration pattern (every view is described by several 3D-2D point correspondences).</li>
<li>Estimate the relative position and orientation of the stereo camera &#8220;heads&#8221; and compute the <em>rectification</em> transformation that makes the camera optical axes parallel.</li>
</ul>
</div></blockquote>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<ul class="last simple">
<li>A calibration sample for 3 cameras in horizontal position can be found at opencv_source_code/samples/cpp/3calibration.cpp</li>
<li>A calibration sample based on a sequence of images can be found at opencv_source_code/samples/cpp/calibration.cpp</li>
<li>A calibration sample in order to do 3D reconstruction can be found at opencv_source_code/samples/cpp/build3dmodel.cpp</li>
<li>A calibration sample of an artificially generated camera and chessboard patterns can be found at opencv_source_code/samples/cpp/calibration_artificial.cpp</li>
<li>A calibration example on stereo calibration can be found at opencv_source_code/samples/cpp/stereo_calib.cpp</li>
<li>A calibration example on stereo matching can be found at opencv_source_code/samples/cpp/stereo_match.cpp</li>
<li>(Python) A camera calibration sample can be found at opencv_source_code/samples/python2/calibrate.py</li>
</ul>
</div>
<div class="section" id="calibratecamera">
<h2>calibrateCamera<a class="headerlink" href="#calibratecamera" title="Permalink to this headline">¶</a></h2>
<p>Finds the camera intrinsic and extrinsic parameters from several views of a calibration pattern.</p>
<dl class="function">
<dt id="double calibrateCamera(InputArrayOfArrays objectPoints, InputArrayOfArrays imagePoints, Size imageSize, InputOutputArray cameraMatrix, InputOutputArray distCoeffs, OutputArrayOfArrays rvecs, OutputArrayOfArrays tvecs, int flags, TermCriteria criteria)">
<strong>C++:</strong><code class="descname"> </code>double <code class="descname">calibrateCamera</code><span class="sig-paren">(</span>InputArrayOfArrays <strong>objectPoints</strong>, InputArrayOfArrays <strong>imagePoints</strong>, Size <strong>imageSize</strong>, InputOutputArray <strong>cameraMatrix</strong>, InputOutputArray <strong>distCoeffs</strong>, OutputArrayOfArrays <strong>rvecs</strong>, OutputArrayOfArrays <strong>tvecs</strong>, int <strong>flags</strong>=0, TermCriteria <strong>criteria</strong>=TermCriteria( TermCriteria::COUNT+TermCriteria::EPS, 30, DBL_EPSILON) <span class="sig-paren">)</span><a class="headerlink" href="#double calibrateCamera(InputArrayOfArrays objectPoints, InputArrayOfArrays imagePoints, Size imageSize, InputOutputArray cameraMatrix, InputOutputArray distCoeffs, OutputArrayOfArrays rvecs, OutputArrayOfArrays tvecs, int flags, TermCriteria criteria)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="pyfunction">
<dt id="cv2.calibrateCamera">
<strong>Python:</strong><code class="descname"> </code><code class="descclassname">cv2.</code><code class="descname">calibrateCamera</code><span class="sig-paren">(</span>objectPoints, imagePoints, imageSize<span class="optional">[</span>, cameraMatrix<span class="optional">[</span>, distCoeffs<span class="optional">[</span>, rvecs<span class="optional">[</span>, tvecs<span class="optional">[</span>, flags<span class="optional">[</span>, criteria<span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span> &rarr; retval, cameraMatrix, distCoeffs, rvecs, tvecs<a class="headerlink" href="#cv2.calibrateCamera" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="cfunction">
<dt id="double cvCalibrateCamera2(const CvMat* object_points, const CvMat* image_points, const CvMat* point_counts, CvSize image_size, CvMat* camera_matrix, CvMat* distortion_coeffs, CvMat* rotation_vectors, CvMat* translation_vectors, int flags, CvTermCriteria term_crit)">
<strong>C:</strong><code class="descname"> </code>double <code class="descname">cvCalibrateCamera2</code><span class="sig-paren">(</span>const CvMat* <strong>object_points</strong>, const CvMat* <strong>image_points</strong>, const CvMat* <strong>point_counts</strong>, CvSize <strong>image_size</strong>, CvMat* <strong>camera_matrix</strong>, CvMat* <strong>distortion_coeffs</strong>, CvMat* <strong>rotation_vectors</strong>=NULL, CvMat* <strong>translation_vectors</strong>=NULL, int <strong>flags</strong>=0, CvTermCriteria <strong>term_crit</strong>=cvTermCriteria( CV_TERMCRIT_ITER+CV_TERMCRIT_EPS,30,DBL_EPSILON) <span class="sig-paren">)</span><a class="headerlink" href="#double cvCalibrateCamera2(const CvMat* object_points, const CvMat* image_points, const CvMat* point_counts, CvSize image_size, CvMat* camera_matrix, CvMat* distortion_coeffs, CvMat* rotation_vectors, CvMat* translation_vectors, int flags, CvTermCriteria term_crit)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="pyoldfunction">
<dt id="cv.CalibrateCamera2">
<strong>Python:</strong><code class="descname"> </code><code class="descclassname">cv.</code><code class="descname">CalibrateCamera2</code><span class="sig-paren">(</span>objectPoints, imagePoints, pointCounts, imageSize, cameraMatrix, distCoeffs, rvecs, tvecs, flags=0<span class="sig-paren">)</span> &rarr; None<a class="headerlink" href="#cv.CalibrateCamera2" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>objectPoints</strong> &#8211; <p>In the new interface it is a vector of vectors of calibration pattern points in the calibration pattern coordinate space (e.g. std::vector&lt;std::vector&lt;cv::Vec3f&gt;&gt;). The outer vector contains as many elements as the number of the pattern views. If the same calibration pattern is shown in each view and it is fully visible, all the vectors will be the same. Although, it is possible to use partially occluded patterns, or even different patterns in different views. Then, the vectors will be different. The points are 3D, but since they are in a pattern coordinate system, then, if the rig is planar, it may make sense to put the model to a XY coordinate plane so that Z-coordinate of each input object point is 0.</p>
<p>In the old interface all the vectors of object points from different views are concatenated together.</p>
</li>
<li><strong>imagePoints</strong> &#8211; <p>In the new interface it is a vector of vectors of the projections of calibration pattern points (e.g. std::vector&lt;std::vector&lt;cv::Vec2f&gt;&gt;). <code class="docutils literal"><span class="pre">imagePoints.size()</span></code> and <code class="docutils literal"><span class="pre">objectPoints.size()</span></code> and <code class="docutils literal"><span class="pre">imagePoints[i].size()</span></code> must be equal to <code class="docutils literal"><span class="pre">objectPoints[i].size()</span></code> for each <code class="docutils literal"><span class="pre">i</span></code>.</p>
<p>In the old interface all the vectors of object points from different views are concatenated together.</p>
</li>
<li><strong>point_counts</strong> &#8211; In the old interface this is a vector of integers, containing as many elements, as the number of views of the calibration pattern. Each element is the number of points in each view. Usually, all the elements are the same and equal to the number of feature points on the calibration pattern.</li>
<li><strong>imageSize</strong> &#8211; Size of the image used only to initialize the intrinsic camera matrix.</li>
<li><strong>cameraMatrix</strong> &#8211; Output 3x3 floating-point camera matrix  <img class="math" src="../../../_images/math/5017fc06df8951eb2ca115915d52e6fe6d8034de.png" alt="A = \vecthreethree{f_x}{0}{c_x}{0}{f_y}{c_y}{0}{0}{1}"/> . If  <code class="docutils literal"><span class="pre">CV_CALIB_USE_INTRINSIC_GUESS</span></code>  and/or  <code class="docutils literal"><span class="pre">CV_CALIB_FIX_ASPECT_RATIO</span></code>  are specified, some or all of  <code class="docutils literal"><span class="pre">fx,</span> <span class="pre">fy,</span> <span class="pre">cx,</span> <span class="pre">cy</span></code>  must be initialized before calling the function.</li>
<li><strong>distCoeffs</strong> &#8211; Output vector of distortion coefficients  <img class="math" src="../../../_images/math/94288b7709d10a7ddf286e33db0074512bda0411.png" alt="(k_1, k_2, p_1, p_2[, k_3[, k_4, k_5, k_6]])"/>  of 4, 5, or 8 elements.</li>
<li><strong>rvecs</strong> &#8211; Output  vector  of rotation vectors (see  <a class="reference internal" href="#void Rodrigues(InputArray src, OutputArray dst, OutputArray jacobian)" title="void Rodrigues(InputArray src, OutputArray dst, OutputArray jacobian)"><code class="xref ocv ocv-func docutils literal"><span class="pre">Rodrigues()</span></code></a> ) estimated for each pattern view (e.g. std::vector&lt;cv::Mat&gt;&gt;). That is, each k-th rotation vector together with the corresponding k-th translation vector (see the next output parameter description) brings the calibration pattern from the model coordinate space (in which object points are specified) to the world coordinate space, that is, a real position of the calibration pattern in the k-th pattern view (k=0.. <em>M</em> -1).</li>
<li><strong>tvecs</strong> &#8211; Output vector of translation vectors estimated for each pattern view.</li>
<li><strong>flags</strong> &#8211; <p>Different flags that may be zero or a combination of the following values:</p>
<blockquote>
<div><ul>
<li><strong>CV_CALIB_USE_INTRINSIC_GUESS</strong> <code class="docutils literal"><span class="pre">cameraMatrix</span></code>  contains valid initial values of  <code class="docutils literal"><span class="pre">fx,</span> <span class="pre">fy,</span> <span class="pre">cx,</span> <span class="pre">cy</span></code>  that are optimized further. Otherwise, <code class="docutils literal"><span class="pre">(cx,</span> <span class="pre">cy)</span></code>  is initially set to the image center ( <code class="docutils literal"><span class="pre">imageSize</span></code>  is used), and focal distances are computed in a least-squares fashion. Note, that if intrinsic parameters are known, there is no need to use this function just to estimate extrinsic parameters. Use  <a class="reference internal" href="#bool solvePnP(InputArray objectPoints, InputArray imagePoints, InputArray cameraMatrix, InputArray distCoeffs, OutputArray rvec, OutputArray tvec, bool useExtrinsicGuess, int flags)" title="bool solvePnP(InputArray objectPoints, InputArray imagePoints, InputArray cameraMatrix, InputArray distCoeffs, OutputArray rvec, OutputArray tvec, bool useExtrinsicGuess, int flags)"><code class="xref ocv ocv-func docutils literal"><span class="pre">solvePnP()</span></code></a>  instead.</li>
<li><strong>CV_CALIB_FIX_PRINCIPAL_POINT</strong> The principal point is not changed during the global optimization. It stays at the center or at a different location specified when    <code class="docutils literal"><span class="pre">CV_CALIB_USE_INTRINSIC_GUESS</span></code>  is set too.</li>
<li><strong>CV_CALIB_FIX_ASPECT_RATIO</strong> The functions considers only  <code class="docutils literal"><span class="pre">fy</span></code>  as a free parameter. The ratio  <code class="docutils literal"><span class="pre">fx/fy</span></code>  stays the same as in the input  <code class="docutils literal"><span class="pre">cameraMatrix</span></code> .   When  <code class="docutils literal"><span class="pre">CV_CALIB_USE_INTRINSIC_GUESS</span></code>  is not set, the actual input values of  <code class="docutils literal"><span class="pre">fx</span></code>  and  <code class="docutils literal"><span class="pre">fy</span></code>  are ignored, only their ratio is computed and used further.</li>
<li><strong>CV_CALIB_ZERO_TANGENT_DIST</strong> Tangential distortion coefficients  <img class="math" src="../../../_images/math/df0896464ec600237315c158ccaae67a23d292ae.png" alt="(p_1, p_2)"/>  are set to zeros and stay zero.</li>
</ul>
</div></blockquote>
<ul>
<li><strong>CV_CALIB_FIX_K1,...,CV_CALIB_FIX_K6</strong> The corresponding radial distortion coefficient is not changed during the optimization. If  <code class="docutils literal"><span class="pre">CV_CALIB_USE_INTRINSIC_GUESS</span></code>  is set, the coefficient from the supplied  <code class="docutils literal"><span class="pre">distCoeffs</span></code>  matrix is used. Otherwise, it is set to 0.</li>
<li><strong>CV_CALIB_RATIONAL_MODEL</strong> Coefficients k4, k5, and k6 are enabled. To provide the backward compatibility, this extra flag should be explicitly specified to make the calibration function use the rational model and return 8 coefficients. If the flag is not set, the function computes  and returns  only 5 distortion coefficients.</li>
</ul>
</li>
<li><strong>criteria</strong> &#8211; Termination criteria for the iterative optimization algorithm.</li>
<li><strong>term_crit</strong> &#8211; same as <code class="docutils literal"><span class="pre">criteria</span></code>.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<p>The function estimates the intrinsic camera
parameters and extrinsic parameters for each of the views. The algorithm is based on <a class="reference internal" href="#zhang2000" id="id1">[Zhang2000]</a> and <a class="reference internal" href="#bouguetmct" id="id2">[BouguetMCT]</a>. The coordinates of 3D object points and their corresponding 2D projections
in each view must be specified. That may be achieved by using an
object with a known geometry and easily detectable feature points.
Such an object is called a calibration rig or calibration pattern,
and OpenCV has built-in support for a chessboard as a calibration
rig (see
<a class="reference internal" href="#bool findChessboardCorners(InputArray image, Size patternSize, OutputArray corners, int flags)" title="bool findChessboardCorners(InputArray image, Size patternSize, OutputArray corners, int flags)"><code class="xref ocv ocv-func docutils literal"><span class="pre">findChessboardCorners()</span></code></a> ). Currently, initialization
of intrinsic parameters (when <code class="docutils literal"><span class="pre">CV_CALIB_USE_INTRINSIC_GUESS</span></code> is not set) is only implemented for planar calibration patterns
(where Z-coordinates of the object points must be all zeros). 3D
calibration rigs can also be used as long as initial <code class="docutils literal"><span class="pre">cameraMatrix</span></code> is provided.</p>
<p>The algorithm performs the following steps:</p>
<ol class="arabic simple">
<li>Compute the initial intrinsic parameters (the option only available for planar calibration patterns) or read them from the input parameters. The distortion coefficients are all set to zeros initially unless some of <code class="docutils literal"><span class="pre">CV_CALIB_FIX_K?</span></code>     are specified.</li>
<li>Estimate the initial camera pose as if the intrinsic parameters have been already known. This is done using
<a class="reference internal" href="#bool solvePnP(InputArray objectPoints, InputArray imagePoints, InputArray cameraMatrix, InputArray distCoeffs, OutputArray rvec, OutputArray tvec, bool useExtrinsicGuess, int flags)" title="bool solvePnP(InputArray objectPoints, InputArray imagePoints, InputArray cameraMatrix, InputArray distCoeffs, OutputArray rvec, OutputArray tvec, bool useExtrinsicGuess, int flags)"><code class="xref ocv ocv-func docutils literal"><span class="pre">solvePnP()</span></code></a> .</li>
<li>Run the global Levenberg-Marquardt optimization algorithm to minimize the reprojection error, that is, the total sum of squared distances between the observed feature points <code class="docutils literal"><span class="pre">imagePoints</span></code>     and the projected (using the current estimates for camera parameters and the poses) object points <code class="docutils literal"><span class="pre">objectPoints</span></code>. See <a class="reference internal" href="#void projectPoints(InputArray objectPoints, InputArray rvec, InputArray tvec, InputArray cameraMatrix, InputArray distCoeffs, OutputArray imagePoints, OutputArray jacobian, double aspectRatio)" title="void projectPoints(InputArray objectPoints, InputArray rvec, InputArray tvec, InputArray cameraMatrix, InputArray distCoeffs, OutputArray imagePoints, OutputArray jacobian, double aspectRatio)"><code class="xref ocv ocv-func docutils literal"><span class="pre">projectPoints()</span></code></a> for details.</li>
</ol>
<p>The function returns the final re-projection error.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">If you use a non-square (=non-NxN) grid and    <a class="reference internal" href="#bool findChessboardCorners(InputArray image, Size patternSize, OutputArray corners, int flags)" title="bool findChessboardCorners(InputArray image, Size patternSize, OutputArray corners, int flags)"><code class="xref ocv ocv-func docutils literal"><span class="pre">findChessboardCorners()</span></code></a> for calibration, and <code class="docutils literal"><span class="pre">calibrateCamera</span></code> returns bad values (zero distortion coefficients, an image center very far from <code class="docutils literal"><span class="pre">(w/2-0.5,h/2-0.5)</span></code>, and/or large differences between <img class="math" src="../../../_images/math/90cbff5be10b7d5d6a3ec6cabfe05e306e99ac1c.png" alt="f_x"/> and <img class="math" src="../../../_images/math/0a9dfcd96704b05afe921dcabeefcd77bfdbd863.png" alt="f_y"/> (ratios of 10:1 or more)), then you have probably used <code class="docutils literal"><span class="pre">patternSize=cvSize(rows,cols)</span></code> instead of using <code class="docutils literal"><span class="pre">patternSize=cvSize(cols,rows)</span></code> in <a class="reference internal" href="#bool findChessboardCorners(InputArray image, Size patternSize, OutputArray corners, int flags)" title="bool findChessboardCorners(InputArray image, Size patternSize, OutputArray corners, int flags)"><code class="xref ocv ocv-func docutils literal"><span class="pre">findChessboardCorners()</span></code></a> .</p>
</div>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#bool findChessboardCorners(InputArray image, Size patternSize, OutputArray corners, int flags)" title="bool findChessboardCorners(InputArray image, Size patternSize, OutputArray corners, int flags)"><code class="xref ocv ocv-func docutils literal"><span class="pre">findChessboardCorners()</span></code></a>,
<a class="reference internal" href="#bool solvePnP(InputArray objectPoints, InputArray imagePoints, InputArray cameraMatrix, InputArray distCoeffs, OutputArray rvec, OutputArray tvec, bool useExtrinsicGuess, int flags)" title="bool solvePnP(InputArray objectPoints, InputArray imagePoints, InputArray cameraMatrix, InputArray distCoeffs, OutputArray rvec, OutputArray tvec, bool useExtrinsicGuess, int flags)"><code class="xref ocv ocv-func docutils literal"><span class="pre">solvePnP()</span></code></a>,
<a class="reference internal" href="#Mat initCameraMatrix2D(InputArrayOfArrays objectPoints, InputArrayOfArrays imagePoints, Size imageSize, double aspectRatio)" title="Mat initCameraMatrix2D(InputArrayOfArrays objectPoints, InputArrayOfArrays imagePoints, Size imageSize, double aspectRatio)"><code class="xref ocv ocv-func docutils literal"><span class="pre">initCameraMatrix2D()</span></code></a>,
<a class="reference internal" href="#double stereoCalibrate(InputArrayOfArrays objectPoints, InputArrayOfArrays imagePoints1, InputArrayOfArrays imagePoints2, InputOutputArray cameraMatrix1, InputOutputArray distCoeffs1, InputOutputArray cameraMatrix2, InputOutputArray distCoeffs2, Size imageSize, OutputArray R, OutputArray T, OutputArray E, OutputArray F, TermCriteria criteria, int flags)" title="double stereoCalibrate(InputArrayOfArrays objectPoints, InputArrayOfArrays imagePoints1, InputArrayOfArrays imagePoints2, InputOutputArray cameraMatrix1, InputOutputArray distCoeffs1, InputOutputArray cameraMatrix2, InputOutputArray distCoeffs2, Size imageSize, OutputArray R, OutputArray T, OutputArray E, OutputArray F, TermCriteria criteria, int flags)"><code class="xref ocv ocv-func docutils literal"><span class="pre">stereoCalibrate()</span></code></a>,
<a class="reference internal" href="../../imgproc/doc/geometric_transformations.html#void undistort(InputArray src, OutputArray dst, InputArray cameraMatrix, InputArray distCoeffs, InputArray newCameraMatrix)" title="void undistort(InputArray src, OutputArray dst, InputArray cameraMatrix, InputArray distCoeffs, InputArray newCameraMatrix)"><code class="xref ocv ocv-func docutils literal"><span class="pre">undistort()</span></code></a></p>
</div>
</div>
<div class="section" id="calibrationmatrixvalues">
<h2>calibrationMatrixValues<a class="headerlink" href="#calibrationmatrixvalues" title="Permalink to this headline">¶</a></h2>
<p>Computes useful camera characteristics from the camera matrix.</p>
<dl class="function">
<dt id="void calibrationMatrixValues(InputArray cameraMatrix, Size imageSize, double apertureWidth, double apertureHeight, double&amp; fovx, double&amp; fovy, double&amp; focalLength, Point2d&amp; principalPoint, double&amp; aspectRatio)">
<strong>C++:</strong><code class="descname"> </code>void <code class="descname">calibrationMatrixValues</code><span class="sig-paren">(</span>InputArray <strong>cameraMatrix</strong>, Size <strong>imageSize</strong>, double <strong>apertureWidth</strong>, double <strong>apertureHeight</strong>, double&amp; <strong>fovx</strong>, double&amp; <strong>fovy</strong>, double&amp; <strong>focalLength</strong>, Point2d&amp; <strong>principalPoint</strong>, double&amp; <strong>aspectRatio</strong><span class="sig-paren">)</span><a class="headerlink" href="#void calibrationMatrixValues(InputArray cameraMatrix, Size imageSize, double apertureWidth, double apertureHeight, double& fovx, double& fovy, double& focalLength, Point2d& principalPoint, double& aspectRatio)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="pyfunction">
<dt id="cv2.calibrationMatrixValues">
<strong>Python:</strong><code class="descname"> </code><code class="descclassname">cv2.</code><code class="descname">calibrationMatrixValues</code><span class="sig-paren">(</span>cameraMatrix, imageSize, apertureWidth, apertureHeight<span class="sig-paren">)</span> &rarr; fovx, fovy, focalLength, principalPoint, aspectRatio<a class="headerlink" href="#cv2.calibrationMatrixValues" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>cameraMatrix</strong> &#8211; Input camera matrix that can be estimated by  <a class="reference internal" href="#double calibrateCamera(InputArrayOfArrays objectPoints, InputArrayOfArrays imagePoints, Size imageSize, InputOutputArray cameraMatrix, InputOutputArray distCoeffs, OutputArrayOfArrays rvecs, OutputArrayOfArrays tvecs, int flags, TermCriteria criteria)" title="double calibrateCamera(InputArrayOfArrays objectPoints, InputArrayOfArrays imagePoints, Size imageSize, InputOutputArray cameraMatrix, InputOutputArray distCoeffs, OutputArrayOfArrays rvecs, OutputArrayOfArrays tvecs, int flags, TermCriteria criteria)"><code class="xref ocv ocv-func docutils literal"><span class="pre">calibrateCamera()</span></code></a>  or  <a class="reference internal" href="#double stereoCalibrate(InputArrayOfArrays objectPoints, InputArrayOfArrays imagePoints1, InputArrayOfArrays imagePoints2, InputOutputArray cameraMatrix1, InputOutputArray distCoeffs1, InputOutputArray cameraMatrix2, InputOutputArray distCoeffs2, Size imageSize, OutputArray R, OutputArray T, OutputArray E, OutputArray F, TermCriteria criteria, int flags)" title="double stereoCalibrate(InputArrayOfArrays objectPoints, InputArrayOfArrays imagePoints1, InputArrayOfArrays imagePoints2, InputOutputArray cameraMatrix1, InputOutputArray distCoeffs1, InputOutputArray cameraMatrix2, InputOutputArray distCoeffs2, Size imageSize, OutputArray R, OutputArray T, OutputArray E, OutputArray F, TermCriteria criteria, int flags)"><code class="xref ocv ocv-func docutils literal"><span class="pre">stereoCalibrate()</span></code></a> .</li>
<li><strong>imageSize</strong> &#8211; Input image size in pixels.</li>
<li><strong>apertureWidth</strong> &#8211; Physical width in mm of the sensor.</li>
<li><strong>apertureHeight</strong> &#8211; Physical height in mm of the sensor.</li>
<li><strong>fovx</strong> &#8211; Output field of view in degrees along the horizontal sensor axis.</li>
<li><strong>fovy</strong> &#8211; Output field of view in degrees along the vertical sensor axis.</li>
<li><strong>focalLength</strong> &#8211; Focal length of the lens in mm.</li>
<li><strong>principalPoint</strong> &#8211; Principal point in mm.</li>
<li><strong>aspectRatio</strong> &#8211; <img class="math" src="../../../_images/math/fe8bdbcf99b78cff443b41021f7a93d54a5dc519.png" alt="f_y/f_x"/></li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<p>The function computes various useful camera characteristics from the previously estimated camera matrix.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Do keep in mind that the unity measure &#8216;mm&#8217; stands for whatever unit of measure one chooses for the chessboard pitch (it can thus be any value).</p>
</div>
</div>
<div class="section" id="composert">
<h2>composeRT<a class="headerlink" href="#composert" title="Permalink to this headline">¶</a></h2>
<p>Combines two rotation-and-shift transformations.</p>
<dl class="function">
<dt id="void composeRT(InputArray rvec1, InputArray tvec1, InputArray rvec2, InputArray tvec2, OutputArray rvec3, OutputArray tvec3, OutputArray dr3dr1, OutputArray dr3dt1, OutputArray dr3dr2, OutputArray dr3dt2, OutputArray dt3dr1, OutputArray dt3dt1, OutputArray dt3dr2, OutputArray dt3dt2)">
<strong>C++:</strong><code class="descname"> </code>void <code class="descname">composeRT</code><span class="sig-paren">(</span>InputArray <strong>rvec1</strong>, InputArray <strong>tvec1</strong>, InputArray <strong>rvec2</strong>, InputArray <strong>tvec2</strong>, OutputArray <strong>rvec3</strong>, OutputArray <strong>tvec3</strong>, OutputArray <strong>dr3dr1</strong>=noArray(), OutputArray <strong>dr3dt1</strong>=noArray(), OutputArray <strong>dr3dr2</strong>=noArray(), OutputArray <strong>dr3dt2</strong>=noArray(), OutputArray <strong>dt3dr1</strong>=noArray(), OutputArray <strong>dt3dt1</strong>=noArray(), OutputArray <strong>dt3dr2</strong>=noArray(), OutputArray <strong>dt3dt2</strong>=noArray() <span class="sig-paren">)</span><a class="headerlink" href="#void composeRT(InputArray rvec1, InputArray tvec1, InputArray rvec2, InputArray tvec2, OutputArray rvec3, OutputArray tvec3, OutputArray dr3dr1, OutputArray dr3dt1, OutputArray dr3dr2, OutputArray dr3dt2, OutputArray dt3dr1, OutputArray dt3dt1, OutputArray dt3dr2, OutputArray dt3dt2)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="pyfunction">
<dt id="cv2.composeRT">
<strong>Python:</strong><code class="descname"> </code><code class="descclassname">cv2.</code><code class="descname">composeRT</code><span class="sig-paren">(</span>rvec1, tvec1, rvec2, tvec2<span class="optional">[</span>, rvec3<span class="optional">[</span>, tvec3<span class="optional">[</span>, dr3dr1<span class="optional">[</span>, dr3dt1<span class="optional">[</span>, dr3dr2<span class="optional">[</span>, dr3dt2<span class="optional">[</span>, dt3dr1<span class="optional">[</span>, dt3dt1<span class="optional">[</span>, dt3dr2<span class="optional">[</span>, dt3dt2<span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span> &rarr; rvec3, tvec3, dr3dr1, dr3dt1, dr3dr2, dr3dt2, dt3dr1, dt3dt1, dt3dr2, dt3dt2<a class="headerlink" href="#cv2.composeRT" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>rvec1</strong> &#8211; First rotation vector.</li>
<li><strong>tvec1</strong> &#8211; First translation vector.</li>
<li><strong>rvec2</strong> &#8211; Second rotation vector.</li>
<li><strong>tvec2</strong> &#8211; Second translation vector.</li>
<li><strong>rvec3</strong> &#8211; Output rotation vector of the superposition.</li>
<li><strong>tvec3</strong> &#8211; Output translation vector of the superposition.</li>
<li><strong>d*d*</strong> &#8211; Optional output derivatives of  <code class="docutils literal"><span class="pre">rvec3</span></code>  or  <code class="docutils literal"><span class="pre">tvec3</span></code>  with regard to  <code class="docutils literal"><span class="pre">rvec1</span></code>, <code class="docutils literal"><span class="pre">rvec2</span></code>, <code class="docutils literal"><span class="pre">tvec1</span></code> and <code class="docutils literal"><span class="pre">tvec2</span></code>, respectively.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<p>The functions compute:</p>
<div class="math">
<p><img src="../../../_images/math/7847aea1115054284b887507fdcf54fed7aea285.png" alt="\begin{array}{l} \texttt{rvec3} =  \mathrm{rodrigues} ^{-1} \left ( \mathrm{rodrigues} ( \texttt{rvec2} )  \cdot \mathrm{rodrigues} ( \texttt{rvec1} ) \right )  \\ \texttt{tvec3} =  \mathrm{rodrigues} ( \texttt{rvec2} )  \cdot \texttt{tvec1} +  \texttt{tvec2} \end{array} ,"/></p>
</div><p>where <img class="math" src="../../../_images/math/addc969f61b0862fb0e50d964a9ccd6087ae67f9.png" alt="\mathrm{rodrigues}"/> denotes a rotation vector to a rotation matrix transformation, and
<img class="math" src="../../../_images/math/f816ef8de5d0a9718231c560993468b45ec1aee7.png" alt="\mathrm{rodrigues}^{-1}"/> denotes the inverse transformation. See <a class="reference internal" href="#void Rodrigues(InputArray src, OutputArray dst, OutputArray jacobian)" title="void Rodrigues(InputArray src, OutputArray dst, OutputArray jacobian)"><code class="xref ocv ocv-func docutils literal"><span class="pre">Rodrigues()</span></code></a> for details.</p>
<p>Also, the functions can compute the derivatives of the output vectors with regards to the input vectors (see <a class="reference internal" href="#void matMulDeriv(InputArray A, InputArray B, OutputArray dABdA, OutputArray dABdB)" title="void matMulDeriv(InputArray A, InputArray B, OutputArray dABdA, OutputArray dABdB)"><code class="xref ocv ocv-func docutils literal"><span class="pre">matMulDeriv()</span></code></a> ).
The functions are used inside <a class="reference internal" href="#double stereoCalibrate(InputArrayOfArrays objectPoints, InputArrayOfArrays imagePoints1, InputArrayOfArrays imagePoints2, InputOutputArray cameraMatrix1, InputOutputArray distCoeffs1, InputOutputArray cameraMatrix2, InputOutputArray distCoeffs2, Size imageSize, OutputArray R, OutputArray T, OutputArray E, OutputArray F, TermCriteria criteria, int flags)" title="double stereoCalibrate(InputArrayOfArrays objectPoints, InputArrayOfArrays imagePoints1, InputArrayOfArrays imagePoints2, InputOutputArray cameraMatrix1, InputOutputArray distCoeffs1, InputOutputArray cameraMatrix2, InputOutputArray distCoeffs2, Size imageSize, OutputArray R, OutputArray T, OutputArray E, OutputArray F, TermCriteria criteria, int flags)"><code class="xref ocv ocv-func docutils literal"><span class="pre">stereoCalibrate()</span></code></a> but can also be used in your own code where Levenberg-Marquardt or another gradient-based solver is used to optimize a function that contains a matrix multiplication.</p>
</div>
<div class="section" id="computecorrespondepilines">
<h2>computeCorrespondEpilines<a class="headerlink" href="#computecorrespondepilines" title="Permalink to this headline">¶</a></h2>
<p>For points in an image of a stereo pair, computes the corresponding epilines in the other image.</p>
<dl class="function">
<dt id="void computeCorrespondEpilines(InputArray points, int whichImage, InputArray F, OutputArray lines)">
<strong>C++:</strong><code class="descname"> </code>void <code class="descname">computeCorrespondEpilines</code><span class="sig-paren">(</span>InputArray <strong>points</strong>, int <strong>whichImage</strong>, InputArray <strong>F</strong>, OutputArray <strong>lines</strong><span class="sig-paren">)</span><a class="headerlink" href="#void computeCorrespondEpilines(InputArray points, int whichImage, InputArray F, OutputArray lines)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="cfunction">
<dt id="void cvComputeCorrespondEpilines(const CvMat* points, int which_image, const CvMat* fundamental_matrix, CvMat* correspondent_lines)">
<strong>C:</strong><code class="descname"> </code>void <code class="descname">cvComputeCorrespondEpilines</code><span class="sig-paren">(</span>const CvMat* <strong>points</strong>, int <strong>which_image</strong>, const CvMat* <strong>fundamental_matrix</strong>, CvMat* <strong>correspondent_lines</strong><span class="sig-paren">)</span><a class="headerlink" href="#void cvComputeCorrespondEpilines(const CvMat* points, int which_image, const CvMat* fundamental_matrix, CvMat* correspondent_lines)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="pyoldfunction">
<dt id="cv.ComputeCorrespondEpilines">
<strong>Python:</strong><code class="descname"> </code><code class="descclassname">cv.</code><code class="descname">ComputeCorrespondEpilines</code><span class="sig-paren">(</span>points, whichImage, F, lines<span class="sig-paren">)</span> &rarr; None<a class="headerlink" href="#cv.ComputeCorrespondEpilines" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>points</strong> &#8211; Input points.  <img class="math" src="../../../_images/math/0ffc812b7baf1ebbcdc6d8494027fdc64fdf35f2.png" alt="N \times 1"/>  or  <img class="math" src="../../../_images/math/176818d22e6473b3b8aaeae20735f505f7cc16d0.png" alt="1 \times N"/>  matrix of type  <code class="docutils literal"><span class="pre">CV_32FC2</span></code>  or  <code class="docutils literal"><span class="pre">vector&lt;Point2f&gt;</span></code> .</li>
<li><strong>whichImage</strong> &#8211; Index of the image (1 or 2) that contains the  <code class="docutils literal"><span class="pre">points</span></code> .</li>
<li><strong>F</strong> &#8211; Fundamental matrix that can be estimated using  <a class="reference internal" href="#Mat findFundamentalMat(InputArray points1, InputArray points2, int method, double param1, double param2, OutputArray mask)" title="Mat findFundamentalMat(InputArray points1, InputArray points2, int method, double param1, double param2, OutputArray mask)"><code class="xref ocv ocv-func docutils literal"><span class="pre">findFundamentalMat()</span></code></a>         or  <a class="reference internal" href="#void stereoRectify(InputArray cameraMatrix1, InputArray distCoeffs1, InputArray cameraMatrix2, InputArray distCoeffs2, Size imageSize, InputArray R, InputArray T, OutputArray R1, OutputArray R2, OutputArray P1, OutputArray P2, OutputArray Q, int flags, double alpha, Size newImageSize, Rect* validPixROI1, Rect* validPixROI2)" title="void stereoRectify(InputArray cameraMatrix1, InputArray distCoeffs1, InputArray cameraMatrix2, InputArray distCoeffs2, Size imageSize, InputArray R, InputArray T, OutputArray R1, OutputArray R2, OutputArray P1, OutputArray P2, OutputArray Q, int flags, double alpha, Size newImageSize, Rect* validPixROI1, Rect* validPixROI2)"><code class="xref ocv ocv-func docutils literal"><span class="pre">stereoRectify()</span></code></a> .</li>
<li><strong>lines</strong> &#8211; Output vector of the epipolar lines corresponding to the points in the other image. Each line <img class="math" src="../../../_images/math/70fa1256286392cb4080c7bc17693821bf4021d3.png" alt="ax + by + c=0"/>  is encoded by 3 numbers  <img class="math" src="../../../_images/math/1fc3347eede98575f8bdaeaa4331bc6194a7d5b8.png" alt="(a, b, c)"/> .</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<p>For every point in one of the two images of a stereo pair, the function finds the equation of the
corresponding epipolar line in the other image.</p>
<p>From the fundamental matrix definition (see
<a class="reference internal" href="#Mat findFundamentalMat(InputArray points1, InputArray points2, int method, double param1, double param2, OutputArray mask)" title="Mat findFundamentalMat(InputArray points1, InputArray points2, int method, double param1, double param2, OutputArray mask)"><code class="xref ocv ocv-func docutils literal"><span class="pre">findFundamentalMat()</span></code></a> ),
line
<img class="math" src="../../../_images/math/139d96b4b617e58d3186381fc4cb1a7e5b462600.png" alt="l^{(2)}_i"/> in the second image for the point
<img class="math" src="../../../_images/math/c468b217b51b54bd4075d931aa390fe8c29c7bfd.png" alt="p^{(1)}_i"/> in the first image (when <code class="docutils literal"><span class="pre">whichImage=1</span></code> ) is computed as:</p>
<div class="math">
<p><img src="../../../_images/math/01793caff34c43428b129202b19644155b2d7abf.png" alt="l^{(2)}_i = F p^{(1)}_i"/></p>
</div><p>And vice versa, when <code class="docutils literal"><span class="pre">whichImage=2</span></code>,
<img class="math" src="../../../_images/math/2f0b537580053b698644b9a36b236f9bc67eff4d.png" alt="l^{(1)}_i"/> is computed from
<img class="math" src="../../../_images/math/2a96c4316cef478442760f44a0b5988b3897d2b0.png" alt="p^{(2)}_i"/> as:</p>
<div class="math">
<p><img src="../../../_images/math/f24d6b4d231394dfa0962c9fa7b752cf050522c1.png" alt="l^{(1)}_i = F^T p^{(2)}_i"/></p>
</div><p>Line coefficients are defined up to a scale. They are normalized so that
<img class="math" src="../../../_images/math/bdd5240f7507e3410d5cf92294cbe1c5109631d9.png" alt="a_i^2+b_i^2=1"/> .</p>
</div>
<div class="section" id="convertpointstohomogeneous">
<h2>convertPointsToHomogeneous<a class="headerlink" href="#convertpointstohomogeneous" title="Permalink to this headline">¶</a></h2>
<p>Converts points from Euclidean to homogeneous space.</p>
<dl class="function">
<dt id="void convertPointsToHomogeneous(InputArray src, OutputArray dst)">
<strong>C++:</strong><code class="descname"> </code>void <code class="descname">convertPointsToHomogeneous</code><span class="sig-paren">(</span>InputArray <strong>src</strong>, OutputArray <strong>dst</strong><span class="sig-paren">)</span><a class="headerlink" href="#void convertPointsToHomogeneous(InputArray src, OutputArray dst)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="pyfunction">
<dt id="cv2.convertPointsToHomogeneous">
<strong>Python:</strong><code class="descname"> </code><code class="descclassname">cv2.</code><code class="descname">convertPointsToHomogeneous</code><span class="sig-paren">(</span>src<span class="optional">[</span>, dst<span class="optional">]</span><span class="sig-paren">)</span> &rarr; dst<a class="headerlink" href="#cv2.convertPointsToHomogeneous" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>src</strong> &#8211; Input vector of <code class="docutils literal"><span class="pre">N</span></code>-dimensional points.</li>
<li><strong>dst</strong> &#8211; Output vector of <code class="docutils literal"><span class="pre">N+1</span></code>-dimensional points.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<p>The function converts points from Euclidean to homogeneous space by appending 1&#8217;s to the tuple of point coordinates. That is, each point <code class="docutils literal"><span class="pre">(x1,</span> <span class="pre">x2,</span> <span class="pre">...,</span> <span class="pre">xn)</span></code> is converted to <code class="docutils literal"><span class="pre">(x1,</span> <span class="pre">x2,</span> <span class="pre">...,</span> <span class="pre">xn,</span> <span class="pre">1)</span></code>.</p>
</div>
<div class="section" id="convertpointsfromhomogeneous">
<h2>convertPointsFromHomogeneous<a class="headerlink" href="#convertpointsfromhomogeneous" title="Permalink to this headline">¶</a></h2>
<p>Converts points from homogeneous to Euclidean space.</p>
<dl class="function">
<dt id="void convertPointsFromHomogeneous(InputArray src, OutputArray dst)">
<strong>C++:</strong><code class="descname"> </code>void <code class="descname">convertPointsFromHomogeneous</code><span class="sig-paren">(</span>InputArray <strong>src</strong>, OutputArray <strong>dst</strong><span class="sig-paren">)</span><a class="headerlink" href="#void convertPointsFromHomogeneous(InputArray src, OutputArray dst)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="pyfunction">
<dt id="cv2.convertPointsFromHomogeneous">
<strong>Python:</strong><code class="descname"> </code><code class="descclassname">cv2.</code><code class="descname">convertPointsFromHomogeneous</code><span class="sig-paren">(</span>src<span class="optional">[</span>, dst<span class="optional">]</span><span class="sig-paren">)</span> &rarr; dst<a class="headerlink" href="#cv2.convertPointsFromHomogeneous" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>src</strong> &#8211; Input vector of <code class="docutils literal"><span class="pre">N</span></code>-dimensional points.</li>
<li><strong>dst</strong> &#8211; Output vector of <code class="docutils literal"><span class="pre">N-1</span></code>-dimensional points.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<p>The function converts points homogeneous to Euclidean space using perspective projection. That is, each point <code class="docutils literal"><span class="pre">(x1,</span> <span class="pre">x2,</span> <span class="pre">...</span> <span class="pre">x(n-1),</span> <span class="pre">xn)</span></code> is converted to <code class="docutils literal"><span class="pre">(x1/xn,</span> <span class="pre">x2/xn,</span> <span class="pre">...,</span> <span class="pre">x(n-1)/xn)</span></code>. When <code class="docutils literal"><span class="pre">xn=0</span></code>, the output point coordinates will be <code class="docutils literal"><span class="pre">(0,0,0,...)</span></code>.</p>
</div>
<div class="section" id="convertpointshomogeneous">
<h2>convertPointsHomogeneous<a class="headerlink" href="#convertpointshomogeneous" title="Permalink to this headline">¶</a></h2>
<p>Converts points to/from homogeneous coordinates.</p>
<dl class="function">
<dt id="void convertPointsHomogeneous(InputArray src, OutputArray dst)">
<strong>C++:</strong><code class="descname"> </code>void <code class="descname">convertPointsHomogeneous</code><span class="sig-paren">(</span>InputArray <strong>src</strong>, OutputArray <strong>dst</strong><span class="sig-paren">)</span><a class="headerlink" href="#void convertPointsHomogeneous(InputArray src, OutputArray dst)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="cfunction">
<dt id="void cvConvertPointsHomogeneous(const CvMat* src, CvMat* dst)">
<strong>C:</strong><code class="descname"> </code>void <code class="descname">cvConvertPointsHomogeneous</code><span class="sig-paren">(</span>const CvMat* <strong>src</strong>, CvMat* <strong>dst</strong><span class="sig-paren">)</span><a class="headerlink" href="#void cvConvertPointsHomogeneous(const CvMat* src, CvMat* dst)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="pyoldfunction">
<dt id="cv.ConvertPointsHomogeneous">
<strong>Python:</strong><code class="descname"> </code><code class="descclassname">cv.</code><code class="descname">ConvertPointsHomogeneous</code><span class="sig-paren">(</span>src, dst<span class="sig-paren">)</span> &rarr; None<a class="headerlink" href="#cv.ConvertPointsHomogeneous" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>src</strong> &#8211; Input array or vector of 2D, 3D, or 4D points.</li>
<li><strong>dst</strong> &#8211; Output vector of 2D, 3D, or 4D points.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<p>The function converts 2D or 3D points from/to homogeneous coordinates by calling either <a class="reference internal" href="#void convertPointsToHomogeneous(InputArray src, OutputArray dst)" title="void convertPointsToHomogeneous(InputArray src, OutputArray dst)"><code class="xref ocv ocv-func docutils literal"><span class="pre">convertPointsToHomogeneous()</span></code></a> or <a class="reference internal" href="#void convertPointsFromHomogeneous(InputArray src, OutputArray dst)" title="void convertPointsFromHomogeneous(InputArray src, OutputArray dst)"><code class="xref ocv ocv-func docutils literal"><span class="pre">convertPointsFromHomogeneous()</span></code></a>.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The function is obsolete. Use one of the previous two functions instead.</p>
</div>
</div>
<div class="section" id="correctmatches">
<h2>correctMatches<a class="headerlink" href="#correctmatches" title="Permalink to this headline">¶</a></h2>
<p>Refines coordinates of corresponding points.</p>
<dl class="function">
<dt id="void correctMatches(InputArray F, InputArray points1, InputArray points2, OutputArray newPoints1, OutputArray newPoints2)">
<strong>C++:</strong><code class="descname"> </code>void <code class="descname">correctMatches</code><span class="sig-paren">(</span>InputArray <strong>F</strong>, InputArray <strong>points1</strong>, InputArray <strong>points2</strong>, OutputArray <strong>newPoints1</strong>, OutputArray <strong>newPoints2</strong><span class="sig-paren">)</span><a class="headerlink" href="#void correctMatches(InputArray F, InputArray points1, InputArray points2, OutputArray newPoints1, OutputArray newPoints2)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="pyfunction">
<dt id="cv2.correctMatches">
<strong>Python:</strong><code class="descname"> </code><code class="descclassname">cv2.</code><code class="descname">correctMatches</code><span class="sig-paren">(</span>F, points1, points2<span class="optional">[</span>, newPoints1<span class="optional">[</span>, newPoints2<span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span> &rarr; newPoints1, newPoints2<a class="headerlink" href="#cv2.correctMatches" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="cfunction">
<dt id="void cvCorrectMatches(CvMat* F, CvMat* points1, CvMat* points2, CvMat* new_points1, CvMat* new_points2)">
<strong>C:</strong><code class="descname"> </code>void <code class="descname">cvCorrectMatches</code><span class="sig-paren">(</span>CvMat* <strong>F</strong>, CvMat* <strong>points1</strong>, CvMat* <strong>points2</strong>, CvMat* <strong>new_points1</strong>, CvMat* <strong>new_points2</strong><span class="sig-paren">)</span><a class="headerlink" href="#void cvCorrectMatches(CvMat* F, CvMat* points1, CvMat* points2, CvMat* new_points1, CvMat* new_points2)" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>F</strong> &#8211; 3x3 fundamental matrix.</li>
<li><strong>points1</strong> &#8211; 1xN array containing the first set of points.</li>
<li><strong>points2</strong> &#8211; 1xN array containing the second set of points.</li>
<li><strong>newPoints1</strong> &#8211; The optimized points1.</li>
<li><strong>newPoints2</strong> &#8211; The optimized points2.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<p>The function implements the Optimal Triangulation Method (see Multiple View Geometry for details). For each given point correspondence points1[i] &lt;-&gt; points2[i], and a fundamental matrix F, it computes the corrected correspondences newPoints1[i] &lt;-&gt; newPoints2[i] that minimize the geometric error  <img class="math" src="../../../_images/math/628211a603e8e7dfff3bbfc475051c9b7b84f935.png" alt="d(points1[i], newPoints1[i])^2 + d(points2[i],newPoints2[i])^2"/>  (where  <img class="math" src="../../../_images/math/3e4e4bf9ea28c505fafa043ed84ba8ebf8ae0563.png" alt="d(a,b)"/>  is the geometric distance between points  <img class="math" src="../../../_images/math/299c00d097414867ab7ef6dc73026305343e80dd.png" alt="a"/>  and  <img class="math" src="../../../_images/math/99e6f571c844c85d38da0ac7d86e658a5d02a67a.png" alt="b"/> ) subject to the epipolar constraint  <img class="math" src="../../../_images/math/78e17b3774e976bf73a920c4fee22c44421c4086.png" alt="newPoints2^T * F * newPoints1 = 0"/> .</p>
</div>
<div class="section" id="decomposeprojectionmatrix">
<h2>decomposeProjectionMatrix<a class="headerlink" href="#decomposeprojectionmatrix" title="Permalink to this headline">¶</a></h2>
<p>Decomposes a projection matrix into a rotation matrix and a camera matrix.</p>
<dl class="function">
<dt id="void decomposeProjectionMatrix(InputArray projMatrix, OutputArray cameraMatrix, OutputArray rotMatrix, OutputArray transVect, OutputArray rotMatrixX, OutputArray rotMatrixY, OutputArray rotMatrixZ, OutputArray eulerAngles)">
<strong>C++:</strong><code class="descname"> </code>void <code class="descname">decomposeProjectionMatrix</code><span class="sig-paren">(</span>InputArray <strong>projMatrix</strong>, OutputArray <strong>cameraMatrix</strong>, OutputArray <strong>rotMatrix</strong>, OutputArray <strong>transVect</strong>, OutputArray <strong>rotMatrixX</strong>=noArray(), OutputArray <strong>rotMatrixY</strong>=noArray(), OutputArray <strong>rotMatrixZ</strong>=noArray(), OutputArray <strong>eulerAngles</strong>=noArray() <span class="sig-paren">)</span><a class="headerlink" href="#void decomposeProjectionMatrix(InputArray projMatrix, OutputArray cameraMatrix, OutputArray rotMatrix, OutputArray transVect, OutputArray rotMatrixX, OutputArray rotMatrixY, OutputArray rotMatrixZ, OutputArray eulerAngles)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="pyfunction">
<dt id="cv2.decomposeProjectionMatrix">
<strong>Python:</strong><code class="descname"> </code><code class="descclassname">cv2.</code><code class="descname">decomposeProjectionMatrix</code><span class="sig-paren">(</span>projMatrix<span class="optional">[</span>, cameraMatrix<span class="optional">[</span>, rotMatrix<span class="optional">[</span>, transVect<span class="optional">[</span>, rotMatrixX<span class="optional">[</span>, rotMatrixY<span class="optional">[</span>, rotMatrixZ<span class="optional">[</span>, eulerAngles<span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span> &rarr; cameraMatrix, rotMatrix, transVect, rotMatrixX, rotMatrixY, rotMatrixZ, eulerAngles<a class="headerlink" href="#cv2.decomposeProjectionMatrix" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="cfunction">
<dt id="void cvDecomposeProjectionMatrix(const CvMat * projMatr, CvMat * calibMatr, CvMat * rotMatr, CvMat * posVect, CvMat * rotMatrX, CvMat * rotMatrY, CvMat * rotMatrZ, CvPoint3D64f * eulerAngles)">
<strong>C:</strong><code class="descname"> </code>void <code class="descname">cvDecomposeProjectionMatrix</code><span class="sig-paren">(</span>const CvMat* <strong>projMatr</strong>, CvMat* <strong>calibMatr</strong>, CvMat* <strong>rotMatr</strong>, CvMat* <strong>posVect</strong>, CvMat* <strong>rotMatrX</strong>=NULL, CvMat* <strong>rotMatrY</strong>=NULL, CvMat* <strong>rotMatrZ</strong>=NULL, CvPoint3D64f* <strong>eulerAngles</strong>=NULL <span class="sig-paren">)</span><a class="headerlink" href="#void cvDecomposeProjectionMatrix(const CvMat * projMatr, CvMat * calibMatr, CvMat * rotMatr, CvMat * posVect, CvMat * rotMatrX, CvMat * rotMatrY, CvMat * rotMatrZ, CvPoint3D64f * eulerAngles)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="pyoldfunction">
<dt id="cv.DecomposeProjectionMatrix">
<strong>Python:</strong><code class="descname"> </code><code class="descclassname">cv.</code><code class="descname">DecomposeProjectionMatrix</code><span class="sig-paren">(</span>projMatrix, cameraMatrix, rotMatrix, transVect, rotMatrX=None, rotMatrY=None, rotMatrZ=None<span class="sig-paren">)</span> &rarr; eulerAngles<a class="headerlink" href="#cv.DecomposeProjectionMatrix" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>projMatrix</strong> &#8211; 3x4 input projection matrix P.</li>
<li><strong>cameraMatrix</strong> &#8211; Output 3x3 camera matrix K.</li>
<li><strong>rotMatrix</strong> &#8211; Output 3x3 external rotation matrix R.</li>
<li><strong>transVect</strong> &#8211; Output 4x1 translation vector T.</li>
<li><strong>rotMatrX</strong> &#8211; Optional 3x3 rotation matrix around x-axis.</li>
<li><strong>rotMatrY</strong> &#8211; Optional 3x3 rotation matrix around y-axis.</li>
<li><strong>rotMatrZ</strong> &#8211; Optional 3x3 rotation matrix around z-axis.</li>
<li><strong>eulerAngles</strong> &#8211; Optional three-element vector containing three Euler angles of rotation in degrees.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<p>The function computes a decomposition of a projection matrix into a calibration and a rotation matrix and the position of a camera.</p>
<p>It optionally returns three rotation matrices, one for each axis, and three Euler angles that could be used in OpenGL. Note, there is always more than one sequence of rotations about the three principle axes that results in the same orientation of an object, eg. see <a class="reference internal" href="#slabaugh" id="id3">[Slabaugh]</a>. Returned tree rotation matrices and corresponding three Euler angules are only one of the possible solutions.</p>
<p>The function is based on
<a class="reference internal" href="#Vec3d RQDecomp3x3(InputArray src, OutputArray mtxR, OutputArray mtxQ, OutputArray Qx, OutputArray Qy, OutputArray Qz)" title="Vec3d RQDecomp3x3(InputArray src, OutputArray mtxR, OutputArray mtxQ, OutputArray Qx, OutputArray Qy, OutputArray Qz)"><code class="xref ocv ocv-func docutils literal"><span class="pre">RQDecomp3x3()</span></code></a> .</p>
</div>
<div class="section" id="drawchessboardcorners">
<h2>drawChessboardCorners<a class="headerlink" href="#drawchessboardcorners" title="Permalink to this headline">¶</a></h2>
<p>Renders the detected chessboard corners.</p>
<dl class="function">
<dt id="void drawChessboardCorners(InputOutputArray image, Size patternSize, InputArray corners, bool patternWasFound)">
<strong>C++:</strong><code class="descname"> </code>void <code class="descname">drawChessboardCorners</code><span class="sig-paren">(</span>InputOutputArray <strong>image</strong>, Size <strong>patternSize</strong>, InputArray <strong>corners</strong>, bool <strong>patternWasFound</strong><span class="sig-paren">)</span><a class="headerlink" href="#void drawChessboardCorners(InputOutputArray image, Size patternSize, InputArray corners, bool patternWasFound)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="pyfunction">
<dt id="cv2.drawChessboardCorners">
<strong>Python:</strong><code class="descname"> </code><code class="descclassname">cv2.</code><code class="descname">drawChessboardCorners</code><span class="sig-paren">(</span>image, patternSize, corners, patternWasFound<span class="sig-paren">)</span> &rarr; None<a class="headerlink" href="#cv2.drawChessboardCorners" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="cfunction">
<dt id="void cvDrawChessboardCorners(CvArr* image, CvSize pattern_size, CvPoint2D32f* corners, int count, int pattern_was_found)">
<strong>C:</strong><code class="descname"> </code>void <code class="descname">cvDrawChessboardCorners</code><span class="sig-paren">(</span>CvArr* <strong>image</strong>, CvSize <strong>pattern_size</strong>, CvPoint2D32f* <strong>corners</strong>, int <strong>count</strong>, int <strong>pattern_was_found</strong><span class="sig-paren">)</span><a class="headerlink" href="#void cvDrawChessboardCorners(CvArr* image, CvSize pattern_size, CvPoint2D32f* corners, int count, int pattern_was_found)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="pyoldfunction">
<dt id="cv.DrawChessboardCorners">
<strong>Python:</strong><code class="descname"> </code><code class="descclassname">cv.</code><code class="descname">DrawChessboardCorners</code><span class="sig-paren">(</span>image, patternSize, corners, patternWasFound<span class="sig-paren">)</span> &rarr; None<a class="headerlink" href="#cv.DrawChessboardCorners" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>image</strong> &#8211; Destination image. It must be an 8-bit color image.</li>
<li><strong>patternSize</strong> &#8211; Number of inner corners per a chessboard row and column <code class="docutils literal"><span class="pre">(patternSize</span> <span class="pre">=</span> <span class="pre">cv::Size(points_per_row,points_per_column))</span></code>.</li>
<li><strong>corners</strong> &#8211; Array of detected corners, the output of <code class="docutils literal"><span class="pre">findChessboardCorners</span></code>.</li>
<li><strong>patternWasFound</strong> &#8211; Parameter indicating whether the complete board was found or not. The return value of <a class="reference internal" href="#bool findChessboardCorners(InputArray image, Size patternSize, OutputArray corners, int flags)" title="bool findChessboardCorners(InputArray image, Size patternSize, OutputArray corners, int flags)"><code class="xref ocv ocv-func docutils literal"><span class="pre">findChessboardCorners()</span></code></a> should be passed here.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<p>The function draws individual chessboard corners detected either as red circles if the board was not found, or as colored corners connected with lines if the board was found.</p>
</div>
<div class="section" id="findchessboardcorners">
<h2>findChessboardCorners<a class="headerlink" href="#findchessboardcorners" title="Permalink to this headline">¶</a></h2>
<p>Finds the positions of internal corners of the chessboard.</p>
<dl class="function">
<dt id="bool findChessboardCorners(InputArray image, Size patternSize, OutputArray corners, int flags)">
<strong>C++:</strong><code class="descname"> </code>bool <code class="descname">findChessboardCorners</code><span class="sig-paren">(</span>InputArray <strong>image</strong>, Size <strong>patternSize</strong>, OutputArray <strong>corners</strong>, int <strong>flags</strong>=CALIB_CB_ADAPTIVE_THRESH+CALIB_CB_NORMALIZE_IMAGE <span class="sig-paren">)</span><a class="headerlink" href="#bool findChessboardCorners(InputArray image, Size patternSize, OutputArray corners, int flags)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="pyfunction">
<dt id="cv2.findChessboardCorners">
<strong>Python:</strong><code class="descname"> </code><code class="descclassname">cv2.</code><code class="descname">findChessboardCorners</code><span class="sig-paren">(</span>image, patternSize<span class="optional">[</span>, corners<span class="optional">[</span>, flags<span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span> &rarr; retval, corners<a class="headerlink" href="#cv2.findChessboardCorners" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="cfunction">
<dt id="int cvFindChessboardCorners(const void* image, CvSize pattern_size, CvPoint2D32f* corners, int* corner_count, int flags)">
<strong>C:</strong><code class="descname"> </code>int <code class="descname">cvFindChessboardCorners</code><span class="sig-paren">(</span>const void* <strong>image</strong>, CvSize <strong>pattern_size</strong>, CvPoint2D32f* <strong>corners</strong>, int* <strong>corner_count</strong>=NULL, int <strong>flags</strong>=CV_CALIB_CB_ADAPTIVE_THRESH+CV_CALIB_CB_NORMALIZE_IMAGE <span class="sig-paren">)</span><a class="headerlink" href="#int cvFindChessboardCorners(const void* image, CvSize pattern_size, CvPoint2D32f* corners, int* corner_count, int flags)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="pyoldfunction">
<dt id="cv.FindChessboardCorners">
<strong>Python:</strong><code class="descname"> </code><code class="descclassname">cv.</code><code class="descname">FindChessboardCorners</code><span class="sig-paren">(</span>image, patternSize, flags=CV_CALIB_CB_ADAPTIVE_THRESH<span class="sig-paren">)</span> &rarr; corners<a class="headerlink" href="#cv.FindChessboardCorners" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>image</strong> &#8211; Source chessboard view. It must be an 8-bit grayscale or color image.</li>
<li><strong>patternSize</strong> &#8211; Number of inner corners per a chessboard row and column <code class="docutils literal"><span class="pre">(</span> <span class="pre">patternSize</span> <span class="pre">=</span> <span class="pre">cvSize(points_per_row,points_per_colum)</span> <span class="pre">=</span> <span class="pre">cvSize(columns,rows)</span> <span class="pre">)</span></code>.</li>
<li><strong>corners</strong> &#8211; Output array of detected corners.</li>
<li><strong>flags</strong> &#8211; <p>Various operation flags that can be zero or a combination of the following values:</p>
<ul>
<li><strong>CALIB_CB_ADAPTIVE_THRESH</strong> Use adaptive thresholding to convert the image to black and white, rather than a fixed threshold level (computed from the average image brightness).</li>
<li><strong>CALIB_CB_NORMALIZE_IMAGE</strong> Normalize the image gamma with  <a class="reference internal" href="../../imgproc/doc/histograms.html#void equalizeHist(InputArray src, OutputArray dst)" title="void equalizeHist(InputArray src, OutputArray dst)"><code class="xref ocv ocv-func docutils literal"><span class="pre">equalizeHist()</span></code></a>  before applying fixed or adaptive thresholding.</li>
<li><strong>CALIB_CB_FILTER_QUADS</strong> Use additional criteria (like contour area, perimeter, square-like shape) to filter out false quads extracted at the contour retrieval stage.</li>
<li><strong>CALIB_CB_FAST_CHECK</strong> Run a fast check on the image that looks for chessboard corners, and shortcut the call if none is found. This can drastically speed up the call in the degenerate condition when no chessboard is observed.</li>
</ul>
</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<p>The function attempts to determine
whether the input image is a view of the chessboard pattern and
locate the internal chessboard corners. The function returns a non-zero
value if all of the corners are found and they are placed
in a certain order (row by row, left to right in every row). Otherwise, if the function fails to find all the corners or reorder
them, it returns 0. For example, a regular chessboard has 8 x 8
squares and 7 x 7 internal corners, that is, points where the black squares touch each other.
The detected coordinates are approximate, and to determine their positions more accurately, the function calls <a class="reference internal" href="../../imgproc/doc/feature_detection.html#void cornerSubPix(InputArray image, InputOutputArray corners, Size winSize, Size zeroZone, TermCriteria criteria)" title="void cornerSubPix(InputArray image, InputOutputArray corners, Size winSize, Size zeroZone, TermCriteria criteria)"><code class="xref ocv ocv-func docutils literal"><span class="pre">cornerSubPix()</span></code></a>.
You also may use the function <a class="reference internal" href="../../imgproc/doc/feature_detection.html#void cornerSubPix(InputArray image, InputOutputArray corners, Size winSize, Size zeroZone, TermCriteria criteria)" title="void cornerSubPix(InputArray image, InputOutputArray corners, Size winSize, Size zeroZone, TermCriteria criteria)"><code class="xref ocv ocv-func docutils literal"><span class="pre">cornerSubPix()</span></code></a> with different parameters if returned coordinates are not accurate enough.</p>
<p>Sample usage of detecting and drawing chessboard corners:</p>
<div class="highlight-cpp"><div class="highlight"><pre><span class="n">Size</span> <span class="nf">patternsize</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span><span class="mi">6</span><span class="p">);</span> <span class="c1">//interior number of corners</span>
<span class="n">Mat</span> <span class="n">gray</span> <span class="o">=</span> <span class="p">....;</span> <span class="c1">//source image</span>
<span class="n">vector</span><span class="o">&lt;</span><span class="n">Point2f</span><span class="o">&gt;</span> <span class="n">corners</span><span class="p">;</span> <span class="c1">//this will be filled by the detected corners</span>

<span class="c1">//CALIB_CB_FAST_CHECK saves a lot of time on images</span>
<span class="c1">//that do not contain any chessboard corners</span>
<span class="kt">bool</span> <span class="n">patternfound</span> <span class="o">=</span> <span class="n">findChessboardCorners</span><span class="p">(</span><span class="n">gray</span><span class="p">,</span> <span class="n">patternsize</span><span class="p">,</span> <span class="n">corners</span><span class="p">,</span>
        <span class="n">CALIB_CB_ADAPTIVE_THRESH</span> <span class="o">+</span> <span class="n">CALIB_CB_NORMALIZE_IMAGE</span>
        <span class="o">+</span> <span class="n">CALIB_CB_FAST_CHECK</span><span class="p">);</span>

<span class="k">if</span><span class="p">(</span><span class="n">patternfound</span><span class="p">)</span>
  <span class="n">cornerSubPix</span><span class="p">(</span><span class="n">gray</span><span class="p">,</span> <span class="n">corners</span><span class="p">,</span> <span class="n">Size</span><span class="p">(</span><span class="mi">11</span><span class="p">,</span> <span class="mi">11</span><span class="p">),</span> <span class="n">Size</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">),</span>
    <span class="n">TermCriteria</span><span class="p">(</span><span class="n">CV_TERMCRIT_EPS</span> <span class="o">+</span> <span class="n">CV_TERMCRIT_ITER</span><span class="p">,</span> <span class="mi">30</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">));</span>

<span class="n">drawChessboardCorners</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">patternsize</span><span class="p">,</span> <span class="n">Mat</span><span class="p">(</span><span class="n">corners</span><span class="p">),</span> <span class="n">patternfound</span><span class="p">);</span>
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The function requires white space (like a square-thick border, the wider the better) around the board to make the detection more robust in various environments. Otherwise, if there is no border and the background is dark, the outer black squares cannot be segmented properly and so the square grouping and ordering algorithm fails.</p>
</div>
</div>
<div class="section" id="findcirclesgrid">
<h2>findCirclesGrid<a class="headerlink" href="#findcirclesgrid" title="Permalink to this headline">¶</a></h2>
<p>Finds centers in the grid of circles.</p>
<dl class="function">
<dt id="bool findCirclesGrid(InputArray image, Size patternSize, OutputArray centers, int flags, const Ptr&lt;FeatureDetector&gt; &amp;blobDetector)">
<strong>C++:</strong><code class="descname"> </code>bool <code class="descname">findCirclesGrid</code><span class="sig-paren">(</span>InputArray <strong>image</strong>, Size <strong>patternSize</strong>, OutputArray <strong>centers</strong>, int <strong>flags</strong>=CALIB_CB_SYMMETRIC_GRID, const Ptr&lt;FeatureDetector&gt;&amp; <strong>blobDetector</strong>=new SimpleBlobDetector() <span class="sig-paren">)</span><a class="headerlink" href="#bool findCirclesGrid(InputArray image, Size patternSize, OutputArray centers, int flags, const Ptr<FeatureDetector> &blobDetector)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="pyfunction">
<dt id="cv2.findCirclesGridDefault">
<strong>Python:</strong><code class="descname"> </code><code class="descclassname">cv2.</code><code class="descname">findCirclesGridDefault</code><span class="sig-paren">(</span>image, patternSize<span class="optional">[</span>, centers<span class="optional">[</span>, flags<span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span> &rarr; retval, centers<a class="headerlink" href="#cv2.findCirclesGridDefault" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>image</strong> &#8211; grid view of input circles; it must be an 8-bit grayscale or color image.</li>
<li><strong>patternSize</strong> &#8211; number of circles per row and column <code class="docutils literal"><span class="pre">(</span> <span class="pre">patternSize</span> <span class="pre">=</span> <span class="pre">Size(points_per_row,</span> <span class="pre">points_per_colum)</span> <span class="pre">)</span></code>.</li>
<li><strong>centers</strong> &#8211; output array of detected centers.</li>
<li><strong>flags</strong> &#8211; <p>various operation flags that can be one of the following values:</p>
<ul>
<li><strong>CALIB_CB_SYMMETRIC_GRID</strong> uses symmetric pattern of circles.</li>
<li><strong>CALIB_CB_ASYMMETRIC_GRID</strong> uses asymmetric pattern of circles.</li>
<li><strong>CALIB_CB_CLUSTERING</strong> uses a special algorithm for grid detection. It is more robust to perspective distortions but much more sensitive to background clutter.</li>
</ul>
</li>
<li><strong>blobDetector</strong> &#8211; feature detector that finds blobs like dark circles on light background.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<p>The function attempts to determine
whether the input image contains a grid of circles. If it is, the function locates centers of the circles. The function returns a
non-zero value if all of the centers have been found and they have been placed
in a certain order (row by row, left to right in every row). Otherwise, if the function fails to find all the corners or reorder
them, it returns 0.</p>
<p>Sample usage of detecting and drawing the centers of circles:</p>
<div class="highlight-cpp"><div class="highlight"><pre><span class="n">Size</span> <span class="nf">patternsize</span><span class="p">(</span><span class="mi">7</span><span class="p">,</span><span class="mi">7</span><span class="p">);</span> <span class="c1">//number of centers</span>
<span class="n">Mat</span> <span class="n">gray</span> <span class="o">=</span> <span class="p">....;</span> <span class="c1">//source image</span>
<span class="n">vector</span><span class="o">&lt;</span><span class="n">Point2f</span><span class="o">&gt;</span> <span class="n">centers</span><span class="p">;</span> <span class="c1">//this will be filled by the detected centers</span>

<span class="kt">bool</span> <span class="n">patternfound</span> <span class="o">=</span> <span class="n">findCirclesGrid</span><span class="p">(</span><span class="n">gray</span><span class="p">,</span> <span class="n">patternsize</span><span class="p">,</span> <span class="n">centers</span><span class="p">);</span>

<span class="n">drawChessboardCorners</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">patternsize</span><span class="p">,</span> <span class="n">Mat</span><span class="p">(</span><span class="n">centers</span><span class="p">),</span> <span class="n">patternfound</span><span class="p">);</span>
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The function requires white space (like a square-thick border, the wider the better) around the board to make the detection more robust in various environments.</p>
</div>
</div>
<div class="section" id="solvepnp">
<h2>solvePnP<a class="headerlink" href="#solvepnp" title="Permalink to this headline">¶</a></h2>
<p>Finds an object pose from 3D-2D point correspondences.</p>
<dl class="function">
<dt id="bool solvePnP(InputArray objectPoints, InputArray imagePoints, InputArray cameraMatrix, InputArray distCoeffs, OutputArray rvec, OutputArray tvec, bool useExtrinsicGuess, int flags)">
<strong>C++:</strong><code class="descname"> </code>bool <code class="descname">solvePnP</code><span class="sig-paren">(</span>InputArray <strong>objectPoints</strong>, InputArray <strong>imagePoints</strong>, InputArray <strong>cameraMatrix</strong>, InputArray <strong>distCoeffs</strong>, OutputArray <strong>rvec</strong>, OutputArray <strong>tvec</strong>, bool <strong>useExtrinsicGuess</strong>=false, int <strong>flags</strong>=ITERATIVE <span class="sig-paren">)</span><a class="headerlink" href="#bool solvePnP(InputArray objectPoints, InputArray imagePoints, InputArray cameraMatrix, InputArray distCoeffs, OutputArray rvec, OutputArray tvec, bool useExtrinsicGuess, int flags)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="pyfunction">
<dt id="cv2.solvePnP">
<strong>Python:</strong><code class="descname"> </code><code class="descclassname">cv2.</code><code class="descname">solvePnP</code><span class="sig-paren">(</span>objectPoints, imagePoints, cameraMatrix, distCoeffs<span class="optional">[</span>, rvec<span class="optional">[</span>, tvec<span class="optional">[</span>, useExtrinsicGuess<span class="optional">[</span>, flags<span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span> &rarr; retval, rvec, tvec<a class="headerlink" href="#cv2.solvePnP" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="cfunction">
<dt id="void cvFindExtrinsicCameraParams2(const CvMat* object_points, const CvMat* image_points, const CvMat* camera_matrix, const CvMat* distortion_coeffs, CvMat* rotation_vector, CvMat* translation_vector, int use_extrinsic_guess)">
<strong>C:</strong><code class="descname"> </code>void <code class="descname">cvFindExtrinsicCameraParams2</code><span class="sig-paren">(</span>const CvMat* <strong>object_points</strong>, const CvMat* <strong>image_points</strong>, const CvMat* <strong>camera_matrix</strong>, const CvMat* <strong>distortion_coeffs</strong>, CvMat* <strong>rotation_vector</strong>, CvMat* <strong>translation_vector</strong>, int <strong>use_extrinsic_guess</strong>=0 <span class="sig-paren">)</span><a class="headerlink" href="#void cvFindExtrinsicCameraParams2(const CvMat* object_points, const CvMat* image_points, const CvMat* camera_matrix, const CvMat* distortion_coeffs, CvMat* rotation_vector, CvMat* translation_vector, int use_extrinsic_guess)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="pyoldfunction">
<dt id="cv.FindExtrinsicCameraParams2">
<strong>Python:</strong><code class="descname"> </code><code class="descclassname">cv.</code><code class="descname">FindExtrinsicCameraParams2</code><span class="sig-paren">(</span>objectPoints, imagePoints, cameraMatrix, distCoeffs, rvec, tvec, useExtrinsicGuess=0<span class="sig-paren">)</span> &rarr; None<a class="headerlink" href="#cv.FindExtrinsicCameraParams2" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>objectPoints</strong> &#8211; Array of object points in the object coordinate space, 3xN/Nx3 1-channel or 1xN/Nx1 3-channel, where N is the number of points.  <code class="docutils literal"><span class="pre">vector&lt;Point3f&gt;</span></code>  can be also passed here.</li>
<li><strong>imagePoints</strong> &#8211; Array of corresponding image points, 2xN/Nx2 1-channel or 1xN/Nx1 2-channel, where N is the number of points.  <code class="docutils literal"><span class="pre">vector&lt;Point2f&gt;</span></code>  can be also passed here.</li>
<li><strong>cameraMatrix</strong> &#8211; Input camera matrix  <img class="math" src="../../../_images/math/b16cc447f582ea242f8261267b77228fbbe12f2e.png" alt="A = \vecthreethree{fx}{0}{cx}{0}{fy}{cy}{0}{0}{1}"/> .</li>
<li><strong>distCoeffs</strong> &#8211; Input vector of distortion coefficients  <img class="math" src="../../../_images/math/94288b7709d10a7ddf286e33db0074512bda0411.png" alt="(k_1, k_2, p_1, p_2[, k_3[, k_4, k_5, k_6]])"/>  of 4, 5, or 8 elements. If the vector is NULL/empty, the zero distortion coefficients are assumed.</li>
<li><strong>rvec</strong> &#8211; Output rotation vector (see  <a class="reference internal" href="#void Rodrigues(InputArray src, OutputArray dst, OutputArray jacobian)" title="void Rodrigues(InputArray src, OutputArray dst, OutputArray jacobian)"><code class="xref ocv ocv-func docutils literal"><span class="pre">Rodrigues()</span></code></a> ) that, together with  <code class="docutils literal"><span class="pre">tvec</span></code> , brings points from the model coordinate system to the camera coordinate system.</li>
<li><strong>tvec</strong> &#8211; Output translation vector.</li>
<li><strong>useExtrinsicGuess</strong> &#8211; If true (1), the function uses the provided  <code class="docutils literal"><span class="pre">rvec</span></code>  and  <code class="docutils literal"><span class="pre">tvec</span></code>  values as initial approximations of the rotation and translation vectors, respectively, and further optimizes them.</li>
<li><strong>flags</strong> &#8211; <p>Method for solving a PnP problem:</p>
<ul>
<li><strong>CV_ITERATIVE</strong> Iterative method is based on Levenberg-Marquardt optimization. In this case the function finds such a pose that minimizes reprojection error, that is the sum of squared distances between the observed projections <code class="docutils literal"><span class="pre">imagePoints</span></code> and the projected (using <a class="reference internal" href="#void projectPoints(InputArray objectPoints, InputArray rvec, InputArray tvec, InputArray cameraMatrix, InputArray distCoeffs, OutputArray imagePoints, OutputArray jacobian, double aspectRatio)" title="void projectPoints(InputArray objectPoints, InputArray rvec, InputArray tvec, InputArray cameraMatrix, InputArray distCoeffs, OutputArray imagePoints, OutputArray jacobian, double aspectRatio)"><code class="xref ocv ocv-func docutils literal"><span class="pre">projectPoints()</span></code></a> ) <code class="docutils literal"><span class="pre">objectPoints</span></code> .</li>
<li><strong>CV_P3P</strong>  Method is based on the paper of X.S. Gao, X.-R. Hou, J. Tang, H.-F. Chang &#8220;Complete Solution Classification for the Perspective-Three-Point Problem&#8221;. In this case the function requires exactly four object and image points.</li>
<li><strong>CV_EPNP</strong> Method has been introduced by F.Moreno-Noguer, V.Lepetit and P.Fua in the paper &#8220;EPnP: Efficient Perspective-n-Point Camera Pose Estimation&#8221;.</li>
</ul>
</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<p>The function estimates the object pose given a set of object points, their corresponding image projections, as well as the camera matrix and the distortion coefficients.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<ul class="last simple">
<li>An example of how to use solvePNP for planar augmented reality can be found at opencv_source_code/samples/python2/plane_ar.py</li>
</ul>
</div>
</div>
<div class="section" id="solvepnpransac">
<h2>solvePnPRansac<a class="headerlink" href="#solvepnpransac" title="Permalink to this headline">¶</a></h2>
<p>Finds an object pose from 3D-2D point correspondences using the RANSAC scheme.</p>
<dl class="function">
<dt id="void solvePnPRansac(InputArray objectPoints, InputArray imagePoints, InputArray cameraMatrix, InputArray distCoeffs, OutputArray rvec, OutputArray tvec, bool useExtrinsicGuess, int iterationsCount , float reprojectionError , int minInliersCount , OutputArray inliers , int flags)">
<strong>C++:</strong><code class="descname"> </code>void <code class="descname">solvePnPRansac</code><span class="sig-paren">(</span>InputArray <strong>objectPoints</strong>, InputArray <strong>imagePoints</strong>, InputArray <strong>cameraMatrix</strong>, InputArray <strong>distCoeffs</strong>, OutputArray <strong>rvec</strong>, OutputArray <strong>tvec</strong>, bool <strong>useExtrinsicGuess</strong>=false, int <strong>iterationsCount</strong>=100, float <strong>reprojectionError</strong>=8.0, int <strong>minInliersCount</strong>=100, OutputArray <strong>inliers</strong>=noArray(), int <strong>flags</strong>=ITERATIVE <span class="sig-paren">)</span><a class="headerlink" href="#void solvePnPRansac(InputArray objectPoints, InputArray imagePoints, InputArray cameraMatrix, InputArray distCoeffs, OutputArray rvec, OutputArray tvec, bool useExtrinsicGuess, int iterationsCount , float reprojectionError , int minInliersCount , OutputArray inliers , int flags)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="pyfunction">
<dt id="cv2.solvePnPRansac">
<strong>Python:</strong><code class="descname"> </code><code class="descclassname">cv2.</code><code class="descname">solvePnPRansac</code><span class="sig-paren">(</span>objectPoints, imagePoints, cameraMatrix, distCoeffs<span class="optional">[</span>, rvec<span class="optional">[</span>, tvec<span class="optional">[</span>, useExtrinsicGuess<span class="optional">[</span>, iterationsCount<span class="optional">[</span>, reprojectionError<span class="optional">[</span>, minInliersCount<span class="optional">[</span>, inliers<span class="optional">[</span>, flags<span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span> &rarr; rvec, tvec, inliers<a class="headerlink" href="#cv2.solvePnPRansac" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>objectPoints</strong> &#8211; Array of object points in the object coordinate space, 3xN/Nx3 1-channel or 1xN/Nx1 3-channel, where N is the number of points.   <code class="docutils literal"><span class="pre">vector&lt;Point3f&gt;</span></code>  can be also passed here.</li>
<li><strong>imagePoints</strong> &#8211; Array of corresponding image points, 2xN/Nx2 1-channel or 1xN/Nx1 2-channel, where N is the number of points.  <code class="docutils literal"><span class="pre">vector&lt;Point2f&gt;</span></code>  can be also passed here.</li>
<li><strong>cameraMatrix</strong> &#8211; Input camera matrix  <img class="math" src="../../../_images/math/b16cc447f582ea242f8261267b77228fbbe12f2e.png" alt="A = \vecthreethree{fx}{0}{cx}{0}{fy}{cy}{0}{0}{1}"/> .</li>
<li><strong>distCoeffs</strong> &#8211; Input vector of distortion coefficients  <img class="math" src="../../../_images/math/94288b7709d10a7ddf286e33db0074512bda0411.png" alt="(k_1, k_2, p_1, p_2[, k_3[, k_4, k_5, k_6]])"/>  of 4, 5, or 8 elements. If the vector is NULL/empty, the zero distortion coefficients are assumed.</li>
<li><strong>rvec</strong> &#8211; Output rotation vector (see  <a class="reference internal" href="#void Rodrigues(InputArray src, OutputArray dst, OutputArray jacobian)" title="void Rodrigues(InputArray src, OutputArray dst, OutputArray jacobian)"><code class="xref ocv ocv-func docutils literal"><span class="pre">Rodrigues()</span></code></a> ) that, together with  <code class="docutils literal"><span class="pre">tvec</span></code> , brings points from the model coordinate system to the camera coordinate system.</li>
<li><strong>tvec</strong> &#8211; Output translation vector.</li>
<li><strong>useExtrinsicGuess</strong> &#8211; If true (1), the function uses the provided  <code class="docutils literal"><span class="pre">rvec</span></code>  and  <code class="docutils literal"><span class="pre">tvec</span></code> values as initial approximations of the rotation and translation vectors, respectively, and further optimizes them.</li>
<li><strong>iterationsCount</strong> &#8211; Number of iterations.</li>
<li><strong>reprojectionError</strong> &#8211; Inlier threshold value used by the RANSAC procedure. The parameter value is the maximum allowed distance between the observed and computed point projections to consider it an inlier.</li>
<li><strong>minInliersCount</strong> &#8211; Number of inliers. If the algorithm at some stage finds more inliers than <code class="docutils literal"><span class="pre">minInliersCount</span></code> , it finishes.</li>
<li><strong>inliers</strong> &#8211; Output vector that contains indices of inliers in <code class="docutils literal"><span class="pre">objectPoints</span></code> and <code class="docutils literal"><span class="pre">imagePoints</span></code> .</li>
<li><strong>flags</strong> &#8211; Method for solving a PnP problem (see  <a class="reference internal" href="#bool solvePnP(InputArray objectPoints, InputArray imagePoints, InputArray cameraMatrix, InputArray distCoeffs, OutputArray rvec, OutputArray tvec, bool useExtrinsicGuess, int flags)" title="bool solvePnP(InputArray objectPoints, InputArray imagePoints, InputArray cameraMatrix, InputArray distCoeffs, OutputArray rvec, OutputArray tvec, bool useExtrinsicGuess, int flags)"><code class="xref ocv ocv-func docutils literal"><span class="pre">solvePnP()</span></code></a> ).</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<p>The function estimates an object pose given a set of object points, their corresponding image projections, as well as the camera matrix and the distortion coefficients. This function finds such a pose that minimizes reprojection error, that is, the sum of squared distances between the observed projections <code class="docutils literal"><span class="pre">imagePoints</span></code> and the projected (using
<a class="reference internal" href="#void projectPoints(InputArray objectPoints, InputArray rvec, InputArray tvec, InputArray cameraMatrix, InputArray distCoeffs, OutputArray imagePoints, OutputArray jacobian, double aspectRatio)" title="void projectPoints(InputArray objectPoints, InputArray rvec, InputArray tvec, InputArray cameraMatrix, InputArray distCoeffs, OutputArray imagePoints, OutputArray jacobian, double aspectRatio)"><code class="xref ocv ocv-func docutils literal"><span class="pre">projectPoints()</span></code></a> ) <code class="docutils literal"><span class="pre">objectPoints</span></code>. The use of RANSAC makes the function resistant to outliers. The function is parallelized with the TBB library.</p>
</div>
<div class="section" id="findfundamentalmat">
<h2>findFundamentalMat<a class="headerlink" href="#findfundamentalmat" title="Permalink to this headline">¶</a></h2>
<p>Calculates a fundamental matrix from the corresponding points in two images.</p>
<dl class="function">
<dt id="Mat findFundamentalMat(InputArray points1, InputArray points2, int method, double param1, double param2, OutputArray mask)">
<strong>C++:</strong><code class="descname"> </code>Mat <code class="descname">findFundamentalMat</code><span class="sig-paren">(</span>InputArray <strong>points1</strong>, InputArray <strong>points2</strong>, int <strong>method</strong>=FM_RANSAC, double <strong>param1</strong>=3., double <strong>param2</strong>=0.99, OutputArray <strong>mask</strong>=noArray() <span class="sig-paren">)</span><a class="headerlink" href="#Mat findFundamentalMat(InputArray points1, InputArray points2, int method, double param1, double param2, OutputArray mask)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="pyfunction">
<dt id="cv2.findFundamentalMat">
<strong>Python:</strong><code class="descname"> </code><code class="descclassname">cv2.</code><code class="descname">findFundamentalMat</code><span class="sig-paren">(</span>points1, points2<span class="optional">[</span>, method<span class="optional">[</span>, param1<span class="optional">[</span>, param2<span class="optional">[</span>, mask<span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span> &rarr; retval, mask<a class="headerlink" href="#cv2.findFundamentalMat" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="cfunction">
<dt id="int cvFindFundamentalMat(const CvMat* points1, const CvMat* points2, CvMat* fundamental_matrix, int method, double param1, double param2, CvMat* status)">
<strong>C:</strong><code class="descname"> </code>int <code class="descname">cvFindFundamentalMat</code><span class="sig-paren">(</span>const CvMat* <strong>points1</strong>, const CvMat* <strong>points2</strong>, CvMat* <strong>fundamental_matrix</strong>, int <strong>method</strong>=CV_FM_RANSAC, double <strong>param1</strong>=3., double <strong>param2</strong>=0.99, CvMat* <strong>status</strong>=NULL <span class="sig-paren">)</span><a class="headerlink" href="#int cvFindFundamentalMat(const CvMat* points1, const CvMat* points2, CvMat* fundamental_matrix, int method, double param1, double param2, CvMat* status)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="pyoldfunction">
<dt id="cv.FindFundamentalMat">
<strong>Python:</strong><code class="descname"> </code><code class="descclassname">cv.</code><code class="descname">FindFundamentalMat</code><span class="sig-paren">(</span>points1, points2, fundamentalMatrix, method=CV_FM_RANSAC, param1=1., param2=0.99, status=None<span class="sig-paren">)</span> &rarr; retval<a class="headerlink" href="#cv.FindFundamentalMat" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>points1</strong> &#8211; Array of  <code class="docutils literal"><span class="pre">N</span></code>  points from the first image. The point coordinates should be floating-point (single or double precision).</li>
<li><strong>points2</strong> &#8211; Array of the second image points of the same size and format as  <code class="docutils literal"><span class="pre">points1</span></code> .</li>
<li><strong>method</strong> &#8211; <p>Method for computing a fundamental matrix.</p>
<ul>
<li><strong>CV_FM_7POINT</strong> for a 7-point algorithm.  <img class="math" src="../../../_images/math/6940b7032604979b0bd039623ae7396eb49655e9.png" alt="N = 7"/></li>
<li><strong>CV_FM_8POINT</strong> for an 8-point algorithm.  <img class="math" src="../../../_images/math/7eeda274320b3c362c3b21591b8efb8901ce7b34.png" alt="N \ge 8"/></li>
<li><strong>CV_FM_RANSAC</strong> for the RANSAC algorithm.  <img class="math" src="../../../_images/math/7eeda274320b3c362c3b21591b8efb8901ce7b34.png" alt="N \ge 8"/></li>
<li><strong>CV_FM_LMEDS</strong> for the LMedS algorithm.  <img class="math" src="../../../_images/math/7eeda274320b3c362c3b21591b8efb8901ce7b34.png" alt="N \ge 8"/></li>
</ul>
</li>
<li><strong>param1</strong> &#8211; Parameter used for RANSAC. It is the maximum distance from a point to an epipolar line in pixels, beyond which the point is considered an outlier and is not used for computing the final fundamental matrix. It can be set to something like 1-3, depending on the accuracy of the point localization, image resolution, and the image noise.</li>
<li><strong>param2</strong> &#8211; Parameter used for the RANSAC or LMedS methods only. It specifies a desirable level of confidence (probability) that the estimated matrix is correct.</li>
<li><strong>mask</strong> &#8211; Output array of N elements, every element of which is set to 0 for outliers and to 1 for the other points. The array is computed only in the RANSAC and LMedS methods. For other methods, it is set to all 1&#8217;s.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<p>The epipolar geometry is described by the following equation:</p>
<div class="math">
<p><img src="../../../_images/math/1c83f2262812b017960514fb184fba470c84f0fe.png" alt="[p_2; 1]^T F [p_1; 1] = 0"/></p>
</div><p>where
<img class="math" src="../../../_images/math/be6771c7d34c7c1a47dc5863ebc1470d10a47720.png" alt="F"/> is a fundamental matrix,
<img class="math" src="../../../_images/math/d405fc06c6077f83cc84c5e3ba41962fc5dede4c.png" alt="p_1"/> and
<img class="math" src="../../../_images/math/a7c121ed51d0825b1c4a6cea032e76438d856c2d.png" alt="p_2"/> are corresponding points in the first and the second images, respectively.</p>
<p>The function calculates the fundamental matrix using one of four methods listed above and returns
the found fundamental matrix. Normally just one matrix is found. But in case of the 7-point algorithm, the function may return up to 3 solutions (
<img class="math" src="../../../_images/math/3efb7f4ce33e93351a7f9e85fcfc85538095dc7f.png" alt="9 \times 3"/> matrix that stores all 3 matrices sequentially).</p>
<p>The calculated fundamental matrix may be passed further to
<a class="reference internal" href="#void computeCorrespondEpilines(InputArray points, int whichImage, InputArray F, OutputArray lines)" title="void computeCorrespondEpilines(InputArray points, int whichImage, InputArray F, OutputArray lines)"><code class="xref ocv ocv-func docutils literal"><span class="pre">computeCorrespondEpilines()</span></code></a> that finds the epipolar lines
corresponding to the specified points. It can also be passed to
<a class="reference internal" href="#bool stereoRectifyUncalibrated(InputArray points1, InputArray points2, InputArray F, Size imgSize, OutputArray H1, OutputArray H2, double threshold)" title="bool stereoRectifyUncalibrated(InputArray points1, InputArray points2, InputArray F, Size imgSize, OutputArray H1, OutputArray H2, double threshold)"><code class="xref ocv ocv-func docutils literal"><span class="pre">stereoRectifyUncalibrated()</span></code></a> to compute the rectification transformation.</p>
<div class="highlight-cpp"><div class="highlight"><pre><span class="c1">// Example. Estimation of fundamental matrix using the RANSAC algorithm</span>
<span class="kt">int</span> <span class="n">point_count</span> <span class="o">=</span> <span class="mi">100</span><span class="p">;</span>
<span class="n">vector</span><span class="o">&lt;</span><span class="n">Point2f</span><span class="o">&gt;</span> <span class="n">points1</span><span class="p">(</span><span class="n">point_count</span><span class="p">);</span>
<span class="n">vector</span><span class="o">&lt;</span><span class="n">Point2f</span><span class="o">&gt;</span> <span class="n">points2</span><span class="p">(</span><span class="n">point_count</span><span class="p">);</span>

<span class="c1">// initialize the points here ... */</span>
<span class="k">for</span><span class="p">(</span> <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">point_count</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span> <span class="p">)</span>
<span class="p">{</span>
    <span class="n">points1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">...;</span>
    <span class="n">points2</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">...;</span>
<span class="p">}</span>

<span class="n">Mat</span> <span class="n">fundamental_matrix</span> <span class="o">=</span>
 <span class="n">findFundamentalMat</span><span class="p">(</span><span class="n">points1</span><span class="p">,</span> <span class="n">points2</span><span class="p">,</span> <span class="n">FM_RANSAC</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mf">0.99</span><span class="p">);</span>
</pre></div>
</div>
</div>
<div class="section" id="findhomography">
<h2>findHomography<a class="headerlink" href="#findhomography" title="Permalink to this headline">¶</a></h2>
<p>Finds a perspective transformation between two planes.</p>
<dl class="function">
<dt id="Mat findHomography(InputArray srcPoints, InputArray dstPoints, int method, double ransacReprojThreshold, OutputArray mask)">
<strong>C++:</strong><code class="descname"> </code>Mat <code class="descname">findHomography</code><span class="sig-paren">(</span>InputArray <strong>srcPoints</strong>, InputArray <strong>dstPoints</strong>, int <strong>method</strong>=0, double <strong>ransacReprojThreshold</strong>=3, OutputArray <strong>mask</strong>=noArray() <span class="sig-paren">)</span><a class="headerlink" href="#Mat findHomography(InputArray srcPoints, InputArray dstPoints, int method, double ransacReprojThreshold, OutputArray mask)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="pyfunction">
<dt id="cv2.findHomography">
<strong>Python:</strong><code class="descname"> </code><code class="descclassname">cv2.</code><code class="descname">findHomography</code><span class="sig-paren">(</span>srcPoints, dstPoints<span class="optional">[</span>, method<span class="optional">[</span>, ransacReprojThreshold<span class="optional">[</span>, mask<span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span> &rarr; retval, mask<a class="headerlink" href="#cv2.findHomography" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="cfunction">
<dt id="int cvFindHomography(const CvMat* src_points, const CvMat* dst_points, CvMat* homography, int method, double ransacReprojThreshold, CvMat* mask)">
<strong>C:</strong><code class="descname"> </code>int <code class="descname">cvFindHomography</code><span class="sig-paren">(</span>const CvMat* <strong>src_points</strong>, const CvMat* <strong>dst_points</strong>, CvMat* <strong>homography</strong>, int <strong>method</strong>=0, double <strong>ransacReprojThreshold</strong>=3, CvMat* <strong>mask</strong>=0 <span class="sig-paren">)</span><a class="headerlink" href="#int cvFindHomography(const CvMat* src_points, const CvMat* dst_points, CvMat* homography, int method, double ransacReprojThreshold, CvMat* mask)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="pyoldfunction">
<dt id="cv.FindHomography">
<strong>Python:</strong><code class="descname"> </code><code class="descclassname">cv.</code><code class="descname">FindHomography</code><span class="sig-paren">(</span>srcPoints, dstPoints, H, method=0, ransacReprojThreshold=3.0, status=None<span class="sig-paren">)</span> &rarr; None<a class="headerlink" href="#cv.FindHomography" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>srcPoints</strong> &#8211; Coordinates of the points in the original plane, a matrix of the type  <code class="docutils literal"><span class="pre">CV_32FC2</span></code>  or <code class="docutils literal"><span class="pre">vector&lt;Point2f&gt;</span></code> .</li>
<li><strong>dstPoints</strong> &#8211; Coordinates of the points in the target plane, a matrix of the type  <code class="docutils literal"><span class="pre">CV_32FC2</span></code>  or a  <code class="docutils literal"><span class="pre">vector&lt;Point2f&gt;</span></code> .</li>
<li><strong>method</strong> &#8211; <p>Method used to computed a homography matrix. The following methods are possible:</p>
<ul>
<li><strong>0</strong> - a regular method using all the points</li>
<li><strong>CV_RANSAC</strong> - RANSAC-based robust method</li>
<li><strong>CV_LMEDS</strong> - Least-Median robust method</li>
</ul>
</li>
<li><strong>ransacReprojThreshold</strong> &#8211; <p>Maximum allowed reprojection error to treat a point pair as an inlier (used in the RANSAC method only). That is, if</p>
<div class="math">
<p><img src="../../../_images/math/4fcf0dae391d53967cd8d8f3284d7d6fdd5937b4.png" alt="\| \texttt{dstPoints} _i -  \texttt{convertPointsHomogeneous} ( \texttt{H} * \texttt{srcPoints} _i) \|  &gt;  \texttt{ransacReprojThreshold}"/></p>
</div><p>then the point  <img class="math" src="../../../_images/math/881d48e575544c8daaa1d83893dcde5f9f7562ec.png" alt="i"/>  is considered an outlier. If  <code class="docutils literal"><span class="pre">srcPoints</span></code>  and  <code class="docutils literal"><span class="pre">dstPoints</span></code>  are measured in pixels, it usually makes sense to set this parameter somewhere in the range of 1 to 10.</p>
</li>
<li><strong>mask</strong> &#8211; Optional output mask set by a robust method ( <code class="docutils literal"><span class="pre">CV_RANSAC</span></code>  or  <code class="docutils literal"><span class="pre">CV_LMEDS</span></code> ).  Note that the input mask values are ignored.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<p>The functions find and return the perspective transformation <img class="math" src="../../../_images/math/662c239f3e7a5d3290da0913485987263a7c1ae7.png" alt="H"/> between the source and the destination planes:</p>
<div class="math">
<p><img src="../../../_images/math/4f61591c20d759599c049f1d04d6835c1a370b66.png" alt="s_i  \vecthree{x'_i}{y'_i}{1} \sim H  \vecthree{x_i}{y_i}{1}"/></p>
</div><p>so that the back-projection error</p>
<div class="math">
<p><img src="../../../_images/math/01c18df9e020bc8df621de23c504397a42d0fff8.png" alt="\sum _i \left ( x'_i- \frac{h_{11} x_i + h_{12} y_i + h_{13}}{h_{31} x_i + h_{32} y_i + h_{33}} \right )^2+ \left ( y'_i- \frac{h_{21} x_i + h_{22} y_i + h_{23}}{h_{31} x_i + h_{32} y_i + h_{33}} \right )^2"/></p>
</div><p>is minimized. If the parameter <code class="docutils literal"><span class="pre">method</span></code> is set to the default value 0, the function
uses all the point pairs to compute an initial homography estimate with a simple least-squares scheme.</p>
<p>However, if not all of the point pairs (
<img class="math" src="../../../_images/math/d1954365f34b2517841c9f9ea81d9e55998abd8e.png" alt="srcPoints_i"/>, <img class="math" src="../../../_images/math/ee70f01503f40cd0cdcef2b507e1bf187e21820a.png" alt="dstPoints_i"/> ) fit the rigid perspective transformation (that is, there
are some outliers), this initial estimate will be poor.
In this case, you can use one of the two robust methods. Both methods, <code class="docutils literal"><span class="pre">RANSAC</span></code> and <code class="docutils literal"><span class="pre">LMeDS</span></code> , try many different random subsets
of the corresponding point pairs (of four pairs each), estimate
the homography matrix using this subset and a simple least-square
algorithm, and then compute the quality/goodness of the computed homography
(which is the number of inliers for RANSAC or the median re-projection
error for LMeDs). The best subset is then used to produce the initial
estimate of the homography matrix and the mask of inliers/outliers.</p>
<p>Regardless of the method, robust or not, the computed homography
matrix is refined further (using inliers only in case of a robust
method) with the Levenberg-Marquardt method to reduce the
re-projection error even more.</p>
<p>The method <code class="docutils literal"><span class="pre">RANSAC</span></code> can handle practically any ratio of outliers
but it needs a threshold to distinguish inliers from outliers.
The method <code class="docutils literal"><span class="pre">LMeDS</span></code> does not need any threshold but it works
correctly only when there are more than 50% of inliers. Finally,
if there are no outliers and the noise is rather small, use the default method (<code class="docutils literal"><span class="pre">method=0</span></code>).</p>
<p>The function is used to find initial intrinsic and extrinsic matrices.
Homography matrix is determined up to a scale. Thus, it is normalized so that
<img class="math" src="../../../_images/math/8cab4a30e512f0538a163ddeaefe64b63ed2ccf2.png" alt="h_{33}=1"/>. Note that whenever an H matrix cannot be estimated, an empty one will be returned.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="../../imgproc/doc/geometric_transformations.html#Mat getAffineTransform(InputArray src, InputArray dst)" title="Mat getAffineTransform(InputArray src, InputArray dst)"><code class="xref ocv ocv-func docutils literal"><span class="pre">getAffineTransform()</span></code></a>,
<a class="reference internal" href="../../imgproc/doc/geometric_transformations.html#Mat getPerspectiveTransform(InputArray src, InputArray dst)" title="Mat getPerspectiveTransform(InputArray src, InputArray dst)"><code class="xref ocv ocv-func docutils literal"><span class="pre">getPerspectiveTransform()</span></code></a>,
<a class="reference internal" href="../../video/doc/motion_analysis_and_object_tracking.html#Mat estimateRigidTransform(InputArray src, InputArray dst, bool fullAffine)" title="Mat estimateRigidTransform(InputArray src, InputArray dst, bool fullAffine)"><code class="xref ocv ocv-func docutils literal"><span class="pre">estimateRigidTransform()</span></code></a>,
<a class="reference internal" href="../../imgproc/doc/geometric_transformations.html#void warpPerspective(InputArray src, OutputArray dst, InputArray M, Size dsize, int flags, int borderMode, const Scalar&amp; borderValue)" title="void warpPerspective(InputArray src, OutputArray dst, InputArray M, Size dsize, int flags, int borderMode, const Scalar&amp; borderValue)"><code class="xref ocv ocv-func docutils literal"><span class="pre">warpPerspective()</span></code></a>,
<a class="reference internal" href="../../core/doc/operations_on_arrays.html#void perspectiveTransform(InputArray src, OutputArray dst, InputArray m)" title="void perspectiveTransform(InputArray src, OutputArray dst, InputArray m)"><code class="xref ocv ocv-func docutils literal"><span class="pre">perspectiveTransform()</span></code></a></p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<ul class="last simple">
<li>A example on calculating a homography for image matching can be found at opencv_source_code/samples/cpp/video_homography.cpp</li>
</ul>
</div>
</div>
<div class="section" id="estimateaffine3d">
<h2>estimateAffine3D<a class="headerlink" href="#estimateaffine3d" title="Permalink to this headline">¶</a></h2>
<p>Computes an optimal affine transformation between two 3D point sets.</p>
<dl class="function">
<dt id="int estimateAffine3D(InputArray src, InputArray dst, OutputArray out, OutputArray inliers, double ransacThreshold , double confidence)">
<strong>C++:</strong><code class="descname"> </code>int <code class="descname">estimateAffine3D</code><span class="sig-paren">(</span>InputArray <strong>src</strong>, InputArray <strong>dst</strong>, OutputArray <strong>out</strong>, OutputArray <strong>inliers</strong>, double <strong>ransacThreshold</strong>=3, double <strong>confidence</strong>=0.99<span class="sig-paren">)</span><a class="headerlink" href="#int estimateAffine3D(InputArray src, InputArray dst, OutputArray out, OutputArray inliers, double ransacThreshold , double confidence)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="pyfunction">
<dt id="cv2.estimateAffine3D">
<strong>Python:</strong><code class="descname"> </code><code class="descclassname">cv2.</code><code class="descname">estimateAffine3D</code><span class="sig-paren">(</span>src, dst<span class="optional">[</span>, out<span class="optional">[</span>, inliers<span class="optional">[</span>, ransacThreshold<span class="optional">[</span>, confidence<span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span> &rarr; retval, out, inliers<a class="headerlink" href="#cv2.estimateAffine3D" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>src</strong> &#8211; First input 3D point set.</li>
<li><strong>dst</strong> &#8211; Second input 3D point set.</li>
<li><strong>out</strong> &#8211; Output 3D affine transformation matrix  <img class="math" src="../../../_images/math/a5149d0815e6a1c11cc6d71732af6d88b8d9fe14.png" alt="3 \times 4"/> .</li>
<li><strong>inliers</strong> &#8211; Output vector indicating which points are inliers.</li>
<li><strong>ransacThreshold</strong> &#8211; Maximum reprojection error in the RANSAC algorithm to consider a point as an inlier.</li>
<li><strong>confidence</strong> &#8211; Confidence level, between 0 and 1, for the estimated transformation. Anything between 0.95 and 0.99 is usually good enough. Values too close to 1 can slow down the estimation significantly. Values lower than 0.8-0.9 can result in an incorrectly estimated transformation.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<p>The function estimates an optimal 3D affine transformation between two 3D point sets using the RANSAC algorithm.</p>
</div>
<div class="section" id="filterspeckles">
<h2>filterSpeckles<a class="headerlink" href="#filterspeckles" title="Permalink to this headline">¶</a></h2>
<p>Filters off small noise blobs (speckles) in the disparity map</p>
<dl class="function">
<dt id="void filterSpeckles(InputOutputArray img, double newVal, int maxSpeckleSize, double maxDiff, InputOutputArray buf)">
<strong>C++:</strong><code class="descname"> </code>void <code class="descname">filterSpeckles</code><span class="sig-paren">(</span>InputOutputArray <strong>img</strong>, double <strong>newVal</strong>, int <strong>maxSpeckleSize</strong>, double <strong>maxDiff</strong>, InputOutputArray <strong>buf</strong>=noArray() <span class="sig-paren">)</span><a class="headerlink" href="#void filterSpeckles(InputOutputArray img, double newVal, int maxSpeckleSize, double maxDiff, InputOutputArray buf)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="pyfunction">
<dt id="cv2.filterSpeckles">
<strong>Python:</strong><code class="descname"> </code><code class="descclassname">cv2.</code><code class="descname">filterSpeckles</code><span class="sig-paren">(</span>img, newVal, maxSpeckleSize, maxDiff<span class="optional">[</span>, buf<span class="optional">]</span><span class="sig-paren">)</span> &rarr; None<a class="headerlink" href="#cv2.filterSpeckles" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>img</strong> &#8211; The input 16-bit signed disparity image</li>
<li><strong>newVal</strong> &#8211; The disparity value used to paint-off the speckles</li>
<li><strong>maxSpeckleSize</strong> &#8211; The maximum speckle size to consider it a speckle. Larger blobs are not affected by the algorithm</li>
<li><strong>maxDiff</strong> &#8211; Maximum difference between neighbor disparity pixels to put them into the same blob. Note that since StereoBM, StereoSGBM and may be other algorithms return a fixed-point disparity map, where disparity values are multiplied by 16, this scale factor should be taken into account when specifying this parameter value.</li>
<li><strong>buf</strong> &#8211; The optional temporary buffer to avoid memory allocation within the function.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="getoptimalnewcameramatrix">
<h2>getOptimalNewCameraMatrix<a class="headerlink" href="#getoptimalnewcameramatrix" title="Permalink to this headline">¶</a></h2>
<p>Returns the new camera matrix based on the free scaling parameter.</p>
<dl class="function">
<dt id="Mat getOptimalNewCameraMatrix(InputArray cameraMatrix, InputArray distCoeffs, Size imageSize, double alpha, Size newImgSize, Rect* validPixROI, bool centerPrincipalPoint)">
<strong>C++:</strong><code class="descname"> </code>Mat <code class="descname">getOptimalNewCameraMatrix</code><span class="sig-paren">(</span>InputArray <strong>cameraMatrix</strong>, InputArray <strong>distCoeffs</strong>, Size <strong>imageSize</strong>, double <strong>alpha</strong>, Size <strong>newImgSize</strong>=Size(), Rect* <strong>validPixROI</strong>=0, bool <strong>centerPrincipalPoint</strong>=false <span class="sig-paren">)</span><a class="headerlink" href="#Mat getOptimalNewCameraMatrix(InputArray cameraMatrix, InputArray distCoeffs, Size imageSize, double alpha, Size newImgSize, Rect* validPixROI, bool centerPrincipalPoint)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="pyfunction">
<dt id="cv2.getOptimalNewCameraMatrix">
<strong>Python:</strong><code class="descname"> </code><code class="descclassname">cv2.</code><code class="descname">getOptimalNewCameraMatrix</code><span class="sig-paren">(</span>cameraMatrix, distCoeffs, imageSize, alpha<span class="optional">[</span>, newImgSize<span class="optional">[</span>, centerPrincipalPoint<span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span> &rarr; retval, validPixROI<a class="headerlink" href="#cv2.getOptimalNewCameraMatrix" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="cfunction">
<dt id="void cvGetOptimalNewCameraMatrix(const CvMat* camera_matrix, const CvMat* dist_coeffs, CvSize image_size, double alpha, CvMat* new_camera_matrix, CvSize new_imag_size, CvRect* valid_pixel_ROI, int center_principal_point)">
<strong>C:</strong><code class="descname"> </code>void <code class="descname">cvGetOptimalNewCameraMatrix</code><span class="sig-paren">(</span>const CvMat* <strong>camera_matrix</strong>, const CvMat* <strong>dist_coeffs</strong>, CvSize <strong>image_size</strong>, double <strong>alpha</strong>, CvMat* <strong>new_camera_matrix</strong>, CvSize <strong>new_imag_size</strong>=cvSize(0,0), CvRect* <strong>valid_pixel_ROI</strong>=0, int <strong>center_principal_point</strong>=0 <span class="sig-paren">)</span><a class="headerlink" href="#void cvGetOptimalNewCameraMatrix(const CvMat* camera_matrix, const CvMat* dist_coeffs, CvSize image_size, double alpha, CvMat* new_camera_matrix, CvSize new_imag_size, CvRect* valid_pixel_ROI, int center_principal_point)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="pyoldfunction">
<dt id="cv.GetOptimalNewCameraMatrix">
<strong>Python:</strong><code class="descname"> </code><code class="descclassname">cv.</code><code class="descname">GetOptimalNewCameraMatrix</code><span class="sig-paren">(</span>cameraMatrix, distCoeffs, imageSize, alpha, newCameraMatrix, newImageSize=(0, 0), validPixROI=0, centerPrincipalPoint=0<span class="sig-paren">)</span> &rarr; None<a class="headerlink" href="#cv.GetOptimalNewCameraMatrix" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>cameraMatrix</strong> &#8211; Input camera matrix.</li>
<li><strong>distCoeffs</strong> &#8211; Input vector of distortion coefficients  <img class="math" src="../../../_images/math/94288b7709d10a7ddf286e33db0074512bda0411.png" alt="(k_1, k_2, p_1, p_2[, k_3[, k_4, k_5, k_6]])"/>  of 4, 5, or 8 elements. If the vector is NULL/empty, the zero distortion coefficients are assumed.</li>
<li><strong>imageSize</strong> &#8211; Original image size.</li>
<li><strong>alpha</strong> &#8211; Free scaling parameter between 0 (when all the pixels in the undistorted image are valid) and 1 (when all the source image pixels are retained in the undistorted image). See  <a class="reference internal" href="#void stereoRectify(InputArray cameraMatrix1, InputArray distCoeffs1, InputArray cameraMatrix2, InputArray distCoeffs2, Size imageSize, InputArray R, InputArray T, OutputArray R1, OutputArray R2, OutputArray P1, OutputArray P2, OutputArray Q, int flags, double alpha, Size newImageSize, Rect* validPixROI1, Rect* validPixROI2)" title="void stereoRectify(InputArray cameraMatrix1, InputArray distCoeffs1, InputArray cameraMatrix2, InputArray distCoeffs2, Size imageSize, InputArray R, InputArray T, OutputArray R1, OutputArray R2, OutputArray P1, OutputArray P2, OutputArray Q, int flags, double alpha, Size newImageSize, Rect* validPixROI1, Rect* validPixROI2)"><code class="xref ocv ocv-func docutils literal"><span class="pre">stereoRectify()</span></code></a> for details.</li>
<li><strong>new_camera_matrix</strong> &#8211; Output new camera matrix.</li>
<li><strong>new_imag_size</strong> &#8211; Image size after rectification. By default,it is set to  <code class="docutils literal"><span class="pre">imageSize</span></code> .</li>
<li><strong>validPixROI</strong> &#8211; Optional output rectangle that outlines all-good-pixels region in the undistorted image. See  <code class="docutils literal"><span class="pre">roi1,</span> <span class="pre">roi2</span></code>  description in  <a class="reference internal" href="#void stereoRectify(InputArray cameraMatrix1, InputArray distCoeffs1, InputArray cameraMatrix2, InputArray distCoeffs2, Size imageSize, InputArray R, InputArray T, OutputArray R1, OutputArray R2, OutputArray P1, OutputArray P2, OutputArray Q, int flags, double alpha, Size newImageSize, Rect* validPixROI1, Rect* validPixROI2)" title="void stereoRectify(InputArray cameraMatrix1, InputArray distCoeffs1, InputArray cameraMatrix2, InputArray distCoeffs2, Size imageSize, InputArray R, InputArray T, OutputArray R1, OutputArray R2, OutputArray P1, OutputArray P2, OutputArray Q, int flags, double alpha, Size newImageSize, Rect* validPixROI1, Rect* validPixROI2)"><code class="xref ocv ocv-func docutils literal"><span class="pre">stereoRectify()</span></code></a> .</li>
<li><strong>centerPrincipalPoint</strong> &#8211; Optional flag that indicates whether in the new camera matrix the principal point should be at the image center or not. By default, the principal point is chosen to best fit a subset of the source image (determined by <code class="docutils literal"><span class="pre">alpha</span></code>) to the corrected image.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<p>The function computes and returns
the optimal new camera matrix based on the free scaling parameter. By varying  this parameter, you may retrieve only sensible pixels <code class="docutils literal"><span class="pre">alpha=0</span></code> , keep all the original image pixels if there is valuable information in the corners <code class="docutils literal"><span class="pre">alpha=1</span></code> , or get something in between. When <code class="docutils literal"><span class="pre">alpha&gt;0</span></code> , the undistortion result is likely to have some black pixels corresponding to &#8220;virtual&#8221; pixels outside of the captured distorted image. The original camera matrix, distortion coefficients, the computed new camera matrix, and <code class="docutils literal"><span class="pre">newImageSize</span></code> should be passed to
<a class="reference internal" href="../../imgproc/doc/geometric_transformations.html#void initUndistortRectifyMap(InputArray cameraMatrix, InputArray distCoeffs, InputArray R, InputArray newCameraMatrix, Size size, int m1type, OutputArray map1, OutputArray map2)" title="void initUndistortRectifyMap(InputArray cameraMatrix, InputArray distCoeffs, InputArray R, InputArray newCameraMatrix, Size size, int m1type, OutputArray map1, OutputArray map2)"><code class="xref ocv ocv-func docutils literal"><span class="pre">initUndistortRectifyMap()</span></code></a> to produce the maps for
<a class="reference internal" href="../../imgproc/doc/geometric_transformations.html#void remap(InputArray src, OutputArray dst, InputArray map1, InputArray map2, int interpolation, int borderMode, const Scalar&amp; borderValue)" title="void remap(InputArray src, OutputArray dst, InputArray map1, InputArray map2, int interpolation, int borderMode, const Scalar&amp; borderValue)"><code class="xref ocv ocv-func docutils literal"><span class="pre">remap()</span></code></a> .</p>
</div>
<div class="section" id="initcameramatrix2d">
<h2>initCameraMatrix2D<a class="headerlink" href="#initcameramatrix2d" title="Permalink to this headline">¶</a></h2>
<p>Finds an initial camera matrix from 3D-2D point correspondences.</p>
<dl class="function">
<dt id="Mat initCameraMatrix2D(InputArrayOfArrays objectPoints, InputArrayOfArrays imagePoints, Size imageSize, double aspectRatio)">
<strong>C++:</strong><code class="descname"> </code>Mat <code class="descname">initCameraMatrix2D</code><span class="sig-paren">(</span>InputArrayOfArrays <strong>objectPoints</strong>, InputArrayOfArrays <strong>imagePoints</strong>, Size <strong>imageSize</strong>, double <strong>aspectRatio</strong>=1.<span class="sig-paren">)</span><a class="headerlink" href="#Mat initCameraMatrix2D(InputArrayOfArrays objectPoints, InputArrayOfArrays imagePoints, Size imageSize, double aspectRatio)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="pyfunction">
<dt id="cv2.initCameraMatrix2D">
<strong>Python:</strong><code class="descname"> </code><code class="descclassname">cv2.</code><code class="descname">initCameraMatrix2D</code><span class="sig-paren">(</span>objectPoints, imagePoints, imageSize<span class="optional">[</span>, aspectRatio<span class="optional">]</span><span class="sig-paren">)</span> &rarr; retval<a class="headerlink" href="#cv2.initCameraMatrix2D" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="cfunction">
<dt id="void cvInitIntrinsicParams2D(const CvMat* object_points, const CvMat* image_points, const CvMat* npoints, CvSize image_size, CvMat* camera_matrix, double aspect_ratio)">
<strong>C:</strong><code class="descname"> </code>void <code class="descname">cvInitIntrinsicParams2D</code><span class="sig-paren">(</span>const CvMat* <strong>object_points</strong>, const CvMat* <strong>image_points</strong>, const CvMat* <strong>npoints</strong>, CvSize <strong>image_size</strong>, CvMat* <strong>camera_matrix</strong>, double <strong>aspect_ratio</strong>=1. <span class="sig-paren">)</span><a class="headerlink" href="#void cvInitIntrinsicParams2D(const CvMat* object_points, const CvMat* image_points, const CvMat* npoints, CvSize image_size, CvMat* camera_matrix, double aspect_ratio)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="pyoldfunction">
<dt id="cv.InitIntrinsicParams2D">
<strong>Python:</strong><code class="descname"> </code><code class="descclassname">cv.</code><code class="descname">InitIntrinsicParams2D</code><span class="sig-paren">(</span>objectPoints, imagePoints, npoints, imageSize, cameraMatrix, aspectRatio=1.<span class="sig-paren">)</span> &rarr; None<a class="headerlink" href="#cv.InitIntrinsicParams2D" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>objectPoints</strong> &#8211; Vector of vectors of the calibration pattern points in the calibration pattern coordinate space. In the old interface all the per-view vectors are concatenated. See <a class="reference internal" href="#double calibrateCamera(InputArrayOfArrays objectPoints, InputArrayOfArrays imagePoints, Size imageSize, InputOutputArray cameraMatrix, InputOutputArray distCoeffs, OutputArrayOfArrays rvecs, OutputArrayOfArrays tvecs, int flags, TermCriteria criteria)" title="double calibrateCamera(InputArrayOfArrays objectPoints, InputArrayOfArrays imagePoints, Size imageSize, InputOutputArray cameraMatrix, InputOutputArray distCoeffs, OutputArrayOfArrays rvecs, OutputArrayOfArrays tvecs, int flags, TermCriteria criteria)"><code class="xref ocv ocv-func docutils literal"><span class="pre">calibrateCamera()</span></code></a> for details.</li>
<li><strong>imagePoints</strong> &#8211; Vector of vectors of the projections of the calibration pattern points. In the old interface all the per-view vectors are concatenated.</li>
<li><strong>npoints</strong> &#8211; The integer vector of point counters for each view.</li>
<li><strong>imageSize</strong> &#8211; Image size in pixels used to initialize the principal point.</li>
<li><strong>aspectRatio</strong> &#8211; If it is zero or negative, both  <img class="math" src="../../../_images/math/90cbff5be10b7d5d6a3ec6cabfe05e306e99ac1c.png" alt="f_x"/>  and  <img class="math" src="../../../_images/math/0a9dfcd96704b05afe921dcabeefcd77bfdbd863.png" alt="f_y"/>  are estimated independently. Otherwise,  <img class="math" src="../../../_images/math/dff19dff36490e0fae71c9f7e314cf25566133c3.png" alt="f_x = f_y * \texttt{aspectRatio}"/> .</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<p>The function estimates and returns an initial camera matrix for the camera calibration process.
Currently, the function only supports planar calibration patterns, which are patterns where each object point has z-coordinate =0.</p>
</div>
<div class="section" id="matmulderiv">
<h2>matMulDeriv<a class="headerlink" href="#matmulderiv" title="Permalink to this headline">¶</a></h2>
<p>Computes partial derivatives of the matrix product for each multiplied matrix.</p>
<dl class="function">
<dt id="void matMulDeriv(InputArray A, InputArray B, OutputArray dABdA, OutputArray dABdB)">
<strong>C++:</strong><code class="descname"> </code>void <code class="descname">matMulDeriv</code><span class="sig-paren">(</span>InputArray <strong>A</strong>, InputArray <strong>B</strong>, OutputArray <strong>dABdA</strong>, OutputArray <strong>dABdB</strong><span class="sig-paren">)</span><a class="headerlink" href="#void matMulDeriv(InputArray A, InputArray B, OutputArray dABdA, OutputArray dABdB)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="pyfunction">
<dt id="cv2.matMulDeriv">
<strong>Python:</strong><code class="descname"> </code><code class="descclassname">cv2.</code><code class="descname">matMulDeriv</code><span class="sig-paren">(</span>A, B<span class="optional">[</span>, dABdA<span class="optional">[</span>, dABdB<span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span> &rarr; dABdA, dABdB<a class="headerlink" href="#cv2.matMulDeriv" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>A</strong> &#8211; First multiplied matrix.</li>
<li><strong>B</strong> &#8211; Second multiplied matrix.</li>
<li><strong>dABdA</strong> &#8211; First output derivative matrix  <code class="docutils literal"><span class="pre">d(A*B)/dA</span></code>  of size  <img class="math" src="../../../_images/math/1b157548e159ea2c237b2e28995436bbeb2c684d.png" alt="\texttt{A.rows*B.cols} \times {A.rows*A.cols}"/> .</li>
<li><strong>dABdB</strong> &#8211; Second output derivative matrix  <code class="docutils literal"><span class="pre">d(A*B)/dB</span></code>  of size  <img class="math" src="../../../_images/math/a6557e02a8ab9c35304a16d62b3dfc51d0719558.png" alt="\texttt{A.rows*B.cols} \times {B.rows*B.cols}"/> .</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<p>The function computes partial derivatives of the elements of the matrix product
<img class="math" src="../../../_images/math/79858b82de9a20772b57fde07d6db14a3ab9b5a4.png" alt="A*B"/> with regard to the elements of each of the two input matrices. The function is used to compute the Jacobian matrices in
<a class="reference internal" href="#double stereoCalibrate(InputArrayOfArrays objectPoints, InputArrayOfArrays imagePoints1, InputArrayOfArrays imagePoints2, InputOutputArray cameraMatrix1, InputOutputArray distCoeffs1, InputOutputArray cameraMatrix2, InputOutputArray distCoeffs2, Size imageSize, OutputArray R, OutputArray T, OutputArray E, OutputArray F, TermCriteria criteria, int flags)" title="double stereoCalibrate(InputArrayOfArrays objectPoints, InputArrayOfArrays imagePoints1, InputArrayOfArrays imagePoints2, InputOutputArray cameraMatrix1, InputOutputArray distCoeffs1, InputOutputArray cameraMatrix2, InputOutputArray distCoeffs2, Size imageSize, OutputArray R, OutputArray T, OutputArray E, OutputArray F, TermCriteria criteria, int flags)"><code class="xref ocv ocv-func docutils literal"><span class="pre">stereoCalibrate()</span></code></a>  but can also be used in any other similar optimization function.</p>
</div>
<div class="section" id="projectpoints">
<h2>projectPoints<a class="headerlink" href="#projectpoints" title="Permalink to this headline">¶</a></h2>
<p>Projects 3D points to an image plane.</p>
<dl class="function">
<dt id="void projectPoints(InputArray objectPoints, InputArray rvec, InputArray tvec, InputArray cameraMatrix, InputArray distCoeffs, OutputArray imagePoints, OutputArray jacobian, double aspectRatio)">
<strong>C++:</strong><code class="descname"> </code>void <code class="descname">projectPoints</code><span class="sig-paren">(</span>InputArray <strong>objectPoints</strong>, InputArray <strong>rvec</strong>, InputArray <strong>tvec</strong>, InputArray <strong>cameraMatrix</strong>, InputArray <strong>distCoeffs</strong>, OutputArray <strong>imagePoints</strong>, OutputArray <strong>jacobian</strong>=noArray(), double <strong>aspectRatio</strong>=0 <span class="sig-paren">)</span><a class="headerlink" href="#void projectPoints(InputArray objectPoints, InputArray rvec, InputArray tvec, InputArray cameraMatrix, InputArray distCoeffs, OutputArray imagePoints, OutputArray jacobian, double aspectRatio)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="pyfunction">
<dt id="cv2.projectPoints">
<strong>Python:</strong><code class="descname"> </code><code class="descclassname">cv2.</code><code class="descname">projectPoints</code><span class="sig-paren">(</span>objectPoints, rvec, tvec, cameraMatrix, distCoeffs<span class="optional">[</span>, imagePoints<span class="optional">[</span>, jacobian<span class="optional">[</span>, aspectRatio<span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span> &rarr; imagePoints, jacobian<a class="headerlink" href="#cv2.projectPoints" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="cfunction">
<dt id="void cvProjectPoints2(const CvMat* object_points, const CvMat* rotation_vector, const CvMat* translation_vector, const CvMat* camera_matrix, const CvMat* distortion_coeffs, CvMat* image_points, CvMat* dpdrot, CvMat* dpdt, CvMat* dpdf, CvMat* dpdc, CvMat* dpddist, double aspect_ratio)">
<strong>C:</strong><code class="descname"> </code>void <code class="descname">cvProjectPoints2</code><span class="sig-paren">(</span>const CvMat* <strong>object_points</strong>, const CvMat* <strong>rotation_vector</strong>, const CvMat* <strong>translation_vector</strong>, const CvMat* <strong>camera_matrix</strong>, const CvMat* <strong>distortion_coeffs</strong>, CvMat* <strong>image_points</strong>, CvMat* <strong>dpdrot</strong>=NULL, CvMat* <strong>dpdt</strong>=NULL, CvMat* <strong>dpdf</strong>=NULL, CvMat* <strong>dpdc</strong>=NULL, CvMat* <strong>dpddist</strong>=NULL, double <strong>aspect_ratio</strong>=0 <span class="sig-paren">)</span><a class="headerlink" href="#void cvProjectPoints2(const CvMat* object_points, const CvMat* rotation_vector, const CvMat* translation_vector, const CvMat* camera_matrix, const CvMat* distortion_coeffs, CvMat* image_points, CvMat* dpdrot, CvMat* dpdt, CvMat* dpdf, CvMat* dpdc, CvMat* dpddist, double aspect_ratio)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="pyoldfunction">
<dt id="cv.ProjectPoints2">
<strong>Python:</strong><code class="descname"> </code><code class="descclassname">cv.</code><code class="descname">ProjectPoints2</code><span class="sig-paren">(</span>objectPoints, rvec, tvec, cameraMatrix, distCoeffs, imagePoints, dpdrot=None, dpdt=None, dpdf=None, dpdc=None, dpddist=None<span class="sig-paren">)</span> &rarr; None<a class="headerlink" href="#cv.ProjectPoints2" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>objectPoints</strong> &#8211; Array of object points, 3xN/Nx3 1-channel or 1xN/Nx1 3-channel  (or  <code class="docutils literal"><span class="pre">vector&lt;Point3f&gt;</span></code> ), where N is the number of points in the view.</li>
<li><strong>rvec</strong> &#8211; Rotation vector. See  <a class="reference internal" href="#void Rodrigues(InputArray src, OutputArray dst, OutputArray jacobian)" title="void Rodrigues(InputArray src, OutputArray dst, OutputArray jacobian)"><code class="xref ocv ocv-func docutils literal"><span class="pre">Rodrigues()</span></code></a> for details.</li>
<li><strong>tvec</strong> &#8211; Translation vector.</li>
<li><strong>cameraMatrix</strong> &#8211; Camera matrix  <img class="math" src="../../../_images/math/ebc0f046fc89c57ff4cca2849a6638ef8878d6cc.png" alt="A = \vecthreethree{f_x}{0}{c_x}{0}{f_y}{c_y}{0}{0}{_1}"/> .</li>
<li><strong>distCoeffs</strong> &#8211; Input vector of distortion coefficients  <img class="math" src="../../../_images/math/94288b7709d10a7ddf286e33db0074512bda0411.png" alt="(k_1, k_2, p_1, p_2[, k_3[, k_4, k_5, k_6]])"/>  of 4, 5, or 8 elements. If the vector is NULL/empty, the zero distortion coefficients are assumed.</li>
<li><strong>imagePoints</strong> &#8211; Output array of image points, 2xN/Nx2 1-channel or 1xN/Nx1 2-channel, or  <code class="docutils literal"><span class="pre">vector&lt;Point2f&gt;</span></code> .</li>
<li><strong>jacobian</strong> &#8211; Optional output 2Nx(10+&lt;numDistCoeffs&gt;) jacobian matrix of derivatives of image points with respect to components of the rotation vector, translation vector, focal lengths, coordinates of the principal point and the distortion coefficients. In the old interface different components of the jacobian are returned via different output parameters.</li>
<li><strong>aspectRatio</strong> &#8211; Optional &#8220;fixed aspect ratio&#8221; parameter. If the parameter is not 0, the function assumes that the aspect ratio (<em>fx/fy</em>) is fixed and correspondingly adjusts the jacobian matrix.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<p>The function computes projections of 3D
points to the image plane given intrinsic and extrinsic camera
parameters. Optionally, the function computes Jacobians - matrices
of partial derivatives of image points coordinates (as functions of all the
input parameters) with respect to the particular parameters, intrinsic and/or
extrinsic. The Jacobians are used during the global optimization
in
<a class="reference internal" href="#double calibrateCamera(InputArrayOfArrays objectPoints, InputArrayOfArrays imagePoints, Size imageSize, InputOutputArray cameraMatrix, InputOutputArray distCoeffs, OutputArrayOfArrays rvecs, OutputArrayOfArrays tvecs, int flags, TermCriteria criteria)" title="double calibrateCamera(InputArrayOfArrays objectPoints, InputArrayOfArrays imagePoints, Size imageSize, InputOutputArray cameraMatrix, InputOutputArray distCoeffs, OutputArrayOfArrays rvecs, OutputArrayOfArrays tvecs, int flags, TermCriteria criteria)"><code class="xref ocv ocv-func docutils literal"><span class="pre">calibrateCamera()</span></code></a>,
<a class="reference internal" href="#bool solvePnP(InputArray objectPoints, InputArray imagePoints, InputArray cameraMatrix, InputArray distCoeffs, OutputArray rvec, OutputArray tvec, bool useExtrinsicGuess, int flags)" title="bool solvePnP(InputArray objectPoints, InputArray imagePoints, InputArray cameraMatrix, InputArray distCoeffs, OutputArray rvec, OutputArray tvec, bool useExtrinsicGuess, int flags)"><code class="xref ocv ocv-func docutils literal"><span class="pre">solvePnP()</span></code></a>, and
<a class="reference internal" href="#double stereoCalibrate(InputArrayOfArrays objectPoints, InputArrayOfArrays imagePoints1, InputArrayOfArrays imagePoints2, InputOutputArray cameraMatrix1, InputOutputArray distCoeffs1, InputOutputArray cameraMatrix2, InputOutputArray distCoeffs2, Size imageSize, OutputArray R, OutputArray T, OutputArray E, OutputArray F, TermCriteria criteria, int flags)" title="double stereoCalibrate(InputArrayOfArrays objectPoints, InputArrayOfArrays imagePoints1, InputArrayOfArrays imagePoints2, InputOutputArray cameraMatrix1, InputOutputArray distCoeffs1, InputOutputArray cameraMatrix2, InputOutputArray distCoeffs2, Size imageSize, OutputArray R, OutputArray T, OutputArray E, OutputArray F, TermCriteria criteria, int flags)"><code class="xref ocv ocv-func docutils literal"><span class="pre">stereoCalibrate()</span></code></a> . The
function itself can also be used to compute a re-projection error given the
current intrinsic and extrinsic parameters.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">By setting <code class="docutils literal"><span class="pre">rvec=tvec=(0,0,0)</span></code>  or by setting <code class="docutils literal"><span class="pre">cameraMatrix</span></code> to a 3x3 identity matrix, or by passing zero distortion coefficients, you can get various useful partial cases of the function. This means that you can compute the distorted coordinates for a sparse set of points or apply a perspective transformation (and also compute the derivatives) in the ideal zero-distortion setup.</p>
</div>
</div>
<div class="section" id="reprojectimageto3d">
<h2>reprojectImageTo3D<a class="headerlink" href="#reprojectimageto3d" title="Permalink to this headline">¶</a></h2>
<p>Reprojects a disparity image to 3D space.</p>
<dl class="function">
<dt id="void reprojectImageTo3D(InputArray disparity, OutputArray _3dImage, InputArray Q, bool handleMissingValues, int ddepth)">
<strong>C++:</strong><code class="descname"> </code>void <code class="descname">reprojectImageTo3D</code><span class="sig-paren">(</span>InputArray <strong>disparity</strong>, OutputArray <strong>_3dImage</strong>, InputArray <strong>Q</strong>, bool <strong>handleMissingValues</strong>=false, int <strong>ddepth</strong>=-1 <span class="sig-paren">)</span><a class="headerlink" href="#void reprojectImageTo3D(InputArray disparity, OutputArray _3dImage, InputArray Q, bool handleMissingValues, int ddepth)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="pyfunction">
<dt id="cv2.reprojectImageTo3D">
<strong>Python:</strong><code class="descname"> </code><code class="descclassname">cv2.</code><code class="descname">reprojectImageTo3D</code><span class="sig-paren">(</span>disparity, Q<span class="optional">[</span>, _3dImage<span class="optional">[</span>, handleMissingValues<span class="optional">[</span>, ddepth<span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span> &rarr; _3dImage<a class="headerlink" href="#cv2.reprojectImageTo3D" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="cfunction">
<dt id="void cvReprojectImageTo3D(const CvArr* disparityImage, CvArr* _3dImage, const CvMat* Q, int handleMissingValues)">
<strong>C:</strong><code class="descname"> </code>void <code class="descname">cvReprojectImageTo3D</code><span class="sig-paren">(</span>const CvArr* <strong>disparityImage</strong>, CvArr* <strong>_3dImage</strong>, const CvMat* <strong>Q</strong>, int <strong>handleMissingValues</strong>=0 <span class="sig-paren">)</span><a class="headerlink" href="#void cvReprojectImageTo3D(const CvArr* disparityImage, CvArr* _3dImage, const CvMat* Q, int handleMissingValues)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="pyoldfunction">
<dt id="cv.ReprojectImageTo3D">
<strong>Python:</strong><code class="descname"> </code><code class="descclassname">cv.</code><code class="descname">ReprojectImageTo3D</code><span class="sig-paren">(</span>disparity, _3dImage, Q, handleMissingValues=0<span class="sig-paren">)</span> &rarr; None<a class="headerlink" href="#cv.ReprojectImageTo3D" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>disparity</strong> &#8211; Input single-channel 8-bit unsigned, 16-bit signed, 32-bit signed or 32-bit floating-point disparity image.</li>
<li><strong>_3dImage</strong> &#8211; Output 3-channel floating-point image of the same size as  <code class="docutils literal"><span class="pre">disparity</span></code> . Each element of  <code class="docutils literal"><span class="pre">_3dImage(x,y)</span></code>  contains 3D coordinates of the point  <code class="docutils literal"><span class="pre">(x,y)</span></code>  computed from the disparity map.</li>
<li><strong>Q</strong> &#8211; <img class="math" src="../../../_images/math/96754e424b2a8b15b1a9dba38a6ffde5cb0e50a8.png" alt="4 \times 4"/>  perspective transformation matrix that can be obtained with  <a class="reference internal" href="#void stereoRectify(InputArray cameraMatrix1, InputArray distCoeffs1, InputArray cameraMatrix2, InputArray distCoeffs2, Size imageSize, InputArray R, InputArray T, OutputArray R1, OutputArray R2, OutputArray P1, OutputArray P2, OutputArray Q, int flags, double alpha, Size newImageSize, Rect* validPixROI1, Rect* validPixROI2)" title="void stereoRectify(InputArray cameraMatrix1, InputArray distCoeffs1, InputArray cameraMatrix2, InputArray distCoeffs2, Size imageSize, InputArray R, InputArray T, OutputArray R1, OutputArray R2, OutputArray P1, OutputArray P2, OutputArray Q, int flags, double alpha, Size newImageSize, Rect* validPixROI1, Rect* validPixROI2)"><code class="xref ocv ocv-func docutils literal"><span class="pre">stereoRectify()</span></code></a>.</li>
<li><strong>handleMissingValues</strong> &#8211; Indicates, whether the function should handle missing values (i.e. points where the disparity was not computed). If <code class="docutils literal"><span class="pre">handleMissingValues=true</span></code>, then pixels with the minimal disparity that corresponds to the outliers (see  <a class="reference internal" href="#void StereoBM::operator()(InputArray left, InputArray right, OutputArray disparity, int disptype)" title="void StereoBM::operator()(InputArray left, InputArray right, OutputArray disparity, int disptype)"><code class="xref ocv ocv-funcx docutils literal"><span class="pre">StereoBM::operator()</span></code></a> ) are transformed to 3D points with a very large Z value (currently set to 10000).</li>
<li><strong>ddepth</strong> &#8211; The optional output array depth. If it is <code class="docutils literal"><span class="pre">-1</span></code>, the output image will have <code class="docutils literal"><span class="pre">CV_32F</span></code> depth. <code class="docutils literal"><span class="pre">ddepth</span></code> can also be set to <code class="docutils literal"><span class="pre">CV_16S</span></code>, <code class="docutils literal"><span class="pre">CV_32S</span></code> or <code class="docutils literal"><span class="pre">CV_32F</span></code>.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<p>The function transforms a single-channel disparity map to a 3-channel image representing a 3D surface. That is, for each pixel <code class="docutils literal"><span class="pre">(x,y)</span></code> andthe  corresponding disparity <code class="docutils literal"><span class="pre">d=disparity(x,y)</span></code> , it computes:</p>
<div class="math">
<p><img src="../../../_images/math/febeb096c7cbbd6472eaad73947edddd8483708a.png" alt="\begin{array}{l} [X \; Y \; Z \; W]^T =  \texttt{Q} *[x \; y \; \texttt{disparity} (x,y) \; 1]^T  \\ \texttt{\_3dImage} (x,y) = (X/W, \; Y/W, \; Z/W) \end{array}"/></p>
</div><p>The matrix <code class="docutils literal"><span class="pre">Q</span></code> can be an arbitrary
<img class="math" src="../../../_images/math/96754e424b2a8b15b1a9dba38a6ffde5cb0e50a8.png" alt="4 \times 4"/> matrix (for example, the one computed by
<a class="reference internal" href="#void stereoRectify(InputArray cameraMatrix1, InputArray distCoeffs1, InputArray cameraMatrix2, InputArray distCoeffs2, Size imageSize, InputArray R, InputArray T, OutputArray R1, OutputArray R2, OutputArray P1, OutputArray P2, OutputArray Q, int flags, double alpha, Size newImageSize, Rect* validPixROI1, Rect* validPixROI2)" title="void stereoRectify(InputArray cameraMatrix1, InputArray distCoeffs1, InputArray cameraMatrix2, InputArray distCoeffs2, Size imageSize, InputArray R, InputArray T, OutputArray R1, OutputArray R2, OutputArray P1, OutputArray P2, OutputArray Q, int flags, double alpha, Size newImageSize, Rect* validPixROI1, Rect* validPixROI2)"><code class="xref ocv ocv-func docutils literal"><span class="pre">stereoRectify()</span></code></a>). To reproject a sparse set of points {(x,y,d),...} to 3D space, use
<a class="reference internal" href="../../core/doc/operations_on_arrays.html#void perspectiveTransform(InputArray src, OutputArray dst, InputArray m)" title="void perspectiveTransform(InputArray src, OutputArray dst, InputArray m)"><code class="xref ocv ocv-func docutils literal"><span class="pre">perspectiveTransform()</span></code></a> .</p>
</div>
<div class="section" id="rqdecomp3x3">
<h2>RQDecomp3x3<a class="headerlink" href="#rqdecomp3x3" title="Permalink to this headline">¶</a></h2>
<p>Computes an RQ decomposition of 3x3 matrices.</p>
<dl class="function">
<dt id="Vec3d RQDecomp3x3(InputArray src, OutputArray mtxR, OutputArray mtxQ, OutputArray Qx, OutputArray Qy, OutputArray Qz)">
<strong>C++:</strong><code class="descname"> </code>Vec3d <code class="descname">RQDecomp3x3</code><span class="sig-paren">(</span>InputArray <strong>src</strong>, OutputArray <strong>mtxR</strong>, OutputArray <strong>mtxQ</strong>, OutputArray <strong>Qx</strong>=noArray(), OutputArray <strong>Qy</strong>=noArray(), OutputArray <strong>Qz</strong>=noArray() <span class="sig-paren">)</span><a class="headerlink" href="#Vec3d RQDecomp3x3(InputArray src, OutputArray mtxR, OutputArray mtxQ, OutputArray Qx, OutputArray Qy, OutputArray Qz)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="pyfunction">
<dt id="cv2.RQDecomp3x3">
<strong>Python:</strong><code class="descname"> </code><code class="descclassname">cv2.</code><code class="descname">RQDecomp3x3</code><span class="sig-paren">(</span>src<span class="optional">[</span>, mtxR<span class="optional">[</span>, mtxQ<span class="optional">[</span>, Qx<span class="optional">[</span>, Qy<span class="optional">[</span>, Qz<span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span> &rarr; retval, mtxR, mtxQ, Qx, Qy, Qz<a class="headerlink" href="#cv2.RQDecomp3x3" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="cfunction">
<dt id="void cvRQDecomp3x3(const CvMat * matrixM, CvMat * matrixR, CvMat * matrixQ, CvMat * matrixQx, CvMat * matrixQy, CvMat * matrixQz, CvPoint3D64f * eulerAngles)">
<strong>C:</strong><code class="descname"> </code>void <code class="descname">cvRQDecomp3x3</code><span class="sig-paren">(</span>const CvMat* <strong>matrixM</strong>, CvMat* <strong>matrixR</strong>, CvMat* <strong>matrixQ</strong>, CvMat* <strong>matrixQx</strong>=NULL, CvMat* <strong>matrixQy</strong>=NULL, CvMat* <strong>matrixQz</strong>=NULL, CvPoint3D64f* <strong>eulerAngles</strong>=NULL <span class="sig-paren">)</span><a class="headerlink" href="#void cvRQDecomp3x3(const CvMat * matrixM, CvMat * matrixR, CvMat * matrixQ, CvMat * matrixQx, CvMat * matrixQy, CvMat * matrixQz, CvPoint3D64f * eulerAngles)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="pyoldfunction">
<dt id="cv.RQDecomp3x3">
<strong>Python:</strong><code class="descname"> </code><code class="descclassname">cv.</code><code class="descname">RQDecomp3x3</code><span class="sig-paren">(</span>M, R, Q, Qx=None, Qy=None, Qz=None<span class="sig-paren">)</span> &rarr; eulerAngles<a class="headerlink" href="#cv.RQDecomp3x3" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>src</strong> &#8211; 3x3 input matrix.</li>
<li><strong>mtxR</strong> &#8211; Output 3x3 upper-triangular matrix.</li>
<li><strong>mtxQ</strong> &#8211; Output 3x3 orthogonal matrix.</li>
<li><strong>Qx</strong> &#8211; Optional output 3x3 rotation matrix around x-axis.</li>
<li><strong>Qy</strong> &#8211; Optional output 3x3 rotation matrix around y-axis.</li>
<li><strong>Qz</strong> &#8211; Optional output 3x3 rotation matrix around z-axis.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<p>The function computes a RQ decomposition using the given rotations. This function is used in
<a class="reference internal" href="#void decomposeProjectionMatrix(InputArray projMatrix, OutputArray cameraMatrix, OutputArray rotMatrix, OutputArray transVect, OutputArray rotMatrixX, OutputArray rotMatrixY, OutputArray rotMatrixZ, OutputArray eulerAngles)" title="void decomposeProjectionMatrix(InputArray projMatrix, OutputArray cameraMatrix, OutputArray rotMatrix, OutputArray transVect, OutputArray rotMatrixX, OutputArray rotMatrixY, OutputArray rotMatrixZ, OutputArray eulerAngles)"><code class="xref ocv ocv-func docutils literal"><span class="pre">decomposeProjectionMatrix()</span></code></a> to decompose the left 3x3 submatrix of a projection matrix into a camera and a rotation matrix.</p>
<p>It optionally returns three rotation matrices, one for each axis, and the three Euler angles in degrees (as the return value) that could be used in OpenGL. Note, there is always more than one sequence of rotations about the three principle axes that results in the same orientation of an object, eg. see <a class="reference internal" href="#slabaugh" id="id4">[Slabaugh]</a>. Returned tree rotation matrices and corresponding three Euler angules are only one of the possible solutions.</p>
</div>
<div class="section" id="rodrigues">
<h2>Rodrigues<a class="headerlink" href="#rodrigues" title="Permalink to this headline">¶</a></h2>
<p>Converts a rotation matrix to a rotation vector or vice versa.</p>
<dl class="function">
<dt id="void Rodrigues(InputArray src, OutputArray dst, OutputArray jacobian)">
<strong>C++:</strong><code class="descname"> </code>void <code class="descname">Rodrigues</code><span class="sig-paren">(</span>InputArray <strong>src</strong>, OutputArray <strong>dst</strong>, OutputArray <strong>jacobian</strong>=noArray()<span class="sig-paren">)</span><a class="headerlink" href="#void Rodrigues(InputArray src, OutputArray dst, OutputArray jacobian)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="pyfunction">
<dt id="cv2.Rodrigues">
<strong>Python:</strong><code class="descname"> </code><code class="descclassname">cv2.</code><code class="descname">Rodrigues</code><span class="sig-paren">(</span>src<span class="optional">[</span>, dst<span class="optional">[</span>, jacobian<span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span> &rarr; dst, jacobian<a class="headerlink" href="#cv2.Rodrigues" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="cfunction">
<dt id="int cvRodrigues2(const CvMat* src, CvMat* dst, CvMat* jacobian)">
<strong>C:</strong><code class="descname"> </code>int <code class="descname">cvRodrigues2</code><span class="sig-paren">(</span>const CvMat* <strong>src</strong>, CvMat* <strong>dst</strong>, CvMat* <strong>jacobian</strong>=0 <span class="sig-paren">)</span><a class="headerlink" href="#int cvRodrigues2(const CvMat* src, CvMat* dst, CvMat* jacobian)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="pyoldfunction">
<dt id="cv.Rodrigues2">
<strong>Python:</strong><code class="descname"> </code><code class="descclassname">cv.</code><code class="descname">Rodrigues2</code><span class="sig-paren">(</span>src, dst, jacobian=0<span class="sig-paren">)</span> &rarr; None<a class="headerlink" href="#cv.Rodrigues2" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>src</strong> &#8211; Input rotation vector (3x1 or 1x3) or rotation matrix (3x3).</li>
<li><strong>dst</strong> &#8211; Output rotation matrix (3x3) or rotation vector (3x1 or 1x3), respectively.</li>
<li><strong>jacobian</strong> &#8211; Optional output Jacobian matrix, 3x9 or 9x3, which is a matrix of partial derivatives of the output array components with respect to the input array components.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<div class="math">
<p><img src="../../../_images/math/8bffbe8d9297cebc136dc8ead9a40cad3940a640.png" alt="\begin{array}{l} \theta \leftarrow norm(r) \\ r  \leftarrow r/ \theta \\ R =  \cos{\theta} I + (1- \cos{\theta} ) r r^T +  \sin{\theta} \vecthreethree{0}{-r_z}{r_y}{r_z}{0}{-r_x}{-r_y}{r_x}{0} \end{array}"/></p>
</div><p>Inverse transformation can be also done easily, since</p>
<div class="math">
<p><img src="../../../_images/math/6934048a1bb64f6c8a7bea580188819270ef867a.png" alt="\sin ( \theta ) \vecthreethree{0}{-r_z}{r_y}{r_z}{0}{-r_x}{-r_y}{r_x}{0} = \frac{R - R^T}{2}"/></p>
</div><p>A rotation vector is a convenient and most compact representation of a rotation matrix
(since any rotation matrix has just 3 degrees of freedom). The representation is
used in the global 3D geometry optimization procedures like
<a class="reference internal" href="#double calibrateCamera(InputArrayOfArrays objectPoints, InputArrayOfArrays imagePoints, Size imageSize, InputOutputArray cameraMatrix, InputOutputArray distCoeffs, OutputArrayOfArrays rvecs, OutputArrayOfArrays tvecs, int flags, TermCriteria criteria)" title="double calibrateCamera(InputArrayOfArrays objectPoints, InputArrayOfArrays imagePoints, Size imageSize, InputOutputArray cameraMatrix, InputOutputArray distCoeffs, OutputArrayOfArrays rvecs, OutputArrayOfArrays tvecs, int flags, TermCriteria criteria)"><code class="xref ocv ocv-func docutils literal"><span class="pre">calibrateCamera()</span></code></a>,
<a class="reference internal" href="#double stereoCalibrate(InputArrayOfArrays objectPoints, InputArrayOfArrays imagePoints1, InputArrayOfArrays imagePoints2, InputOutputArray cameraMatrix1, InputOutputArray distCoeffs1, InputOutputArray cameraMatrix2, InputOutputArray distCoeffs2, Size imageSize, OutputArray R, OutputArray T, OutputArray E, OutputArray F, TermCriteria criteria, int flags)" title="double stereoCalibrate(InputArrayOfArrays objectPoints, InputArrayOfArrays imagePoints1, InputArrayOfArrays imagePoints2, InputOutputArray cameraMatrix1, InputOutputArray distCoeffs1, InputOutputArray cameraMatrix2, InputOutputArray distCoeffs2, Size imageSize, OutputArray R, OutputArray T, OutputArray E, OutputArray F, TermCriteria criteria, int flags)"><code class="xref ocv ocv-func docutils literal"><span class="pre">stereoCalibrate()</span></code></a>, or
<a class="reference internal" href="#bool solvePnP(InputArray objectPoints, InputArray imagePoints, InputArray cameraMatrix, InputArray distCoeffs, OutputArray rvec, OutputArray tvec, bool useExtrinsicGuess, int flags)" title="bool solvePnP(InputArray objectPoints, InputArray imagePoints, InputArray cameraMatrix, InputArray distCoeffs, OutputArray rvec, OutputArray tvec, bool useExtrinsicGuess, int flags)"><code class="xref ocv ocv-func docutils literal"><span class="pre">solvePnP()</span></code></a> .</p>
</div>
<div class="section" id="stereobm">
<h2>StereoBM<a class="headerlink" href="#stereobm" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="StereoBM">
<em class="property">class </em><code class="descname">StereoBM</code><a class="headerlink" href="#StereoBM" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p>Class for computing stereo correspondence using the block matching algorithm.</p>
<div class="highlight-cpp"><div class="highlight"><pre><span class="c1">// Block matching stereo correspondence algorithm class StereoBM</span>
<span class="p">{</span>
    <span class="k">enum</span> <span class="p">{</span> <span class="n">NORMALIZED_RESPONSE</span> <span class="o">=</span> <span class="n">CV_STEREO_BM_NORMALIZED_RESPONSE</span><span class="p">,</span>
        <span class="n">BASIC_PRESET</span><span class="o">=</span><span class="n">CV_STEREO_BM_BASIC</span><span class="p">,</span>
        <span class="n">FISH_EYE_PRESET</span><span class="o">=</span><span class="n">CV_STEREO_BM_FISH_EYE</span><span class="p">,</span>
        <span class="n">NARROW_PRESET</span><span class="o">=</span><span class="n">CV_STEREO_BM_NARROW</span> <span class="p">};</span>

    <span class="n">StereoBM</span><span class="p">();</span>
    <span class="c1">// the preset is one of ..._PRESET above.</span>
    <span class="c1">// ndisparities is the size of disparity range,</span>
    <span class="c1">// in which the optimal disparity at each pixel is searched for.</span>
    <span class="c1">// SADWindowSize is the size of averaging window used to match pixel blocks</span>
    <span class="c1">//    (larger values mean better robustness to noise, but yield blurry disparity maps)</span>
    <span class="n">StereoBM</span><span class="p">(</span><span class="kt">int</span> <span class="n">preset</span><span class="p">,</span> <span class="kt">int</span> <span class="n">ndisparities</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="kt">int</span> <span class="n">SADWindowSize</span><span class="o">=</span><span class="mi">21</span><span class="p">);</span>
    <span class="c1">// separate initialization function</span>
    <span class="kt">void</span> <span class="nf">init</span><span class="p">(</span><span class="kt">int</span> <span class="n">preset</span><span class="p">,</span> <span class="kt">int</span> <span class="n">ndisparities</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="kt">int</span> <span class="n">SADWindowSize</span><span class="o">=</span><span class="mi">21</span><span class="p">);</span>
    <span class="c1">// computes the disparity for the two rectified 8-bit single-channel images.</span>
    <span class="c1">// the disparity will be 16-bit signed (fixed-point) or 32-bit floating-point image of the same size as left.</span>
    <span class="kt">void</span> <span class="nf">operator</span><span class="p">()(</span> <span class="n">InputArray</span> <span class="n">left</span><span class="p">,</span> <span class="n">InputArray</span> <span class="n">right</span><span class="p">,</span> <span class="n">OutputArray</span> <span class="n">disparity</span><span class="p">,</span> <span class="kt">int</span> <span class="n">disptype</span><span class="o">=</span><span class="n">CV_16S</span> <span class="p">);</span>

    <span class="n">Ptr</span><span class="o">&lt;</span><span class="n">CvStereoBMState</span><span class="o">&gt;</span> <span class="n">state</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
<p>The class is a C++ wrapper for the associated functions. In particular, <a class="reference internal" href="#void StereoBM::operator()(InputArray left, InputArray right, OutputArray disparity, int disptype)" title="void StereoBM::operator()(InputArray left, InputArray right, OutputArray disparity, int disptype)"><code class="xref ocv ocv-funcx docutils literal"><span class="pre">StereoBM::operator()</span></code></a> is the wrapper for
<a class="reference internal" href="#void cvFindStereoCorrespondenceBM(const CvArr* left, const CvArr* right, CvArr* disparity, CvStereoBMState* state)" title="void cvFindStereoCorrespondenceBM(const CvArr* left, const CvArr* right, CvArr* disparity, CvStereoBMState* state)"><code class="xref ocv ocv-cfunc docutils literal"><span class="pre">cvFindStereoCorrespondenceBM()</span></code></a>.</p>
</div>
<div class="section" id="stereobm-stereobm">
<h2>StereoBM::StereoBM<a class="headerlink" href="#stereobm-stereobm" title="Permalink to this headline">¶</a></h2>
<p>The constructors.</p>
<dl class="function">
<dt id="StereoBM::StereoBM()">
<strong>C++:</strong><code class="descname"> </code> <code class="descclassname">StereoBM::</code><code class="descname">StereoBM</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#StereoBM::StereoBM()" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="StereoBM::StereoBM(int preset, int ndisparities, int SADWindowSize)">
<strong>C++:</strong><code class="descname"> </code> <code class="descclassname">StereoBM::</code><code class="descname">StereoBM</code><span class="sig-paren">(</span>int <strong>preset</strong>, int <strong>ndisparities</strong>=0, int <strong>SADWindowSize</strong>=21<span class="sig-paren">)</span><a class="headerlink" href="#StereoBM::StereoBM(int preset, int ndisparities, int SADWindowSize)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="pyfunction">
<dt id="cv2.StereoBM">
<strong>Python:</strong><code class="descname"> </code><code class="descclassname">cv2.</code><code class="descname">StereoBM</code><span class="sig-paren">(</span><span class="optional">[</span>preset<span class="optional">[</span>, ndisparities<span class="optional">[</span>, SADWindowSize<span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span> &rarr; &lt;StereoBM object&gt;<a class="headerlink" href="#cv2.StereoBM" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="cfunction">
<dt id="CvStereoBMState* cvCreateStereoBMState(int preset, int numberOfDisparities)">
<strong>C:</strong><code class="descname"> </code>CvStereoBMState* <code class="descname">cvCreateStereoBMState</code><span class="sig-paren">(</span>int <strong>preset</strong>=CV_STEREO_BM_BASIC, int <strong>numberOfDisparities</strong>=0 <span class="sig-paren">)</span><a class="headerlink" href="#CvStereoBMState* cvCreateStereoBMState(int preset, int numberOfDisparities)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="pyoldfunction">
<dt id="cv.CreateStereoBMState">
<strong>Python:</strong><code class="descname"> </code><code class="descclassname">cv.</code><code class="descname">CreateStereoBMState</code><span class="sig-paren">(</span>preset=CV_STEREO_BM_BASIC, numberOfDisparities=0<span class="sig-paren">)</span> &rarr; CvStereoBMState<a class="headerlink" href="#cv.CreateStereoBMState" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>preset</strong> &#8211; <p>specifies the whole set of algorithm parameters, one of:</p>
<blockquote>
<div><ul>
<li>BASIC_PRESET - parameters suitable for general cameras</li>
<li>FISH_EYE_PRESET - parameters suitable for wide-angle cameras</li>
<li>NARROW_PRESET - parameters suitable for narrow-angle cameras</li>
</ul>
</div></blockquote>
<p>After constructing the class, you can override any parameters set by the preset.</p>
</li>
<li><strong>ndisparities</strong> &#8211; the disparity search range. For each pixel algorithm will find the best disparity from 0 (default minimum disparity) to <code class="docutils literal"><span class="pre">ndisparities</span></code>. The search range can then be shifted by changing the minimum disparity.</li>
<li><strong>SADWindowSize</strong> &#8211; the linear size of the blocks compared by the algorithm. The size should be odd (as the block is centered at the current pixel). Larger block size implies smoother, though less accurate disparity map. Smaller block size gives more detailed disparity map, but there is higher chance for algorithm to find a wrong correspondence.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<p>The constructors initialize <code class="docutils literal"><span class="pre">StereoBM</span></code> state. You can then call <code class="docutils literal"><span class="pre">StereoBM::operator()</span></code> to compute disparity for a specific stereo pair.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">In the C API you need to deallocate <code class="docutils literal"><span class="pre">CvStereoBM</span></code> state when it is not needed anymore using <code class="docutils literal"><span class="pre">cvReleaseStereoBMState(&amp;stereobm)</span></code>.</p>
</div>
</div>
<div class="section" id="stereobm-operator">
<h2>StereoBM::operator()<a class="headerlink" href="#stereobm-operator" title="Permalink to this headline">¶</a></h2>
<p>Computes disparity using the BM algorithm for a rectified stereo pair.</p>
<dl class="function">
<dt id="void StereoBM::operator()(InputArray left, InputArray right, OutputArray disparity, int disptype)">
<strong>C++:</strong><code class="descname"> </code>void <code class="descclassname">StereoBM::</code><code class="descname">operator()</code><span class="sig-paren">(</span>InputArray <strong>left</strong>, InputArray <strong>right</strong>, OutputArray <strong>disparity</strong>, int <strong>disptype</strong>=CV_16S <span class="sig-paren">)</span><a class="headerlink" href="#void StereoBM::operator()(InputArray left, InputArray right, OutputArray disparity, int disptype)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="pyfunction">
<dt id="cv2.StereoBM.compute">
<strong>Python:</strong><code class="descname"> </code><code class="descclassname">cv2.StereoBM.</code><code class="descname">compute</code><span class="sig-paren">(</span>left, right<span class="optional">[</span>, disparity<span class="optional">[</span>, disptype<span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span> &rarr; disparity<a class="headerlink" href="#cv2.StereoBM.compute" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="cfunction">
<dt id="void cvFindStereoCorrespondenceBM(const CvArr* left, const CvArr* right, CvArr* disparity, CvStereoBMState* state)">
<strong>C:</strong><code class="descname"> </code>void <code class="descname">cvFindStereoCorrespondenceBM</code><span class="sig-paren">(</span>const CvArr* <strong>left</strong>, const CvArr* <strong>right</strong>, CvArr* <strong>disparity</strong>, CvStereoBMState* <strong>state</strong><span class="sig-paren">)</span><a class="headerlink" href="#void cvFindStereoCorrespondenceBM(const CvArr* left, const CvArr* right, CvArr* disparity, CvStereoBMState* state)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="pyoldfunction">
<dt id="cv.FindStereoCorrespondenceBM">
<strong>Python:</strong><code class="descname"> </code><code class="descclassname">cv.</code><code class="descname">FindStereoCorrespondenceBM</code><span class="sig-paren">(</span>left, right, disparity, state<span class="sig-paren">)</span> &rarr; None<a class="headerlink" href="#cv.FindStereoCorrespondenceBM" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>left</strong> &#8211; Left 8-bit single-channel image.</li>
<li><strong>right</strong> &#8211; Right image of the same size and the same type as the left one.</li>
<li><strong>disparity</strong> &#8211; Output disparity map. It has the same size as the input images. When <code class="docutils literal"><span class="pre">disptype==CV_16S</span></code>, the map is a 16-bit signed single-channel image, containing disparity values scaled by 16. To get the true disparity values from such fixed-point representation, you will need to divide each  <code class="docutils literal"><span class="pre">disp</span></code> element by 16. If <code class="docutils literal"><span class="pre">disptype==CV_32F</span></code>, the disparity map will already contain the real disparity values on output.</li>
<li><strong>disptype</strong> &#8211; Type of the output disparity map, <code class="docutils literal"><span class="pre">CV_16S</span></code> (default) or <code class="docutils literal"><span class="pre">CV_32F</span></code>.</li>
<li><strong>state</strong> &#8211; The pre-initialized <code class="docutils literal"><span class="pre">CvStereoBMState</span></code> structure in the case of the old API.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<p>The method executes the BM algorithm on a rectified stereo pair. See the <code class="docutils literal"><span class="pre">stereo_match.cpp</span></code> OpenCV sample on how to prepare images and call the method. Note that the method is not constant, thus you should not use the same <code class="docutils literal"><span class="pre">StereoBM</span></code> instance from within different threads simultaneously. The function is parallelized with the TBB library.</p>
</div>
<div class="section" id="stereosgbm">
<h2>StereoSGBM<a class="headerlink" href="#stereosgbm" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="StereoSGBM">
<em class="property">class </em><code class="descname">StereoSGBM</code><a class="headerlink" href="#StereoSGBM" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p>Class for computing stereo correspondence using the semi-global block matching algorithm.</p>
<div class="highlight-cpp"><div class="highlight"><pre><span class="k">class</span> <span class="nc">StereoSGBM</span>
<span class="p">{</span>
    <span class="n">StereoSGBM</span><span class="p">();</span>
    <span class="n">StereoSGBM</span><span class="p">(</span><span class="kt">int</span> <span class="n">minDisparity</span><span class="p">,</span> <span class="kt">int</span> <span class="n">numDisparities</span><span class="p">,</span> <span class="kt">int</span> <span class="n">SADWindowSize</span><span class="p">,</span>
               <span class="kt">int</span> <span class="n">P1</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="kt">int</span> <span class="n">P2</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="kt">int</span> <span class="n">disp12MaxDiff</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
               <span class="kt">int</span> <span class="n">preFilterCap</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="kt">int</span> <span class="n">uniquenessRatio</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
               <span class="kt">int</span> <span class="n">speckleWindowSize</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="kt">int</span> <span class="n">speckleRange</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
               <span class="kt">bool</span> <span class="n">fullDP</span><span class="o">=</span><span class="nb">false</span><span class="p">);</span>
    <span class="k">virtual</span> <span class="o">~</span><span class="n">StereoSGBM</span><span class="p">();</span>

    <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">operator</span><span class="p">()(</span><span class="n">InputArray</span> <span class="n">left</span><span class="p">,</span> <span class="n">InputArray</span> <span class="n">right</span><span class="p">,</span> <span class="n">OutputArray</span> <span class="n">disp</span><span class="p">);</span>

    <span class="kt">int</span> <span class="n">minDisparity</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">numberOfDisparities</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">SADWindowSize</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">preFilterCap</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">uniquenessRatio</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">P1</span><span class="p">,</span> <span class="n">P2</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">speckleWindowSize</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">speckleRange</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">disp12MaxDiff</span><span class="p">;</span>
    <span class="kt">bool</span> <span class="n">fullDP</span><span class="p">;</span>

    <span class="p">...</span>
<span class="p">};</span>
</pre></div>
</div>
<p>The class implements the modified H. Hirschmuller algorithm <a class="reference internal" href="#hh08" id="id5">[HH08]</a> that differs from the original one as follows:</p>
<blockquote>
<div><ul class="simple">
<li>By default, the algorithm is single-pass, which means that you consider only 5 directions instead of 8. Set <code class="docutils literal"><span class="pre">fullDP=true</span></code> to run the full variant of the algorithm but beware that it may consume a lot of memory.</li>
<li>The algorithm matches blocks, not individual pixels. Though, setting <code class="docutils literal"><span class="pre">SADWindowSize=1</span></code> reduces the blocks to single pixels.</li>
<li>Mutual information cost function is not implemented. Instead, a simpler Birchfield-Tomasi sub-pixel metric from <a class="reference internal" href="#bt98" id="id6">[BT98]</a> is used. Though, the color images are supported as well.</li>
<li>Some pre- and post- processing steps from K. Konolige algorithm <a class="reference internal" href="#void StereoBM::operator()(InputArray left, InputArray right, OutputArray disparity, int disptype)" title="void StereoBM::operator()(InputArray left, InputArray right, OutputArray disparity, int disptype)"><code class="xref ocv ocv-funcx docutils literal"><span class="pre">StereoBM::operator()</span></code></a>  are included, for example: pre-filtering (<code class="docutils literal"><span class="pre">CV_STEREO_BM_XSOBEL</span></code> type) and post-filtering (uniqueness check, quadratic interpolation and speckle filtering).</li>
</ul>
</div></blockquote>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<ul class="last simple">
<li>(Python) An example illustrating the use of the StereoSGBM matching algorithm can be found at opencv_source_code/samples/python2/stereo_match.py</li>
</ul>
</div>
</div>
<div class="section" id="stereosgbm-stereosgbm">
<h2>StereoSGBM::StereoSGBM<a class="headerlink" href="#stereosgbm-stereosgbm" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="StereoSGBM::StereoSGBM()">
<strong>C++:</strong><code class="descname"> </code> <code class="descclassname">StereoSGBM::</code><code class="descname">StereoSGBM</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#StereoSGBM::StereoSGBM()" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="StereoSGBM::StereoSGBM(int minDisparity, int numDisparities, int SADWindowSize, int P1, int P2, int disp12MaxDiff, int preFilterCap, int uniquenessRatio, int speckleWindowSize, int speckleRange, bool fullDP)">
<strong>C++:</strong><code class="descname"> </code> <code class="descclassname">StereoSGBM::</code><code class="descname">StereoSGBM</code><span class="sig-paren">(</span>int <strong>minDisparity</strong>, int <strong>numDisparities</strong>, int <strong>SADWindowSize</strong>, int <strong>P1</strong>=0, int <strong>P2</strong>=0, int <strong>disp12MaxDiff</strong>=0, int <strong>preFilterCap</strong>=0, int <strong>uniquenessRatio</strong>=0, int <strong>speckleWindowSize</strong>=0, int <strong>speckleRange</strong>=0, bool <strong>fullDP</strong>=false<span class="sig-paren">)</span><a class="headerlink" href="#StereoSGBM::StereoSGBM(int minDisparity, int numDisparities, int SADWindowSize, int P1, int P2, int disp12MaxDiff, int preFilterCap, int uniquenessRatio, int speckleWindowSize, int speckleRange, bool fullDP)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="pyfunction">
<dt id="cv2.StereoSGBM">
<strong>Python:</strong><code class="descname"> </code><code class="descclassname">cv2.</code><code class="descname">StereoSGBM</code><span class="sig-paren">(</span><span class="optional">[</span>minDisparity, numDisparities, SADWindowSize<span class="optional">[</span>, P1<span class="optional">[</span>, P2<span class="optional">[</span>, disp12MaxDiff<span class="optional">[</span>, preFilterCap<span class="optional">[</span>, uniquenessRatio<span class="optional">[</span>, speckleWindowSize<span class="optional">[</span>, speckleRange<span class="optional">[</span>, fullDP<span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span> &rarr; &lt;StereoSGBM object&gt;<a class="headerlink" href="#cv2.StereoSGBM" title="Permalink to this definition">¶</a></dt>
<dd><p>Initializes <code class="docutils literal"><span class="pre">StereoSGBM</span></code> and sets parameters to custom values.??</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>minDisparity</strong> &#8211; Minimum possible disparity value. Normally, it is zero but sometimes rectification algorithms can shift images, so this parameter needs to be adjusted accordingly.</li>
<li><strong>numDisparities</strong> &#8211; Maximum disparity minus minimum disparity. The value is always greater than zero. In the current implementation, this parameter must be divisible by 16.</li>
<li><strong>SADWindowSize</strong> &#8211; Matched block size. It must be an odd number  <code class="docutils literal"><span class="pre">&gt;=1</span></code> . Normally, it should be somewhere in  the <code class="docutils literal"><span class="pre">3..11</span></code>  range.</li>
<li><strong>P1</strong> &#8211; The first parameter controlling the disparity smoothness. See below.</li>
<li><strong>P2</strong> &#8211; The second parameter controlling the disparity smoothness. The larger the values are, the smoother the disparity is.  <code class="docutils literal"><span class="pre">P1</span></code>  is the penalty on the disparity change by plus or minus 1 between neighbor pixels.  <code class="docutils literal"><span class="pre">P2</span></code>  is the penalty on the disparity change by more than 1 between neighbor pixels. The algorithm requires  <code class="docutils literal"><span class="pre">P2</span> <span class="pre">&gt;</span> <span class="pre">P1</span></code> . See  <code class="docutils literal"><span class="pre">stereo_match.cpp</span></code>  sample where some reasonably good  <code class="docutils literal"><span class="pre">P1</span></code>  and  <code class="docutils literal"><span class="pre">P2</span></code>  values are shown (like  <code class="docutils literal"><span class="pre">8*number_of_image_channels*SADWindowSize*SADWindowSize</span></code>  and  <code class="docutils literal"><span class="pre">32*number_of_image_channels*SADWindowSize*SADWindowSize</span></code> , respectively).</li>
<li><strong>disp12MaxDiff</strong> &#8211; Maximum allowed difference (in integer pixel units) in the left-right disparity check. Set it to a non-positive value to disable the check.</li>
<li><strong>preFilterCap</strong> &#8211; Truncation value for the prefiltered image pixels. The algorithm first computes x-derivative at each pixel and clips its value by  <code class="docutils literal"><span class="pre">[-preFilterCap,</span> <span class="pre">preFilterCap]</span></code>  interval. The result values are passed to the Birchfield-Tomasi pixel cost function.</li>
<li><strong>uniquenessRatio</strong> &#8211; Margin in percentage by which the best (minimum) computed cost function value should &#8220;win&#8221; the second best value to consider the found match correct. Normally, a value within the 5-15 range is good enough.</li>
<li><strong>speckleWindowSize</strong> &#8211; Maximum size of smooth disparity regions to consider their noise speckles and invalidate. Set it to 0 to disable speckle filtering. Otherwise, set it somewhere in the 50-200 range.</li>
<li><strong>speckleRange</strong> &#8211; Maximum disparity variation within each connected component. If you do speckle filtering, set the parameter to a positive value, it will be implicitly multiplied by 16. Normally, 1 or 2 is good enough.</li>
<li><strong>fullDP</strong> &#8211; Set it to  <code class="docutils literal"><span class="pre">true</span></code>  to run the full-scale two-pass dynamic programming algorithm. It will consume O(W*H*numDisparities) bytes, which is large for 640x480 stereo and huge for HD-size pictures. By default, it is set to <code class="docutils literal"><span class="pre">false</span></code> .</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<p>The first constructor initializes <code class="docutils literal"><span class="pre">StereoSGBM</span></code> with all the default parameters. So, you only have to set <code class="docutils literal"><span class="pre">StereoSGBM::numberOfDisparities</span></code> at minimum. The second constructor enables you to set each parameter to a custom value.</p>
</div>
<div class="section" id="stereosgbm-operator">
<h2>StereoSGBM::operator ()<a class="headerlink" href="#stereosgbm-operator" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="void StereoSGBM::operator()(InputArray left, InputArray right, OutputArray disp)">
<strong>C++:</strong><code class="descname"> </code>void <code class="descclassname">StereoSGBM::</code><code class="descname">operator()</code><span class="sig-paren">(</span>InputArray <strong>left</strong>, InputArray <strong>right</strong>, OutputArray <strong>disp</strong><span class="sig-paren">)</span><a class="headerlink" href="#void StereoSGBM::operator()(InputArray left, InputArray right, OutputArray disp)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="pyfunction">
<dt id="cv2.StereoSGBM.compute">
<strong>Python:</strong><code class="descname"> </code><code class="descclassname">cv2.StereoSGBM.</code><code class="descname">compute</code><span class="sig-paren">(</span>left, right<span class="optional">[</span>, disp<span class="optional">]</span><span class="sig-paren">)</span> &rarr; disp<a class="headerlink" href="#cv2.StereoSGBM.compute" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes disparity using the SGBM algorithm for a rectified stereo pair.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>left</strong> &#8211; Left 8-bit single-channel or 3-channel image.</li>
<li><strong>right</strong> &#8211; Right image of the same size and the same type as the left one.</li>
<li><strong>disp</strong> &#8211; Output disparity map. It is a 16-bit signed single-channel image of the same size as the input image. It contains disparity values  scaled by 16. So, to get the floating-point disparity map, you need to divide each  <code class="docutils literal"><span class="pre">disp</span></code>  element by 16.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<p>The method executes the SGBM algorithm on a rectified stereo pair. See <code class="docutils literal"><span class="pre">stereo_match.cpp</span></code> OpenCV sample on how to prepare images and call the method.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The method is not constant, so you should not use the same <code class="docutils literal"><span class="pre">StereoSGBM</span></code> instance from different threads simultaneously.</p>
</div>
</div>
<div class="section" id="stereocalibrate">
<h2>stereoCalibrate<a class="headerlink" href="#stereocalibrate" title="Permalink to this headline">¶</a></h2>
<p>Calibrates the stereo camera.</p>
<dl class="function">
<dt id="double stereoCalibrate(InputArrayOfArrays objectPoints, InputArrayOfArrays imagePoints1, InputArrayOfArrays imagePoints2, InputOutputArray cameraMatrix1, InputOutputArray distCoeffs1, InputOutputArray cameraMatrix2, InputOutputArray distCoeffs2, Size imageSize, OutputArray R, OutputArray T, OutputArray E, OutputArray F, TermCriteria criteria, int flags)">
<strong>C++:</strong><code class="descname"> </code>double <code class="descname">stereoCalibrate</code><span class="sig-paren">(</span>InputArrayOfArrays <strong>objectPoints</strong>, InputArrayOfArrays <strong>imagePoints1</strong>, InputArrayOfArrays <strong>imagePoints2</strong>, InputOutputArray <strong>cameraMatrix1</strong>, InputOutputArray <strong>distCoeffs1</strong>, InputOutputArray <strong>cameraMatrix2</strong>, InputOutputArray <strong>distCoeffs2</strong>, Size <strong>imageSize</strong>, OutputArray <strong>R</strong>, OutputArray <strong>T</strong>, OutputArray <strong>E</strong>, OutputArray <strong>F</strong>, TermCriteria <strong>criteria</strong>=TermCriteria(TermCriteria::COUNT+TermCriteria::EPS, 30, 1e-6), int <strong>flags</strong>=CALIB_FIX_INTRINSIC <span class="sig-paren">)</span><a class="headerlink" href="#double stereoCalibrate(InputArrayOfArrays objectPoints, InputArrayOfArrays imagePoints1, InputArrayOfArrays imagePoints2, InputOutputArray cameraMatrix1, InputOutputArray distCoeffs1, InputOutputArray cameraMatrix2, InputOutputArray distCoeffs2, Size imageSize, OutputArray R, OutputArray T, OutputArray E, OutputArray F, TermCriteria criteria, int flags)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="pyfunction">
<dt id="cv2.stereoCalibrate">
<strong>Python:</strong><code class="descname"> </code><code class="descclassname">cv2.</code><code class="descname">stereoCalibrate</code><span class="sig-paren">(</span>objectPoints, imagePoints1, imagePoints2, imageSize<span class="optional">[</span>, cameraMatrix1<span class="optional">[</span>, distCoeffs1<span class="optional">[</span>, cameraMatrix2<span class="optional">[</span>, distCoeffs2<span class="optional">[</span>, R<span class="optional">[</span>, T<span class="optional">[</span>, E<span class="optional">[</span>, F<span class="optional">[</span>, criteria<span class="optional">[</span>, flags<span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span> &rarr; retval, cameraMatrix1, distCoeffs1, cameraMatrix2, distCoeffs2, R, T, E, F<a class="headerlink" href="#cv2.stereoCalibrate" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="cfunction">
<dt id="double cvStereoCalibrate(const CvMat* object_points, const CvMat* image_points1, const CvMat* image_points2, const CvMat* npoints, CvMat* camera_matrix1, CvMat* dist_coeffs1, CvMat* camera_matrix2, CvMat* dist_coeffs2, CvSize image_size, CvMat* R, CvMat* T, CvMat* E, CvMat* F, CvTermCriteria term_crit, int flags)">
<strong>C:</strong><code class="descname"> </code>double <code class="descname">cvStereoCalibrate</code><span class="sig-paren">(</span>const CvMat* <strong>object_points</strong>, const CvMat* <strong>image_points1</strong>, const CvMat* <strong>image_points2</strong>, const CvMat* <strong>npoints</strong>, CvMat* <strong>camera_matrix1</strong>, CvMat* <strong>dist_coeffs1</strong>, CvMat* <strong>camera_matrix2</strong>, CvMat* <strong>dist_coeffs2</strong>, CvSize <strong>image_size</strong>, CvMat* <strong>R</strong>, CvMat* <strong>T</strong>, CvMat* <strong>E</strong>=0, CvMat* <strong>F</strong>=0, CvTermCriteria <strong>term_crit</strong>=cvTermCriteria( CV_TERMCRIT_ITER+CV_TERMCRIT_EPS,30,1e-6), int <strong>flags</strong>=CV_CALIB_FIX_INTRINSIC <span class="sig-paren">)</span><a class="headerlink" href="#double cvStereoCalibrate(const CvMat* object_points, const CvMat* image_points1, const CvMat* image_points2, const CvMat* npoints, CvMat* camera_matrix1, CvMat* dist_coeffs1, CvMat* camera_matrix2, CvMat* dist_coeffs2, CvSize image_size, CvMat* R, CvMat* T, CvMat* E, CvMat* F, CvTermCriteria term_crit, int flags)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="pyoldfunction">
<dt id="cv.StereoCalibrate">
<strong>Python:</strong><code class="descname"> </code><code class="descclassname">cv.</code><code class="descname">StereoCalibrate</code><span class="sig-paren">(</span>objectPoints, imagePoints1, imagePoints2, pointCounts, cameraMatrix1, distCoeffs1, cameraMatrix2, distCoeffs2, imageSize, R, T, E=None, F=None, term_crit=(CV_TERMCRIT_ITER+CV_TERMCRIT_EPS, 30, 1e-6), flags=CV_CALIB_FIX_INTRINSIC<span class="sig-paren">)</span> &rarr; None<a class="headerlink" href="#cv.StereoCalibrate" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>objectPoints</strong> &#8211; Vector of vectors of the calibration pattern points.</li>
<li><strong>imagePoints1</strong> &#8211; Vector of vectors of the projections of the calibration pattern points, observed by the first camera.</li>
<li><strong>imagePoints2</strong> &#8211; Vector of vectors of the projections of the calibration pattern points, observed by the second camera.</li>
<li><strong>cameraMatrix1</strong> &#8211; Input/output first camera matrix:  <img class="math" src="../../../_images/math/5ee676b6ee878edfbf911dbae8728c10904b1f96.png" alt="\vecthreethree{f_x^{(j)}}{0}{c_x^{(j)}}{0}{f_y^{(j)}}{c_y^{(j)}}{0}{0}{1}"/> , <img class="math" src="../../../_images/math/0d57eaca449f2cca6adfbdad206557639791b400.png" alt="j = 0,\, 1"/> . If any of  <code class="docutils literal"><span class="pre">CV_CALIB_USE_INTRINSIC_GUESS</span></code> , <code class="docutils literal"><span class="pre">CV_CALIB_FIX_ASPECT_RATIO</span></code> , <code class="docutils literal"><span class="pre">CV_CALIB_FIX_INTRINSIC</span></code> , or  <code class="docutils literal"><span class="pre">CV_CALIB_FIX_FOCAL_LENGTH</span></code>  are specified, some or all of the matrix components must be initialized. See the flags description for details.</li>
<li><strong>distCoeffs1</strong> &#8211; Input/output vector of distortion coefficients  <img class="math" src="../../../_images/math/94288b7709d10a7ddf286e33db0074512bda0411.png" alt="(k_1, k_2, p_1, p_2[, k_3[, k_4, k_5, k_6]])"/>  of 4, 5, or 8 elements. The output vector length depends on the flags.</li>
<li><strong>cameraMatrix2</strong> &#8211; Input/output second camera matrix. The parameter is similar to <code class="docutils literal"><span class="pre">cameraMatrix1</span></code> .</li>
<li><strong>distCoeffs2</strong> &#8211; Input/output lens distortion coefficients for the second camera. The parameter is similar to  <code class="docutils literal"><span class="pre">distCoeffs1</span></code> .</li>
<li><strong>imageSize</strong> &#8211; Size of the image used only to initialize intrinsic camera matrix.</li>
<li><strong>R</strong> &#8211; Output rotation matrix between the 1st and the 2nd camera coordinate systems.</li>
<li><strong>T</strong> &#8211; Output translation vector between the coordinate systems of the cameras.</li>
<li><strong>E</strong> &#8211; Output essential matrix.</li>
<li><strong>F</strong> &#8211; Output fundamental matrix.</li>
<li><strong>term_crit</strong> &#8211; Termination criteria for the iterative optimization algorithm.</li>
<li><strong>flags</strong> &#8211; <p>Different flags that may be zero or a combination of the following values:</p>
<ul>
<li><strong>CV_CALIB_FIX_INTRINSIC</strong> Fix <code class="docutils literal"><span class="pre">cameraMatrix?</span></code> and  <code class="docutils literal"><span class="pre">distCoeffs?</span></code>  so that only  <code class="docutils literal"><span class="pre">R,</span> <span class="pre">T,</span> <span class="pre">E</span></code> ,  and  <code class="docutils literal"><span class="pre">F</span></code> matrices are estimated.</li>
<li><strong>CV_CALIB_USE_INTRINSIC_GUESS</strong> Optimize some or all of the intrinsic parameters according to the specified flags. Initial values are provided by the user.</li>
<li><strong>CV_CALIB_FIX_PRINCIPAL_POINT</strong> Fix the principal points during the optimization.</li>
<li><strong>CV_CALIB_FIX_FOCAL_LENGTH</strong> Fix <img class="math" src="../../../_images/math/6631be5a15c0b7b5c03bbeebf74c540ca7d9eba3.png" alt="f^{(j)}_x"/>  and  <img class="math" src="../../../_images/math/ae7295bbd852df3996336cdd9a8a0be7eecf7357.png" alt="f^{(j)}_y"/> .</li>
<li><strong>CV_CALIB_FIX_ASPECT_RATIO</strong> Optimize <img class="math" src="../../../_images/math/ae7295bbd852df3996336cdd9a8a0be7eecf7357.png" alt="f^{(j)}_y"/> . Fix the ratio  <img class="math" src="../../../_images/math/3882576687233087c9aff3891e45cf4e60129915.png" alt="f^{(j)}_x/f^{(j)}_y"/> .</li>
<li><strong>CV_CALIB_SAME_FOCAL_LENGTH</strong> Enforce  <img class="math" src="../../../_images/math/6dbe0d157431bdbee74e1a6dd2b171fc05b721b7.png" alt="f^{(0)}_x=f^{(1)}_x"/>  and  <img class="math" src="../../../_images/math/fd0e6de2ed45740a4b383f204be79ad50ec6542f.png" alt="f^{(0)}_y=f^{(1)}_y"/> .</li>
<li><strong>CV_CALIB_ZERO_TANGENT_DIST</strong> Set tangential distortion coefficients for each camera to zeros and fix there.</li>
<li><strong>CV_CALIB_FIX_K1,...,CV_CALIB_FIX_K6</strong> Do not change the corresponding radial distortion coefficient during the optimization. If  <code class="docutils literal"><span class="pre">CV_CALIB_USE_INTRINSIC_GUESS</span></code>  is set, the coefficient from the supplied  <code class="docutils literal"><span class="pre">distCoeffs</span></code>  matrix is used. Otherwise, it is set to 0.</li>
<li><strong>CV_CALIB_RATIONAL_MODEL</strong> Enable coefficients k4, k5, and k6. To provide the backward compatibility, this extra flag should be explicitly specified to make the calibration function use the rational model and return 8 coefficients. If the flag is not set, the function computes  and returns only 5 distortion coefficients.</li>
</ul>
</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<p>The function estimates transformation between two cameras making a stereo pair. If you have a stereo camera where the relative position and orientation of two cameras is fixed, and if you computed poses of an object relative to the first camera and to the second camera, (R1, T1) and (R2, T2), respectively (this can be done with
<a class="reference internal" href="#bool solvePnP(InputArray objectPoints, InputArray imagePoints, InputArray cameraMatrix, InputArray distCoeffs, OutputArray rvec, OutputArray tvec, bool useExtrinsicGuess, int flags)" title="bool solvePnP(InputArray objectPoints, InputArray imagePoints, InputArray cameraMatrix, InputArray distCoeffs, OutputArray rvec, OutputArray tvec, bool useExtrinsicGuess, int flags)"><code class="xref ocv ocv-func docutils literal"><span class="pre">solvePnP()</span></code></a> ), then those poses definitely relate to each other. This means that, given (
<img class="math" src="../../../_images/math/583336cd8b2420cd6cc905f22e3c8771db6dd884.png" alt="R_1"/>,:math:<cite>T_1</cite> ), it should be possible to compute (
<img class="math" src="../../../_images/math/d475263a752283e7ff7ce9170977d67e1f8c47c5.png" alt="R_2"/>,:math:<cite>T_2</cite> ). You only need to know the position and orientation of the second camera relative to the first camera. This is what the described function does. It computes (
<img class="math" src="../../../_images/math/8fa391da5431a5d6eaba1325c3e7cb3da22812b5.png" alt="R"/>,:math:<cite>T</cite> ) so that:</p>
<div class="math">
<p><img src="../../../_images/math/6a70d1c215a676fb280cc38f24df38c5b5e7724e.png" alt="R_2=R*R_1
T_2=R*T_1 + T,"/></p>
</div><p>Optionally, it computes the essential matrix E:</p>
<div class="math">
<p><img src="../../../_images/math/ca732c8c378a36d10278ec96528216de4ef1f7d0.png" alt="E= \vecthreethree{0}{-T_2}{T_1}{T_2}{0}{-T_0}{-T_1}{T_0}{0} *R"/></p>
</div><p>where
<img class="math" src="../../../_images/math/5af4cfb74b7786edb28461590ba973cc966a8f43.png" alt="T_i"/> are components of the translation vector
<img class="math" src="../../../_images/math/87804527283a4539e1e17c5861df8cb92a97fd6d.png" alt="T"/> :
<img class="math" src="../../../_images/math/9ab068430870cda7cb8b114c4876a69b0ef7a89a.png" alt="T=[T_0, T_1, T_2]^T"/> . And the function can also compute the fundamental matrix F:</p>
<div class="math">
<p><img src="../../../_images/math/4b1d1dea6f23d488d7193091e7ddf95b6450efce.png" alt="F = cameraMatrix2^{-T} E cameraMatrix1^{-1}"/></p>
</div><p>Besides the stereo-related information, the function can also perform a full calibration of each of two cameras. However, due to the high dimensionality of the parameter space and noise in the input data, the function can diverge from the correct solution. If the intrinsic parameters can be estimated with high accuracy for each of the cameras individually (for example, using
<a class="reference internal" href="#double calibrateCamera(InputArrayOfArrays objectPoints, InputArrayOfArrays imagePoints, Size imageSize, InputOutputArray cameraMatrix, InputOutputArray distCoeffs, OutputArrayOfArrays rvecs, OutputArrayOfArrays tvecs, int flags, TermCriteria criteria)" title="double calibrateCamera(InputArrayOfArrays objectPoints, InputArrayOfArrays imagePoints, Size imageSize, InputOutputArray cameraMatrix, InputOutputArray distCoeffs, OutputArrayOfArrays rvecs, OutputArrayOfArrays tvecs, int flags, TermCriteria criteria)"><code class="xref ocv ocv-func docutils literal"><span class="pre">calibrateCamera()</span></code></a> ), you are recommended to do so and then pass <code class="docutils literal"><span class="pre">CV_CALIB_FIX_INTRINSIC</span></code> flag to the function along with the computed intrinsic parameters. Otherwise, if all the parameters are estimated at once, it makes sense to restrict some parameters, for example, pass <code class="docutils literal"><span class="pre">CV_CALIB_SAME_FOCAL_LENGTH</span></code> and <code class="docutils literal"><span class="pre">CV_CALIB_ZERO_TANGENT_DIST</span></code> flags, which is usually a reasonable assumption.</p>
<p>Similarly to <a class="reference internal" href="#double calibrateCamera(InputArrayOfArrays objectPoints, InputArrayOfArrays imagePoints, Size imageSize, InputOutputArray cameraMatrix, InputOutputArray distCoeffs, OutputArrayOfArrays rvecs, OutputArrayOfArrays tvecs, int flags, TermCriteria criteria)" title="double calibrateCamera(InputArrayOfArrays objectPoints, InputArrayOfArrays imagePoints, Size imageSize, InputOutputArray cameraMatrix, InputOutputArray distCoeffs, OutputArrayOfArrays rvecs, OutputArrayOfArrays tvecs, int flags, TermCriteria criteria)"><code class="xref ocv ocv-func docutils literal"><span class="pre">calibrateCamera()</span></code></a> , the function minimizes the total re-projection error for all the points in all the available views from both cameras. The function returns the final value of the re-projection error.</p>
</div>
<div class="section" id="stereorectify">
<h2>stereoRectify<a class="headerlink" href="#stereorectify" title="Permalink to this headline">¶</a></h2>
<p>Computes rectification transforms for each head of a calibrated stereo camera.</p>
<dl class="function">
<dt id="void stereoRectify(InputArray cameraMatrix1, InputArray distCoeffs1, InputArray cameraMatrix2, InputArray distCoeffs2, Size imageSize, InputArray R, InputArray T, OutputArray R1, OutputArray R2, OutputArray P1, OutputArray P2, OutputArray Q, int flags, double alpha, Size newImageSize, Rect* validPixROI1, Rect* validPixROI2)">
<strong>C++:</strong><code class="descname"> </code>void <code class="descname">stereoRectify</code><span class="sig-paren">(</span>InputArray <strong>cameraMatrix1</strong>, InputArray <strong>distCoeffs1</strong>, InputArray <strong>cameraMatrix2</strong>, InputArray <strong>distCoeffs2</strong>, Size <strong>imageSize</strong>, InputArray <strong>R</strong>, InputArray <strong>T</strong>, OutputArray <strong>R1</strong>, OutputArray <strong>R2</strong>, OutputArray <strong>P1</strong>, OutputArray <strong>P2</strong>, OutputArray <strong>Q</strong>, int <strong>flags</strong>=CALIB_ZERO_DISPARITY, double <strong>alpha</strong>=-1, Size <strong>newImageSize</strong>=Size(), Rect* <strong>validPixROI1</strong>=0, Rect* <strong>validPixROI2</strong>=0 <span class="sig-paren">)</span><a class="headerlink" href="#void stereoRectify(InputArray cameraMatrix1, InputArray distCoeffs1, InputArray cameraMatrix2, InputArray distCoeffs2, Size imageSize, InputArray R, InputArray T, OutputArray R1, OutputArray R2, OutputArray P1, OutputArray P2, OutputArray Q, int flags, double alpha, Size newImageSize, Rect* validPixROI1, Rect* validPixROI2)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="cfunction">
<dt id="void cvStereoRectify(const CvMat* camera_matrix1, const CvMat* camera_matrix2, const CvMat* dist_coeffs1, const CvMat* dist_coeffs2, CvSize image_size, const CvMat* R, const CvMat* T, CvMat* R1, CvMat* R2, CvMat* P1, CvMat* P2, CvMat* Q, int flags, double alpha, CvSize new_image_size, CvRect* valid_pix_ROI1, CvRect* valid_pix_ROI2)">
<strong>C:</strong><code class="descname"> </code>void <code class="descname">cvStereoRectify</code><span class="sig-paren">(</span>const CvMat* <strong>camera_matrix1</strong>, const CvMat* <strong>camera_matrix2</strong>, const CvMat* <strong>dist_coeffs1</strong>, const CvMat* <strong>dist_coeffs2</strong>, CvSize <strong>image_size</strong>, const CvMat* <strong>R</strong>, const CvMat* <strong>T</strong>, CvMat* <strong>R1</strong>, CvMat* <strong>R2</strong>, CvMat* <strong>P1</strong>, CvMat* <strong>P2</strong>, CvMat* <strong>Q</strong>=0, int <strong>flags</strong>=CV_CALIB_ZERO_DISPARITY, double <strong>alpha</strong>=-1, CvSize <strong>new_image_size</strong>=cvSize(0,0), CvRect* <strong>valid_pix_ROI1</strong>=0, CvRect* <strong>valid_pix_ROI2</strong>=0 <span class="sig-paren">)</span><a class="headerlink" href="#void cvStereoRectify(const CvMat* camera_matrix1, const CvMat* camera_matrix2, const CvMat* dist_coeffs1, const CvMat* dist_coeffs2, CvSize image_size, const CvMat* R, const CvMat* T, CvMat* R1, CvMat* R2, CvMat* P1, CvMat* P2, CvMat* Q, int flags, double alpha, CvSize new_image_size, CvRect* valid_pix_ROI1, CvRect* valid_pix_ROI2)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="pyoldfunction">
<dt id="cv.StereoRectify">
<strong>Python:</strong><code class="descname"> </code><code class="descclassname">cv.</code><code class="descname">StereoRectify</code><span class="sig-paren">(</span>cameraMatrix1, cameraMatrix2, distCoeffs1, distCoeffs2, imageSize, R, T, R1, R2, P1, P2, Q=None, flags=CV_CALIB_ZERO_DISPARITY, alpha=-1, newImageSize=(0, 0)) -&gt; (roi1, roi2<span class="sig-paren">)</span><a class="headerlink" href="#cv.StereoRectify" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>cameraMatrix1</strong> &#8211; First camera matrix.</li>
<li><strong>cameraMatrix2</strong> &#8211; Second camera matrix.</li>
<li><strong>distCoeffs1</strong> &#8211; First camera distortion parameters.</li>
<li><strong>distCoeffs2</strong> &#8211; Second camera distortion parameters.</li>
<li><strong>imageSize</strong> &#8211; Size of the image used for stereo calibration.</li>
<li><strong>R</strong> &#8211; Rotation matrix between the coordinate systems of the first and the second cameras.</li>
<li><strong>T</strong> &#8211; Translation vector between coordinate systems of the cameras.</li>
<li><strong>R1</strong> &#8211; Output  3x3 rectification transform (rotation matrix) for the first camera.</li>
<li><strong>R2</strong> &#8211; Output  3x3 rectification transform (rotation matrix) for the second camera.</li>
<li><strong>P1</strong> &#8211; Output  3x4 projection matrix in the new (rectified) coordinate systems for the first camera.</li>
<li><strong>P2</strong> &#8211; Output  3x4 projection matrix in the new (rectified) coordinate systems for the second camera.</li>
<li><strong>Q</strong> &#8211; Output  <img class="math" src="../../../_images/math/96754e424b2a8b15b1a9dba38a6ffde5cb0e50a8.png" alt="4 \times 4"/>  disparity-to-depth mapping matrix (see  <a class="reference internal" href="#void reprojectImageTo3D(InputArray disparity, OutputArray _3dImage, InputArray Q, bool handleMissingValues, int ddepth)" title="void reprojectImageTo3D(InputArray disparity, OutputArray _3dImage, InputArray Q, bool handleMissingValues, int ddepth)"><code class="xref ocv ocv-func docutils literal"><span class="pre">reprojectImageTo3D()</span></code></a> ).</li>
<li><strong>flags</strong> &#8211; Operation flags that may be zero or  <code class="docutils literal"><span class="pre">CV_CALIB_ZERO_DISPARITY</span></code> . If the flag is set, the function makes the principal points of each camera have the same pixel coordinates in the rectified views. And if the flag is not set, the function may still shift the images in the horizontal or vertical direction (depending on the orientation of epipolar lines) to maximize the useful image area.</li>
<li><strong>alpha</strong> &#8211; Free scaling parameter. If it is -1  or absent, the function performs the default scaling. Otherwise, the parameter should be between 0 and 1.  <code class="docutils literal"><span class="pre">alpha=0</span></code>  means that the rectified images are zoomed and shifted so that only valid pixels are visible (no black areas after rectification).  <code class="docutils literal"><span class="pre">alpha=1</span></code>  means that the rectified image is decimated and shifted so that all the pixels from the original images from the cameras are retained in the rectified images (no source image pixels are lost). Obviously, any intermediate value yields an intermediate result between those two extreme cases.</li>
<li><strong>newImageSize</strong> &#8211; New image resolution after rectification. The same size should be passed to  <a class="reference internal" href="../../imgproc/doc/geometric_transformations.html#void initUndistortRectifyMap(InputArray cameraMatrix, InputArray distCoeffs, InputArray R, InputArray newCameraMatrix, Size size, int m1type, OutputArray map1, OutputArray map2)" title="void initUndistortRectifyMap(InputArray cameraMatrix, InputArray distCoeffs, InputArray R, InputArray newCameraMatrix, Size size, int m1type, OutputArray map1, OutputArray map2)"><code class="xref ocv ocv-func docutils literal"><span class="pre">initUndistortRectifyMap()</span></code></a> (see the  <code class="docutils literal"><span class="pre">stereo_calib.cpp</span></code>  sample in OpenCV samples directory). When (0,0) is passed (default), it is set to the original  <code class="docutils literal"><span class="pre">imageSize</span></code> . Setting it to larger value can help you preserve details in the original image, especially when there is a big radial distortion.</li>
<li><strong>validPixROI1</strong> &#8211; Optional output rectangles inside the rectified images where all the pixels are valid. If  <code class="docutils literal"><span class="pre">alpha=0</span></code> , the ROIs cover the whole images. Otherwise, they are likely to be smaller (see the picture below).</li>
<li><strong>validPixROI2</strong> &#8211; Optional output rectangles inside the rectified images where all the pixels are valid. If  <code class="docutils literal"><span class="pre">alpha=0</span></code> , the ROIs cover the whole images. Otherwise, they are likely to be smaller (see the picture below).</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<p>The function computes the rotation matrices for each camera that (virtually) make both camera image planes the same plane. Consequently, this makes all the epipolar lines parallel and thus simplifies the dense stereo correspondence problem. The function takes the matrices computed by
<a class="reference internal" href="#double stereoCalibrate(InputArrayOfArrays objectPoints, InputArrayOfArrays imagePoints1, InputArrayOfArrays imagePoints2, InputOutputArray cameraMatrix1, InputOutputArray distCoeffs1, InputOutputArray cameraMatrix2, InputOutputArray distCoeffs2, Size imageSize, OutputArray R, OutputArray T, OutputArray E, OutputArray F, TermCriteria criteria, int flags)" title="double stereoCalibrate(InputArrayOfArrays objectPoints, InputArrayOfArrays imagePoints1, InputArrayOfArrays imagePoints2, InputOutputArray cameraMatrix1, InputOutputArray distCoeffs1, InputOutputArray cameraMatrix2, InputOutputArray distCoeffs2, Size imageSize, OutputArray R, OutputArray T, OutputArray E, OutputArray F, TermCriteria criteria, int flags)"><code class="xref ocv ocv-func docutils literal"><span class="pre">stereoCalibrate()</span></code></a> as input. As output, it provides two rotation matrices and also two projection matrices in the new coordinates. The function distinguishes the following two cases:</p>
<ol class="arabic">
<li><p class="first"><strong>Horizontal stereo</strong>: the first and the second camera views are shifted relative to each other mainly along the x axis (with possible small vertical shift). In the rectified images, the corresponding epipolar lines in the left and right cameras are horizontal and have the same y-coordinate. P1 and P2 look like:</p>
<div class="math">
<p><img src="../../../_images/math/31f5b4b3e2df643c121fc55026c53d887d2ad199.png" alt="\texttt{P1} = \begin{bmatrix} f &amp; 0 &amp; cx_1 &amp; 0 \\ 0 &amp; f &amp; cy &amp; 0 \\ 0 &amp; 0 &amp; 1 &amp; 0 \end{bmatrix}"/></p>
</div><div class="math">
<p><img src="../../../_images/math/e0deaa9bfa3ef379dc4d95cb1d1ea909bb1749e2.png" alt="\texttt{P2} = \begin{bmatrix} f &amp; 0 &amp; cx_2 &amp; T_x*f \\ 0 &amp; f &amp; cy &amp; 0 \\ 0 &amp; 0 &amp; 1 &amp; 0 \end{bmatrix} ,"/></p>
</div><p>where
<img class="math" src="../../../_images/math/87351e965c26820790e0e80f149ab7f582a6f885.png" alt="T_x"/>     is a horizontal shift between the cameras and
<img class="math" src="../../../_images/math/6aa1460565d6f067186bfe392ddd749794799d7b.png" alt="cx_1=cx_2"/>     if <code class="docutils literal"><span class="pre">CV_CALIB_ZERO_DISPARITY</span></code>     is set.</p>
</li>
<li><p class="first"><strong>Vertical stereo</strong>: the first and the second camera views are shifted relative to each other mainly in vertical direction (and probably a bit in the horizontal direction too). The epipolar lines in the rectified images are vertical and have the same x-coordinate. P1 and P2 look like:</p>
<div class="math">
<p><img src="../../../_images/math/f70a9daea567e9ae20a5b0a83e5be92157ed07cb.png" alt="\texttt{P1} = \begin{bmatrix} f &amp; 0 &amp; cx &amp; 0 \\ 0 &amp; f &amp; cy_1 &amp; 0 \\ 0 &amp; 0 &amp; 1 &amp; 0 \end{bmatrix}"/></p>
</div><div class="math">
<p><img src="../../../_images/math/3350747095f69e2f0fd4c2d0a3443d5c6bd9d137.png" alt="\texttt{P2} = \begin{bmatrix} f &amp; 0 &amp; cx &amp; 0 \\ 0 &amp; f &amp; cy_2 &amp; T_y*f \\ 0 &amp; 0 &amp; 1 &amp; 0 \end{bmatrix} ,"/></p>
</div><p>where
<img class="math" src="../../../_images/math/beddaf607132e0ba215d08a0552cc7b74d0b37ed.png" alt="T_y"/>     is a vertical shift between the cameras and
<img class="math" src="../../../_images/math/8342b47740d019024e7a2e1fd322e7d41ac190d7.png" alt="cy_1=cy_2"/>     if <code class="docutils literal"><span class="pre">CALIB_ZERO_DISPARITY</span></code>     is set.</p>
</li>
</ol>
<p>As you can see, the first three columns of <code class="docutils literal"><span class="pre">P1</span></code> and <code class="docutils literal"><span class="pre">P2</span></code> will effectively be the new &#8220;rectified&#8221; camera matrices.
The matrices, together with <code class="docutils literal"><span class="pre">R1</span></code> and <code class="docutils literal"><span class="pre">R2</span></code> , can then be passed to
<a class="reference internal" href="../../imgproc/doc/geometric_transformations.html#void initUndistortRectifyMap(InputArray cameraMatrix, InputArray distCoeffs, InputArray R, InputArray newCameraMatrix, Size size, int m1type, OutputArray map1, OutputArray map2)" title="void initUndistortRectifyMap(InputArray cameraMatrix, InputArray distCoeffs, InputArray R, InputArray newCameraMatrix, Size size, int m1type, OutputArray map1, OutputArray map2)"><code class="xref ocv ocv-func docutils literal"><span class="pre">initUndistortRectifyMap()</span></code></a> to initialize the rectification map for each camera.</p>
<p>See below the screenshot from the <code class="docutils literal"><span class="pre">stereo_calib.cpp</span></code> sample. Some red horizontal lines pass through the corresponding image regions. This means that the images are well rectified, which is what most stereo correspondence algorithms rely on. The green rectangles are <code class="docutils literal"><span class="pre">roi1</span></code> and <code class="docutils literal"><span class="pre">roi2</span></code> . You see that their interiors are all valid pixels.</p>
<img alt="../../../_images/stereo_undistort.jpg" src="../../../_images/stereo_undistort.jpg" />
</div>
<div class="section" id="stereorectifyuncalibrated">
<h2>stereoRectifyUncalibrated<a class="headerlink" href="#stereorectifyuncalibrated" title="Permalink to this headline">¶</a></h2>
<p>Computes a rectification transform for an uncalibrated stereo camera.</p>
<dl class="function">
<dt id="bool stereoRectifyUncalibrated(InputArray points1, InputArray points2, InputArray F, Size imgSize, OutputArray H1, OutputArray H2, double threshold)">
<strong>C++:</strong><code class="descname"> </code>bool <code class="descname">stereoRectifyUncalibrated</code><span class="sig-paren">(</span>InputArray <strong>points1</strong>, InputArray <strong>points2</strong>, InputArray <strong>F</strong>, Size <strong>imgSize</strong>, OutputArray <strong>H1</strong>, OutputArray <strong>H2</strong>, double <strong>threshold</strong>=5 <span class="sig-paren">)</span><a class="headerlink" href="#bool stereoRectifyUncalibrated(InputArray points1, InputArray points2, InputArray F, Size imgSize, OutputArray H1, OutputArray H2, double threshold)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="pyfunction">
<dt id="cv2.stereoRectifyUncalibrated">
<strong>Python:</strong><code class="descname"> </code><code class="descclassname">cv2.</code><code class="descname">stereoRectifyUncalibrated</code><span class="sig-paren">(</span>points1, points2, F, imgSize<span class="optional">[</span>, H1<span class="optional">[</span>, H2<span class="optional">[</span>, threshold<span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span> &rarr; retval, H1, H2<a class="headerlink" href="#cv2.stereoRectifyUncalibrated" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="cfunction">
<dt id="int cvStereoRectifyUncalibrated(const CvMat* points1, const CvMat* points2, const CvMat* F, CvSize img_size, CvMat* H1, CvMat* H2, double threshold)">
<strong>C:</strong><code class="descname"> </code>int <code class="descname">cvStereoRectifyUncalibrated</code><span class="sig-paren">(</span>const CvMat* <strong>points1</strong>, const CvMat* <strong>points2</strong>, const CvMat* <strong>F</strong>, CvSize <strong>img_size</strong>, CvMat* <strong>H1</strong>, CvMat* <strong>H2</strong>, double <strong>threshold</strong>=5 <span class="sig-paren">)</span><a class="headerlink" href="#int cvStereoRectifyUncalibrated(const CvMat* points1, const CvMat* points2, const CvMat* F, CvSize img_size, CvMat* H1, CvMat* H2, double threshold)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="pyoldfunction">
<dt id="cv.StereoRectifyUncalibrated">
<strong>Python:</strong><code class="descname"> </code><code class="descclassname">cv.</code><code class="descname">StereoRectifyUncalibrated</code><span class="sig-paren">(</span>points1, points2, F, imageSize, H1, H2, threshold=5<span class="sig-paren">)</span> &rarr; None<a class="headerlink" href="#cv.StereoRectifyUncalibrated" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>points1</strong> &#8211; Array of feature points in the first image.</li>
<li><strong>points2</strong> &#8211; The corresponding points in the second image. The same formats as in  <a class="reference internal" href="#Mat findFundamentalMat(InputArray points1, InputArray points2, int method, double param1, double param2, OutputArray mask)" title="Mat findFundamentalMat(InputArray points1, InputArray points2, int method, double param1, double param2, OutputArray mask)"><code class="xref ocv ocv-func docutils literal"><span class="pre">findFundamentalMat()</span></code></a> are supported.</li>
<li><strong>F</strong> &#8211; Input fundamental matrix. It can be computed from the same set of point pairs using  <a class="reference internal" href="#Mat findFundamentalMat(InputArray points1, InputArray points2, int method, double param1, double param2, OutputArray mask)" title="Mat findFundamentalMat(InputArray points1, InputArray points2, int method, double param1, double param2, OutputArray mask)"><code class="xref ocv ocv-func docutils literal"><span class="pre">findFundamentalMat()</span></code></a> .</li>
<li><strong>imgSize</strong> &#8211; Size of the image.</li>
<li><strong>H1</strong> &#8211; Output rectification homography matrix for the first image.</li>
<li><strong>H2</strong> &#8211; Output rectification homography matrix for the second image.</li>
<li><strong>threshold</strong> &#8211; Optional threshold used to filter out the outliers. If the parameter is greater than zero, all the point pairs that do not comply with the epipolar geometry (that is, the points for which  <img class="math" src="../../../_images/math/b4be51fed0f7cc700726e152a48af4056b9599c9.png" alt="|\texttt{points2[i]}^T*\texttt{F}*\texttt{points1[i]}|&gt;\texttt{threshold}"/> ) are rejected prior to computing the homographies. Otherwise,all the points are considered inliers.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<p>The function computes the rectification transformations without knowing intrinsic parameters of the cameras and their relative position in the space, which explains the suffix &#8220;uncalibrated&#8221;. Another related difference from
<a class="reference internal" href="#void stereoRectify(InputArray cameraMatrix1, InputArray distCoeffs1, InputArray cameraMatrix2, InputArray distCoeffs2, Size imageSize, InputArray R, InputArray T, OutputArray R1, OutputArray R2, OutputArray P1, OutputArray P2, OutputArray Q, int flags, double alpha, Size newImageSize, Rect* validPixROI1, Rect* validPixROI2)" title="void stereoRectify(InputArray cameraMatrix1, InputArray distCoeffs1, InputArray cameraMatrix2, InputArray distCoeffs2, Size imageSize, InputArray R, InputArray T, OutputArray R1, OutputArray R2, OutputArray P1, OutputArray P2, OutputArray Q, int flags, double alpha, Size newImageSize, Rect* validPixROI1, Rect* validPixROI2)"><code class="xref ocv ocv-func docutils literal"><span class="pre">stereoRectify()</span></code></a> is that the function outputs not the rectification transformations in the object (3D) space, but the planar perspective transformations encoded by the homography matrices <code class="docutils literal"><span class="pre">H1</span></code> and <code class="docutils literal"><span class="pre">H2</span></code> . The function implements the algorithm
<a class="reference internal" href="#hartley99" id="id7">[Hartley99]</a>.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">While the algorithm does not need to know the intrinsic parameters of the cameras, it heavily depends on the epipolar geometry. Therefore, if the camera lenses have a significant distortion, it would be better to correct it before computing the fundamental matrix and calling this function. For example, distortion coefficients can be estimated for each head of stereo camera separately by using <a class="reference internal" href="#double calibrateCamera(InputArrayOfArrays objectPoints, InputArrayOfArrays imagePoints, Size imageSize, InputOutputArray cameraMatrix, InputOutputArray distCoeffs, OutputArrayOfArrays rvecs, OutputArrayOfArrays tvecs, int flags, TermCriteria criteria)" title="double calibrateCamera(InputArrayOfArrays objectPoints, InputArrayOfArrays imagePoints, Size imageSize, InputOutputArray cameraMatrix, InputOutputArray distCoeffs, OutputArrayOfArrays rvecs, OutputArrayOfArrays tvecs, int flags, TermCriteria criteria)"><code class="xref ocv ocv-func docutils literal"><span class="pre">calibrateCamera()</span></code></a> . Then, the images can be corrected using <a class="reference internal" href="../../imgproc/doc/geometric_transformations.html#void undistort(InputArray src, OutputArray dst, InputArray cameraMatrix, InputArray distCoeffs, InputArray newCameraMatrix)" title="void undistort(InputArray src, OutputArray dst, InputArray cameraMatrix, InputArray distCoeffs, InputArray newCameraMatrix)"><code class="xref ocv ocv-func docutils literal"><span class="pre">undistort()</span></code></a> , or just the point coordinates can be corrected with <a class="reference internal" href="../../imgproc/doc/geometric_transformations.html#void undistortPoints(InputArray src, OutputArray dst, InputArray cameraMatrix, InputArray distCoeffs, InputArray R, InputArray P)" title="void undistortPoints(InputArray src, OutputArray dst, InputArray cameraMatrix, InputArray distCoeffs, InputArray R, InputArray P)"><code class="xref ocv ocv-func docutils literal"><span class="pre">undistortPoints()</span></code></a> .</p>
</div>
</div>
<div class="section" id="triangulatepoints">
<h2>triangulatePoints<a class="headerlink" href="#triangulatepoints" title="Permalink to this headline">¶</a></h2>
<p>Reconstructs points by triangulation.</p>
<dl class="function">
<dt id="void triangulatePoints(InputArray projMatr1, InputArray projMatr2, InputArray projPoints1, InputArray projPoints2, OutputArray points4D)">
<strong>C++:</strong><code class="descname"> </code>void <code class="descname">triangulatePoints</code><span class="sig-paren">(</span>InputArray <strong>projMatr1</strong>, InputArray <strong>projMatr2</strong>, InputArray <strong>projPoints1</strong>, InputArray <strong>projPoints2</strong>, OutputArray <strong>points4D</strong><span class="sig-paren">)</span><a class="headerlink" href="#void triangulatePoints(InputArray projMatr1, InputArray projMatr2, InputArray projPoints1, InputArray projPoints2, OutputArray points4D)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="pyfunction">
<dt id="cv2.triangulatePoints">
<strong>Python:</strong><code class="descname"> </code><code class="descclassname">cv2.</code><code class="descname">triangulatePoints</code><span class="sig-paren">(</span>projMatr1, projMatr2, projPoints1, projPoints2<span class="optional">[</span>, points4D<span class="optional">]</span><span class="sig-paren">)</span> &rarr; points4D<a class="headerlink" href="#cv2.triangulatePoints" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="cfunction">
<dt id="void cvTriangulatePoints(CvMat* projMatr1, CvMat* projMatr2, CvMat* projPoints1, CvMat* projPoints2, CvMat* points4D)">
<strong>C:</strong><code class="descname"> </code>void <code class="descname">cvTriangulatePoints</code><span class="sig-paren">(</span>CvMat* <strong>projMatr1</strong>, CvMat* <strong>projMatr2</strong>, CvMat* <strong>projPoints1</strong>, CvMat* <strong>projPoints2</strong>, CvMat* <strong>points4D</strong><span class="sig-paren">)</span><a class="headerlink" href="#void cvTriangulatePoints(CvMat* projMatr1, CvMat* projMatr2, CvMat* projPoints1, CvMat* projPoints2, CvMat* points4D)" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>projMatr1</strong> &#8211; 3x4 projection matrix of the first camera.</li>
<li><strong>projMatr2</strong> &#8211; 3x4 projection matrix of the second camera.</li>
<li><strong>projPoints1</strong> &#8211; 2xN array of feature points in the first image. In case of c++ version it can be also a vector of feature points or two-channel matrix of size 1xN or Nx1.</li>
<li><strong>projPoints2</strong> &#8211; 2xN array of corresponding points in the second image. In case of c++ version it can be also a vector of feature points or two-channel matrix of size 1xN or Nx1.</li>
<li><strong>points4D</strong> &#8211; 4xN array of reconstructed points in homogeneous coordinates.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<p>The function reconstructs 3-dimensional points (in homogeneous coordinates) by using their observations with a stereo camera. Projections matrices can be obtained from <a class="reference internal" href="#void stereoRectify(InputArray cameraMatrix1, InputArray distCoeffs1, InputArray cameraMatrix2, InputArray distCoeffs2, Size imageSize, InputArray R, InputArray T, OutputArray R1, OutputArray R2, OutputArray P1, OutputArray P2, OutputArray Q, int flags, double alpha, Size newImageSize, Rect* validPixROI1, Rect* validPixROI2)" title="void stereoRectify(InputArray cameraMatrix1, InputArray distCoeffs1, InputArray cameraMatrix2, InputArray distCoeffs2, Size imageSize, InputArray R, InputArray T, OutputArray R1, OutputArray R2, OutputArray P1, OutputArray P2, OutputArray Q, int flags, double alpha, Size newImageSize, Rect* validPixROI1, Rect* validPixROI2)"><code class="xref ocv ocv-func docutils literal"><span class="pre">stereoRectify()</span></code></a>.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Keep in mind that all input data should be of float type in order for this function to work.</p>
</div>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#void reprojectImageTo3D(InputArray disparity, OutputArray _3dImage, InputArray Q, bool handleMissingValues, int ddepth)" title="void reprojectImageTo3D(InputArray disparity, OutputArray _3dImage, InputArray Q, bool handleMissingValues, int ddepth)"><code class="xref ocv ocv-func docutils literal"><span class="pre">reprojectImageTo3D()</span></code></a></p>
</div>
</div>
<div class="section" id="fisheye">
<h2>fisheye<a class="headerlink" href="#fisheye" title="Permalink to this headline">¶</a></h2>
<p>The methods in this namespace use a so-called fisheye camera model.</p>
<div class="highlight-cpp"><div class="highlight"><pre><span class="k">namespace</span> <span class="n">fisheye</span>
<span class="p">{</span>
    <span class="c1">//! projects 3D points using fisheye model</span>
    <span class="kt">void</span> <span class="n">projectPoints</span><span class="p">(</span><span class="n">InputArray</span> <span class="n">objectPoints</span><span class="p">,</span> <span class="n">OutputArray</span> <span class="n">imagePoints</span><span class="p">,</span> <span class="k">const</span> <span class="n">Affine3d</span><span class="o">&amp;</span> <span class="n">affine</span><span class="p">,</span>
        <span class="n">InputArray</span> <span class="n">K</span><span class="p">,</span> <span class="n">InputArray</span> <span class="n">D</span><span class="p">,</span> <span class="kt">double</span> <span class="n">alpha</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">OutputArray</span> <span class="n">jacobian</span> <span class="o">=</span> <span class="n">noArray</span><span class="p">());</span>

    <span class="c1">//! projects points using fisheye model</span>
    <span class="kt">void</span> <span class="nf">projectPoints</span><span class="p">(</span><span class="n">InputArray</span> <span class="n">objectPoints</span><span class="p">,</span> <span class="n">OutputArray</span> <span class="n">imagePoints</span><span class="p">,</span> <span class="n">InputArray</span> <span class="n">rvec</span><span class="p">,</span> <span class="n">InputArray</span> <span class="n">tvec</span><span class="p">,</span>
        <span class="n">InputArray</span> <span class="n">K</span><span class="p">,</span> <span class="n">InputArray</span> <span class="n">D</span><span class="p">,</span> <span class="kt">double</span> <span class="n">alpha</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">OutputArray</span> <span class="n">jacobian</span> <span class="o">=</span> <span class="n">noArray</span><span class="p">());</span>

    <span class="c1">//! distorts 2D points using fisheye model</span>
    <span class="kt">void</span> <span class="nf">distortPoints</span><span class="p">(</span><span class="n">InputArray</span> <span class="n">undistorted</span><span class="p">,</span> <span class="n">OutputArray</span> <span class="n">distorted</span><span class="p">,</span> <span class="n">InputArray</span> <span class="n">K</span><span class="p">,</span> <span class="n">InputArray</span> <span class="n">D</span><span class="p">,</span> <span class="kt">double</span> <span class="n">alpha</span> <span class="o">=</span> <span class="mi">0</span><span class="p">);</span>

    <span class="c1">//! undistorts 2D points using fisheye model</span>
    <span class="kt">void</span> <span class="nf">undistortPoints</span><span class="p">(</span><span class="n">InputArray</span> <span class="n">distorted</span><span class="p">,</span> <span class="n">OutputArray</span> <span class="n">undistorted</span><span class="p">,</span>
        <span class="n">InputArray</span> <span class="n">K</span><span class="p">,</span> <span class="n">InputArray</span> <span class="n">D</span><span class="p">,</span> <span class="n">InputArray</span> <span class="n">R</span> <span class="o">=</span> <span class="n">noArray</span><span class="p">(),</span> <span class="n">InputArray</span> <span class="n">P</span>  <span class="o">=</span> <span class="n">noArray</span><span class="p">());</span>

    <span class="c1">//! computing undistortion and rectification maps for image transform by cv::remap()</span>
    <span class="c1">//! If D is empty zero distortion is used, if R or P is empty identity matrixes are used</span>
    <span class="kt">void</span> <span class="nf">initUndistortRectifyMap</span><span class="p">(</span><span class="n">InputArray</span> <span class="n">K</span><span class="p">,</span> <span class="n">InputArray</span> <span class="n">D</span><span class="p">,</span> <span class="n">InputArray</span> <span class="n">R</span><span class="p">,</span> <span class="n">InputArray</span> <span class="n">P</span><span class="p">,</span>
        <span class="k">const</span> <span class="n">cv</span><span class="o">::</span><span class="n">Size</span><span class="o">&amp;</span> <span class="n">size</span><span class="p">,</span> <span class="kt">int</span> <span class="n">m1type</span><span class="p">,</span> <span class="n">OutputArray</span> <span class="n">map1</span><span class="p">,</span> <span class="n">OutputArray</span> <span class="n">map2</span><span class="p">);</span>

    <span class="c1">//! undistorts image, optionally changes resolution and camera matrix.</span>
    <span class="kt">void</span> <span class="nf">undistortImage</span><span class="p">(</span><span class="n">InputArray</span> <span class="n">distorted</span><span class="p">,</span> <span class="n">OutputArray</span> <span class="n">undistorted</span><span class="p">,</span>
        <span class="n">InputArray</span> <span class="n">K</span><span class="p">,</span> <span class="n">InputArray</span> <span class="n">D</span><span class="p">,</span> <span class="n">InputArray</span> <span class="n">Knew</span> <span class="o">=</span> <span class="n">cv</span><span class="o">::</span><span class="n">noArray</span><span class="p">(),</span> <span class="k">const</span> <span class="n">Size</span><span class="o">&amp;</span> <span class="n">new_size</span> <span class="o">=</span> <span class="n">Size</span><span class="p">());</span>

    <span class="c1">//! estimates new camera matrix for undistortion or rectification</span>
    <span class="kt">void</span> <span class="nf">estimateNewCameraMatrixForUndistortRectify</span><span class="p">(</span><span class="n">InputArray</span> <span class="n">K</span><span class="p">,</span> <span class="n">InputArray</span> <span class="n">D</span><span class="p">,</span> <span class="k">const</span> <span class="n">Size</span> <span class="o">&amp;</span><span class="n">image_size</span><span class="p">,</span> <span class="n">InputArray</span> <span class="n">R</span><span class="p">,</span>
        <span class="n">OutputArray</span> <span class="n">P</span><span class="p">,</span> <span class="kt">double</span> <span class="n">balance</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">,</span> <span class="k">const</span> <span class="n">Size</span><span class="o">&amp;</span> <span class="n">new_size</span> <span class="o">=</span> <span class="n">Size</span><span class="p">(),</span> <span class="kt">double</span> <span class="n">fov_scale</span> <span class="o">=</span> <span class="mf">1.0</span><span class="p">);</span>

    <span class="c1">//! performs camera calibaration</span>
    <span class="kt">double</span> <span class="nf">calibrate</span><span class="p">(</span><span class="n">InputArrayOfArrays</span> <span class="n">objectPoints</span><span class="p">,</span> <span class="n">InputArrayOfArrays</span> <span class="n">imagePoints</span><span class="p">,</span> <span class="k">const</span> <span class="n">Size</span><span class="o">&amp;</span> <span class="n">image_size</span><span class="p">,</span>
        <span class="n">InputOutputArray</span> <span class="n">K</span><span class="p">,</span> <span class="n">InputOutputArray</span> <span class="n">D</span><span class="p">,</span> <span class="n">OutputArrayOfArrays</span> <span class="n">rvecs</span><span class="p">,</span> <span class="n">OutputArrayOfArrays</span> <span class="n">tvecs</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
            <span class="n">TermCriteria</span> <span class="n">criteria</span> <span class="o">=</span> <span class="n">TermCriteria</span><span class="p">(</span><span class="n">TermCriteria</span><span class="o">::</span><span class="n">COUNT</span> <span class="o">+</span> <span class="n">TermCriteria</span><span class="o">::</span><span class="n">EPS</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="n">DBL_EPSILON</span><span class="p">));</span>

    <span class="c1">//! stereo rectification estimation</span>
    <span class="kt">void</span> <span class="nf">stereoRectify</span><span class="p">(</span><span class="n">InputArray</span> <span class="n">K1</span><span class="p">,</span> <span class="n">InputArray</span> <span class="n">D1</span><span class="p">,</span> <span class="n">InputArray</span> <span class="n">K2</span><span class="p">,</span> <span class="n">InputArray</span> <span class="n">D2</span><span class="p">,</span> <span class="k">const</span> <span class="n">Size</span> <span class="o">&amp;</span><span class="n">imageSize</span><span class="p">,</span> <span class="n">InputArray</span> <span class="n">R</span><span class="p">,</span> <span class="n">InputArray</span> <span class="n">tvec</span><span class="p">,</span>
        <span class="n">OutputArray</span> <span class="n">R1</span><span class="p">,</span> <span class="n">OutputArray</span> <span class="n">R2</span><span class="p">,</span> <span class="n">OutputArray</span> <span class="n">P1</span><span class="p">,</span> <span class="n">OutputArray</span> <span class="n">P2</span><span class="p">,</span> <span class="n">OutputArray</span> <span class="n">Q</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">,</span> <span class="k">const</span> <span class="n">Size</span> <span class="o">&amp;</span><span class="n">newImageSize</span> <span class="o">=</span> <span class="n">Size</span><span class="p">(),</span>
        <span class="kt">double</span> <span class="n">balance</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">,</span> <span class="kt">double</span> <span class="n">fov_scale</span> <span class="o">=</span> <span class="mf">1.0</span><span class="p">);</span>

    <span class="c1">//! performs stereo calibration</span>
    <span class="kt">double</span> <span class="nf">stereoCalibrate</span><span class="p">(</span><span class="n">InputArrayOfArrays</span> <span class="n">objectPoints</span><span class="p">,</span> <span class="n">InputArrayOfArrays</span> <span class="n">imagePoints1</span><span class="p">,</span> <span class="n">InputArrayOfArrays</span> <span class="n">imagePoints2</span><span class="p">,</span>
                                  <span class="n">InputOutputArray</span> <span class="n">K1</span><span class="p">,</span> <span class="n">InputOutputArray</span> <span class="n">D1</span><span class="p">,</span> <span class="n">InputOutputArray</span> <span class="n">K2</span><span class="p">,</span> <span class="n">InputOutputArray</span> <span class="n">D2</span><span class="p">,</span> <span class="n">Size</span> <span class="n">imageSize</span><span class="p">,</span>
                                  <span class="n">OutputArray</span> <span class="n">R</span><span class="p">,</span> <span class="n">OutputArray</span> <span class="n">T</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span> <span class="o">=</span> <span class="n">CALIB_FIX_INTRINSIC</span><span class="p">,</span>
                                  <span class="n">TermCriteria</span> <span class="n">criteria</span> <span class="o">=</span> <span class="n">TermCriteria</span><span class="p">(</span><span class="n">TermCriteria</span><span class="o">::</span><span class="n">COUNT</span> <span class="o">+</span> <span class="n">TermCriteria</span><span class="o">::</span><span class="n">EPS</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="n">DBL_EPSILON</span><span class="p">));</span>
<span class="p">};</span>
</pre></div>
</div>
<p>Definitions:
Let P be a point in 3D of coordinates X in the world reference frame (stored in the matrix X)
The coordinate vector of P in the camera reference frame is:</p>
<dl class="class">
<dt id="center">
<em class="property">class </em><code class="descname">center</code><a class="headerlink" href="#center" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<div class="math">
<p><img src="../../../_images/math/d283fec10bac8881202816230dd457b03ab12d85.png" alt="Xc = R X + T"/></p>
</div><p>where R is the rotation matrix corresponding to the rotation vector om: R = rodrigues(om);
call x, y and z the 3 coordinates of Xc:</p>
<dl class="class">
<dt>
<em class="property">class </em><code class="descname">center</code></dt>
<dd></dd></dl>

<div class="math">
<p><img src="../../../_images/math/1ea8600ba1aa4dfae5b9d6958b6dd518a6bc18e2.png" alt="x = Xc_1 \\
y = Xc_2 \\
z = Xc_3"/></p>
</div><p>The pinehole projection coordinates of P is [a; b] where</p>
<dl class="class">
<dt>
<em class="property">class </em><code class="descname">center</code></dt>
<dd></dd></dl>

<div class="math">
<p><img src="../../../_images/math/15729e731b8044d59241a8343a123e295a8035f8.png" alt="a = x / z \ and \ b = y / z \\
r^2 = a^2 + b^2 \\
\theta = atan(r)"/></p>
</div><p>Fisheye distortion:</p>
<dl class="class">
<dt>
<em class="property">class </em><code class="descname">center</code></dt>
<dd></dd></dl>

<div class="math">
<p><img src="../../../_images/math/2c3567f912bf60b24464f52f4c3ec243c8689a1e.png" alt="\theta_d = \theta (1 + k_1 \theta^2 + k_2 \theta^4 + k_3 \theta^6 + k_4 \theta^8)"/></p>
</div><p>The distorted point coordinates are [x&#8217;; y&#8217;] where</p>
<p>..class:: center
.. math:</p>
<div class="highlight-cpp"><div class="highlight"><pre>x&#39; = (\theta_d / r) x \\
y&#39; = (\theta_d / r) y
</pre></div>
</div>
<p>Finally, conversion into pixel coordinates: The final pixel coordinates vector [u; v] where:</p>
<dl class="class">
<dt>
<em class="property">class </em><code class="descname">center</code></dt>
<dd></dd></dl>

<div class="math">
<p><img src="../../../_images/math/cfdee70c1e4f1a9ec9a087dfa9aeb8b2bb188860.png" alt="u = f_x (x' + \alpha y') + c_x \\
v = f_y yy + c_y"/></p>
</div></div>
<div class="section" id="fisheye-projectpoints">
<h2>fisheye::projectPoints<a class="headerlink" href="#fisheye-projectpoints" title="Permalink to this headline">¶</a></h2>
<p>Projects points using fisheye model</p>
<dl class="function">
<dt id="void fisheye::projectPoints(InputArray objectPoints, OutputArray imagePoints, const Affine3d&amp; affine, InputArray K, InputArray D, double alpha , OutputArray jacobian)">
<strong>C++:</strong><code class="descname"> </code>void <code class="descclassname">fisheye::</code><code class="descname">projectPoints</code><span class="sig-paren">(</span>InputArray <strong>objectPoints</strong>, OutputArray <strong>imagePoints</strong>, const Affine3d&amp; <strong>affine</strong>, InputArray <strong>K</strong>, InputArray <strong>D</strong>, double <strong>alpha</strong>=0, OutputArray <strong>jacobian</strong>=noArray()<span class="sig-paren">)</span><a class="headerlink" href="#void fisheye::projectPoints(InputArray objectPoints, OutputArray imagePoints, const Affine3d& affine, InputArray K, InputArray D, double alpha , OutputArray jacobian)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="void fisheye::projectPoints(InputArray objectPoints, OutputArray imagePoints, InputArray rvec, InputArray tvec, InputArray K, InputArray D, double alpha , OutputArray jacobian)">
<strong>C++:</strong><code class="descname"> </code>void <code class="descclassname">fisheye::</code><code class="descname">projectPoints</code><span class="sig-paren">(</span>InputArray <strong>objectPoints</strong>, OutputArray <strong>imagePoints</strong>, InputArray <strong>rvec</strong>, InputArray <strong>tvec</strong>, InputArray <strong>K</strong>, InputArray <strong>D</strong>, double <strong>alpha</strong>=0, OutputArray <strong>jacobian</strong>=noArray()<span class="sig-paren">)</span><a class="headerlink" href="#void fisheye::projectPoints(InputArray objectPoints, OutputArray imagePoints, InputArray rvec, InputArray tvec, InputArray K, InputArray D, double alpha , OutputArray jacobian)" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>objectPoints</strong> &#8211; Array of object points, 1xN/Nx1 3-channel  (or  <code class="docutils literal"><span class="pre">vector&lt;Point3f&gt;</span></code> ), where N is the number of points in the view.</li>
<li><strong>rvec</strong> &#8211; Rotation vector. See <a class="reference internal" href="#void Rodrigues(InputArray src, OutputArray dst, OutputArray jacobian)" title="void Rodrigues(InputArray src, OutputArray dst, OutputArray jacobian)"><code class="xref ocv ocv-func docutils literal"><span class="pre">Rodrigues()</span></code></a> for details.</li>
<li><strong>tvec</strong> &#8211; Translation vector.</li>
<li><strong>K</strong> &#8211; Camera matrix  <img class="math" src="../../../_images/math/3f8adfb3baa1446e35bead06fcc6d3c752666a82.png" alt="K = \vecthreethree{f_x}{0}{c_x}{0}{f_y}{c_y}{0}{0}{_1}"/>.</li>
<li><strong>D</strong> &#8211; Input vector of distortion coefficients  <img class="math" src="../../../_images/math/18d439093847c70d5d51f29b0b6e8294c0e4b540.png" alt="(k_1, k_2, k_3, k_4)"/>.</li>
<li><strong>alpha</strong> &#8211; The skew coefficient.</li>
<li><strong>imagePoints</strong> &#8211; Output array of image points, 2xN/Nx2 1-channel or 1xN/Nx1 2-channel, or  <code class="docutils literal"><span class="pre">vector&lt;Point2f&gt;</span></code>.</li>
<li><strong>jacobian</strong> &#8211; Optional output 2Nx15 jacobian matrix of derivatives of image points with respect to components of the focal lengths, coordinates of the principal point, distortion coefficients, rotation vector, translation vector, and the skew. In the old interface different components of the jacobian are returned via different output parameters.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<p>The function computes projections of 3D points to the image plane given intrinsic and extrinsic camera parameters. Optionally, the function computes Jacobians - matrices of partial derivatives of image points coordinates (as functions of all the input parameters) with respect to the particular parameters, intrinsic and/or extrinsic.</p>
</div>
<div class="section" id="fisheye-distortpoints">
<h2>fisheye::distortPoints<a class="headerlink" href="#fisheye-distortpoints" title="Permalink to this headline">¶</a></h2>
<p>Distorts 2D points using fisheye model.</p>
<dl class="function">
<dt id="void fisheye::distortPoints(InputArray undistorted, OutputArray distorted, InputArray K, InputArray D, double alpha)">
<strong>C++:</strong><code class="descname"> </code>void <code class="descclassname">fisheye::</code><code class="descname">distortPoints</code><span class="sig-paren">(</span>InputArray <strong>undistorted</strong>, OutputArray <strong>distorted</strong>, InputArray <strong>K</strong>, InputArray <strong>D</strong>, double <strong>alpha</strong>=0<span class="sig-paren">)</span><a class="headerlink" href="#void fisheye::distortPoints(InputArray undistorted, OutputArray distorted, InputArray K, InputArray D, double alpha)" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>undistorted</strong> &#8211; Array of object points, 1xN/Nx1 2-channel  (or  <code class="docutils literal"><span class="pre">vector&lt;Point2f&gt;</span></code> ), where N is the number of points in the view.</li>
<li><strong>K</strong> &#8211; Camera matrix  <img class="math" src="../../../_images/math/3f8adfb3baa1446e35bead06fcc6d3c752666a82.png" alt="K = \vecthreethree{f_x}{0}{c_x}{0}{f_y}{c_y}{0}{0}{_1}"/>.</li>
<li><strong>D</strong> &#8211; Input vector of distortion coefficients  <img class="math" src="../../../_images/math/18d439093847c70d5d51f29b0b6e8294c0e4b540.png" alt="(k_1, k_2, k_3, k_4)"/>.</li>
<li><strong>alpha</strong> &#8211; The skew coefficient.</li>
<li><strong>distorted</strong> &#8211; Output array of image points, 1xN/Nx1 2-channel, or  <code class="docutils literal"><span class="pre">vector&lt;Point2f&gt;</span></code> .</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="fisheye-undistortpoints">
<h2>fisheye::undistortPoints<a class="headerlink" href="#fisheye-undistortpoints" title="Permalink to this headline">¶</a></h2>
<p>Undistorts 2D points using fisheye model</p>
<dl class="function">
<dt id="void fisheye::undistortPoints(InputArray distorted, OutputArray undistorted, InputArray K, InputArray D, InputArray R , InputArray P)">
<strong>C++:</strong><code class="descname"> </code>void <code class="descclassname">fisheye::</code><code class="descname">undistortPoints</code><span class="sig-paren">(</span>InputArray <strong>distorted</strong>, OutputArray <strong>undistorted</strong>, InputArray <strong>K</strong>, InputArray <strong>D</strong>, InputArray <strong>R</strong>=noArray(), InputArray <strong>P</strong>=noArray()<span class="sig-paren">)</span><a class="headerlink" href="#void fisheye::undistortPoints(InputArray distorted, OutputArray undistorted, InputArray K, InputArray D, InputArray R , InputArray P)" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>distorted</strong> &#8211; Array of object points, 1xN/Nx1 2-channel  (or  <code class="docutils literal"><span class="pre">vector&lt;Point2f&gt;</span></code> ), where N is the number of points in the view.</li>
<li><strong>K</strong> &#8211; Camera matrix  <img class="math" src="../../../_images/math/3f8adfb3baa1446e35bead06fcc6d3c752666a82.png" alt="K = \vecthreethree{f_x}{0}{c_x}{0}{f_y}{c_y}{0}{0}{_1}"/>.</li>
<li><strong>D</strong> &#8211; Input vector of distortion coefficients  <img class="math" src="../../../_images/math/18d439093847c70d5d51f29b0b6e8294c0e4b540.png" alt="(k_1, k_2, k_3, k_4)"/>.</li>
<li><strong>R</strong> &#8211; Rectification transformation in the object space: 3x3 1-channel, or vector: 3x1/1x3 1-channel or 1x1 3-channel</li>
<li><strong>P</strong> &#8211; New camera matrix (3x3) or new projection matrix (3x4)</li>
<li><strong>undistorted</strong> &#8211; Output array of image points, 1xN/Nx1 2-channel, or <code class="docutils literal"><span class="pre">vector&lt;Point2f&gt;</span></code> .</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="fisheye-initundistortrectifymap">
<h2>fisheye::initUndistortRectifyMap<a class="headerlink" href="#fisheye-initundistortrectifymap" title="Permalink to this headline">¶</a></h2>
<p>Computes undistortion and rectification maps for image transform by cv::remap(). If D is empty zero distortion is used, if R or P is empty identity matrixes are used.</p>
<dl class="function">
<dt id="void fisheye::initUndistortRectifyMap(InputArray K, InputArray D, InputArray R, InputArray P, const cv::Size&amp; size, int m1type, OutputArray map1, OutputArray map2)">
<strong>C++:</strong><code class="descname"> </code>void <code class="descclassname">fisheye::</code><code class="descname">initUndistortRectifyMap</code><span class="sig-paren">(</span>InputArray <strong>K</strong>, InputArray <strong>D</strong>, InputArray <strong>R</strong>, InputArray <strong>P</strong>, const cv::Size&amp; <strong>size</strong>, int <strong>m1type</strong>, OutputArray <strong>map1</strong>, OutputArray <strong>map2</strong><span class="sig-paren">)</span><a class="headerlink" href="#void fisheye::initUndistortRectifyMap(InputArray K, InputArray D, InputArray R, InputArray P, const cv::Size& size, int m1type, OutputArray map1, OutputArray map2)" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>K</strong> &#8211; Camera matrix  <img class="math" src="../../../_images/math/3f8adfb3baa1446e35bead06fcc6d3c752666a82.png" alt="K = \vecthreethree{f_x}{0}{c_x}{0}{f_y}{c_y}{0}{0}{_1}"/>.</li>
<li><strong>D</strong> &#8211; Input vector of distortion coefficients  <img class="math" src="../../../_images/math/18d439093847c70d5d51f29b0b6e8294c0e4b540.png" alt="(k_1, k_2, k_3, k_4)"/>.</li>
<li><strong>R</strong> &#8211; Rectification transformation in the object space: 3x3 1-channel, or vector: 3x1/1x3 1-channel or 1x1 3-channel</li>
<li><strong>P</strong> &#8211; New camera matrix (3x3) or new projection matrix (3x4)</li>
<li><strong>size</strong> &#8211; Undistorted image size.</li>
<li><strong>m1type</strong> &#8211; Type of the first output map that can be CV_32FC1 or CV_16SC2 . See convertMaps() for details.</li>
<li><strong>map1</strong> &#8211; The first output map.</li>
<li><strong>map2</strong> &#8211; The second output map.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="fisheye-undistortimage">
<h2>fisheye::undistortImage<a class="headerlink" href="#fisheye-undistortimage" title="Permalink to this headline">¶</a></h2>
<p>Transforms an image to compensate for fisheye lens distortion.</p>
<dl class="function">
<dt id="void fisheye::undistortImage(InputArray distorted, OutputArray undistorted, InputArray K, InputArray D, InputArray Knew , const Size&amp; new_size)">
<strong>C++:</strong><code class="descname"> </code>void <code class="descclassname">fisheye::</code><code class="descname">undistortImage</code><span class="sig-paren">(</span>InputArray <strong>distorted</strong>, OutputArray <strong>undistorted</strong>, InputArray <strong>K</strong>, InputArray <strong>D</strong>, InputArray <strong>Knew</strong>=cv::noArray(), const Size&amp; <strong>new_size</strong>=Size()<span class="sig-paren">)</span><a class="headerlink" href="#void fisheye::undistortImage(InputArray distorted, OutputArray undistorted, InputArray K, InputArray D, InputArray Knew , const Size& new_size)" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>distorted</strong> &#8211; image with fisheye lens distortion.</li>
<li><strong>K</strong> &#8211; Camera matrix  <img class="math" src="../../../_images/math/3f8adfb3baa1446e35bead06fcc6d3c752666a82.png" alt="K = \vecthreethree{f_x}{0}{c_x}{0}{f_y}{c_y}{0}{0}{_1}"/>.</li>
<li><strong>D</strong> &#8211; Input vector of distortion coefficients  <img class="math" src="../../../_images/math/18d439093847c70d5d51f29b0b6e8294c0e4b540.png" alt="(k_1, k_2, k_3, k_4)"/>.</li>
<li><strong>Knew</strong> &#8211; Camera matrix of the distorted image. By default, it is the identity matrix but you may additionally scale and shift the result by using a different matrix.</li>
<li><strong>undistorted</strong> &#8211; Output image with compensated fisheye lens distortion.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<p>The function transforms an image to compensate radial and tangential lens distortion.</p>
<p>The function is simply a combination of
<a class="reference internal" href="#void fisheye::initUndistortRectifyMap(InputArray K, InputArray D, InputArray R, InputArray P, const cv::Size&amp; size, int m1type, OutputArray map1, OutputArray map2)" title="void fisheye::initUndistortRectifyMap(InputArray K, InputArray D, InputArray R, InputArray P, const cv::Size&amp; size, int m1type, OutputArray map1, OutputArray map2)"><code class="xref ocv ocv-func docutils literal"><span class="pre">fisheye::initUndistortRectifyMap()</span></code></a> (with unity <code class="docutils literal"><span class="pre">R</span></code> ) and
<a class="reference internal" href="../../imgproc/doc/geometric_transformations.html#void remap(InputArray src, OutputArray dst, InputArray map1, InputArray map2, int interpolation, int borderMode, const Scalar&amp; borderValue)" title="void remap(InputArray src, OutputArray dst, InputArray map1, InputArray map2, int interpolation, int borderMode, const Scalar&amp; borderValue)"><code class="xref ocv ocv-func docutils literal"><span class="pre">remap()</span></code></a> (with bilinear interpolation). See the former function for details of the transformation being performed.</p>
<dl class="docutils">
<dt>See below the results of undistortImage.</dt>
<dd><ul class="first last simple">
<li>a) result of <a class="reference internal" href="../../imgproc/doc/geometric_transformations.html#void undistort(InputArray src, OutputArray dst, InputArray cameraMatrix, InputArray distCoeffs, InputArray newCameraMatrix)" title="void undistort(InputArray src, OutputArray dst, InputArray cameraMatrix, InputArray distCoeffs, InputArray newCameraMatrix)"><code class="xref ocv ocv-func docutils literal"><span class="pre">undistort()</span></code></a> of perspective camera model (all possible coefficients (k_1, k_2, k_3, k_4, k_5, k_6) of distortion were optimized under calibration)</li>
<li>b) result of <a class="reference internal" href="#void fisheye::undistortImage(InputArray distorted, OutputArray undistorted, InputArray K, InputArray D, InputArray Knew , const Size&amp; new_size)" title="void fisheye::undistortImage(InputArray distorted, OutputArray undistorted, InputArray K, InputArray D, InputArray Knew , const Size&amp; new_size)"><code class="xref ocv ocv-func docutils literal"><span class="pre">fisheye::undistortImage()</span></code></a> of fisheye camera model (all possible coefficients (k_1, k_2, k_3, k_4) of fisheye distortion were optimized under calibration)</li>
<li>c) original image was captured with fisheye lens</li>
</ul>
</dd>
</dl>
<p>Pictures a) and b) almost the same. But if we consider points of image located far from the center of image, we can notice that on image a) these points are distorted.</p>
<img alt="../../../_images/fisheye_undistorted.jpg" src="../../../_images/fisheye_undistorted.jpg" />
</div>
<div class="section" id="fisheye-estimatenewcameramatrixforundistortrectify">
<h2>fisheye::estimateNewCameraMatrixForUndistortRectify<a class="headerlink" href="#fisheye-estimatenewcameramatrixforundistortrectify" title="Permalink to this headline">¶</a></h2>
<p>Estimates new camera matrix for undistortion or rectification.</p>
<dl class="function">
<dt id="void fisheye::estimateNewCameraMatrixForUndistortRectify(InputArray K, InputArray D, const Size &amp;image_size, InputArray R, OutputArray P, double balance , const Size&amp; new_size , double fov_scale)">
<strong>C++:</strong><code class="descname"> </code>void <code class="descclassname">fisheye::</code><code class="descname">estimateNewCameraMatrixForUndistortRectify</code><span class="sig-paren">(</span>InputArray <strong>K</strong>, InputArray <strong>D</strong>, const Size&amp; <strong>image_size</strong>, InputArray <strong>R</strong>, OutputArray <strong>P</strong>, double <strong>balance</strong>=0.0, const Size&amp; <strong>new_size</strong>=Size(), double <strong>fov_scale</strong>=1.0<span class="sig-paren">)</span><a class="headerlink" href="#void fisheye::estimateNewCameraMatrixForUndistortRectify(InputArray K, InputArray D, const Size &image_size, InputArray R, OutputArray P, double balance , const Size& new_size , double fov_scale)" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>K</strong> &#8211; Camera matrix  <img class="math" src="../../../_images/math/3f8adfb3baa1446e35bead06fcc6d3c752666a82.png" alt="K = \vecthreethree{f_x}{0}{c_x}{0}{f_y}{c_y}{0}{0}{_1}"/>.</li>
<li><strong>D</strong> &#8211; Input vector of distortion coefficients  <img class="math" src="../../../_images/math/18d439093847c70d5d51f29b0b6e8294c0e4b540.png" alt="(k_1, k_2, k_3, k_4)"/>.</li>
<li><strong>R</strong> &#8211; Rectification transformation in the object space: 3x3 1-channel, or vector: 3x1/1x3 1-channel or 1x1 3-channel</li>
<li><strong>P</strong> &#8211; New camera matrix (3x3) or new projection matrix (3x4)</li>
<li><strong>balance</strong> &#8211; Sets the new focal length in range between the min focal length and the max focal length. Balance is in range of [0, 1].</li>
<li><strong>fov_scale</strong> &#8211; Divisor for new focal length.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="fisheye-stereorectify">
<h2>fisheye::stereoRectify<a class="headerlink" href="#fisheye-stereorectify" title="Permalink to this headline">¶</a></h2>
<p>Stereo rectification for fisheye camera model</p>
<dl class="function">
<dt id="void fisheye::stereoRectify(InputArray K1, InputArray D1, InputArray K2, InputArray D2, const Size &amp;imageSize, InputArray R, InputArray tvec, OutputArray R1, OutputArray R2, OutputArray P1, OutputArray P2, OutputArray Q, int flags, const Size &amp;newImageSize , double balance , double fov_scale)">
<strong>C++:</strong><code class="descname"> </code>void <code class="descclassname">fisheye::</code><code class="descname">stereoRectify</code><span class="sig-paren">(</span>InputArray <strong>K1</strong>, InputArray <strong>D1</strong>, InputArray <strong>K2</strong>, InputArray <strong>D2</strong>, const Size&amp; <strong>imageSize</strong>, InputArray <strong>R</strong>, InputArray <strong>tvec</strong>, OutputArray <strong>R1</strong>, OutputArray <strong>R2</strong>, OutputArray <strong>P1</strong>, OutputArray <strong>P2</strong>, OutputArray <strong>Q</strong>, int <strong>flags</strong>, const Size&amp; <strong>newImageSize</strong>=Size(), double <strong>balance</strong>=0.0, double <strong>fov_scale</strong>=1.0<span class="sig-paren">)</span><a class="headerlink" href="#void fisheye::stereoRectify(InputArray K1, InputArray D1, InputArray K2, InputArray D2, const Size &imageSize, InputArray R, InputArray tvec, OutputArray R1, OutputArray R2, OutputArray P1, OutputArray P2, OutputArray Q, int flags, const Size &newImageSize , double balance , double fov_scale)" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>K1</strong> &#8211; First camera matrix.</li>
<li><strong>K2</strong> &#8211; Second camera matrix.</li>
<li><strong>D1</strong> &#8211; First camera distortion parameters.</li>
<li><strong>D2</strong> &#8211; Second camera distortion parameters.</li>
<li><strong>imageSize</strong> &#8211; Size of the image used for stereo calibration.</li>
<li><strong>rotation</strong> &#8211; Rotation matrix between the coordinate systems of the first and the second cameras.</li>
<li><strong>tvec</strong> &#8211; Translation vector between coordinate systems of the cameras.</li>
<li><strong>R1</strong> &#8211; Output  3x3 rectification transform (rotation matrix) for the first camera.</li>
<li><strong>R2</strong> &#8211; Output  3x3 rectification transform (rotation matrix) for the second camera.</li>
<li><strong>P1</strong> &#8211; Output  3x4 projection matrix in the new (rectified) coordinate systems for the first camera.</li>
<li><strong>P2</strong> &#8211; Output  3x4 projection matrix in the new (rectified) coordinate systems for the second camera.</li>
<li><strong>Q</strong> &#8211; Output  <img class="math" src="../../../_images/math/96754e424b2a8b15b1a9dba38a6ffde5cb0e50a8.png" alt="4 \times 4"/>  disparity-to-depth mapping matrix (see  <a class="reference internal" href="#void reprojectImageTo3D(InputArray disparity, OutputArray _3dImage, InputArray Q, bool handleMissingValues, int ddepth)" title="void reprojectImageTo3D(InputArray disparity, OutputArray _3dImage, InputArray Q, bool handleMissingValues, int ddepth)"><code class="xref ocv ocv-func docutils literal"><span class="pre">reprojectImageTo3D()</span></code></a> ).</li>
<li><strong>flags</strong> &#8211; Operation flags that may be zero or  <code class="docutils literal"><span class="pre">CV_CALIB_ZERO_DISPARITY</span></code> . If the flag is set, the function makes the principal points of each camera have the same pixel coordinates in the rectified views. And if the flag is not set, the function may still shift the images in the horizontal or vertical direction (depending on the orientation of epipolar lines) to maximize the useful image area.</li>
<li><strong>alpha</strong> &#8211; Free scaling parameter. If it is -1  or absent, the function performs the default scaling. Otherwise, the parameter should be between 0 and 1.  <code class="docutils literal"><span class="pre">alpha=0</span></code>  means that the rectified images are zoomed and shifted so that only valid pixels are visible (no black areas after rectification).  <code class="docutils literal"><span class="pre">alpha=1</span></code>  means that the rectified image is decimated and shifted so that all the pixels from the original images from the cameras are retained in the rectified images (no source image pixels are lost). Obviously, any intermediate value yields an intermediate result between those two extreme cases.</li>
<li><strong>newImageSize</strong> &#8211; New image resolution after rectification. The same size should be passed to  <a class="reference internal" href="../../imgproc/doc/geometric_transformations.html#void initUndistortRectifyMap(InputArray cameraMatrix, InputArray distCoeffs, InputArray R, InputArray newCameraMatrix, Size size, int m1type, OutputArray map1, OutputArray map2)" title="void initUndistortRectifyMap(InputArray cameraMatrix, InputArray distCoeffs, InputArray R, InputArray newCameraMatrix, Size size, int m1type, OutputArray map1, OutputArray map2)"><code class="xref ocv ocv-func docutils literal"><span class="pre">initUndistortRectifyMap()</span></code></a> (see the  <code class="docutils literal"><span class="pre">stereo_calib.cpp</span></code>  sample in OpenCV samples directory). When (0,0) is passed (default), it is set to the original  <code class="docutils literal"><span class="pre">imageSize</span></code> . Setting it to larger value can help you preserve details in the original image, especially when there is a big radial distortion.</li>
<li><strong>roi1</strong> &#8211; Optional output rectangles inside the rectified images where all the pixels are valid. If  <code class="docutils literal"><span class="pre">alpha=0</span></code> , the ROIs cover the whole images. Otherwise, they are likely to be smaller (see the picture below).</li>
<li><strong>roi2</strong> &#8211; Optional output rectangles inside the rectified images where all the pixels are valid. If  <code class="docutils literal"><span class="pre">alpha=0</span></code> , the ROIs cover the whole images. Otherwise, they are likely to be smaller (see the picture below).</li>
<li><strong>balance</strong> &#8211; Sets the new focal length in range between the min focal length and the max focal length. Balance is in range of [0, 1].</li>
<li><strong>fov_scale</strong> &#8211; Divisor for new focal length.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="fisheye-calibrate">
<h2>fisheye::calibrate<a class="headerlink" href="#fisheye-calibrate" title="Permalink to this headline">¶</a></h2>
<p>Performs camera calibaration</p>
<dl class="function">
<dt id="double fisheye::calibrate(InputArrayOfArrays objectPoints, InputArrayOfArrays imagePoints, const Size&amp; image_size, InputOutputArray K, InputOutputArray D, OutputArrayOfArrays rvecs, OutputArrayOfArrays tvecs, int flags , TermCriteria criteria)">
<strong>C++:</strong><code class="descname"> </code>double <code class="descclassname">fisheye::</code><code class="descname">calibrate</code><span class="sig-paren">(</span>InputArrayOfArrays <strong>objectPoints</strong>, InputArrayOfArrays <strong>imagePoints</strong>, const Size&amp; <strong>image_size</strong>, InputOutputArray <strong>K</strong>, InputOutputArray <strong>D</strong>, OutputArrayOfArrays <strong>rvecs</strong>, OutputArrayOfArrays <strong>tvecs</strong>, int <strong>flags</strong>=0, TermCriteria <strong>criteria</strong>=TermCriteria(TermCriteria::COUNT + TermCriteria::EPS, 100, DBL_EPSILON)<span class="sig-paren">)</span><a class="headerlink" href="#double fisheye::calibrate(InputArrayOfArrays objectPoints, InputArrayOfArrays imagePoints, const Size& image_size, InputOutputArray K, InputOutputArray D, OutputArrayOfArrays rvecs, OutputArrayOfArrays tvecs, int flags , TermCriteria criteria)" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>objectPoints</strong> &#8211; vector of vectors of calibration pattern points in the calibration pattern coordinate space.</li>
<li><strong>imagePoints</strong> &#8211; vector of vectors of the projections of calibration pattern points. <code class="docutils literal"><span class="pre">imagePoints.size()</span></code> and <code class="docutils literal"><span class="pre">objectPoints.size()</span></code> and <code class="docutils literal"><span class="pre">imagePoints[i].size()</span></code> must be equal to <code class="docutils literal"><span class="pre">objectPoints[i].size()</span></code> for each <code class="docutils literal"><span class="pre">i</span></code>.</li>
<li><strong>image_size</strong> &#8211; Size of the image used only to initialize the intrinsic camera matrix.</li>
<li><strong>K</strong> &#8211; Output 3x3 floating-point camera matrix  <img class="math" src="../../../_images/math/5017fc06df8951eb2ca115915d52e6fe6d8034de.png" alt="A = \vecthreethree{f_x}{0}{c_x}{0}{f_y}{c_y}{0}{0}{1}"/> . If  <code class="docutils literal"><span class="pre">fisheye::CALIB_USE_INTRINSIC_GUESS</span></code>/ is specified, some or all of  <code class="docutils literal"><span class="pre">fx,</span> <span class="pre">fy,</span> <span class="pre">cx,</span> <span class="pre">cy</span></code>  must be initialized before calling the function.</li>
<li><strong>D</strong> &#8211; Output vector of distortion coefficients  <img class="math" src="../../../_images/math/18d439093847c70d5d51f29b0b6e8294c0e4b540.png" alt="(k_1, k_2, k_3, k_4)"/>.</li>
<li><strong>rvecs</strong> &#8211; Output  vector  of rotation vectors (see  <a class="reference internal" href="#void Rodrigues(InputArray src, OutputArray dst, OutputArray jacobian)" title="void Rodrigues(InputArray src, OutputArray dst, OutputArray jacobian)"><code class="xref ocv ocv-func docutils literal"><span class="pre">Rodrigues()</span></code></a> ) estimated for each pattern view. That is, each k-th rotation vector together with the corresponding k-th translation vector (see the next output parameter description) brings the calibration pattern from the model coordinate space (in which object points are specified) to the world coordinate space, that is, a real position of the calibration pattern in the k-th pattern view (k=0.. <em>M</em> -1).</li>
<li><strong>tvecs</strong> &#8211; Output vector of translation vectors estimated for each pattern view.</li>
<li><strong>flags</strong> &#8211; <p>Different flags that may be zero or a combination of the following values:</p>
<ul>
<li><strong>fisheye::CALIB_USE_INTRINSIC_GUESS</strong> <code class="docutils literal"><span class="pre">cameraMatrix</span></code>  contains valid initial values of  <code class="docutils literal"><span class="pre">fx,</span> <span class="pre">fy,</span> <span class="pre">cx,</span> <span class="pre">cy</span></code>  that are optimized further. Otherwise, <code class="docutils literal"><span class="pre">(cx,</span> <span class="pre">cy)</span></code>  is initially set to the image center ( <code class="docutils literal"><span class="pre">imageSize</span></code>  is used), and focal distances are computed in a least-squares fashion.</li>
<li><strong>fisheye::CALIB_RECOMPUTE_EXTRINSIC</strong> Extrinsic will be recomputed after each iteration of intrinsic optimization.</li>
<li><strong>fisheye::CALIB_CHECK_COND</strong> The functions will check validity of condition number.</li>
<li><strong>fisheye::CALIB_FIX_SKEW</strong> Skew coefficient (alpha) is set to zero and stay zero.</li>
<li><strong>fisheye::CALIB_FIX_K1..4</strong> Selected distortion coefficients are set to zeros and stay zero.</li>
</ul>
</li>
<li><strong>criteria</strong> &#8211; Termination criteria for the iterative optimization algorithm.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="fisheye-stereocalibrate">
<h2>fisheye::stereoCalibrate<a class="headerlink" href="#fisheye-stereocalibrate" title="Permalink to this headline">¶</a></h2>
<p>Performs stereo calibration</p>
<dl class="function">
<dt id="double fisheye::stereoCalibrate(InputArrayOfArrays objectPoints, InputArrayOfArrays imagePoints1, InputArrayOfArrays imagePoints2, InputOutputArray K1, InputOutputArray D1, InputOutputArray K2, InputOutputArray D2, Size imageSize, OutputArray R, OutputArray T, int flags , TermCriteria criteria)">
<strong>C++:</strong><code class="descname"> </code>double <code class="descclassname">fisheye::</code><code class="descname">stereoCalibrate</code><span class="sig-paren">(</span>InputArrayOfArrays <strong>objectPoints</strong>, InputArrayOfArrays <strong>imagePoints1</strong>, InputArrayOfArrays <strong>imagePoints2</strong>, InputOutputArray <strong>K1</strong>, InputOutputArray <strong>D1</strong>, InputOutputArray <strong>K2</strong>, InputOutputArray <strong>D2</strong>, Size <strong>imageSize</strong>, OutputArray <strong>R</strong>, OutputArray <strong>T</strong>, int <strong>flags</strong>=CALIB_FIX_INTRINSIC, TermCriteria <strong>criteria</strong>=TermCriteria(TermCriteria::COUNT + TermCriteria::EPS, 100, DBL_EPSILON)<span class="sig-paren">)</span><a class="headerlink" href="#double fisheye::stereoCalibrate(InputArrayOfArrays objectPoints, InputArrayOfArrays imagePoints1, InputArrayOfArrays imagePoints2, InputOutputArray K1, InputOutputArray D1, InputOutputArray K2, InputOutputArray D2, Size imageSize, OutputArray R, OutputArray T, int flags , TermCriteria criteria)" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>objectPoints</strong> &#8211; Vector of vectors of the calibration pattern points.</li>
<li><strong>imagePoints1</strong> &#8211; Vector of vectors of the projections of the calibration pattern points, observed by the first camera.</li>
<li><strong>imagePoints2</strong> &#8211; Vector of vectors of the projections of the calibration pattern points, observed by the second camera.</li>
<li><strong>K1</strong> &#8211; Input/output first camera matrix:  <img class="math" src="../../../_images/math/5ee676b6ee878edfbf911dbae8728c10904b1f96.png" alt="\vecthreethree{f_x^{(j)}}{0}{c_x^{(j)}}{0}{f_y^{(j)}}{c_y^{(j)}}{0}{0}{1}"/> , <img class="math" src="../../../_images/math/0d57eaca449f2cca6adfbdad206557639791b400.png" alt="j = 0,\, 1"/> . If any of  <code class="docutils literal"><span class="pre">fisheye::CALIB_USE_INTRINSIC_GUESS</span></code> , <code class="docutils literal"><span class="pre">fisheye::CV_CALIB_FIX_INTRINSIC</span></code> are specified, some or all of the matrix components must be initialized.</li>
<li><strong>D1</strong> &#8211; Input/output vector of distortion coefficients  <img class="math" src="../../../_images/math/18d439093847c70d5d51f29b0b6e8294c0e4b540.png" alt="(k_1, k_2, k_3, k_4)"/>  of 4 elements.</li>
<li><strong>K2</strong> &#8211; Input/output second camera matrix. The parameter is similar to <code class="docutils literal"><span class="pre">K1</span></code> .</li>
<li><strong>D2</strong> &#8211; Input/output lens distortion coefficients for the second camera. The parameter is similar to  <code class="docutils literal"><span class="pre">D1</span></code> .</li>
<li><strong>imageSize</strong> &#8211; Size of the image used only to initialize intrinsic camera matrix.</li>
<li><strong>R</strong> &#8211; Output rotation matrix between the 1st and the 2nd camera coordinate systems.</li>
<li><strong>T</strong> &#8211; Output translation vector between the coordinate systems of the cameras.</li>
<li><strong>flags</strong> &#8211; <p>Different flags that may be zero or a combination of the following values:</p>
<ul>
<li><strong>fisheye::CV_CALIB_FIX_INTRINSIC</strong> Fix <code class="docutils literal"><span class="pre">K1,</span> <span class="pre">K2?</span></code> and <code class="docutils literal"><span class="pre">D1,</span> <span class="pre">D2?</span></code> so that only <code class="docutils literal"><span class="pre">R,</span> <span class="pre">T</span></code> matrices are estimated.</li>
<li><strong>fisheye::CALIB_USE_INTRINSIC_GUESS</strong> <code class="docutils literal"><span class="pre">K1,</span> <span class="pre">K2</span></code> contains valid initial values of <code class="docutils literal"><span class="pre">fx,</span> <span class="pre">fy,</span> <span class="pre">cx,</span> <span class="pre">cy</span></code> that are optimized further. Otherwise, <code class="docutils literal"><span class="pre">(cx,</span> <span class="pre">cy)</span></code> is initially set to the image center (<code class="docutils literal"><span class="pre">imageSize</span></code> is used), and focal distances are computed in a least-squares fashion.</li>
<li><strong>fisheye::CALIB_RECOMPUTE_EXTRINSIC</strong> Extrinsic will be recomputed after each iteration of intrinsic optimization.</li>
<li><strong>fisheye::CALIB_CHECK_COND</strong> The functions will check validity of condition number.</li>
<li><strong>fisheye::CALIB_FIX_SKEW</strong> Skew coefficient (alpha) is set to zero and stay zero.</li>
<li><strong>fisheye::CALIB_FIX_K1..4</strong> Selected distortion coefficients are set to zeros and stay zero.</li>
</ul>
</li>
<li><strong>criteria</strong> &#8211; Termination criteria for the iterative optimization algorithm.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<table class="docutils citation" frame="void" id="bt98" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id6">[BT98]</a></td><td>Birchfield, S. and Tomasi, C. A pixel dissimilarity measure that is insensitive to image sampling. IEEE Transactions on Pattern Analysis and Machine Intelligence. 1998.</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="bouguetmct" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id2">[BouguetMCT]</a></td><td>J.Y.Bouguet. MATLAB calibration tool. <a class="reference external" href="http://www.vision.caltech.edu/bouguetj/calib_doc/">http://www.vision.caltech.edu/bouguetj/calib_doc/</a></td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="hartley99" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id7">[Hartley99]</a></td><td>Hartley, R.I., Theory and Practice of Projective Rectification. IJCV 35 2, pp 115-127 (1999)</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="hh08" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id5">[HH08]</a></td><td>Hirschmuller, H. Stereo Processing by Semiglobal Matching and Mutual Information, PAMI(30), No. 2, February 2008, pp. 328-341.</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="slabaugh" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[Slabaugh]</td><td><em>(<a class="fn-backref" href="#id3">1</a>, <a class="fn-backref" href="#id4">2</a>)</em> Slabaugh, G.G. Computing Euler angles from a rotation matrix. <a class="reference external" href="http://www.soi.city.ac.uk/~sbbh653/publications/euler.pdf">http://www.soi.city.ac.uk/~sbbh653/publications/euler.pdf</a> (verified: 2013-04-15)</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="zhang2000" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id1">[Zhang2000]</a></td><td><ol class="first last upperalpha simple" start="26">
<li>Zhang. A Flexible New Technique for Camera Calibration. IEEE Transactions on Pattern Analysis and Machine Intelligence, 22(11):1330-1334, 2000.</li>
</ol>
</td></tr>
</tbody>
</table>
</div>
</div>


          </div>
          <div class="feedback">
              <h2>Help and Feedback</h2>
              You did not find what you were looking for?
              <ul>
                  
                  
                  
                  <li>Ask a question on the <a href="http://answers.opencv.org">Q&A forum</a>.</li>
                  <li>If you think something is missing or wrong in the documentation,
                  please file a <a href="http://code.opencv.org">bug report</a>.</li>
              </ul>
          </div>
        </div>
      </div>

      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../../../index.html">
              <img class="logo" src="../../../_static/opencv-logo-white.png" alt="Logo"/>
            </a></p>
<div id="searchbox" style="display: none">
      <form class="search" action="../../../search.html" method="get">
      <input type="text" name="q" size="18" />
      <input type="submit" value="Search" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
      </p>
    </form>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
  <h3><a href="../../../index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Camera Calibration and 3D Reconstruction</a><ul>
<li><a class="reference internal" href="#calibratecamera">calibrateCamera</a></li>
<li><a class="reference internal" href="#calibrationmatrixvalues">calibrationMatrixValues</a></li>
<li><a class="reference internal" href="#composert">composeRT</a></li>
<li><a class="reference internal" href="#computecorrespondepilines">computeCorrespondEpilines</a></li>
<li><a class="reference internal" href="#convertpointstohomogeneous">convertPointsToHomogeneous</a></li>
<li><a class="reference internal" href="#convertpointsfromhomogeneous">convertPointsFromHomogeneous</a></li>
<li><a class="reference internal" href="#convertpointshomogeneous">convertPointsHomogeneous</a></li>
<li><a class="reference internal" href="#correctmatches">correctMatches</a></li>
<li><a class="reference internal" href="#decomposeprojectionmatrix">decomposeProjectionMatrix</a></li>
<li><a class="reference internal" href="#drawchessboardcorners">drawChessboardCorners</a></li>
<li><a class="reference internal" href="#findchessboardcorners">findChessboardCorners</a></li>
<li><a class="reference internal" href="#findcirclesgrid">findCirclesGrid</a></li>
<li><a class="reference internal" href="#solvepnp">solvePnP</a></li>
<li><a class="reference internal" href="#solvepnpransac">solvePnPRansac</a></li>
<li><a class="reference internal" href="#findfundamentalmat">findFundamentalMat</a></li>
<li><a class="reference internal" href="#findhomography">findHomography</a></li>
<li><a class="reference internal" href="#estimateaffine3d">estimateAffine3D</a></li>
<li><a class="reference internal" href="#filterspeckles">filterSpeckles</a></li>
<li><a class="reference internal" href="#getoptimalnewcameramatrix">getOptimalNewCameraMatrix</a></li>
<li><a class="reference internal" href="#initcameramatrix2d">initCameraMatrix2D</a></li>
<li><a class="reference internal" href="#matmulderiv">matMulDeriv</a></li>
<li><a class="reference internal" href="#projectpoints">projectPoints</a></li>
<li><a class="reference internal" href="#reprojectimageto3d">reprojectImageTo3D</a></li>
<li><a class="reference internal" href="#rqdecomp3x3">RQDecomp3x3</a></li>
<li><a class="reference internal" href="#rodrigues">Rodrigues</a></li>
<li><a class="reference internal" href="#stereobm">StereoBM</a></li>
<li><a class="reference internal" href="#stereobm-stereobm">StereoBM::StereoBM</a></li>
<li><a class="reference internal" href="#stereobm-operator">StereoBM::operator()</a></li>
<li><a class="reference internal" href="#stereosgbm">StereoSGBM</a></li>
<li><a class="reference internal" href="#stereosgbm-stereosgbm">StereoSGBM::StereoSGBM</a></li>
<li><a class="reference internal" href="#stereosgbm-operator">StereoSGBM::operator ()</a></li>
<li><a class="reference internal" href="#stereocalibrate">stereoCalibrate</a></li>
<li><a class="reference internal" href="#stereorectify">stereoRectify</a></li>
<li><a class="reference internal" href="#stereorectifyuncalibrated">stereoRectifyUncalibrated</a></li>
<li><a class="reference internal" href="#triangulatepoints">triangulatePoints</a></li>
<li><a class="reference internal" href="#fisheye">fisheye</a></li>
<li><a class="reference internal" href="#fisheye-projectpoints">fisheye::projectPoints</a></li>
<li><a class="reference internal" href="#fisheye-distortpoints">fisheye::distortPoints</a></li>
<li><a class="reference internal" href="#fisheye-undistortpoints">fisheye::undistortPoints</a></li>
<li><a class="reference internal" href="#fisheye-initundistortrectifymap">fisheye::initUndistortRectifyMap</a></li>
<li><a class="reference internal" href="#fisheye-undistortimage">fisheye::undistortImage</a></li>
<li><a class="reference internal" href="#fisheye-estimatenewcameramatrixforundistortrectify">fisheye::estimateNewCameraMatrixForUndistortRectify</a></li>
<li><a class="reference internal" href="#fisheye-stereorectify">fisheye::stereoRectify</a></li>
<li><a class="reference internal" href="#fisheye-calibrate">fisheye::calibrate</a></li>
<li><a class="reference internal" href="#fisheye-stereocalibrate">fisheye::stereoCalibrate</a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="calib3d.html"
                        title="previous chapter">calib3d. Camera Calibration and 3D Reconstruction</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="../../features2d/doc/features2d.html"
                        title="next chapter">features2d. 2D Features Framework</a></p>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../../../_sources/modules/calib3d/doc/camera_calibration_and_3d_reconstruction.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../features2d/doc/features2d.html" title="features2d. 2D Features Framework"
             >next</a> |</li>
        <li class="right" >
          <a href="calib3d.html" title="calib3d. Camera Calibration and 3D Reconstruction"
             >previous</a> |</li>
        <li><a href="../../../index.html">OpenCV 2.4.13.7 documentation</a> &raquo;</li>
          <li><a href="../../refman.html" >OpenCV API Reference</a> &raquo;</li>
          <li><a href="calib3d.html" >calib3d. Camera Calibration and 3D Reconstruction</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2011-2014, opencv dev team.
      Last updated on Jul 12, 2018.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.3.6.
    </div>
  </body>
</html>
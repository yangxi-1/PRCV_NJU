<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<script type="text/javascript">

  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-33108845-1']);
  _gaq.push(['_setDomainName', 'opencv.org']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();

</script>

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Camera Calibration and 3D Reconstruction &mdash; OpenCV 2.4.13.7 documentation</title>
    <link rel="stylesheet" href="../../../_static/default.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../../',
        VERSION:     '2.4.13.7',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../../_static/doctools.js"></script>
    <link rel="top" title="OpenCV 2.4.13.7 documentation" href="../../../index.html" />
    <link rel="up" title="gpu. GPU-accelerated Computer Vision" href="gpu.html" />
    <link rel="next" title="Video Analysis" href="video.html" />
    <link rel="prev" title="Image Filtering" href="image_filtering.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="video.html" title="Video Analysis"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="image_filtering.html" title="Image Filtering"
             accesskey="P">previous</a> |</li>
        <li><a href="../../../index.html">OpenCV 2.4.13.7 documentation</a> &raquo;</li>
          <li><a href="../../refman.html" >OpenCV API Reference</a> &raquo;</li>
          <li><a href="gpu.html" accesskey="U">gpu. GPU-accelerated Computer Vision</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
  
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="camera-calibration-and-3d-reconstruction">
<h1>Camera Calibration and 3D Reconstruction<a class="headerlink" href="#camera-calibration-and-3d-reconstruction" title="Permalink to this headline">¶</a></h1>
<div class="section" id="gpu-stereobm-gpu">
<h2>gpu::StereoBM_GPU<a class="headerlink" href="#gpu-stereobm-gpu" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="gpu::StereoBM_GPU">
<em class="property">class </em><code class="descclassname">gpu::</code><code class="descname">StereoBM_GPU</code><a class="headerlink" href="#gpu::StereoBM_GPU" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p>Class computing stereo correspondence (disparity map) using the block matching algorithm.</p>
<div class="highlight-cpp"><div class="highlight"><pre><span class="k">class</span> <span class="nc">StereoBM_GPU</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="k">enum</span> <span class="p">{</span> <span class="n">BASIC_PRESET</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">PREFILTER_XSOBEL</span> <span class="o">=</span> <span class="mi">1</span> <span class="p">};</span>

    <span class="k">enum</span> <span class="p">{</span> <span class="n">DEFAULT_NDISP</span> <span class="o">=</span> <span class="mi">64</span><span class="p">,</span> <span class="n">DEFAULT_WINSZ</span> <span class="o">=</span> <span class="mi">19</span> <span class="p">};</span>

    <span class="n">StereoBM_GPU</span><span class="p">();</span>
    <span class="n">StereoBM_GPU</span><span class="p">(</span><span class="kt">int</span> <span class="n">preset</span><span class="p">,</span> <span class="kt">int</span> <span class="n">ndisparities</span> <span class="o">=</span> <span class="n">DEFAULT_NDISP</span><span class="p">,</span>
                 <span class="kt">int</span> <span class="n">winSize</span> <span class="o">=</span> <span class="n">DEFAULT_WINSZ</span><span class="p">);</span>

    <span class="kt">void</span> <span class="nf">operator</span><span class="p">()</span> <span class="p">(</span><span class="k">const</span> <span class="n">GpuMat</span><span class="o">&amp;</span> <span class="n">left</span><span class="p">,</span> <span class="k">const</span> <span class="n">GpuMat</span><span class="o">&amp;</span> <span class="n">right</span><span class="p">,</span>
                     <span class="n">GpuMat</span><span class="o">&amp;</span> <span class="n">disparity</span><span class="p">,</span> <span class="n">Stream</span><span class="o">&amp;</span> <span class="n">stream</span> <span class="o">=</span> <span class="n">Stream</span><span class="o">::</span><span class="n">Null</span><span class="p">());</span>

    <span class="k">static</span> <span class="kt">bool</span> <span class="nf">checkIfGpuCallReasonable</span><span class="p">();</span>

    <span class="kt">int</span> <span class="n">preset</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">ndisp</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">winSize</span><span class="p">;</span>

    <span class="kt">float</span> <span class="n">avergeTexThreshold</span><span class="p">;</span>

    <span class="p">...</span>
<span class="p">};</span>
</pre></div>
</div>
<p>The class also performs pre- and post-filtering steps: Sobel pre-filtering (if <code class="docutils literal"><span class="pre">PREFILTER_XSOBEL</span></code> flag is set) and low textureness filtering (if <code class="docutils literal"><span class="pre">averageTexThreshols</span> <span class="pre">&gt;</span> <span class="pre">0</span></code> ). If <code class="docutils literal"><span class="pre">avergeTexThreshold</span> <span class="pre">=</span> <span class="pre">0</span></code> , low textureness filtering is disabled. Otherwise, the disparity is set to 0 in each point <code class="docutils literal"><span class="pre">(x,</span> <span class="pre">y)</span></code> , where for the left image</p>
<div class="math">
<p><img src="../../../_images/math/bf67124653ef8d65a8846382d71a18a48b722141.png" alt="\sum HorizontalGradiensInWindow(x, y, winSize) &lt; (winSize \cdot winSize) \cdot avergeTexThreshold"/></p>
</div><p>This means that the input left image is low textured.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<ul class="last simple">
<li>A basic stereo matching example can be found at opencv_source_code/samples/gpu/stereo_match.cpp</li>
<li>A stereo matching example using several GPU&#8217;s can be found at opencv_source_code/samples/gpu/stereo_multi.cpp</li>
<li>A stereo matching example using several GPU&#8217;s and driver API can be found at opencv_source_code/samples/gpu/driver_api_stereo_multi.cpp</li>
</ul>
</div>
</div>
<div class="section" id="gpu-stereobm-gpu-stereobm-gpu">
<h2>gpu::StereoBM_GPU::StereoBM_GPU<a class="headerlink" href="#gpu-stereobm-gpu-stereobm-gpu" title="Permalink to this headline">¶</a></h2>
<p>Enables <a class="reference internal" href="#gpu::StereoBM_GPU" title="class gpu::StereoBM_GPU"><code class="xref ocv ocv-class docutils literal"><span class="pre">gpu::StereoBM_GPU</span></code></a> constructors.</p>
<dl class="function">
<dt id="gpu::StereoBM_GPU::StereoBM_GPU()">
<strong>C++:</strong><code class="descname"> </code> <code class="descclassname">gpu::StereoBM_GPU::</code><code class="descname">StereoBM_GPU</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#gpu::StereoBM_GPU::StereoBM_GPU()" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="gpu::StereoBM_GPU::StereoBM_GPU(int preset, int ndisparities , int winSize)">
<strong>C++:</strong><code class="descname"> </code> <code class="descclassname">gpu::StereoBM_GPU::</code><code class="descname">StereoBM_GPU</code><span class="sig-paren">(</span>int <strong>preset</strong>, int <strong>ndisparities</strong>=DEFAULT_NDISP, int <strong>winSize</strong>=DEFAULT_WINSZ<span class="sig-paren">)</span><a class="headerlink" href="#gpu::StereoBM_GPU::StereoBM_GPU(int preset, int ndisparities , int winSize)" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>preset</strong> &#8211; <p>Parameter presetting:</p>
<ul>
<li><strong>BASIC_PRESET</strong> Basic mode without pre-processing.</li>
<li><strong>PREFILTER_XSOBEL</strong> Sobel pre-filtering mode.</li>
</ul>
</li>
<li><strong>ndisparities</strong> &#8211; Number of disparities. It must be a multiple of 8 and less or equal to 256.</li>
<li><strong>winSize</strong> &#8211; Block size.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="gpu-stereobm-gpu-operator">
<h2>gpu::StereoBM_GPU::operator ()<a class="headerlink" href="#gpu-stereobm-gpu-operator" title="Permalink to this headline">¶</a></h2>
<p>Enables the stereo correspondence operator that finds the disparity for the specified rectified stereo pair.</p>
<dl class="function">
<dt id="void gpu::StereoBM_GPU::operator ()(const GpuMat&amp; left, const GpuMat&amp; right, GpuMat&amp; disparity, Stream&amp; stream)">
<strong>C++:</strong><code class="descname"> </code>void <code class="descclassname">gpu::StereoBM_GPU::</code><code class="descname">operator()</code><span class="sig-paren">(</span>const GpuMat&amp; <strong>left</strong>, const GpuMat&amp; <strong>right</strong>, GpuMat&amp; <strong>disparity</strong>, Stream&amp; <strong>stream</strong>=Stream::Null()<span class="sig-paren">)</span><a class="headerlink" href="#void gpu::StereoBM_GPU::operator ()(const GpuMat& left, const GpuMat& right, GpuMat& disparity, Stream& stream)" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>left</strong> &#8211; Left image. Only  <code class="docutils literal"><span class="pre">CV_8UC1</span></code>  type is supported.</li>
<li><strong>right</strong> &#8211; Right image with the same size and the same type as the left one.</li>
<li><strong>disparity</strong> &#8211; Output disparity map. It is a  <code class="docutils literal"><span class="pre">CV_8UC1</span></code>  image with the same size as the input images.</li>
<li><strong>stream</strong> &#8211; Stream for the asynchronous version.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="gpu-stereobm-gpu-checkifgpucallreasonable">
<h2>gpu::StereoBM_GPU::checkIfGpuCallReasonable<a class="headerlink" href="#gpu-stereobm-gpu-checkifgpucallreasonable" title="Permalink to this headline">¶</a></h2>
<p>Uses a heuristic method to estimate whether the current GPU is faster than the CPU in this algorithm. It queries the currently active device.</p>
<dl class="function">
<dt id="bool gpu::StereoBM_GPU::checkIfGpuCallReasonable()">
<strong>C++:</strong><code class="descname"> </code>bool <code class="descclassname">gpu::StereoBM_GPU::</code><code class="descname">checkIfGpuCallReasonable</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#bool gpu::StereoBM_GPU::checkIfGpuCallReasonable()" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</div>
<div class="section" id="gpu-stereobeliefpropagation">
<h2>gpu::StereoBeliefPropagation<a class="headerlink" href="#gpu-stereobeliefpropagation" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="gpu::StereoBeliefPropagation">
<em class="property">class </em><code class="descclassname">gpu::</code><code class="descname">StereoBeliefPropagation</code><a class="headerlink" href="#gpu::StereoBeliefPropagation" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p>Class computing stereo correspondence using the belief propagation algorithm.</p>
<div class="highlight-cpp"><div class="highlight"><pre><span class="k">class</span> <span class="nc">StereoBeliefPropagation</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="k">enum</span> <span class="p">{</span> <span class="n">DEFAULT_NDISP</span>  <span class="o">=</span> <span class="mi">64</span> <span class="p">};</span>
    <span class="k">enum</span> <span class="p">{</span> <span class="n">DEFAULT_ITERS</span>  <span class="o">=</span> <span class="mi">5</span>  <span class="p">};</span>
    <span class="k">enum</span> <span class="p">{</span> <span class="n">DEFAULT_LEVELS</span> <span class="o">=</span> <span class="mi">5</span>  <span class="p">};</span>

    <span class="k">static</span> <span class="kt">void</span> <span class="nf">estimateRecommendedParams</span><span class="p">(</span><span class="kt">int</span> <span class="n">width</span><span class="p">,</span> <span class="kt">int</span> <span class="n">height</span><span class="p">,</span>
        <span class="kt">int</span><span class="o">&amp;</span> <span class="n">ndisp</span><span class="p">,</span> <span class="kt">int</span><span class="o">&amp;</span> <span class="n">iters</span><span class="p">,</span> <span class="kt">int</span><span class="o">&amp;</span> <span class="n">levels</span><span class="p">);</span>

    <span class="k">explicit</span> <span class="nf">StereoBeliefPropagation</span><span class="p">(</span><span class="kt">int</span> <span class="n">ndisp</span> <span class="o">=</span> <span class="n">DEFAULT_NDISP</span><span class="p">,</span>
        <span class="kt">int</span> <span class="n">iters</span>  <span class="o">=</span> <span class="n">DEFAULT_ITERS</span><span class="p">,</span>
        <span class="kt">int</span> <span class="n">levels</span> <span class="o">=</span> <span class="n">DEFAULT_LEVELS</span><span class="p">,</span>
        <span class="kt">int</span> <span class="n">msg_type</span> <span class="o">=</span> <span class="n">CV_32F</span><span class="p">);</span>
    <span class="n">StereoBeliefPropagation</span><span class="p">(</span><span class="kt">int</span> <span class="n">ndisp</span><span class="p">,</span> <span class="kt">int</span> <span class="n">iters</span><span class="p">,</span> <span class="kt">int</span> <span class="n">levels</span><span class="p">,</span>
        <span class="kt">float</span> <span class="n">max_data_term</span><span class="p">,</span> <span class="kt">float</span> <span class="n">data_weight</span><span class="p">,</span>
        <span class="kt">float</span> <span class="n">max_disc_term</span><span class="p">,</span> <span class="kt">float</span> <span class="n">disc_single_jump</span><span class="p">,</span>
        <span class="kt">int</span> <span class="n">msg_type</span> <span class="o">=</span> <span class="n">CV_32F</span><span class="p">);</span>

    <span class="kt">void</span> <span class="nf">operator</span><span class="p">()(</span><span class="k">const</span> <span class="n">GpuMat</span><span class="o">&amp;</span> <span class="n">left</span><span class="p">,</span> <span class="k">const</span> <span class="n">GpuMat</span><span class="o">&amp;</span> <span class="n">right</span><span class="p">,</span>
                    <span class="n">GpuMat</span><span class="o">&amp;</span> <span class="n">disparity</span><span class="p">,</span> <span class="n">Stream</span><span class="o">&amp;</span> <span class="n">stream</span> <span class="o">=</span> <span class="n">Stream</span><span class="o">::</span><span class="n">Null</span><span class="p">());</span>
    <span class="kt">void</span> <span class="nf">operator</span><span class="p">()(</span><span class="k">const</span> <span class="n">GpuMat</span><span class="o">&amp;</span> <span class="n">data</span><span class="p">,</span> <span class="n">GpuMat</span><span class="o">&amp;</span> <span class="n">disparity</span><span class="p">,</span> <span class="n">Stream</span><span class="o">&amp;</span> <span class="n">stream</span> <span class="o">=</span> <span class="n">Stream</span><span class="o">::</span><span class="n">Null</span><span class="p">());</span>

    <span class="kt">int</span> <span class="n">ndisp</span><span class="p">;</span>

    <span class="kt">int</span> <span class="n">iters</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">levels</span><span class="p">;</span>

    <span class="kt">float</span> <span class="n">max_data_term</span><span class="p">;</span>
    <span class="kt">float</span> <span class="n">data_weight</span><span class="p">;</span>
    <span class="kt">float</span> <span class="n">max_disc_term</span><span class="p">;</span>
    <span class="kt">float</span> <span class="n">disc_single_jump</span><span class="p">;</span>

    <span class="kt">int</span> <span class="n">msg_type</span><span class="p">;</span>

    <span class="p">...</span>
<span class="p">};</span>
</pre></div>
</div>
<p>The class implements algorithm described in <a class="reference internal" href="#felzenszwalb2006" id="id1">[Felzenszwalb2006]</a> . It can compute own data cost (using a truncated linear model) or use a user-provided data cost.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p><code class="docutils literal"><span class="pre">StereoBeliefPropagation</span></code> requires a lot of memory for message storage:</p>
<div class="math">
<p><img src="../../../_images/math/294aabb6292cd884f70694f751c425344d76b5b7.png" alt="width \_ step  \cdot height  \cdot ndisp  \cdot 4  \cdot (1 + 0.25)"/></p>
</div><p>and for data cost storage:</p>
<div class="math">
<p><img src="../../../_images/math/10cf1cff96af2cffdf579a06fa2fa64b24216ca1.png" alt="width\_step \cdot height \cdot ndisp \cdot (1 + 0.25 + 0.0625 +  \dotsm + \frac{1}{4^{levels}})"/></p>
</div><p class="last"><code class="docutils literal"><span class="pre">width_step</span></code> is the number of bytes in a line including padding.</p>
</div>
</div>
<div class="section" id="gpu-stereobeliefpropagation-stereobeliefpropagation">
<h2>gpu::StereoBeliefPropagation::StereoBeliefPropagation<a class="headerlink" href="#gpu-stereobeliefpropagation-stereobeliefpropagation" title="Permalink to this headline">¶</a></h2>
<p>Enables the <a class="reference internal" href="#gpu::StereoBeliefPropagation" title="class gpu::StereoBeliefPropagation"><code class="xref ocv ocv-class docutils literal"><span class="pre">gpu::StereoBeliefPropagation</span></code></a> constructors.</p>
<dl class="function">
<dt id="gpu::StereoBeliefPropagation::StereoBeliefPropagation(int ndisp , int iters , int levels , int msg_type)">
<strong>C++:</strong><code class="descname"> </code> <code class="descclassname">gpu::StereoBeliefPropagation::</code><code class="descname">StereoBeliefPropagation</code><span class="sig-paren">(</span>int <strong>ndisp</strong>=DEFAULT_NDISP, int <strong>iters</strong>=DEFAULT_ITERS, int <strong>levels</strong>=DEFAULT_LEVELS, int <strong>msg_type</strong>=CV_32F<span class="sig-paren">)</span><a class="headerlink" href="#gpu::StereoBeliefPropagation::StereoBeliefPropagation(int ndisp , int iters , int levels , int msg_type)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="gpu::StereoBeliefPropagation::StereoBeliefPropagation(int ndisp, int iters, int levels, float max_data_term, float data_weight, float max_disc_term, float disc_single_jump, int msg_type)">
<strong>C++:</strong><code class="descname"> </code> <code class="descclassname">gpu::StereoBeliefPropagation::</code><code class="descname">StereoBeliefPropagation</code><span class="sig-paren">(</span>int <strong>ndisp</strong>, int <strong>iters</strong>, int <strong>levels</strong>, float <strong>max_data_term</strong>, float <strong>data_weight</strong>, float <strong>max_disc_term</strong>, float <strong>disc_single_jump</strong>, int <strong>msg_type</strong>=CV_32F<span class="sig-paren">)</span><a class="headerlink" href="#gpu::StereoBeliefPropagation::StereoBeliefPropagation(int ndisp, int iters, int levels, float max_data_term, float data_weight, float max_disc_term, float disc_single_jump, int msg_type)" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>ndisp</strong> &#8211; Number of disparities.</li>
<li><strong>iters</strong> &#8211; Number of BP iterations on each level.</li>
<li><strong>levels</strong> &#8211; Number of levels.</li>
<li><strong>max_data_term</strong> &#8211; Threshold for data cost truncation.</li>
<li><strong>data_weight</strong> &#8211; Data weight.</li>
<li><strong>max_disc_term</strong> &#8211; Threshold for discontinuity truncation.</li>
<li><strong>disc_single_jump</strong> &#8211; Discontinuity single jump.</li>
<li><strong>msg_type</strong> &#8211; Type for messages.  <code class="docutils literal"><span class="pre">CV_16SC1</span></code>  and  <code class="docutils literal"><span class="pre">CV_32FC1</span></code> types are supported.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<p><code class="docutils literal"><span class="pre">StereoBeliefPropagation</span></code> uses a truncated linear model for the data cost and discontinuity terms:</p>
<div class="math">
<p><img src="../../../_images/math/2f175a6b441383423cc8d58a07eb1e33e37b47d9.png" alt="DataCost = data \_ weight  \cdot \min ( \lvert Img_Left(x,y)-Img_Right(x-d,y)  \rvert , max \_ data \_ term)"/></p>
</div><div class="math">
<p><img src="../../../_images/math/fdcdeea0879f1695066c0b5b73c7a904bf7a623b.png" alt="DiscTerm =  \min (disc \_ single \_ jump  \cdot \lvert f_1-f_2  \rvert , max \_ disc \_ term)"/></p>
</div><p>For more details, see <a class="reference internal" href="#felzenszwalb2006" id="id2">[Felzenszwalb2006]</a>.</p>
<p>By default, <a class="reference internal" href="#gpu::StereoBeliefPropagation" title="class gpu::StereoBeliefPropagation"><code class="xref ocv ocv-class docutils literal"><span class="pre">gpu::StereoBeliefPropagation</span></code></a> uses floating-point arithmetics and the <code class="docutils literal"><span class="pre">CV_32FC1</span></code> type for messages. But it can also use fixed-point arithmetics and the <code class="docutils literal"><span class="pre">CV_16SC1</span></code> message type for better performance. To avoid an overflow in this case, the parameters must satisfy the following requirement:</p>
<div class="math">
<p><img src="../../../_images/math/ca35fe43476448e06dbfdc993587b2f9643a87c3.png" alt="10  \cdot 2^{levels-1}  \cdot max \_ data \_ term &lt; SHRT \_ MAX"/></p>
</div></div>
<div class="section" id="gpu-stereobeliefpropagation-estimaterecommendedparams">
<h2>gpu::StereoBeliefPropagation::estimateRecommendedParams<a class="headerlink" href="#gpu-stereobeliefpropagation-estimaterecommendedparams" title="Permalink to this headline">¶</a></h2>
<p>Uses a heuristic method to compute the recommended parameters ( <code class="docutils literal"><span class="pre">ndisp</span></code>, <code class="docutils literal"><span class="pre">iters</span></code> and <code class="docutils literal"><span class="pre">levels</span></code> ) for the specified image size ( <code class="docutils literal"><span class="pre">width</span></code> and <code class="docutils literal"><span class="pre">height</span></code> ).</p>
<dl class="function">
<dt id="void gpu::StereoBeliefPropagation::estimateRecommendedParams(int width, int height, int&amp; ndisp, int&amp; iters, int&amp; levels)">
<strong>C++:</strong><code class="descname"> </code>void <code class="descclassname">gpu::StereoBeliefPropagation::</code><code class="descname">estimateRecommendedParams</code><span class="sig-paren">(</span>int <strong>width</strong>, int <strong>height</strong>, int&amp; <strong>ndisp</strong>, int&amp; <strong>iters</strong>, int&amp; <strong>levels</strong><span class="sig-paren">)</span><a class="headerlink" href="#void gpu::StereoBeliefPropagation::estimateRecommendedParams(int width, int height, int& ndisp, int& iters, int& levels)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</div>
<div class="section" id="gpu-stereobeliefpropagation-operator">
<h2>gpu::StereoBeliefPropagation::operator ()<a class="headerlink" href="#gpu-stereobeliefpropagation-operator" title="Permalink to this headline">¶</a></h2>
<p>Enables the stereo correspondence operator that finds the disparity for the specified rectified stereo pair or data cost.</p>
<dl class="function">
<dt id="void gpu::StereoBeliefPropagation::operator ()(const GpuMat&amp; left, const GpuMat&amp; right, GpuMat&amp; disparity, Stream&amp; stream)">
<strong>C++:</strong><code class="descname"> </code>void <code class="descclassname">gpu::StereoBeliefPropagation::</code><code class="descname">operator()</code><span class="sig-paren">(</span>const GpuMat&amp; <strong>left</strong>, const GpuMat&amp; <strong>right</strong>, GpuMat&amp; <strong>disparity</strong>, Stream&amp; <strong>stream</strong>=Stream::Null()<span class="sig-paren">)</span><a class="headerlink" href="#void gpu::StereoBeliefPropagation::operator ()(const GpuMat& left, const GpuMat& right, GpuMat& disparity, Stream& stream)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="void gpu::StereoBeliefPropagation::operator ()(const GpuMat&amp; data, GpuMat&amp; disparity, Stream&amp; stream)">
<strong>C++:</strong><code class="descname"> </code>void <code class="descclassname">gpu::StereoBeliefPropagation::</code><code class="descname">operator()</code><span class="sig-paren">(</span>const GpuMat&amp; <strong>data</strong>, GpuMat&amp; <strong>disparity</strong>, Stream&amp; <strong>stream</strong>=Stream::Null()<span class="sig-paren">)</span><a class="headerlink" href="#void gpu::StereoBeliefPropagation::operator ()(const GpuMat& data, GpuMat& disparity, Stream& stream)" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>left</strong> &#8211; Left image. <code class="docutils literal"><span class="pre">CV_8UC1</span></code> , <code class="docutils literal"><span class="pre">CV_8UC3</span></code>  and  <code class="docutils literal"><span class="pre">CV_8UC4</span></code>  types are supported.</li>
<li><strong>right</strong> &#8211; Right image with the same size and the same type as the left one.</li>
<li><strong>data</strong> &#8211; User-specified data cost, a matrix of <code class="docutils literal"><span class="pre">msg_type</span></code> type and <code class="docutils literal"><span class="pre">Size(&lt;image</span> <span class="pre">columns&gt;*ndisp,</span> <span class="pre">&lt;image</span> <span class="pre">rows&gt;)</span></code> size.</li>
<li><strong>disparity</strong> &#8211; Output disparity map. If  <code class="docutils literal"><span class="pre">disparity</span></code>  is empty, the output type is  <code class="docutils literal"><span class="pre">CV_16SC1</span></code> . Otherwise, the type is retained.</li>
<li><strong>stream</strong> &#8211; Stream for the asynchronous version.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="gpu-stereoconstantspacebp">
<h2>gpu::StereoConstantSpaceBP<a class="headerlink" href="#gpu-stereoconstantspacebp" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="gpu::StereoConstantSpaceBP">
<em class="property">class </em><code class="descclassname">gpu::</code><code class="descname">StereoConstantSpaceBP</code><a class="headerlink" href="#gpu::StereoConstantSpaceBP" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p>Class computing stereo correspondence using the constant space belief propagation algorithm.</p>
<div class="highlight-cpp"><div class="highlight"><pre><span class="k">class</span> <span class="nc">StereoConstantSpaceBP</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="k">enum</span> <span class="p">{</span> <span class="n">DEFAULT_NDISP</span>    <span class="o">=</span> <span class="mi">128</span> <span class="p">};</span>
    <span class="k">enum</span> <span class="p">{</span> <span class="n">DEFAULT_ITERS</span>    <span class="o">=</span> <span class="mi">8</span>   <span class="p">};</span>
    <span class="k">enum</span> <span class="p">{</span> <span class="n">DEFAULT_LEVELS</span>   <span class="o">=</span> <span class="mi">4</span>   <span class="p">};</span>
    <span class="k">enum</span> <span class="p">{</span> <span class="n">DEFAULT_NR_PLANE</span> <span class="o">=</span> <span class="mi">4</span>   <span class="p">};</span>

    <span class="k">static</span> <span class="kt">void</span> <span class="nf">estimateRecommendedParams</span><span class="p">(</span><span class="kt">int</span> <span class="n">width</span><span class="p">,</span> <span class="kt">int</span> <span class="n">height</span><span class="p">,</span>
        <span class="kt">int</span><span class="o">&amp;</span> <span class="n">ndisp</span><span class="p">,</span> <span class="kt">int</span><span class="o">&amp;</span> <span class="n">iters</span><span class="p">,</span> <span class="kt">int</span><span class="o">&amp;</span> <span class="n">levels</span><span class="p">,</span> <span class="kt">int</span><span class="o">&amp;</span> <span class="n">nr_plane</span><span class="p">);</span>

    <span class="k">explicit</span> <span class="nf">StereoConstantSpaceBP</span><span class="p">(</span><span class="kt">int</span> <span class="n">ndisp</span> <span class="o">=</span> <span class="n">DEFAULT_NDISP</span><span class="p">,</span>
        <span class="kt">int</span> <span class="n">iters</span>    <span class="o">=</span> <span class="n">DEFAULT_ITERS</span><span class="p">,</span>
        <span class="kt">int</span> <span class="n">levels</span>   <span class="o">=</span> <span class="n">DEFAULT_LEVELS</span><span class="p">,</span>
        <span class="kt">int</span> <span class="n">nr_plane</span> <span class="o">=</span> <span class="n">DEFAULT_NR_PLANE</span><span class="p">,</span>
        <span class="kt">int</span> <span class="n">msg_type</span> <span class="o">=</span> <span class="n">CV_32F</span><span class="p">);</span>
    <span class="n">StereoConstantSpaceBP</span><span class="p">(</span><span class="kt">int</span> <span class="n">ndisp</span><span class="p">,</span> <span class="kt">int</span> <span class="n">iters</span><span class="p">,</span> <span class="kt">int</span> <span class="n">levels</span><span class="p">,</span> <span class="kt">int</span> <span class="n">nr_plane</span><span class="p">,</span>
        <span class="kt">float</span> <span class="n">max_data_term</span><span class="p">,</span> <span class="kt">float</span> <span class="n">data_weight</span><span class="p">,</span>
        <span class="kt">float</span> <span class="n">max_disc_term</span><span class="p">,</span> <span class="kt">float</span> <span class="n">disc_single_jump</span><span class="p">,</span>
        <span class="kt">int</span> <span class="n">min_disp_th</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
        <span class="kt">int</span> <span class="n">msg_type</span> <span class="o">=</span> <span class="n">CV_32F</span><span class="p">);</span>

    <span class="kt">void</span> <span class="nf">operator</span><span class="p">()(</span><span class="k">const</span> <span class="n">GpuMat</span><span class="o">&amp;</span> <span class="n">left</span><span class="p">,</span> <span class="k">const</span> <span class="n">GpuMat</span><span class="o">&amp;</span> <span class="n">right</span><span class="p">,</span>
                    <span class="n">GpuMat</span><span class="o">&amp;</span> <span class="n">disparity</span><span class="p">,</span> <span class="n">Stream</span><span class="o">&amp;</span> <span class="n">stream</span> <span class="o">=</span> <span class="n">Stream</span><span class="o">::</span><span class="n">Null</span><span class="p">());</span>

    <span class="kt">int</span> <span class="n">ndisp</span><span class="p">;</span>

    <span class="kt">int</span> <span class="n">iters</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">levels</span><span class="p">;</span>

    <span class="kt">int</span> <span class="n">nr_plane</span><span class="p">;</span>

    <span class="kt">float</span> <span class="n">max_data_term</span><span class="p">;</span>
    <span class="kt">float</span> <span class="n">data_weight</span><span class="p">;</span>
    <span class="kt">float</span> <span class="n">max_disc_term</span><span class="p">;</span>
    <span class="kt">float</span> <span class="n">disc_single_jump</span><span class="p">;</span>

    <span class="kt">int</span> <span class="n">min_disp_th</span><span class="p">;</span>

    <span class="kt">int</span> <span class="n">msg_type</span><span class="p">;</span>

    <span class="kt">bool</span> <span class="n">use_local_init_data_cost</span><span class="p">;</span>

    <span class="p">...</span>
<span class="p">};</span>
</pre></div>
</div>
<p>The class implements algorithm described in <a class="reference internal" href="#yang2010" id="id3">[Yang2010]</a>. <code class="docutils literal"><span class="pre">StereoConstantSpaceBP</span></code> supports both local minimum and global minimum data cost initialization algorithms. For more details, see the paper mentioned above. By default, a local algorithm is used. To enable a global algorithm, set <code class="docutils literal"><span class="pre">use_local_init_data_cost</span></code> to <code class="docutils literal"><span class="pre">false</span></code> .</p>
</div>
<div class="section" id="gpu-stereoconstantspacebp-stereoconstantspacebp">
<h2>gpu::StereoConstantSpaceBP::StereoConstantSpaceBP<a class="headerlink" href="#gpu-stereoconstantspacebp-stereoconstantspacebp" title="Permalink to this headline">¶</a></h2>
<p>Enables the <a class="reference internal" href="#gpu::StereoConstantSpaceBP" title="class gpu::StereoConstantSpaceBP"><code class="xref ocv ocv-class docutils literal"><span class="pre">gpu::StereoConstantSpaceBP</span></code></a> constructors.</p>
<dl class="function">
<dt id="gpu::StereoConstantSpaceBP::StereoConstantSpaceBP(int ndisp , int iters , int levels , int nr_plane , int msg_type)">
<strong>C++:</strong><code class="descname"> </code> <code class="descclassname">gpu::StereoConstantSpaceBP::</code><code class="descname">StereoConstantSpaceBP</code><span class="sig-paren">(</span>int <strong>ndisp</strong>=DEFAULT_NDISP, int <strong>iters</strong>=DEFAULT_ITERS, int <strong>levels</strong>=DEFAULT_LEVELS, int <strong>nr_plane</strong>=DEFAULT_NR_PLANE, int <strong>msg_type</strong>=CV_32F<span class="sig-paren">)</span><a class="headerlink" href="#gpu::StereoConstantSpaceBP::StereoConstantSpaceBP(int ndisp , int iters , int levels , int nr_plane , int msg_type)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="gpu::StereoConstantSpaceBP::StereoConstantSpaceBP(int ndisp, int iters, int levels, int nr_plane, float max_data_term, float data_weight, float max_disc_term, float disc_single_jump, int min_disp_th , int msg_type)">
<strong>C++:</strong><code class="descname"> </code> <code class="descclassname">gpu::StereoConstantSpaceBP::</code><code class="descname">StereoConstantSpaceBP</code><span class="sig-paren">(</span>int <strong>ndisp</strong>, int <strong>iters</strong>, int <strong>levels</strong>, int <strong>nr_plane</strong>, float <strong>max_data_term</strong>, float <strong>data_weight</strong>, float <strong>max_disc_term</strong>, float <strong>disc_single_jump</strong>, int <strong>min_disp_th</strong>=0, int <strong>msg_type</strong>=CV_32F<span class="sig-paren">)</span><a class="headerlink" href="#gpu::StereoConstantSpaceBP::StereoConstantSpaceBP(int ndisp, int iters, int levels, int nr_plane, float max_data_term, float data_weight, float max_disc_term, float disc_single_jump, int min_disp_th , int msg_type)" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>ndisp</strong> &#8211; Number of disparities.</li>
<li><strong>iters</strong> &#8211; Number of BP iterations on each level.</li>
<li><strong>levels</strong> &#8211; Number of levels.</li>
<li><strong>nr_plane</strong> &#8211; Number of disparity levels on the first level.</li>
<li><strong>max_data_term</strong> &#8211; Truncation of data cost.</li>
<li><strong>data_weight</strong> &#8211; Data weight.</li>
<li><strong>max_disc_term</strong> &#8211; Truncation of discontinuity.</li>
<li><strong>disc_single_jump</strong> &#8211; Discontinuity single jump.</li>
<li><strong>min_disp_th</strong> &#8211; Minimal disparity threshold.</li>
<li><strong>msg_type</strong> &#8211; Type for messages.  <code class="docutils literal"><span class="pre">CV_16SC1</span></code>  and  <code class="docutils literal"><span class="pre">CV_32FC1</span></code> types are supported.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<p><code class="docutils literal"><span class="pre">StereoConstantSpaceBP</span></code> uses a truncated linear model for the data cost and discontinuity terms:</p>
<div class="math">
<p><img src="../../../_images/math/2ef8bf5d08e35f01b4b696d64452b10ba8477aa9.png" alt="DataCost = data \_ weight  \cdot \min ( \lvert I_2-I_1  \rvert , max \_ data \_ term)"/></p>
</div><div class="math">
<p><img src="../../../_images/math/fdcdeea0879f1695066c0b5b73c7a904bf7a623b.png" alt="DiscTerm =  \min (disc \_ single \_ jump  \cdot \lvert f_1-f_2  \rvert , max \_ disc \_ term)"/></p>
</div><p>For more details, see <a class="reference internal" href="#yang2010" id="id4">[Yang2010]</a>.</p>
<p>By default, <code class="docutils literal"><span class="pre">StereoConstantSpaceBP</span></code> uses floating-point arithmetics and the <code class="docutils literal"><span class="pre">CV_32FC1</span></code> type for messages. But it can also use fixed-point arithmetics and the <code class="docutils literal"><span class="pre">CV_16SC1</span></code> message type for better performance. To avoid an overflow in this case, the parameters must satisfy the following requirement:</p>
<div class="math">
<p><img src="../../../_images/math/ca35fe43476448e06dbfdc993587b2f9643a87c3.png" alt="10  \cdot 2^{levels-1}  \cdot max \_ data \_ term &lt; SHRT \_ MAX"/></p>
</div></div>
<div class="section" id="gpu-stereoconstantspacebp-estimaterecommendedparams">
<h2>gpu::StereoConstantSpaceBP::estimateRecommendedParams<a class="headerlink" href="#gpu-stereoconstantspacebp-estimaterecommendedparams" title="Permalink to this headline">¶</a></h2>
<p>Uses a heuristic method to compute parameters (ndisp, iters, levelsand nrplane) for the specified image size (widthand height).</p>
<dl class="function">
<dt id="void gpu::StereoConstantSpaceBP::estimateRecommendedParams(int width, int height, int&amp; ndisp, int&amp; iters, int&amp; levels, int&amp; nr_plane)">
<strong>C++:</strong><code class="descname"> </code>void <code class="descclassname">gpu::StereoConstantSpaceBP::</code><code class="descname">estimateRecommendedParams</code><span class="sig-paren">(</span>int <strong>width</strong>, int <strong>height</strong>, int&amp; <strong>ndisp</strong>, int&amp; <strong>iters</strong>, int&amp; <strong>levels</strong>, int&amp; <strong>nr_plane</strong><span class="sig-paren">)</span><a class="headerlink" href="#void gpu::StereoConstantSpaceBP::estimateRecommendedParams(int width, int height, int& ndisp, int& iters, int& levels, int& nr_plane)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</div>
<div class="section" id="gpu-stereoconstantspacebp-operator">
<h2>gpu::StereoConstantSpaceBP::operator ()<a class="headerlink" href="#gpu-stereoconstantspacebp-operator" title="Permalink to this headline">¶</a></h2>
<p>Enables the stereo correspondence operator that finds the disparity for the specified rectified stereo pair.</p>
<dl class="function">
<dt id="void gpu::StereoConstantSpaceBP::operator ()(const GpuMat&amp; left, const GpuMat&amp; right, GpuMat&amp; disparity, Stream&amp; stream)">
<strong>C++:</strong><code class="descname"> </code>void <code class="descclassname">gpu::StereoConstantSpaceBP::</code><code class="descname">operator()</code><span class="sig-paren">(</span>const GpuMat&amp; <strong>left</strong>, const GpuMat&amp; <strong>right</strong>, GpuMat&amp; <strong>disparity</strong>, Stream&amp; <strong>stream</strong>=Stream::Null()<span class="sig-paren">)</span><a class="headerlink" href="#void gpu::StereoConstantSpaceBP::operator ()(const GpuMat& left, const GpuMat& right, GpuMat& disparity, Stream& stream)" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>left</strong> &#8211; Left image. <code class="docutils literal"><span class="pre">CV_8UC1</span></code> , <code class="docutils literal"><span class="pre">CV_8UC3</span></code>  and  <code class="docutils literal"><span class="pre">CV_8UC4</span></code>  types are supported.</li>
<li><strong>right</strong> &#8211; Right image with the same size and the same type as the left one.</li>
<li><strong>disparity</strong> &#8211; Output disparity map. If  <code class="docutils literal"><span class="pre">disparity</span></code>  is empty, the output type is  <code class="docutils literal"><span class="pre">CV_16SC1</span></code> . Otherwise, the output type is  <code class="docutils literal"><span class="pre">disparity.type()</span></code> .</li>
<li><strong>stream</strong> &#8211; Stream for the asynchronous version.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="gpu-disparitybilateralfilter">
<h2>gpu::DisparityBilateralFilter<a class="headerlink" href="#gpu-disparitybilateralfilter" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="gpu::DisparityBilateralFilter">
<em class="property">class </em><code class="descclassname">gpu::</code><code class="descname">DisparityBilateralFilter</code><a class="headerlink" href="#gpu::DisparityBilateralFilter" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p>Class refining a disparity map using joint bilateral filtering.</p>
<div class="highlight-cpp"><div class="highlight"><pre><span class="k">class</span> <span class="nc">CV_EXPORTS</span> <span class="n">DisparityBilateralFilter</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="k">enum</span> <span class="p">{</span> <span class="n">DEFAULT_NDISP</span>  <span class="o">=</span> <span class="mi">64</span> <span class="p">};</span>
    <span class="k">enum</span> <span class="p">{</span> <span class="n">DEFAULT_RADIUS</span> <span class="o">=</span> <span class="mi">3</span> <span class="p">};</span>
    <span class="k">enum</span> <span class="p">{</span> <span class="n">DEFAULT_ITERS</span>  <span class="o">=</span> <span class="mi">1</span> <span class="p">};</span>

    <span class="k">explicit</span> <span class="nf">DisparityBilateralFilter</span><span class="p">(</span><span class="kt">int</span> <span class="n">ndisp</span> <span class="o">=</span> <span class="n">DEFAULT_NDISP</span><span class="p">,</span>
        <span class="kt">int</span> <span class="n">radius</span> <span class="o">=</span> <span class="n">DEFAULT_RADIUS</span><span class="p">,</span> <span class="kt">int</span> <span class="n">iters</span> <span class="o">=</span> <span class="n">DEFAULT_ITERS</span><span class="p">);</span>

    <span class="n">DisparityBilateralFilter</span><span class="p">(</span><span class="kt">int</span> <span class="n">ndisp</span><span class="p">,</span> <span class="kt">int</span> <span class="n">radius</span><span class="p">,</span> <span class="kt">int</span> <span class="n">iters</span><span class="p">,</span>
        <span class="kt">float</span> <span class="n">edge_threshold</span><span class="p">,</span> <span class="kt">float</span> <span class="n">max_disc_threshold</span><span class="p">,</span>
        <span class="kt">float</span> <span class="n">sigma_range</span><span class="p">);</span>

    <span class="kt">void</span> <span class="nf">operator</span><span class="p">()(</span><span class="k">const</span> <span class="n">GpuMat</span><span class="o">&amp;</span> <span class="n">disparity</span><span class="p">,</span> <span class="k">const</span> <span class="n">GpuMat</span><span class="o">&amp;</span> <span class="n">image</span><span class="p">,</span>
                    <span class="n">GpuMat</span><span class="o">&amp;</span> <span class="n">dst</span><span class="p">,</span> <span class="n">Stream</span><span class="o">&amp;</span> <span class="n">stream</span> <span class="o">=</span> <span class="n">Stream</span><span class="o">::</span><span class="n">Null</span><span class="p">());</span>

    <span class="p">...</span>
<span class="p">};</span>
</pre></div>
</div>
<p>The class implements <a class="reference internal" href="#yang2010" id="id5">[Yang2010]</a> algorithm.</p>
</div>
<div class="section" id="gpu-disparitybilateralfilter-disparitybilateralfilter">
<h2>gpu::DisparityBilateralFilter::DisparityBilateralFilter<a class="headerlink" href="#gpu-disparitybilateralfilter-disparitybilateralfilter" title="Permalink to this headline">¶</a></h2>
<p>Enables the <a class="reference internal" href="#gpu::DisparityBilateralFilter" title="class gpu::DisparityBilateralFilter"><code class="xref ocv ocv-class docutils literal"><span class="pre">gpu::DisparityBilateralFilter</span></code></a> constructors.</p>
<dl class="function">
<dt id="gpu::DisparityBilateralFilter::DisparityBilateralFilter(int ndisp , int radius , int iters)">
<strong>C++:</strong><code class="descname"> </code> <code class="descclassname">gpu::DisparityBilateralFilter::</code><code class="descname">DisparityBilateralFilter</code><span class="sig-paren">(</span>int <strong>ndisp</strong>=DEFAULT_NDISP, int <strong>radius</strong>=DEFAULT_RADIUS, int <strong>iters</strong>=DEFAULT_ITERS<span class="sig-paren">)</span><a class="headerlink" href="#gpu::DisparityBilateralFilter::DisparityBilateralFilter(int ndisp , int radius , int iters)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="gpu::DisparityBilateralFilter::DisparityBilateralFilter(int ndisp, int radius, int iters, float edge_threshold, float max_disc_threshold, float sigma_range)">
<strong>C++:</strong><code class="descname"> </code> <code class="descclassname">gpu::DisparityBilateralFilter::</code><code class="descname">DisparityBilateralFilter</code><span class="sig-paren">(</span>int <strong>ndisp</strong>, int <strong>radius</strong>, int <strong>iters</strong>, float <strong>edge_threshold</strong>, float <strong>max_disc_threshold</strong>, float <strong>sigma_range</strong><span class="sig-paren">)</span><a class="headerlink" href="#gpu::DisparityBilateralFilter::DisparityBilateralFilter(int ndisp, int radius, int iters, float edge_threshold, float max_disc_threshold, float sigma_range)" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>ndisp</strong> &#8211; Number of disparities.</li>
<li><strong>radius</strong> &#8211; Filter radius.</li>
<li><strong>iters</strong> &#8211; Number of iterations.</li>
<li><strong>edge_threshold</strong> &#8211; Threshold for edges.</li>
<li><strong>max_disc_threshold</strong> &#8211; Constant to reject outliers.</li>
<li><strong>sigma_range</strong> &#8211; Filter range.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="gpu-disparitybilateralfilter-operator">
<h2>gpu::DisparityBilateralFilter::operator ()<a class="headerlink" href="#gpu-disparitybilateralfilter-operator" title="Permalink to this headline">¶</a></h2>
<p>Refines a disparity map using joint bilateral filtering.</p>
<dl class="function">
<dt id="void gpu::DisparityBilateralFilter::operator ()(const GpuMat&amp; disparity, const GpuMat&amp; image, GpuMat&amp; dst, Stream&amp; stream)">
<strong>C++:</strong><code class="descname"> </code>void <code class="descclassname">gpu::DisparityBilateralFilter::</code><code class="descname">operator()</code><span class="sig-paren">(</span>const GpuMat&amp; <strong>disparity</strong>, const GpuMat&amp; <strong>image</strong>, GpuMat&amp; <strong>dst</strong>, Stream&amp; <strong>stream</strong>=Stream::Null()<span class="sig-paren">)</span><a class="headerlink" href="#void gpu::DisparityBilateralFilter::operator ()(const GpuMat& disparity, const GpuMat& image, GpuMat& dst, Stream& stream)" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>disparity</strong> &#8211; Input disparity map.  <code class="docutils literal"><span class="pre">CV_8UC1</span></code>  and  <code class="docutils literal"><span class="pre">CV_16SC1</span></code>  types are supported.</li>
<li><strong>image</strong> &#8211; Input image. <code class="docutils literal"><span class="pre">CV_8UC1</span></code>  and  <code class="docutils literal"><span class="pre">CV_8UC3</span></code>  types are supported.</li>
<li><strong>dst</strong> &#8211; Destination disparity map. It has the same size and type as  <code class="docutils literal"><span class="pre">disparity</span></code> .</li>
<li><strong>stream</strong> &#8211; Stream for the asynchronous version.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="gpu-drawcolordisp">
<h2>gpu::drawColorDisp<a class="headerlink" href="#gpu-drawcolordisp" title="Permalink to this headline">¶</a></h2>
<p>Colors a disparity image.</p>
<dl class="function">
<dt id="void gpu::drawColorDisp(const GpuMat&amp; src_disp, GpuMat&amp; dst_disp, int ndisp, Stream&amp; stream)">
<strong>C++:</strong><code class="descname"> </code>void <code class="descclassname">gpu::</code><code class="descname">drawColorDisp</code><span class="sig-paren">(</span>const GpuMat&amp; <strong>src_disp</strong>, GpuMat&amp; <strong>dst_disp</strong>, int <strong>ndisp</strong>, Stream&amp; <strong>stream</strong>=Stream::Null()<span class="sig-paren">)</span><a class="headerlink" href="#void gpu::drawColorDisp(const GpuMat& src_disp, GpuMat& dst_disp, int ndisp, Stream& stream)" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>src_disp</strong> &#8211; Source disparity image.  <code class="docutils literal"><span class="pre">CV_8UC1</span></code>  and  <code class="docutils literal"><span class="pre">CV_16SC1</span></code>  types are supported.</li>
<li><strong>dst_disp</strong> &#8211; Output disparity image. It has the same size as  <code class="docutils literal"><span class="pre">src_disp</span></code> . The  type is <code class="docutils literal"><span class="pre">CV_8UC4</span></code>  in  <code class="docutils literal"><span class="pre">BGRA</span></code>  format (alpha = 255).</li>
<li><strong>ndisp</strong> &#8211; Number of disparities.</li>
<li><strong>stream</strong> &#8211; Stream for the asynchronous version.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<p>This function draws a colored disparity map by converting disparity values from <code class="docutils literal"><span class="pre">[0..ndisp)</span></code> interval first to <code class="docutils literal"><span class="pre">HSV</span></code> color space (where different disparity values correspond to different hues) and then converting the pixels to <code class="docutils literal"><span class="pre">RGB</span></code> for visualization.</p>
</div>
<div class="section" id="gpu-reprojectimageto3d">
<h2>gpu::reprojectImageTo3D<a class="headerlink" href="#gpu-reprojectimageto3d" title="Permalink to this headline">¶</a></h2>
<p>Reprojects a disparity image to 3D space.</p>
<dl class="function">
<dt id="void gpu::reprojectImageTo3D(const GpuMat&amp; disp, GpuMat&amp; xyzw, const Mat&amp; Q, int dst_cn , Stream&amp; stream)">
<strong>C++:</strong><code class="descname"> </code>void <code class="descclassname">gpu::</code><code class="descname">reprojectImageTo3D</code><span class="sig-paren">(</span>const GpuMat&amp; <strong>disp</strong>, GpuMat&amp; <strong>xyzw</strong>, const Mat&amp; <strong>Q</strong>, int <strong>dst_cn</strong>=4, Stream&amp; <strong>stream</strong>=Stream::Null()<span class="sig-paren">)</span><a class="headerlink" href="#void gpu::reprojectImageTo3D(const GpuMat& disp, GpuMat& xyzw, const Mat& Q, int dst_cn , Stream& stream)" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>disp</strong> &#8211; Input disparity image.  <code class="docutils literal"><span class="pre">CV_8U</span></code>  and  <code class="docutils literal"><span class="pre">CV_16S</span></code>  types are supported.</li>
<li><strong>xyzw</strong> &#8211; Output 3- or 4-channel floating-point image of the same size as  <code class="docutils literal"><span class="pre">disp</span></code> . Each element of  <code class="docutils literal"><span class="pre">xyzw(x,y)</span></code>  contains 3D coordinates <code class="docutils literal"><span class="pre">(x,y,z)</span></code> or <code class="docutils literal"><span class="pre">(x,y,z,1)</span></code>  of the point  <code class="docutils literal"><span class="pre">(x,y)</span></code> , computed from the disparity map.</li>
<li><strong>Q</strong> &#8211; <img class="math" src="../../../_images/math/96754e424b2a8b15b1a9dba38a6ffde5cb0e50a8.png" alt="4 \times 4"/>  perspective transformation matrix that can be obtained via  <a class="reference internal" href="../../calib3d/doc/camera_calibration_and_3d_reconstruction.html#void stereoRectify(InputArray cameraMatrix1, InputArray distCoeffs1, InputArray cameraMatrix2, InputArray distCoeffs2, Size imageSize, InputArray R, InputArray T, OutputArray R1, OutputArray R2, OutputArray P1, OutputArray P2, OutputArray Q, int flags, double alpha, Size newImageSize, Rect* validPixROI1, Rect* validPixROI2)" title="void stereoRectify(InputArray cameraMatrix1, InputArray distCoeffs1, InputArray cameraMatrix2, InputArray distCoeffs2, Size imageSize, InputArray R, InputArray T, OutputArray R1, OutputArray R2, OutputArray P1, OutputArray P2, OutputArray Q, int flags, double alpha, Size newImageSize, Rect* validPixROI1, Rect* validPixROI2)"><code class="xref ocv ocv-func docutils literal"><span class="pre">stereoRectify()</span></code></a> .</li>
<li><strong>dst_cn</strong> &#8211; The number of channels for output image. Can be 3 or 4.</li>
<li><strong>stream</strong> &#8211; Stream for the asynchronous version.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="../../calib3d/doc/camera_calibration_and_3d_reconstruction.html#void reprojectImageTo3D(InputArray disparity, OutputArray _3dImage, InputArray Q, bool handleMissingValues, int ddepth)" title="void reprojectImageTo3D(InputArray disparity, OutputArray _3dImage, InputArray Q, bool handleMissingValues, int ddepth)"><code class="xref ocv ocv-func docutils literal"><span class="pre">reprojectImageTo3D()</span></code></a></p>
</div>
</div>
<div class="section" id="gpu-solvepnpransac">
<h2>gpu::solvePnPRansac<a class="headerlink" href="#gpu-solvepnpransac" title="Permalink to this headline">¶</a></h2>
<p>Finds the object pose from 3D-2D point correspondences.</p>
<dl class="function">
<dt id="void gpu::solvePnPRansac(const Mat&amp; object, const Mat&amp; image, const Mat&amp; camera_mat, const Mat&amp; dist_coef, Mat&amp; rvec, Mat&amp; tvec, bool use_extrinsic_guess, int num_iters, float max_dist, int min_inlier_count, vector&lt;int&gt;* inliers)">
<strong>C++:</strong><code class="descname"> </code>void <code class="descclassname">gpu::</code><code class="descname">solvePnPRansac</code><span class="sig-paren">(</span>const Mat&amp; <strong>object</strong>, const Mat&amp; <strong>image</strong>, const Mat&amp; <strong>camera_mat</strong>, const Mat&amp; <strong>dist_coef</strong>, Mat&amp; <strong>rvec</strong>, Mat&amp; <strong>tvec</strong>, bool <strong>use_extrinsic_guess</strong>=false, int <strong>num_iters</strong>=100, float <strong>max_dist</strong>=8.0, int <strong>min_inlier_count</strong>=100, vector&lt;int&gt;* <strong>inliers</strong>=NULL<span class="sig-paren">)</span><a class="headerlink" href="#void gpu::solvePnPRansac(const Mat& object, const Mat& image, const Mat& camera_mat, const Mat& dist_coef, Mat& rvec, Mat& tvec, bool use_extrinsic_guess, int num_iters, float max_dist, int min_inlier_count, vector<int>* inliers)" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>object</strong> &#8211; Single-row matrix of object points.</li>
<li><strong>image</strong> &#8211; Single-row matrix of image points.</li>
<li><strong>camera_mat</strong> &#8211; 3x3 matrix of intrinsic camera parameters.</li>
<li><strong>dist_coef</strong> &#8211; Distortion coefficients. See <a class="reference internal" href="../../imgproc/doc/geometric_transformations.html#void undistortPoints(InputArray src, OutputArray dst, InputArray cameraMatrix, InputArray distCoeffs, InputArray R, InputArray P)" title="void undistortPoints(InputArray src, OutputArray dst, InputArray cameraMatrix, InputArray distCoeffs, InputArray R, InputArray P)"><code class="xref ocv ocv-func docutils literal"><span class="pre">undistortPoints()</span></code></a> for details.</li>
<li><strong>rvec</strong> &#8211; Output 3D rotation vector.</li>
<li><strong>tvec</strong> &#8211; Output 3D translation vector.</li>
<li><strong>use_extrinsic_guess</strong> &#8211; Flag to indicate that the function must use <code class="docutils literal"><span class="pre">rvec</span></code> and <code class="docutils literal"><span class="pre">tvec</span></code> as an initial transformation guess. It is not supported for now.</li>
<li><strong>num_iters</strong> &#8211; Maximum number of RANSAC iterations.</li>
<li><strong>max_dist</strong> &#8211; Euclidean distance threshold to detect whether point is inlier or not.</li>
<li><strong>min_inlier_count</strong> &#8211; Flag to indicate that the function must stop if greater or equal number of inliers is achieved. It is not supported for now.</li>
<li><strong>inliers</strong> &#8211; Output vector of inlier indices.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="../../calib3d/doc/camera_calibration_and_3d_reconstruction.html#void solvePnPRansac(InputArray objectPoints, InputArray imagePoints, InputArray cameraMatrix, InputArray distCoeffs, OutputArray rvec, OutputArray tvec, bool useExtrinsicGuess, int iterationsCount , float reprojectionError , int minInliersCount , OutputArray inliers , int flags)" title="void solvePnPRansac(InputArray objectPoints, InputArray imagePoints, InputArray cameraMatrix, InputArray distCoeffs, OutputArray rvec, OutputArray tvec, bool useExtrinsicGuess, int iterationsCount , float reprojectionError , int minInliersCount , OutputArray inliers , int flags)"><code class="xref ocv ocv-func docutils literal"><span class="pre">solvePnPRansac()</span></code></a></p>
</div>
<table class="docutils citation" frame="void" id="felzenszwalb2006" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[Felzenszwalb2006]</td><td><em>(<a class="fn-backref" href="#id1">1</a>, <a class="fn-backref" href="#id2">2</a>)</em> Pedro F. Felzenszwalb algorithm [Pedro F. Felzenszwalb and Daniel P. Huttenlocher. <em>Efficient belief propagation for early vision</em>. International Journal of Computer Vision, 70(1), October 2006</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="yang2010" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[Yang2010]</td><td><em>(<a class="fn-backref" href="#id3">1</a>, <a class="fn-backref" href="#id4">2</a>, <a class="fn-backref" href="#id5">3</a>)</em> <ol class="last upperalpha simple" start="17">
<li>Yang, L. Wang, and N. Ahuja. <em>A constant-space belief propagation algorithm for stereo matching</em>. In CVPR, 2010.</li>
</ol>
</td></tr>
</tbody>
</table>
</div>
</div>


          </div>
          <div class="feedback">
              <h2>Help and Feedback</h2>
              You did not find what you were looking for?
              <ul>
                  
                  
                  
                  <li>Ask a question on the <a href="http://answers.opencv.org">Q&A forum</a>.</li>
                  <li>If you think something is missing or wrong in the documentation,
                  please file a <a href="http://code.opencv.org">bug report</a>.</li>
              </ul>
          </div>
        </div>
      </div>

      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../../../index.html">
              <img class="logo" src="../../../_static/opencv-logo-white.png" alt="Logo"/>
            </a></p>
<div id="searchbox" style="display: none">
      <form class="search" action="../../../search.html" method="get">
      <input type="text" name="q" size="18" />
      <input type="submit" value="Search" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
      </p>
    </form>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
  <h3><a href="../../../index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Camera Calibration and 3D Reconstruction</a><ul>
<li><a class="reference internal" href="#gpu-stereobm-gpu">gpu::StereoBM_GPU</a></li>
<li><a class="reference internal" href="#gpu-stereobm-gpu-stereobm-gpu">gpu::StereoBM_GPU::StereoBM_GPU</a></li>
<li><a class="reference internal" href="#gpu-stereobm-gpu-operator">gpu::StereoBM_GPU::operator ()</a></li>
<li><a class="reference internal" href="#gpu-stereobm-gpu-checkifgpucallreasonable">gpu::StereoBM_GPU::checkIfGpuCallReasonable</a></li>
<li><a class="reference internal" href="#gpu-stereobeliefpropagation">gpu::StereoBeliefPropagation</a></li>
<li><a class="reference internal" href="#gpu-stereobeliefpropagation-stereobeliefpropagation">gpu::StereoBeliefPropagation::StereoBeliefPropagation</a></li>
<li><a class="reference internal" href="#gpu-stereobeliefpropagation-estimaterecommendedparams">gpu::StereoBeliefPropagation::estimateRecommendedParams</a></li>
<li><a class="reference internal" href="#gpu-stereobeliefpropagation-operator">gpu::StereoBeliefPropagation::operator ()</a></li>
<li><a class="reference internal" href="#gpu-stereoconstantspacebp">gpu::StereoConstantSpaceBP</a></li>
<li><a class="reference internal" href="#gpu-stereoconstantspacebp-stereoconstantspacebp">gpu::StereoConstantSpaceBP::StereoConstantSpaceBP</a></li>
<li><a class="reference internal" href="#gpu-stereoconstantspacebp-estimaterecommendedparams">gpu::StereoConstantSpaceBP::estimateRecommendedParams</a></li>
<li><a class="reference internal" href="#gpu-stereoconstantspacebp-operator">gpu::StereoConstantSpaceBP::operator ()</a></li>
<li><a class="reference internal" href="#gpu-disparitybilateralfilter">gpu::DisparityBilateralFilter</a></li>
<li><a class="reference internal" href="#gpu-disparitybilateralfilter-disparitybilateralfilter">gpu::DisparityBilateralFilter::DisparityBilateralFilter</a></li>
<li><a class="reference internal" href="#gpu-disparitybilateralfilter-operator">gpu::DisparityBilateralFilter::operator ()</a></li>
<li><a class="reference internal" href="#gpu-drawcolordisp">gpu::drawColorDisp</a></li>
<li><a class="reference internal" href="#gpu-reprojectimageto3d">gpu::reprojectImageTo3D</a></li>
<li><a class="reference internal" href="#gpu-solvepnpransac">gpu::solvePnPRansac</a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="image_filtering.html"
                        title="previous chapter">Image Filtering</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="video.html"
                        title="next chapter">Video Analysis</a></p>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../../../_sources/modules/gpu/doc/camera_calibration_and_3d_reconstruction.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="video.html" title="Video Analysis"
             >next</a> |</li>
        <li class="right" >
          <a href="image_filtering.html" title="Image Filtering"
             >previous</a> |</li>
        <li><a href="../../../index.html">OpenCV 2.4.13.7 documentation</a> &raquo;</li>
          <li><a href="../../refman.html" >OpenCV API Reference</a> &raquo;</li>
          <li><a href="gpu.html" >gpu. GPU-accelerated Computer Vision</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2011-2014, opencv dev team.
      Last updated on Jul 12, 2018.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.3.6.
    </div>
  </body>
</html>
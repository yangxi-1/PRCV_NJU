<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<script type="text/javascript">

  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-33108845-1']);
  _gaq.push(['_setDomainName', 'opencv.org']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();

</script>

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Image Filtering &mdash; OpenCV 2.4.13.7 documentation</title>
    <link rel="stylesheet" href="../../../_static/default.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../../',
        VERSION:     '2.4.13.7',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../../_static/doctools.js"></script>
    <link rel="top" title="OpenCV 2.4.13.7 documentation" href="../../../index.html" />
    <link rel="up" title="imgproc. Image Processing" href="imgproc.html" />
    <link rel="next" title="Geometric Image Transformations" href="geometric_transformations.html" />
    <link rel="prev" title="imgproc. Image Processing" href="imgproc.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="geometric_transformations.html" title="Geometric Image Transformations"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="imgproc.html" title="imgproc. Image Processing"
             accesskey="P">previous</a> |</li>
        <li><a href="../../../index.html">OpenCV 2.4.13.7 documentation</a> &raquo;</li>
          <li><a href="../../refman.html" >OpenCV API Reference</a> &raquo;</li>
          <li><a href="imgproc.html" accesskey="U">imgproc. Image Processing</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
  
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="image-filtering">
<h1>Image Filtering<a class="headerlink" href="#image-filtering" title="Permalink to this headline">¶</a></h1>
<p>Functions and classes described in this section are used to perform various linear or non-linear filtering operations on 2D images (represented as
<code class="xref ocv ocv-func docutils literal"><span class="pre">Mat()</span></code>&#8216;s). It means that for each pixel location
<img class="math" src="../../../_images/math/45b34b73b5a1fed1fd38b3a37ca1ada031de9970.png" alt="(x,y)"/> in the source image (normally, rectangular), its neighborhood is considered and used to compute the response. In case of a linear filter, it is a weighted sum of pixel values. In case of morphological operations, it is the minimum or maximum values, and so on. The computed response is stored in the destination image at the same location
<img class="math" src="../../../_images/math/45b34b73b5a1fed1fd38b3a37ca1ada031de9970.png" alt="(x,y)"/> . It means that the output image will be of the same size as the input image. Normally, the functions support multi-channel arrays, in which case every channel is processed independently. Therefore, the output image will also have the same number of channels as the input one.</p>
<p>Another common feature of the functions and classes described in this section is that, unlike simple arithmetic functions, they need to extrapolate values of some non-existing pixels. For example, if you want to smooth an image using a Gaussian
<img class="math" src="../../../_images/math/4e17330236365b9188352f6e0aeef470b1f872f1.png" alt="3 \times 3"/> filter, then, when processing the left-most pixels in each row, you need pixels to the left of them, that is, outside of the image. You can let these pixels be the same as the left-most image pixels (&#8220;replicated border&#8221; extrapolation method), or assume that all the non-existing pixels are zeros (&#8220;constant border&#8221; extrapolation method), and so on.
OpenCV enables you to specify the extrapolation method. For details, see the function  <a class="reference internal" href="#int borderInterpolate(int p, int len, int borderType)" title="int borderInterpolate(int p, int len, int borderType)"><code class="xref ocv ocv-func docutils literal"><span class="pre">borderInterpolate()</span></code></a>  and discussion of the  <code class="docutils literal"><span class="pre">borderType</span></code>  parameter in the section and various functions below.</p>
<div class="highlight-cpp"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> Various border types, image boundaries are denoted with &#39;|&#39;</span>

<span class="cm"> * BORDER_REPLICATE:     aaaaaa|abcdefgh|hhhhhhh</span>
<span class="cm"> * BORDER_REFLECT:       fedcba|abcdefgh|hgfedcb</span>
<span class="cm"> * BORDER_REFLECT_101:   gfedcb|abcdefgh|gfedcba</span>
<span class="cm"> * BORDER_WRAP:          cdefgh|abcdefgh|abcdefg</span>
<span class="cm"> * BORDER_CONSTANT:      iiiiii|abcdefgh|iiiiiii  with some specified &#39;i&#39;</span>
<span class="cm"> */</span>
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<ul class="last simple">
<li>(Python) A complete example illustrating different morphological operations like erode/dilate, open/close, blackhat/tophat ... can be found at opencv_source_code/samples/python2/morphology.py</li>
</ul>
</div>
<div class="section" id="basecolumnfilter">
<h2>BaseColumnFilter<a class="headerlink" href="#basecolumnfilter" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="BaseColumnFilter">
<em class="property">class </em><code class="descname">BaseColumnFilter</code><a class="headerlink" href="#BaseColumnFilter" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p>Base class for filters with single-column kernels.</p>
<div class="highlight-cpp"><div class="highlight"><pre><span class="k">class</span> <span class="nc">BaseColumnFilter</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="k">virtual</span> <span class="o">~</span><span class="n">BaseColumnFilter</span><span class="p">();</span>

    <span class="c1">// To be overriden by the user.</span>
    <span class="c1">//</span>
    <span class="c1">// runs a filtering operation on the set of rows,</span>
    <span class="c1">// &quot;dstcount + ksize - 1&quot; rows on input,</span>
    <span class="c1">// &quot;dstcount&quot; rows on output,</span>
    <span class="c1">// each input and output row has &quot;width&quot; elements</span>
    <span class="c1">// the filtered rows are written into &quot;dst&quot; buffer.</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">operator</span><span class="p">()(</span><span class="k">const</span> <span class="n">uchar</span><span class="o">**</span> <span class="n">src</span><span class="p">,</span> <span class="n">uchar</span><span class="o">*</span> <span class="n">dst</span><span class="p">,</span> <span class="kt">int</span> <span class="n">dststep</span><span class="p">,</span>
                            <span class="kt">int</span> <span class="n">dstcount</span><span class="p">,</span> <span class="kt">int</span> <span class="n">width</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="c1">// resets the filter state (may be needed for IIR filters)</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">reset</span><span class="p">();</span>

    <span class="kt">int</span> <span class="n">ksize</span><span class="p">;</span> <span class="c1">// the aperture size</span>
    <span class="kt">int</span> <span class="n">anchor</span><span class="p">;</span> <span class="c1">// position of the anchor point,</span>
                <span class="c1">// normally not used during the processing</span>
<span class="p">};</span>
</pre></div>
</div>
<p>The class <code class="docutils literal"><span class="pre">BaseColumnFilter</span></code> is a base class for filtering data using single-column kernels. Filtering does not have to be a linear operation. In general, it could be written as follows:</p>
<div class="math">
<p><img src="../../../_images/math/87b6998da76fc87faea44038ee7f16881939a466.png" alt="\texttt{dst} (x,y) = F( \texttt{src} [y](x), \; \texttt{src} [y+1](x), \; ..., \; \texttt{src} [y+ \texttt{ksize} -1](x)"/></p>
</div><p>where
<img class="math" src="../../../_images/math/be6771c7d34c7c1a47dc5863ebc1470d10a47720.png" alt="F"/> is a filtering function but, as it is represented as a class, it can produce any side effects, memorize previously processed data, and so on. The class only defines an interface and is not used directly. Instead, there are several functions in OpenCV (and you can add more) that return pointers to the derived classes that implement specific filtering operations. Those pointers are then passed to the
<a class="reference internal" href="#FilterEngine" title="class FilterEngine"><code class="xref ocv ocv-class docutils literal"><span class="pre">FilterEngine</span></code></a> constructor. While the filtering operation interface uses the <code class="docutils literal"><span class="pre">uchar</span></code> type, a particular implementation is not limited to 8-bit data.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#BaseRowFilter" title="class BaseRowFilter"><code class="xref ocv ocv-class docutils literal"><span class="pre">BaseRowFilter</span></code></a>,
<a class="reference internal" href="#BaseFilter" title="class BaseFilter"><code class="xref ocv ocv-class docutils literal"><span class="pre">BaseFilter</span></code></a>,
<a class="reference internal" href="#FilterEngine" title="class FilterEngine"><code class="xref ocv ocv-class docutils literal"><span class="pre">FilterEngine</span></code></a>,
<a class="reference internal" href="#Ptr&lt;BaseColumnFilter&gt; getColumnSumFilter(int sumType, int dstType, int ksize, int anchor, double scale)" title="Ptr&lt;BaseColumnFilter&gt; getColumnSumFilter(int sumType, int dstType, int ksize, int anchor, double scale)"><code class="xref ocv ocv-func docutils literal"><span class="pre">getColumnSumFilter()</span></code></a>,
<a class="reference internal" href="#Ptr&lt;BaseColumnFilter&gt; getLinearColumnFilter(int bufType, int dstType, InputArray kernel, int anchor, int symmetryType, double delta, int bits)" title="Ptr&lt;BaseColumnFilter&gt; getLinearColumnFilter(int bufType, int dstType, InputArray kernel, int anchor, int symmetryType, double delta, int bits)"><code class="xref ocv ocv-func docutils literal"><span class="pre">getLinearColumnFilter()</span></code></a>,
<a class="reference internal" href="#Ptr&lt;BaseColumnFilter&gt; getMorphologyColumnFilter(int op, int type, int ksize, int anchor)" title="Ptr&lt;BaseColumnFilter&gt; getMorphologyColumnFilter(int op, int type, int ksize, int anchor)"><code class="xref ocv ocv-func docutils literal"><span class="pre">getMorphologyColumnFilter()</span></code></a></p>
</div>
</div>
<div class="section" id="basefilter">
<h2>BaseFilter<a class="headerlink" href="#basefilter" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="BaseFilter">
<em class="property">class </em><code class="descname">BaseFilter</code><a class="headerlink" href="#BaseFilter" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p>Base class for 2D image filters.</p>
<div class="highlight-cpp"><div class="highlight"><pre><span class="k">class</span> <span class="nc">BaseFilter</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="k">virtual</span> <span class="o">~</span><span class="n">BaseFilter</span><span class="p">();</span>

    <span class="c1">// To be overriden by the user.</span>
    <span class="c1">//</span>
    <span class="c1">// runs a filtering operation on the set of rows,</span>
    <span class="c1">// &quot;dstcount + ksize.height - 1&quot; rows on input,</span>
    <span class="c1">// &quot;dstcount&quot; rows on output,</span>
    <span class="c1">// each input row has &quot;(width + ksize.width-1)*cn&quot; elements</span>
    <span class="c1">// each output row has &quot;width*cn&quot; elements.</span>
    <span class="c1">// the filtered rows are written into &quot;dst&quot; buffer.</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">operator</span><span class="p">()(</span><span class="k">const</span> <span class="n">uchar</span><span class="o">**</span> <span class="n">src</span><span class="p">,</span> <span class="n">uchar</span><span class="o">*</span> <span class="n">dst</span><span class="p">,</span> <span class="kt">int</span> <span class="n">dststep</span><span class="p">,</span>
                            <span class="kt">int</span> <span class="n">dstcount</span><span class="p">,</span> <span class="kt">int</span> <span class="n">width</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cn</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="c1">// resets the filter state (may be needed for IIR filters)</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">reset</span><span class="p">();</span>
    <span class="n">Size</span> <span class="n">ksize</span><span class="p">;</span>
    <span class="n">Point</span> <span class="n">anchor</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
<p>The class <code class="docutils literal"><span class="pre">BaseFilter</span></code> is a base class for filtering data using 2D kernels. Filtering does not have to be a linear operation. In general, it could be written as follows:</p>
<div class="math">
<p><img src="../../../_images/math/2e66263937a705482e5789af472844442b4c4a84.png" alt="\begin{array}{l} \texttt{dst} (x,y) = F(  \texttt{src} [y](x), \; \texttt{src} [y](x+1), \; ..., \; \texttt{src} [y](x+ \texttt{ksize.width} -1),  \\ \texttt{src} [y+1](x), \; \texttt{src} [y+1](x+1), \; ..., \; \texttt{src} [y+1](x+ \texttt{ksize.width} -1),  \\ .........................................................................................  \\ \texttt{src} [y+ \texttt{ksize.height-1} ](x), \\ \texttt{src} [y+ \texttt{ksize.height-1} ](x+1), \\ ...
   \texttt{src} [y+ \texttt{ksize.height-1} ](x+ \texttt{ksize.width} -1))
   \end{array}"/></p>
</div><p>where
<img class="math" src="../../../_images/math/be6771c7d34c7c1a47dc5863ebc1470d10a47720.png" alt="F"/> is a filtering function. The class only defines an interface and is not used directly. Instead, there are several functions in OpenCV (and you can add more) that return pointers to the derived classes that implement specific filtering operations. Those pointers are then passed to the
<a class="reference internal" href="#FilterEngine" title="class FilterEngine"><code class="xref ocv ocv-class docutils literal"><span class="pre">FilterEngine</span></code></a> constructor. While the filtering operation interface uses the <code class="docutils literal"><span class="pre">uchar</span></code> type, a particular implementation is not limited to 8-bit data.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#BaseColumnFilter" title="class BaseColumnFilter"><code class="xref ocv ocv-class docutils literal"><span class="pre">BaseColumnFilter</span></code></a>,
<a class="reference internal" href="#BaseRowFilter" title="class BaseRowFilter"><code class="xref ocv ocv-class docutils literal"><span class="pre">BaseRowFilter</span></code></a>,
<a class="reference internal" href="#FilterEngine" title="class FilterEngine"><code class="xref ocv ocv-class docutils literal"><span class="pre">FilterEngine</span></code></a>,
<a class="reference internal" href="#Ptr&lt;BaseFilter&gt; getLinearFilter(int srcType, int dstType, InputArray kernel, Point anchor, double delta, int bits)" title="Ptr&lt;BaseFilter&gt; getLinearFilter(int srcType, int dstType, InputArray kernel, Point anchor, double delta, int bits)"><code class="xref ocv ocv-func docutils literal"><span class="pre">getLinearFilter()</span></code></a>,
<a class="reference internal" href="#Ptr&lt;BaseFilter&gt; getMorphologyFilter(int op, int type, InputArray kernel, Point anchor)" title="Ptr&lt;BaseFilter&gt; getMorphologyFilter(int op, int type, InputArray kernel, Point anchor)"><code class="xref ocv ocv-func docutils literal"><span class="pre">getMorphologyFilter()</span></code></a></p>
</div>
</div>
<div class="section" id="baserowfilter">
<h2>BaseRowFilter<a class="headerlink" href="#baserowfilter" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="BaseRowFilter">
<em class="property">class </em><code class="descname">BaseRowFilter</code><a class="headerlink" href="#BaseRowFilter" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p>Base class for filters with single-row kernels.</p>
<div class="highlight-cpp"><div class="highlight"><pre><span class="k">class</span> <span class="nc">BaseRowFilter</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="k">virtual</span> <span class="o">~</span><span class="n">BaseRowFilter</span><span class="p">();</span>

    <span class="c1">// To be overriden by the user.</span>
    <span class="c1">//</span>
    <span class="c1">// runs filtering operation on the single input row</span>
    <span class="c1">// of &quot;width&quot; element, each element is has &quot;cn&quot; channels.</span>
    <span class="c1">// the filtered row is written into &quot;dst&quot; buffer.</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">operator</span><span class="p">()(</span><span class="k">const</span> <span class="n">uchar</span><span class="o">*</span> <span class="n">src</span><span class="p">,</span> <span class="n">uchar</span><span class="o">*</span> <span class="n">dst</span><span class="p">,</span>
                            <span class="kt">int</span> <span class="n">width</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cn</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">ksize</span><span class="p">,</span> <span class="n">anchor</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
<p>The class <code class="docutils literal"><span class="pre">BaseRowFilter</span></code> is a base class for filtering data using single-row kernels. Filtering does not have to be a linear operation. In general, it could be written as follows:</p>
<div class="math">
<p><img src="../../../_images/math/878d5ea99017960ebae06a6ba057f838f11c8c09.png" alt="\texttt{dst} (x,y) = F( \texttt{src} [y](x), \; \texttt{src} [y](x+1), \; ..., \; \texttt{src} [y](x+ \texttt{ksize.width} -1))"/></p>
</div><p>where
<img class="math" src="../../../_images/math/be6771c7d34c7c1a47dc5863ebc1470d10a47720.png" alt="F"/> is a filtering function. The class only defines an interface and is not used directly. Instead, there are several functions in OpenCV (and you can add more) that return pointers to the derived classes that implement specific filtering operations. Those pointers are then passed to the
<a class="reference internal" href="#FilterEngine" title="class FilterEngine"><code class="xref ocv ocv-class docutils literal"><span class="pre">FilterEngine</span></code></a> constructor. While the filtering operation interface uses the <code class="docutils literal"><span class="pre">uchar</span></code> type, a particular implementation is not limited to 8-bit data.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#BaseColumnFilter" title="class BaseColumnFilter"><code class="xref ocv ocv-class docutils literal"><span class="pre">BaseColumnFilter</span></code></a>,
<a class="reference internal" href="#BaseFilter" title="class BaseFilter"><code class="xref ocv ocv-class docutils literal"><span class="pre">BaseFilter</span></code></a>,
<a class="reference internal" href="#FilterEngine" title="class FilterEngine"><code class="xref ocv ocv-class docutils literal"><span class="pre">FilterEngine</span></code></a>,
<a class="reference internal" href="#Ptr&lt;BaseRowFilter&gt; getLinearRowFilter(int srcType, int bufType, InputArray kernel, int anchor, int symmetryType)" title="Ptr&lt;BaseRowFilter&gt; getLinearRowFilter(int srcType, int bufType, InputArray kernel, int anchor, int symmetryType)"><code class="xref ocv ocv-func docutils literal"><span class="pre">getLinearRowFilter()</span></code></a>,
<a class="reference internal" href="#Ptr&lt;BaseRowFilter&gt; getMorphologyRowFilter(int op, int type, int ksize, int anchor)" title="Ptr&lt;BaseRowFilter&gt; getMorphologyRowFilter(int op, int type, int ksize, int anchor)"><code class="xref ocv ocv-func docutils literal"><span class="pre">getMorphologyRowFilter()</span></code></a>,
<a class="reference internal" href="#Ptr&lt;BaseRowFilter&gt; getRowSumFilter(int srcType, int sumType, int ksize, int anchor)" title="Ptr&lt;BaseRowFilter&gt; getRowSumFilter(int srcType, int sumType, int ksize, int anchor)"><code class="xref ocv ocv-func docutils literal"><span class="pre">getRowSumFilter()</span></code></a></p>
</div>
</div>
<div class="section" id="filterengine">
<h2>FilterEngine<a class="headerlink" href="#filterengine" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="FilterEngine">
<em class="property">class </em><code class="descname">FilterEngine</code><a class="headerlink" href="#FilterEngine" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p>Generic image filtering class.</p>
<div class="highlight-cpp"><div class="highlight"><pre><span class="k">class</span> <span class="nc">FilterEngine</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="c1">// empty constructor</span>
    <span class="n">FilterEngine</span><span class="p">();</span>
    <span class="c1">// builds a 2D non-separable filter (!_filter2D.empty()) or</span>
    <span class="c1">// a separable filter (!_rowFilter.empty() &amp;&amp; !_columnFilter.empty())</span>
    <span class="c1">// the input data type will be &quot;srcType&quot;, the output data type will be &quot;dstType&quot;,</span>
    <span class="c1">// the intermediate data type is &quot;bufType&quot;.</span>
    <span class="c1">// _rowBorderType and _columnBorderType determine how the image</span>
    <span class="c1">// will be extrapolated beyond the image boundaries.</span>
    <span class="c1">// _borderValue is only used when _rowBorderType and/or _columnBorderType</span>
    <span class="c1">// == BORDER_CONSTANT</span>
    <span class="n">FilterEngine</span><span class="p">(</span><span class="k">const</span> <span class="n">Ptr</span><span class="o">&lt;</span><span class="n">BaseFilter</span><span class="o">&gt;&amp;</span> <span class="n">_filter2D</span><span class="p">,</span>
                 <span class="k">const</span> <span class="n">Ptr</span><span class="o">&lt;</span><span class="n">BaseRowFilter</span><span class="o">&gt;&amp;</span> <span class="n">_rowFilter</span><span class="p">,</span>
                 <span class="k">const</span> <span class="n">Ptr</span><span class="o">&lt;</span><span class="n">BaseColumnFilter</span><span class="o">&gt;&amp;</span> <span class="n">_columnFilter</span><span class="p">,</span>
                 <span class="kt">int</span> <span class="n">srcType</span><span class="p">,</span> <span class="kt">int</span> <span class="n">dstType</span><span class="p">,</span> <span class="kt">int</span> <span class="n">bufType</span><span class="p">,</span>
                 <span class="kt">int</span> <span class="n">_rowBorderType</span><span class="o">=</span><span class="n">BORDER_REPLICATE</span><span class="p">,</span>
                 <span class="kt">int</span> <span class="n">_columnBorderType</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="c1">// use _rowBorderType by default</span>
                 <span class="k">const</span> <span class="n">Scalar</span><span class="o">&amp;</span> <span class="n">_borderValue</span><span class="o">=</span><span class="n">Scalar</span><span class="p">());</span>
    <span class="k">virtual</span> <span class="o">~</span><span class="n">FilterEngine</span><span class="p">();</span>
    <span class="c1">// separate function for the engine initialization</span>
    <span class="kt">void</span> <span class="nf">init</span><span class="p">(</span><span class="k">const</span> <span class="n">Ptr</span><span class="o">&lt;</span><span class="n">BaseFilter</span><span class="o">&gt;&amp;</span> <span class="n">_filter2D</span><span class="p">,</span>
              <span class="k">const</span> <span class="n">Ptr</span><span class="o">&lt;</span><span class="n">BaseRowFilter</span><span class="o">&gt;&amp;</span> <span class="n">_rowFilter</span><span class="p">,</span>
              <span class="k">const</span> <span class="n">Ptr</span><span class="o">&lt;</span><span class="n">BaseColumnFilter</span><span class="o">&gt;&amp;</span> <span class="n">_columnFilter</span><span class="p">,</span>
              <span class="kt">int</span> <span class="n">srcType</span><span class="p">,</span> <span class="kt">int</span> <span class="n">dstType</span><span class="p">,</span> <span class="kt">int</span> <span class="n">bufType</span><span class="p">,</span>
              <span class="kt">int</span> <span class="n">_rowBorderType</span><span class="o">=</span><span class="n">BORDER_REPLICATE</span><span class="p">,</span> <span class="kt">int</span> <span class="n">_columnBorderType</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span>
              <span class="k">const</span> <span class="n">Scalar</span><span class="o">&amp;</span> <span class="n">_borderValue</span><span class="o">=</span><span class="n">Scalar</span><span class="p">());</span>
    <span class="c1">// starts filtering of the ROI in an image of size &quot;wholeSize&quot;.</span>
    <span class="c1">// returns the starting y-position in the source image.</span>
    <span class="k">virtual</span> <span class="kt">int</span> <span class="nf">start</span><span class="p">(</span><span class="n">Size</span> <span class="n">wholeSize</span><span class="p">,</span> <span class="n">Rect</span> <span class="n">roi</span><span class="p">,</span> <span class="kt">int</span> <span class="n">maxBufRows</span><span class="o">=-</span><span class="mi">1</span><span class="p">);</span>
    <span class="c1">// alternative form of start that takes the image</span>
    <span class="c1">// itself instead of &quot;wholeSize&quot;. Set isolated to true to pretend that</span>
    <span class="c1">// there are no real pixels outside of the ROI</span>
    <span class="c1">// (so that the pixels are extrapolated using the specified border modes)</span>
    <span class="k">virtual</span> <span class="kt">int</span> <span class="nf">start</span><span class="p">(</span><span class="k">const</span> <span class="n">Mat</span><span class="o">&amp;</span> <span class="n">src</span><span class="p">,</span> <span class="k">const</span> <span class="n">Rect</span><span class="o">&amp;</span> <span class="n">srcRoi</span><span class="o">=</span><span class="n">Rect</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">),</span>
                      <span class="kt">bool</span> <span class="n">isolated</span><span class="o">=</span><span class="nb">false</span><span class="p">,</span> <span class="kt">int</span> <span class="n">maxBufRows</span><span class="o">=-</span><span class="mi">1</span><span class="p">);</span>
    <span class="c1">// processes the next portion of the source image,</span>
    <span class="c1">// &quot;srcCount&quot; rows starting from &quot;src&quot; and</span>
    <span class="c1">// stores the results in &quot;dst&quot;.</span>
    <span class="c1">// returns the number of produced rows</span>
    <span class="k">virtual</span> <span class="kt">int</span> <span class="nf">proceed</span><span class="p">(</span><span class="k">const</span> <span class="n">uchar</span><span class="o">*</span> <span class="n">src</span><span class="p">,</span> <span class="kt">int</span> <span class="n">srcStep</span><span class="p">,</span> <span class="kt">int</span> <span class="n">srcCount</span><span class="p">,</span>
                        <span class="n">uchar</span><span class="o">*</span> <span class="n">dst</span><span class="p">,</span> <span class="kt">int</span> <span class="n">dstStep</span><span class="p">);</span>
    <span class="c1">// higher-level function that processes the whole</span>
    <span class="c1">// ROI or the whole image with a single call</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">apply</span><span class="p">(</span> <span class="k">const</span> <span class="n">Mat</span><span class="o">&amp;</span> <span class="n">src</span><span class="p">,</span> <span class="n">Mat</span><span class="o">&amp;</span> <span class="n">dst</span><span class="p">,</span>
                        <span class="k">const</span> <span class="n">Rect</span><span class="o">&amp;</span> <span class="n">srcRoi</span><span class="o">=</span><span class="n">Rect</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">),</span>
                        <span class="n">Point</span> <span class="n">dstOfs</span><span class="o">=</span><span class="n">Point</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span>
                        <span class="kt">bool</span> <span class="n">isolated</span><span class="o">=</span><span class="nb">false</span><span class="p">);</span>
    <span class="kt">bool</span> <span class="nf">isSeparable</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">filter2D</span><span class="p">.</span><span class="n">empty</span><span class="p">();</span> <span class="p">}</span>
    <span class="c1">// how many rows from the input image are not yet processed</span>
    <span class="kt">int</span> <span class="nf">remainingInputRows</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
    <span class="c1">// how many output rows are not yet produced</span>
    <span class="kt">int</span> <span class="nf">remainingOutputRows</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
    <span class="p">...</span>
    <span class="c1">// the starting and the ending rows in the source image</span>
    <span class="kt">int</span> <span class="n">startY</span><span class="p">,</span> <span class="n">endY</span><span class="p">;</span>

    <span class="c1">// pointers to the filters</span>
    <span class="n">Ptr</span><span class="o">&lt;</span><span class="n">BaseFilter</span><span class="o">&gt;</span> <span class="n">filter2D</span><span class="p">;</span>
    <span class="n">Ptr</span><span class="o">&lt;</span><span class="n">BaseRowFilter</span><span class="o">&gt;</span> <span class="n">rowFilter</span><span class="p">;</span>
    <span class="n">Ptr</span><span class="o">&lt;</span><span class="n">BaseColumnFilter</span><span class="o">&gt;</span> <span class="n">columnFilter</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
<p>The class <code class="docutils literal"><span class="pre">FilterEngine</span></code> can be used to apply an arbitrary filtering operation to an image.
It contains all the necessary intermediate buffers, computes extrapolated values
of the &#8220;virtual&#8221; pixels outside of the image, and so on. Pointers to the initialized <code class="docutils literal"><span class="pre">FilterEngine</span></code> instances
are returned by various <code class="docutils literal"><span class="pre">create*Filter</span></code> functions (see below) and they are used inside high-level functions such as
<a class="reference internal" href="#void filter2D(InputArray src, OutputArray dst, int ddepth, InputArray kernel, Point anchor, double delta, int borderType)" title="void filter2D(InputArray src, OutputArray dst, int ddepth, InputArray kernel, Point anchor, double delta, int borderType)"><code class="xref ocv ocv-func docutils literal"><span class="pre">filter2D()</span></code></a>,
<a class="reference internal" href="#void erode(InputArray src, OutputArray dst, InputArray kernel, Point anchor, int iterations, int borderType, const Scalar&amp; borderValue)" title="void erode(InputArray src, OutputArray dst, InputArray kernel, Point anchor, int iterations, int borderType, const Scalar&amp; borderValue)"><code class="xref ocv ocv-func docutils literal"><span class="pre">erode()</span></code></a>,
<a class="reference internal" href="#void dilate(InputArray src, OutputArray dst, InputArray kernel, Point anchor, int iterations, int borderType, const Scalar&amp; borderValue)" title="void dilate(InputArray src, OutputArray dst, InputArray kernel, Point anchor, int iterations, int borderType, const Scalar&amp; borderValue)"><code class="xref ocv ocv-func docutils literal"><span class="pre">dilate()</span></code></a>, and others. Thus, the class plays a key role in many of OpenCV filtering functions.</p>
<p>This class makes it easier to combine filtering operations with other operations, such as color space conversions, thresholding, arithmetic operations, and others. By combining several operations together you can get much better performance because your data will stay in cache. For example, see below the implementation of the Laplace operator for floating-point images, which is a simplified implementation of
<a class="reference internal" href="#void Laplacian(InputArray src, OutputArray dst, int ddepth, int ksize, double scale, double delta, int borderType)" title="void Laplacian(InputArray src, OutputArray dst, int ddepth, int ksize, double scale, double delta, int borderType)"><code class="xref ocv ocv-func docutils literal"><span class="pre">Laplacian()</span></code></a> :</p>
<div class="highlight-cpp"><div class="highlight"><pre><span class="kt">void</span> <span class="nf">laplace_f</span><span class="p">(</span><span class="k">const</span> <span class="n">Mat</span><span class="o">&amp;</span> <span class="n">src</span><span class="p">,</span> <span class="n">Mat</span><span class="o">&amp;</span> <span class="n">dst</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">CV_Assert</span><span class="p">(</span> <span class="n">src</span><span class="p">.</span><span class="n">type</span><span class="p">()</span> <span class="o">==</span> <span class="n">CV_32F</span> <span class="p">);</span>
    <span class="n">dst</span><span class="p">.</span><span class="n">create</span><span class="p">(</span><span class="n">src</span><span class="p">.</span><span class="n">size</span><span class="p">(),</span> <span class="n">src</span><span class="p">.</span><span class="n">type</span><span class="p">());</span>

    <span class="c1">// get the derivative and smooth kernels for d2I/dx2.</span>
    <span class="c1">// for d2I/dy2 consider using the same kernels, just swapped</span>
    <span class="n">Mat</span> <span class="n">kd</span><span class="p">,</span> <span class="n">ks</span><span class="p">;</span>
    <span class="n">getSobelKernels</span><span class="p">(</span> <span class="n">kd</span><span class="p">,</span> <span class="n">ks</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">ksize</span><span class="p">,</span> <span class="nb">false</span><span class="p">,</span> <span class="n">ktype</span> <span class="p">);</span>

    <span class="c1">// process 10 source rows at once</span>
    <span class="kt">int</span> <span class="n">DELTA</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">min</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="n">src</span><span class="p">.</span><span class="n">rows</span><span class="p">);</span>
    <span class="n">Ptr</span><span class="o">&lt;</span><span class="n">FilterEngine</span><span class="o">&gt;</span> <span class="n">Fxx</span> <span class="o">=</span> <span class="n">createSeparableLinearFilter</span><span class="p">(</span><span class="n">src</span><span class="p">.</span><span class="n">type</span><span class="p">(),</span>
        <span class="n">dst</span><span class="p">.</span><span class="n">type</span><span class="p">(),</span> <span class="n">kd</span><span class="p">,</span> <span class="n">ks</span><span class="p">,</span> <span class="n">Point</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span> <span class="n">borderType</span><span class="p">,</span> <span class="n">borderType</span><span class="p">,</span> <span class="n">Scalar</span><span class="p">()</span> <span class="p">);</span>
    <span class="n">Ptr</span><span class="o">&lt;</span><span class="n">FilterEngine</span><span class="o">&gt;</span> <span class="n">Fyy</span> <span class="o">=</span> <span class="n">createSeparableLinearFilter</span><span class="p">(</span><span class="n">src</span><span class="p">.</span><span class="n">type</span><span class="p">(),</span>
        <span class="n">dst</span><span class="p">.</span><span class="n">type</span><span class="p">(),</span> <span class="n">ks</span><span class="p">,</span> <span class="n">kd</span><span class="p">,</span> <span class="n">Point</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span> <span class="n">borderType</span><span class="p">,</span> <span class="n">borderType</span><span class="p">,</span> <span class="n">Scalar</span><span class="p">()</span> <span class="p">);</span>

    <span class="kt">int</span> <span class="n">y</span> <span class="o">=</span> <span class="n">Fxx</span><span class="o">-&gt;</span><span class="n">start</span><span class="p">(</span><span class="n">src</span><span class="p">),</span> <span class="n">dsty</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">dy</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">Fyy</span><span class="o">-&gt;</span><span class="n">start</span><span class="p">(</span><span class="n">src</span><span class="p">);</span>
    <span class="k">const</span> <span class="n">uchar</span><span class="o">*</span> <span class="n">sptr</span> <span class="o">=</span> <span class="n">src</span><span class="p">.</span><span class="n">data</span> <span class="o">+</span> <span class="n">y</span><span class="o">*</span><span class="n">src</span><span class="p">.</span><span class="n">step</span><span class="p">;</span>

    <span class="c1">// allocate the buffers for the spatial image derivatives;</span>
    <span class="c1">// the buffers need to have more than DELTA rows, because at the</span>
    <span class="c1">// last iteration the output may take max(kd.rows-1,ks.rows-1)</span>
    <span class="c1">// rows more than the input.</span>
    <span class="n">Mat</span> <span class="n">Ixx</span><span class="p">(</span> <span class="n">DELTA</span> <span class="o">+</span> <span class="n">kd</span><span class="p">.</span><span class="n">rows</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">src</span><span class="p">.</span><span class="n">cols</span><span class="p">,</span> <span class="n">dst</span><span class="p">.</span><span class="n">type</span><span class="p">()</span> <span class="p">);</span>
    <span class="n">Mat</span> <span class="n">Iyy</span><span class="p">(</span> <span class="n">DELTA</span> <span class="o">+</span> <span class="n">kd</span><span class="p">.</span><span class="n">rows</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">src</span><span class="p">.</span><span class="n">cols</span><span class="p">,</span> <span class="n">dst</span><span class="p">.</span><span class="n">type</span><span class="p">()</span> <span class="p">);</span>

    <span class="c1">// inside the loop always pass DELTA rows to the filter</span>
    <span class="c1">// (note that the &quot;proceed&quot; method takes care of possibe overflow, since</span>
    <span class="c1">// it was given the actual image height in the &quot;start&quot; method)</span>
    <span class="c1">// on output you can get:</span>
    <span class="c1">//  * &lt; DELTA rows (initial buffer accumulation stage)</span>
    <span class="c1">//  * = DELTA rows (settled state in the middle)</span>
    <span class="c1">//  * &gt; DELTA rows (when the input image is over, generate</span>
    <span class="c1">//                  &quot;virtual&quot; rows using the border mode and filter them)</span>
    <span class="c1">// this variable number of output rows is dy.</span>
    <span class="c1">// dsty is the current output row.</span>
    <span class="c1">// sptr is the pointer to the first input row in the portion to process</span>
    <span class="k">for</span><span class="p">(</span> <span class="p">;</span> <span class="n">dsty</span> <span class="o">&lt;</span> <span class="n">dst</span><span class="p">.</span><span class="n">rows</span><span class="p">;</span> <span class="n">sptr</span> <span class="o">+=</span> <span class="n">DELTA</span><span class="o">*</span><span class="n">src</span><span class="p">.</span><span class="n">step</span><span class="p">,</span> <span class="n">dsty</span> <span class="o">+=</span> <span class="n">dy</span> <span class="p">)</span>
    <span class="p">{</span>
        <span class="n">Fxx</span><span class="o">-&gt;</span><span class="n">proceed</span><span class="p">(</span> <span class="n">sptr</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">src</span><span class="p">.</span><span class="n">step</span><span class="p">,</span> <span class="n">DELTA</span><span class="p">,</span> <span class="n">Ixx</span><span class="p">.</span><span class="n">data</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">Ixx</span><span class="p">.</span><span class="n">step</span> <span class="p">);</span>
        <span class="n">dy</span> <span class="o">=</span> <span class="n">Fyy</span><span class="o">-&gt;</span><span class="n">proceed</span><span class="p">(</span> <span class="n">sptr</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">src</span><span class="p">.</span><span class="n">step</span><span class="p">,</span> <span class="n">DELTA</span><span class="p">,</span> <span class="n">d2y</span><span class="p">.</span><span class="n">data</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">Iyy</span><span class="p">.</span><span class="n">step</span> <span class="p">);</span>
        <span class="k">if</span><span class="p">(</span> <span class="n">dy</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="p">)</span>
        <span class="p">{</span>
            <span class="n">Mat</span> <span class="n">dstripe</span> <span class="o">=</span> <span class="n">dst</span><span class="p">.</span><span class="n">rowRange</span><span class="p">(</span><span class="n">dsty</span><span class="p">,</span> <span class="n">dsty</span> <span class="o">+</span> <span class="n">dy</span><span class="p">);</span>
            <span class="n">add</span><span class="p">(</span><span class="n">Ixx</span><span class="p">.</span><span class="n">rowRange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">dy</span><span class="p">),</span> <span class="n">Iyy</span><span class="p">.</span><span class="n">rowRange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">dy</span><span class="p">),</span> <span class="n">dstripe</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>If you do not need that much control of the filtering process, you can simply use the <code class="docutils literal"><span class="pre">FilterEngine::apply</span></code> method. The method is implemented as follows:</p>
<div class="highlight-cpp"><div class="highlight"><pre><span class="kt">void</span> <span class="n">FilterEngine</span><span class="o">::</span><span class="n">apply</span><span class="p">(</span><span class="k">const</span> <span class="n">Mat</span><span class="o">&amp;</span> <span class="n">src</span><span class="p">,</span> <span class="n">Mat</span><span class="o">&amp;</span> <span class="n">dst</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">Rect</span><span class="o">&amp;</span> <span class="n">srcRoi</span><span class="p">,</span> <span class="n">Point</span> <span class="n">dstOfs</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">isolated</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// check matrix types</span>
    <span class="n">CV_Assert</span><span class="p">(</span> <span class="n">src</span><span class="p">.</span><span class="n">type</span><span class="p">()</span> <span class="o">==</span> <span class="n">srcType</span> <span class="o">&amp;&amp;</span> <span class="n">dst</span><span class="p">.</span><span class="n">type</span><span class="p">()</span> <span class="o">==</span> <span class="n">dstType</span> <span class="p">);</span>

    <span class="c1">// handle the &quot;whole image&quot; case</span>
    <span class="n">Rect</span> <span class="n">_srcRoi</span> <span class="o">=</span> <span class="n">srcRoi</span><span class="p">;</span>
    <span class="k">if</span><span class="p">(</span> <span class="n">_srcRoi</span> <span class="o">==</span> <span class="n">Rect</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">)</span>
        <span class="n">_srcRoi</span> <span class="o">=</span> <span class="n">Rect</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="n">src</span><span class="p">.</span><span class="n">cols</span><span class="p">,</span><span class="n">src</span><span class="p">.</span><span class="n">rows</span><span class="p">);</span>

    <span class="c1">// check if the destination ROI is inside dst.</span>
    <span class="c1">// and FilterEngine::start will check if the source ROI is inside src.</span>
    <span class="n">CV_Assert</span><span class="p">(</span> <span class="n">dstOfs</span><span class="p">.</span><span class="n">x</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">dstOfs</span><span class="p">.</span><span class="n">y</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span>
        <span class="n">dstOfs</span><span class="p">.</span><span class="n">x</span> <span class="o">+</span> <span class="n">_srcRoi</span><span class="p">.</span><span class="n">width</span> <span class="o">&lt;=</span> <span class="n">dst</span><span class="p">.</span><span class="n">cols</span> <span class="o">&amp;&amp;</span>
        <span class="n">dstOfs</span><span class="p">.</span><span class="n">y</span> <span class="o">+</span> <span class="n">_srcRoi</span><span class="p">.</span><span class="n">height</span> <span class="o">&lt;=</span> <span class="n">dst</span><span class="p">.</span><span class="n">rows</span> <span class="p">);</span>

    <span class="c1">// start filtering</span>
    <span class="kt">int</span> <span class="n">y</span> <span class="o">=</span> <span class="n">start</span><span class="p">(</span><span class="n">src</span><span class="p">,</span> <span class="n">_srcRoi</span><span class="p">,</span> <span class="n">isolated</span><span class="p">);</span>

    <span class="c1">// process the whole ROI. Note that &quot;endY - startY&quot; is the total number</span>
    <span class="c1">// of the source rows to process</span>
    <span class="c1">// (including the possible rows outside of srcRoi but inside the source image)</span>
    <span class="n">proceed</span><span class="p">(</span> <span class="n">src</span><span class="p">.</span><span class="n">data</span> <span class="o">+</span> <span class="n">y</span><span class="o">*</span><span class="n">src</span><span class="p">.</span><span class="n">step</span><span class="p">,</span>
             <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">src</span><span class="p">.</span><span class="n">step</span><span class="p">,</span> <span class="n">endY</span> <span class="o">-</span> <span class="n">startY</span><span class="p">,</span>
             <span class="n">dst</span><span class="p">.</span><span class="n">data</span> <span class="o">+</span> <span class="n">dstOfs</span><span class="p">.</span><span class="n">y</span><span class="o">*</span><span class="n">dst</span><span class="p">.</span><span class="n">step</span> <span class="o">+</span>
             <span class="n">dstOfs</span><span class="p">.</span><span class="n">x</span><span class="o">*</span><span class="n">dst</span><span class="p">.</span><span class="n">elemSize</span><span class="p">(),</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">dst</span><span class="p">.</span><span class="n">step</span> <span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Unlike the earlier versions of OpenCV, now the filtering operations fully support the notion of image ROI, that is, pixels outside of the ROI but inside the image can be used in the filtering operations. For example, you can take a ROI of a single pixel and filter it. This will be a filter response at that particular pixel. However, it is possible to emulate the old behavior by passing <code class="docutils literal"><span class="pre">isolated=false</span></code> to <code class="docutils literal"><span class="pre">FilterEngine::start</span></code> or <code class="docutils literal"><span class="pre">FilterEngine::apply</span></code> . You can pass the ROI explicitly to <code class="docutils literal"><span class="pre">FilterEngine::apply</span></code>  or construct new matrix headers:</p>
<div class="highlight-cpp"><div class="highlight"><pre><span class="c1">// compute dI/dx derivative at src(x,y)</span>

<span class="c1">// method 1:</span>
<span class="c1">// form a matrix header for a single value</span>
<span class="kt">float</span> <span class="n">val1</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="n">Mat</span> <span class="nf">dst1</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="n">CV_32F</span><span class="p">,</span><span class="o">&amp;</span><span class="n">val1</span><span class="p">);</span>

<span class="n">Ptr</span><span class="o">&lt;</span><span class="n">FilterEngine</span><span class="o">&gt;</span> <span class="n">Fx</span> <span class="o">=</span> <span class="n">createDerivFilter</span><span class="p">(</span><span class="n">CV_32F</span><span class="p">,</span> <span class="n">CV_32F</span><span class="p">,</span>
                        <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="n">BORDER_REFLECT_101</span><span class="p">);</span>
<span class="n">Fx</span><span class="o">-&gt;</span><span class="n">apply</span><span class="p">(</span><span class="n">src</span><span class="p">,</span> <span class="n">Rect</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span> <span class="n">Point</span><span class="p">(),</span> <span class="n">dst1</span><span class="p">);</span>

<span class="c1">// method 2:</span>
<span class="c1">// form a matrix header for a single value</span>
<span class="kt">float</span> <span class="n">val2</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="n">Mat</span> <span class="nf">dst2</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="n">CV_32F</span><span class="p">,</span><span class="o">&amp;</span><span class="n">val2</span><span class="p">);</span>

<span class="n">Mat</span> <span class="nf">pix_roi</span><span class="p">(</span><span class="n">src</span><span class="p">,</span> <span class="n">Rect</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">));</span>
<span class="n">Sobel</span><span class="p">(</span><span class="n">pix_roi</span><span class="p">,</span> <span class="n">dst2</span><span class="p">,</span> <span class="n">dst2</span><span class="p">.</span><span class="n">type</span><span class="p">(),</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">BORDER_REFLECT_101</span><span class="p">);</span>

<span class="n">printf</span><span class="p">(</span><span class="s">&quot;method1 =</span>
</pre></div>
</div>
<p>Explore the data types. As it was mentioned in the
<a class="reference internal" href="#BaseFilter" title="class BaseFilter"><code class="xref ocv ocv-class docutils literal"><span class="pre">BaseFilter</span></code></a> description, the specific filters can process data of any type, despite that <code class="docutils literal"><span class="pre">Base*Filter::operator()</span></code> only takes <code class="docutils literal"><span class="pre">uchar</span></code> pointers and no information about the actual types. To make it all work, the following rules are used:</p>
<ul class="simple">
<li>In case of separable filtering, <code class="docutils literal"><span class="pre">FilterEngine::rowFilter</span></code>   is  applied first. It transforms the input image data (of type <code class="docutils literal"><span class="pre">srcType</span></code>  ) to the intermediate results stored in the internal buffers (of type <code class="docutils literal"><span class="pre">bufType</span></code>   ). Then, these intermediate results are processed as
<em>single-channel data</em>
with <code class="docutils literal"><span class="pre">FilterEngine::columnFilter</span></code>     and stored in the output image (of type <code class="docutils literal"><span class="pre">dstType</span></code>     ). Thus, the input type for <code class="docutils literal"><span class="pre">rowFilter</span></code>     is <code class="docutils literal"><span class="pre">srcType</span></code>     and the output type is <code class="docutils literal"><span class="pre">bufType</span></code>  . The input type for <code class="docutils literal"><span class="pre">columnFilter</span></code>     is <code class="docutils literal"><span class="pre">CV_MAT_DEPTH(bufType)</span></code>     and the output type is <code class="docutils literal"><span class="pre">CV_MAT_DEPTH(dstType)</span></code>     .</li>
<li>In case of non-separable filtering, <code class="docutils literal"><span class="pre">bufType</span></code>     must be the same as <code class="docutils literal"><span class="pre">srcType</span></code>     . The source data is copied to the temporary buffer, if needed, and then just passed to <code class="docutils literal"><span class="pre">FilterEngine::filter2D</span></code>     . That is, the input type for <code class="docutils literal"><span class="pre">filter2D</span></code>     is <code class="docutils literal"><span class="pre">srcType</span></code>     (= <code class="docutils literal"><span class="pre">bufType</span></code>     ) and the output type is <code class="docutils literal"><span class="pre">dstType</span></code>     .</li>
</ul>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#BaseColumnFilter" title="class BaseColumnFilter"><code class="xref ocv ocv-class docutils literal"><span class="pre">BaseColumnFilter</span></code></a>,
<a class="reference internal" href="#BaseFilter" title="class BaseFilter"><code class="xref ocv ocv-class docutils literal"><span class="pre">BaseFilter</span></code></a>,
<a class="reference internal" href="#BaseRowFilter" title="class BaseRowFilter"><code class="xref ocv ocv-class docutils literal"><span class="pre">BaseRowFilter</span></code></a>,
<a class="reference internal" href="#Ptr&lt;FilterEngine&gt; createBoxFilter(int srcType, int dstType, Size ksize, Point anchor, bool normalize, int borderType)" title="Ptr&lt;FilterEngine&gt; createBoxFilter(int srcType, int dstType, Size ksize, Point anchor, bool normalize, int borderType)"><code class="xref ocv ocv-func docutils literal"><span class="pre">createBoxFilter()</span></code></a>,
<a class="reference internal" href="#Ptr&lt;FilterEngine&gt; createDerivFilter(int srcType, int dstType, int dx, int dy, int ksize, int borderType)" title="Ptr&lt;FilterEngine&gt; createDerivFilter(int srcType, int dstType, int dx, int dy, int ksize, int borderType)"><code class="xref ocv ocv-func docutils literal"><span class="pre">createDerivFilter()</span></code></a>,
<a class="reference internal" href="#Ptr&lt;FilterEngine&gt; createGaussianFilter(int type, Size ksize, double sigma1, double sigma2, int borderType)" title="Ptr&lt;FilterEngine&gt; createGaussianFilter(int type, Size ksize, double sigma1, double sigma2, int borderType)"><code class="xref ocv ocv-func docutils literal"><span class="pre">createGaussianFilter()</span></code></a>,
<a class="reference internal" href="#Ptr&lt;FilterEngine&gt; createLinearFilter(int srcType, int dstType, InputArray kernel, Point _anchor, double delta, int rowBorderType, int columnBorderType, const Scalar&amp; borderValue)" title="Ptr&lt;FilterEngine&gt; createLinearFilter(int srcType, int dstType, InputArray kernel, Point _anchor, double delta, int rowBorderType, int columnBorderType, const Scalar&amp; borderValue)"><code class="xref ocv ocv-func docutils literal"><span class="pre">createLinearFilter()</span></code></a>,
<a class="reference internal" href="#Ptr&lt;FilterEngine&gt; createMorphologyFilter(int op, int type, InputArray kernel, Point anchor, int rowBorderType, int columnBorderType, const Scalar&amp; borderValue)" title="Ptr&lt;FilterEngine&gt; createMorphologyFilter(int op, int type, InputArray kernel, Point anchor, int rowBorderType, int columnBorderType, const Scalar&amp; borderValue)"><code class="xref ocv ocv-func docutils literal"><span class="pre">createMorphologyFilter()</span></code></a>,
<a class="reference internal" href="#Ptr&lt;FilterEngine&gt; createSeparableLinearFilter(int srcType, int dstType, InputArray rowKernel, InputArray columnKernel, Point anchor, double delta, int rowBorderType, int columnBorderType, const Scalar&amp; borderValue)" title="Ptr&lt;FilterEngine&gt; createSeparableLinearFilter(int srcType, int dstType, InputArray rowKernel, InputArray columnKernel, Point anchor, double delta, int rowBorderType, int columnBorderType, const Scalar&amp; borderValue)"><code class="xref ocv ocv-func docutils literal"><span class="pre">createSeparableLinearFilter()</span></code></a></p>
</div>
</div>
<div class="section" id="bilateralfilter">
<h2>bilateralFilter<a class="headerlink" href="#bilateralfilter" title="Permalink to this headline">¶</a></h2>
<p>Applies the bilateral filter to an image.</p>
<dl class="function">
<dt id="void bilateralFilter(InputArray src, OutputArray dst, int d, double sigmaColor, double sigmaSpace, int borderType)">
<strong>C++:</strong><code class="descname"> </code>void <code class="descname">bilateralFilter</code><span class="sig-paren">(</span>InputArray <strong>src</strong>, OutputArray <strong>dst</strong>, int <strong>d</strong>, double <strong>sigmaColor</strong>, double <strong>sigmaSpace</strong>, int <strong>borderType</strong>=BORDER_DEFAULT <span class="sig-paren">)</span><a class="headerlink" href="#void bilateralFilter(InputArray src, OutputArray dst, int d, double sigmaColor, double sigmaSpace, int borderType)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="pyfunction">
<dt id="cv2.bilateralFilter">
<strong>Python:</strong><code class="descname"> </code><code class="descclassname">cv2.</code><code class="descname">bilateralFilter</code><span class="sig-paren">(</span>src, d, sigmaColor, sigmaSpace<span class="optional">[</span>, dst<span class="optional">[</span>, borderType<span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span> &rarr; dst<a class="headerlink" href="#cv2.bilateralFilter" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>src</strong> &#8211; Source 8-bit or floating-point, 1-channel or 3-channel image.</li>
<li><strong>dst</strong> &#8211; Destination image of the same size and type as  <code class="docutils literal"><span class="pre">src</span></code> .</li>
<li><strong>d</strong> &#8211; Diameter of each pixel neighborhood that is used during filtering. If it is non-positive, it is computed from  <code class="docutils literal"><span class="pre">sigmaSpace</span></code> .</li>
<li><strong>sigmaColor</strong> &#8211; Filter sigma in the color space. A larger value of the parameter means that farther colors within the pixel neighborhood (see  <code class="docutils literal"><span class="pre">sigmaSpace</span></code> ) will be mixed together, resulting in larger areas of semi-equal color.</li>
<li><strong>sigmaSpace</strong> &#8211; Filter sigma in the coordinate space. A larger value of the parameter means that farther pixels will influence each other as long as their colors are close enough (see  <code class="docutils literal"><span class="pre">sigmaColor</span></code> ). When  <code class="docutils literal"><span class="pre">d&gt;0</span></code> , it specifies the neighborhood size regardless of  <code class="docutils literal"><span class="pre">sigmaSpace</span></code> . Otherwise,  <code class="docutils literal"><span class="pre">d</span></code>  is proportional to  <code class="docutils literal"><span class="pre">sigmaSpace</span></code> .</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<p>The function applies bilateral filtering to the input image, as described in
<a class="reference external" href="http://www.dai.ed.ac.uk/CVonline/LOCAL_COPIES/MANDUCHI1/Bilateral_Filtering.html">http://www.dai.ed.ac.uk/CVonline/LOCAL_COPIES/MANDUCHI1/Bilateral_Filtering.html</a>
<code class="docutils literal"><span class="pre">bilateralFilter</span></code> can reduce unwanted noise very well while keeping edges fairly sharp. However, it is very slow compared to most filters.</p>
<p><em>Sigma values</em>: For simplicity, you can set the 2 sigma values to be the same. If they are small (&lt; 10), the filter will not have much effect, whereas if they are large (&gt; 150), they will have a very strong effect, making the image look &#8220;cartoonish&#8221;.</p>
<p><em>Filter size</em>: Large filters (d &gt; 5) are very slow, so it is recommended to use d=5 for real-time applications, and perhaps d=9 for offline applications that need heavy noise filtering.</p>
<p>This filter does not work inplace.</p>
</div>
<div class="section" id="adaptivebilateralfilter">
<h2>adaptiveBilateralFilter<a class="headerlink" href="#adaptivebilateralfilter" title="Permalink to this headline">¶</a></h2>
<p>Applies the adaptive bilateral filter to an image.</p>
<dl class="function">
<dt id="void adaptiveBilateralFilter(InputArray src, OutputArray dst, Size ksize, double sigmaSpace, double maxSigmaColor , Point anchor, int borderType)">
<strong>C++:</strong><code class="descname"> </code>void <code class="descname">adaptiveBilateralFilter</code><span class="sig-paren">(</span>InputArray <strong>src</strong>, OutputArray <strong>dst</strong>, Size <strong>ksize</strong>, double <strong>sigmaSpace</strong>, double <strong>maxSigmaColor</strong>=20.0, Point <strong>anchor</strong>=Point(-1, -1), int <strong>borderType</strong>=BORDER_DEFAULT <span class="sig-paren">)</span><a class="headerlink" href="#void adaptiveBilateralFilter(InputArray src, OutputArray dst, Size ksize, double sigmaSpace, double maxSigmaColor , Point anchor, int borderType)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="pyfunction">
<dt id="cv2.adaptiveBilateralFilter">
<strong>Python:</strong><code class="descname"> </code><code class="descclassname">cv2.</code><code class="descname">adaptiveBilateralFilter</code><span class="sig-paren">(</span>src, ksize, sigmaSpace<span class="optional">[</span>, dst<span class="optional">[</span>, maxSigmaColor<span class="optional">[</span>, anchor<span class="optional">[</span>, borderType<span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span> &rarr; dst<a class="headerlink" href="#cv2.adaptiveBilateralFilter" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>src</strong> &#8211; The source image</li>
<li><strong>dst</strong> &#8211; The destination image; will have the same size and the same type as src</li>
<li><strong>ksize</strong> &#8211; The kernel size. This is the neighborhood where the local variance will be calculated, and where pixels will contribute (in a weighted manner).</li>
<li><strong>sigmaSpace</strong> &#8211; Filter sigma in the coordinate space. Larger value of the parameter means that farther pixels will influence each other (as long as their colors are close enough; see sigmaColor). Then d&gt;0, it specifies the neighborhood size regardless of sigmaSpace, otherwise d is proportional to sigmaSpace.</li>
<li><strong>maxSigmaColor</strong> &#8211; Maximum allowed sigma color (will clamp the value calculated in the ksize neighborhood. Larger value of the parameter means that more dissimilar pixels will influence each other (as long as their colors are close enough; see sigmaColor). Then d&gt;0, it specifies the neighborhood size regardless of sigmaSpace, otherwise d is proportional to sigmaSpace.</li>
<li><strong>borderType</strong> &#8211; Pixel extrapolation method.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<p>A main part of our strategy will be to load each raw pixel once, and reuse it to calculate all pixels in the output (filtered) image that need this pixel value. The math of the filter is that of the usual bilateral filter, except that the sigma color is calculated in the neighborhood, and clamped by the optional input value.</p>
</div>
<div class="section" id="blur">
<h2>blur<a class="headerlink" href="#blur" title="Permalink to this headline">¶</a></h2>
<p>Blurs an image using the normalized box filter.</p>
<dl class="function">
<dt id="void blur(InputArray src, OutputArray dst, Size ksize, Point anchor, int borderType)">
<strong>C++:</strong><code class="descname"> </code>void <code class="descname">blur</code><span class="sig-paren">(</span>InputArray <strong>src</strong>, OutputArray <strong>dst</strong>, Size <strong>ksize</strong>, Point <strong>anchor</strong>=Point(-1,-1), int <strong>borderType</strong>=BORDER_DEFAULT <span class="sig-paren">)</span><a class="headerlink" href="#void blur(InputArray src, OutputArray dst, Size ksize, Point anchor, int borderType)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="pyfunction">
<dt id="cv2.blur">
<strong>Python:</strong><code class="descname"> </code><code class="descclassname">cv2.</code><code class="descname">blur</code><span class="sig-paren">(</span>src, ksize<span class="optional">[</span>, dst<span class="optional">[</span>, anchor<span class="optional">[</span>, borderType<span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span> &rarr; dst<a class="headerlink" href="#cv2.blur" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>src</strong> &#8211; input image; it can have any number of channels, which are processed independently, but the depth should be <code class="docutils literal"><span class="pre">CV_8U</span></code>, <code class="docutils literal"><span class="pre">CV_16U</span></code>, <code class="docutils literal"><span class="pre">CV_16S</span></code>, <code class="docutils literal"><span class="pre">CV_32F</span></code> or <code class="docutils literal"><span class="pre">CV_64F</span></code>.</li>
<li><strong>dst</strong> &#8211; output image of the same size and type as <code class="docutils literal"><span class="pre">src</span></code>.</li>
<li><strong>ksize</strong> &#8211; blurring kernel size.</li>
<li><strong>anchor</strong> &#8211; anchor point; default value <code class="docutils literal"><span class="pre">Point(-1,-1)</span></code> means that the anchor is at the kernel center.</li>
<li><strong>borderType</strong> &#8211; border mode used to extrapolate pixels outside of the image.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<p>The function smoothes an image using the kernel:</p>
<div class="math">
<p><img src="../../../_images/math/0a3a3decb904a04778cbe67506aa86d2dba618d6.png" alt="\texttt{K} =  \frac{1}{\texttt{ksize.width*ksize.height}} \begin{bmatrix} 1 &amp; 1 &amp; 1 &amp;  \cdots &amp; 1 &amp; 1  \\ 1 &amp; 1 &amp; 1 &amp;  \cdots &amp; 1 &amp; 1  \\ \hdotsfor{6} \\ 1 &amp; 1 &amp; 1 &amp;  \cdots &amp; 1 &amp; 1  \\ \end{bmatrix}"/></p>
</div><p>The call <code class="docutils literal"><span class="pre">blur(src,</span> <span class="pre">dst,</span> <span class="pre">ksize,</span> <span class="pre">anchor,</span> <span class="pre">borderType)</span></code> is equivalent to <code class="docutils literal"><span class="pre">boxFilter(src,</span> <span class="pre">dst,</span> <span class="pre">src.type(),</span> <span class="pre">anchor,</span> <span class="pre">true,</span> <span class="pre">borderType)</span></code> .</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#void boxFilter(InputArray src, OutputArray dst, int ddepth, Size ksize, Point anchor, bool normalize, int borderType)" title="void boxFilter(InputArray src, OutputArray dst, int ddepth, Size ksize, Point anchor, bool normalize, int borderType)"><code class="xref ocv ocv-func docutils literal"><span class="pre">boxFilter()</span></code></a>,
<a class="reference internal" href="#void bilateralFilter(InputArray src, OutputArray dst, int d, double sigmaColor, double sigmaSpace, int borderType)" title="void bilateralFilter(InputArray src, OutputArray dst, int d, double sigmaColor, double sigmaSpace, int borderType)"><code class="xref ocv ocv-func docutils literal"><span class="pre">bilateralFilter()</span></code></a>,
<a class="reference internal" href="#void GaussianBlur(InputArray src, OutputArray dst, Size ksize, double sigmaX, double sigmaY, int borderType)" title="void GaussianBlur(InputArray src, OutputArray dst, Size ksize, double sigmaX, double sigmaY, int borderType)"><code class="xref ocv ocv-func docutils literal"><span class="pre">GaussianBlur()</span></code></a>,
<a class="reference internal" href="#void medianBlur(InputArray src, OutputArray dst, int ksize)" title="void medianBlur(InputArray src, OutputArray dst, int ksize)"><code class="xref ocv ocv-func docutils literal"><span class="pre">medianBlur()</span></code></a></p>
</div>
</div>
<div class="section" id="borderinterpolate">
<h2>borderInterpolate<a class="headerlink" href="#borderinterpolate" title="Permalink to this headline">¶</a></h2>
<p>Computes the source location of an extrapolated pixel.</p>
<dl class="function">
<dt id="int borderInterpolate(int p, int len, int borderType)">
<strong>C++:</strong><code class="descname"> </code>int <code class="descname">borderInterpolate</code><span class="sig-paren">(</span>int <strong>p</strong>, int <strong>len</strong>, int <strong>borderType</strong><span class="sig-paren">)</span><a class="headerlink" href="#int borderInterpolate(int p, int len, int borderType)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="pyfunction">
<dt id="cv2.borderInterpolate">
<strong>Python:</strong><code class="descname"> </code><code class="descclassname">cv2.</code><code class="descname">borderInterpolate</code><span class="sig-paren">(</span>p, len, borderType<span class="sig-paren">)</span> &rarr; retval<a class="headerlink" href="#cv2.borderInterpolate" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>p</strong> &#8211; 0-based coordinate of the extrapolated pixel along one of the axes, likely &lt;0 or &gt;= <code class="docutils literal"><span class="pre">len</span></code> .</li>
<li><strong>len</strong> &#8211; Length of the array along the corresponding axis.</li>
<li><strong>borderType</strong> &#8211; Border type, one of the  <code class="docutils literal"><span class="pre">BORDER_*</span></code> , except for  <code class="docutils literal"><span class="pre">BORDER_TRANSPARENT</span></code>  and  <code class="docutils literal"><span class="pre">BORDER_ISOLATED</span></code> . When  <code class="docutils literal"><span class="pre">borderType==BORDER_CONSTANT</span></code> , the function always returns -1, regardless of  <code class="docutils literal"><span class="pre">p</span></code>  and  <code class="docutils literal"><span class="pre">len</span></code> .</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<p>The function computes and returns the coordinate of a donor pixel corresponding to the specified extrapolated pixel when using the specified extrapolation border mode. For example, if you use <code class="docutils literal"><span class="pre">BORDER_WRAP</span></code> mode in the horizontal direction, <code class="docutils literal"><span class="pre">BORDER_REFLECT_101</span></code> in the vertical direction and want to compute value of the &#8220;virtual&#8221; pixel <code class="docutils literal"><span class="pre">Point(-5,</span> <span class="pre">100)</span></code> in a floating-point image <code class="docutils literal"><span class="pre">img</span></code> , it looks like:</p>
<div class="highlight-cpp"><div class="highlight"><pre><span class="kt">float</span> <span class="n">val</span> <span class="o">=</span> <span class="n">img</span><span class="p">.</span><span class="n">at</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span><span class="p">(</span><span class="n">borderInterpolate</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span> <span class="n">img</span><span class="p">.</span><span class="n">rows</span><span class="p">,</span> <span class="n">BORDER_REFLECT_101</span><span class="p">),</span>
                          <span class="n">borderInterpolate</span><span class="p">(</span><span class="o">-</span><span class="mi">5</span><span class="p">,</span> <span class="n">img</span><span class="p">.</span><span class="n">cols</span><span class="p">,</span> <span class="n">BORDER_WRAP</span><span class="p">));</span>
</pre></div>
</div>
<p>Normally, the function is not called directly. It is used inside
<a class="reference internal" href="#FilterEngine" title="class FilterEngine"><code class="xref ocv ocv-class docutils literal"><span class="pre">FilterEngine</span></code></a> and
<a class="reference internal" href="#void copyMakeBorder(InputArray src, OutputArray dst, int top, int bottom, int left, int right, int borderType, const Scalar&amp; value)" title="void copyMakeBorder(InputArray src, OutputArray dst, int top, int bottom, int left, int right, int borderType, const Scalar&amp; value)"><code class="xref ocv ocv-func docutils literal"><span class="pre">copyMakeBorder()</span></code></a> to compute tables for quick extrapolation.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#FilterEngine" title="class FilterEngine"><code class="xref ocv ocv-class docutils literal"><span class="pre">FilterEngine</span></code></a>,
<a class="reference internal" href="#void copyMakeBorder(InputArray src, OutputArray dst, int top, int bottom, int left, int right, int borderType, const Scalar&amp; value)" title="void copyMakeBorder(InputArray src, OutputArray dst, int top, int bottom, int left, int right, int borderType, const Scalar&amp; value)"><code class="xref ocv ocv-func docutils literal"><span class="pre">copyMakeBorder()</span></code></a></p>
</div>
</div>
<div class="section" id="boxfilter">
<h2>boxFilter<a class="headerlink" href="#boxfilter" title="Permalink to this headline">¶</a></h2>
<p>Blurs an image using the box filter.</p>
<dl class="function">
<dt id="void boxFilter(InputArray src, OutputArray dst, int ddepth, Size ksize, Point anchor, bool normalize, int borderType)">
<strong>C++:</strong><code class="descname"> </code>void <code class="descname">boxFilter</code><span class="sig-paren">(</span>InputArray <strong>src</strong>, OutputArray <strong>dst</strong>, int <strong>ddepth</strong>, Size <strong>ksize</strong>, Point <strong>anchor</strong>=Point(-1,-1), bool <strong>normalize</strong>=true, int <strong>borderType</strong>=BORDER_DEFAULT <span class="sig-paren">)</span><a class="headerlink" href="#void boxFilter(InputArray src, OutputArray dst, int ddepth, Size ksize, Point anchor, bool normalize, int borderType)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="pyfunction">
<dt id="cv2.boxFilter">
<strong>Python:</strong><code class="descname"> </code><code class="descclassname">cv2.</code><code class="descname">boxFilter</code><span class="sig-paren">(</span>src, ddepth, ksize<span class="optional">[</span>, dst<span class="optional">[</span>, anchor<span class="optional">[</span>, normalize<span class="optional">[</span>, borderType<span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span> &rarr; dst<a class="headerlink" href="#cv2.boxFilter" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>src</strong> &#8211; input image.</li>
<li><strong>dst</strong> &#8211; output image of the same size and type as <code class="docutils literal"><span class="pre">src</span></code>.</li>
<li><strong>ddepth</strong> &#8211; the output image depth (-1 to use <code class="docutils literal"><span class="pre">src.depth()</span></code>).</li>
<li><strong>ksize</strong> &#8211; blurring kernel size.</li>
<li><strong>anchor</strong> &#8211; anchor point; default value <code class="docutils literal"><span class="pre">Point(-1,-1)</span></code> means that the anchor is at the kernel center.</li>
<li><strong>normalize</strong> &#8211; flag, specifying whether the kernel is normalized by its area or not.</li>
<li><strong>borderType</strong> &#8211; border mode used to extrapolate pixels outside of the image.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<p>The function smoothes an image using the kernel:</p>
<div class="math">
<p><img src="../../../_images/math/39f9e9decf02ff5891fe62d9892ff1bee82f2904.png" alt="\texttt{K} =  \alpha \begin{bmatrix} 1 &amp; 1 &amp; 1 &amp;  \cdots &amp; 1 &amp; 1  \\ 1 &amp; 1 &amp; 1 &amp;  \cdots &amp; 1 &amp; 1  \\ \hdotsfor{6} \\ 1 &amp; 1 &amp; 1 &amp;  \cdots &amp; 1 &amp; 1 \end{bmatrix}"/></p>
</div><p>where</p>
<div class="math">
<p><img src="../../../_images/math/3f79f034b1b1b131f02a860eb808df10daa25525.png" alt="\alpha = \fork{\frac{1}{\texttt{ksize.width*ksize.height}}}{when \texttt{normalize=true}}{1}{otherwise}"/></p>
</div><p>Unnormalized box filter is useful for computing various integral characteristics over each pixel neighborhood, such as covariance matrices of image derivatives (used in dense optical flow algorithms, and so on). If you need to compute pixel sums over variable-size windows, use <a class="reference internal" href="miscellaneous_transformations.html#void integral(InputArray src, OutputArray sum, int sdepth)" title="void integral(InputArray src, OutputArray sum, int sdepth)"><code class="xref ocv ocv-func docutils literal"><span class="pre">integral()</span></code></a> .</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#void blur(InputArray src, OutputArray dst, Size ksize, Point anchor, int borderType)" title="void blur(InputArray src, OutputArray dst, Size ksize, Point anchor, int borderType)"><code class="xref ocv ocv-func docutils literal"><span class="pre">blur()</span></code></a>,
<a class="reference internal" href="#void bilateralFilter(InputArray src, OutputArray dst, int d, double sigmaColor, double sigmaSpace, int borderType)" title="void bilateralFilter(InputArray src, OutputArray dst, int d, double sigmaColor, double sigmaSpace, int borderType)"><code class="xref ocv ocv-func docutils literal"><span class="pre">bilateralFilter()</span></code></a>,
<a class="reference internal" href="#void GaussianBlur(InputArray src, OutputArray dst, Size ksize, double sigmaX, double sigmaY, int borderType)" title="void GaussianBlur(InputArray src, OutputArray dst, Size ksize, double sigmaX, double sigmaY, int borderType)"><code class="xref ocv ocv-func docutils literal"><span class="pre">GaussianBlur()</span></code></a>,
<a class="reference internal" href="#void medianBlur(InputArray src, OutputArray dst, int ksize)" title="void medianBlur(InputArray src, OutputArray dst, int ksize)"><code class="xref ocv ocv-func docutils literal"><span class="pre">medianBlur()</span></code></a>,
<a class="reference internal" href="miscellaneous_transformations.html#void integral(InputArray src, OutputArray sum, int sdepth)" title="void integral(InputArray src, OutputArray sum, int sdepth)"><code class="xref ocv ocv-func docutils literal"><span class="pre">integral()</span></code></a></p>
</div>
</div>
<div class="section" id="buildpyramid">
<h2>buildPyramid<a class="headerlink" href="#buildpyramid" title="Permalink to this headline">¶</a></h2>
<p>Constructs the Gaussian pyramid for an image.</p>
<dl class="function">
<dt id="void buildPyramid(InputArray src, OutputArrayOfArrays dst, int maxlevel, int borderType)">
<strong>C++:</strong><code class="descname"> </code>void <code class="descname">buildPyramid</code><span class="sig-paren">(</span>InputArray <strong>src</strong>, OutputArrayOfArrays <strong>dst</strong>, int <strong>maxlevel</strong>, int <strong>borderType</strong>=BORDER_DEFAULT <span class="sig-paren">)</span><a class="headerlink" href="#void buildPyramid(InputArray src, OutputArrayOfArrays dst, int maxlevel, int borderType)" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>src</strong> &#8211; Source image. Check  <a class="reference internal" href="#void pyrDown(InputArray src, OutputArray dst, const Size&amp; dstsize, int borderType)" title="void pyrDown(InputArray src, OutputArray dst, const Size&amp; dstsize, int borderType)"><code class="xref ocv ocv-func docutils literal"><span class="pre">pyrDown()</span></code></a>  for the list of supported types.</li>
<li><strong>dst</strong> &#8211; Destination vector of  <code class="docutils literal"><span class="pre">maxlevel+1</span></code>  images of the same type as  <code class="docutils literal"><span class="pre">src</span></code> . <code class="docutils literal"><span class="pre">dst[0]</span></code>  will be the same as  <code class="docutils literal"><span class="pre">src</span></code> .  <code class="docutils literal"><span class="pre">dst[1]</span></code>  is the next pyramid layer, a smoothed and down-sized  <code class="docutils literal"><span class="pre">src</span></code>  , and so on.</li>
<li><strong>maxlevel</strong> &#8211; 0-based index of the last (the smallest) pyramid layer. It must be non-negative.</li>
<li><strong>borderType</strong> &#8211; Pixel extrapolation method (BORDER_CONSTANT don&#8217;t supported). See  <a class="reference internal" href="#int borderInterpolate(int p, int len, int borderType)" title="int borderInterpolate(int p, int len, int borderType)"><code class="xref ocv ocv-func docutils literal"><span class="pre">borderInterpolate()</span></code></a> for details.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<p>The function constructs a vector of images and builds the Gaussian pyramid by recursively applying
<a class="reference internal" href="#void pyrDown(InputArray src, OutputArray dst, const Size&amp; dstsize, int borderType)" title="void pyrDown(InputArray src, OutputArray dst, const Size&amp; dstsize, int borderType)"><code class="xref ocv ocv-func docutils literal"><span class="pre">pyrDown()</span></code></a> to the previously built pyramid layers, starting from <code class="docutils literal"><span class="pre">dst[0]==src</span></code> .</p>
</div>
<div class="section" id="copymakeborder">
<h2>copyMakeBorder<a class="headerlink" href="#copymakeborder" title="Permalink to this headline">¶</a></h2>
<p>Forms a border around an image.</p>
<dl class="function">
<dt id="void copyMakeBorder(InputArray src, OutputArray dst, int top, int bottom, int left, int right, int borderType, const Scalar&amp; value)">
<strong>C++:</strong><code class="descname"> </code>void <code class="descname">copyMakeBorder</code><span class="sig-paren">(</span>InputArray <strong>src</strong>, OutputArray <strong>dst</strong>, int <strong>top</strong>, int <strong>bottom</strong>, int <strong>left</strong>, int <strong>right</strong>, int <strong>borderType</strong>, const Scalar&amp; <strong>value</strong>=Scalar() <span class="sig-paren">)</span><a class="headerlink" href="#void copyMakeBorder(InputArray src, OutputArray dst, int top, int bottom, int left, int right, int borderType, const Scalar& value)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="pyfunction">
<dt id="cv2.copyMakeBorder">
<strong>Python:</strong><code class="descname"> </code><code class="descclassname">cv2.</code><code class="descname">copyMakeBorder</code><span class="sig-paren">(</span>src, top, bottom, left, right, borderType<span class="optional">[</span>, dst<span class="optional">[</span>, value<span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span> &rarr; dst<a class="headerlink" href="#cv2.copyMakeBorder" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="cfunction">
<dt id="void cvCopyMakeBorder(const CvArr* src, CvArr* dst, CvPoint offset, int bordertype, CvScalar value)">
<strong>C:</strong><code class="descname"> </code>void <code class="descname">cvCopyMakeBorder</code><span class="sig-paren">(</span>const CvArr* <strong>src</strong>, CvArr* <strong>dst</strong>, CvPoint <strong>offset</strong>, int <strong>bordertype</strong>, CvScalar <strong>value</strong>=cvScalarAll(0) <span class="sig-paren">)</span><a class="headerlink" href="#void cvCopyMakeBorder(const CvArr* src, CvArr* dst, CvPoint offset, int bordertype, CvScalar value)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="pyoldfunction">
<dt id="cv.CopyMakeBorder">
<strong>Python:</strong><code class="descname"> </code><code class="descclassname">cv.</code><code class="descname">CopyMakeBorder</code><span class="sig-paren">(</span>src, dst, offset, bordertype, value=(0, 0, 0, 0)<span class="sig-paren">)</span> &rarr; None<a class="headerlink" href="#cv.CopyMakeBorder" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>src</strong> &#8211; Source image.</li>
<li><strong>dst</strong> &#8211; Destination image of the same type as  <code class="docutils literal"><span class="pre">src</span></code>  and the size  <code class="docutils literal"><span class="pre">Size(src.cols+left+right,</span> <span class="pre">src.rows+top+bottom)</span></code> .</li>
<li><strong>top</strong> &#8211; </li>
<li><strong>bottom</strong> &#8211; </li>
<li><strong>left</strong> &#8211; </li>
<li><strong>right</strong> &#8211; Parameter specifying how many pixels in each direction from the source image rectangle to extrapolate. For example,  <code class="docutils literal"><span class="pre">top=1,</span> <span class="pre">bottom=1,</span> <span class="pre">left=1,</span> <span class="pre">right=1</span></code>  mean that 1 pixel-wide border needs to be built.</li>
<li><strong>borderType</strong> &#8211; Border type. See  <a class="reference internal" href="#int borderInterpolate(int p, int len, int borderType)" title="int borderInterpolate(int p, int len, int borderType)"><code class="xref ocv ocv-func docutils literal"><span class="pre">borderInterpolate()</span></code></a> for details.</li>
<li><strong>value</strong> &#8211; Border value if  <code class="docutils literal"><span class="pre">borderType==BORDER_CONSTANT</span></code> .</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<p>The function copies the source image into the middle of the destination image. The areas to the left, to the right, above and below the copied source image will be filled with extrapolated pixels. This is not what
<a class="reference internal" href="#FilterEngine" title="class FilterEngine"><code class="xref ocv ocv-class docutils literal"><span class="pre">FilterEngine</span></code></a> or filtering functions based on it do (they extrapolate pixels on-fly), but what other more complex functions, including your own, may do to simplify image boundary handling.</p>
<p>The function supports the mode when <code class="docutils literal"><span class="pre">src</span></code> is already in the middle of <code class="docutils literal"><span class="pre">dst</span></code> . In this case, the function does not copy <code class="docutils literal"><span class="pre">src</span></code> itself but simply constructs the border, for example:</p>
<div class="highlight-cpp"><div class="highlight"><pre><span class="c1">// let border be the same in all directions</span>
<span class="kt">int</span> <span class="n">border</span><span class="o">=</span><span class="mi">2</span><span class="p">;</span>
<span class="c1">// constructs a larger image to fit both the image and the border</span>
<span class="n">Mat</span> <span class="nf">gray_buf</span><span class="p">(</span><span class="n">rgb</span><span class="p">.</span><span class="n">rows</span> <span class="o">+</span> <span class="n">border</span><span class="o">*</span><span class="mi">2</span><span class="p">,</span> <span class="n">rgb</span><span class="p">.</span><span class="n">cols</span> <span class="o">+</span> <span class="n">border</span><span class="o">*</span><span class="mi">2</span><span class="p">,</span> <span class="n">rgb</span><span class="p">.</span><span class="n">depth</span><span class="p">());</span>
<span class="c1">// select the middle part of it w/o copying data</span>
<span class="n">Mat</span> <span class="nf">gray</span><span class="p">(</span><span class="n">gray_canvas</span><span class="p">,</span> <span class="n">Rect</span><span class="p">(</span><span class="n">border</span><span class="p">,</span> <span class="n">border</span><span class="p">,</span> <span class="n">rgb</span><span class="p">.</span><span class="n">cols</span><span class="p">,</span> <span class="n">rgb</span><span class="p">.</span><span class="n">rows</span><span class="p">));</span>
<span class="c1">// convert image from RGB to grayscale</span>
<span class="n">cvtColor</span><span class="p">(</span><span class="n">rgb</span><span class="p">,</span> <span class="n">gray</span><span class="p">,</span> <span class="n">CV_RGB2GRAY</span><span class="p">);</span>
<span class="c1">// form a border in-place</span>
<span class="n">copyMakeBorder</span><span class="p">(</span><span class="n">gray</span><span class="p">,</span> <span class="n">gray_buf</span><span class="p">,</span> <span class="n">border</span><span class="p">,</span> <span class="n">border</span><span class="p">,</span>
               <span class="n">border</span><span class="p">,</span> <span class="n">border</span><span class="p">,</span> <span class="n">BORDER_REPLICATE</span><span class="p">);</span>
<span class="c1">// now do some custom filtering ...</span>
<span class="p">...</span>
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">When the source image is a part (ROI) of a bigger image, the function will try to use the pixels outside of the ROI to form a border. To disable this feature and always do extrapolation, as if <code class="docutils literal"><span class="pre">src</span></code> was not a ROI, use <code class="docutils literal"><span class="pre">borderType</span> <span class="pre">|</span> <span class="pre">BORDER_ISOLATED</span></code>.</p>
</div>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#int borderInterpolate(int p, int len, int borderType)" title="int borderInterpolate(int p, int len, int borderType)"><code class="xref ocv ocv-func docutils literal"><span class="pre">borderInterpolate()</span></code></a></p>
</div>
</div>
<div class="section" id="createboxfilter">
<h2>createBoxFilter<a class="headerlink" href="#createboxfilter" title="Permalink to this headline">¶</a></h2>
<p>Returns a box filter engine.</p>
<dl class="function">
<dt id="Ptr&lt;FilterEngine&gt; createBoxFilter(int srcType, int dstType, Size ksize, Point anchor, bool normalize, int borderType)">
<strong>C++:</strong><code class="descname"> </code>Ptr&lt;FilterEngine&gt; <code class="descname">createBoxFilter</code><span class="sig-paren">(</span>int <strong>srcType</strong>, int <strong>dstType</strong>, Size <strong>ksize</strong>, Point <strong>anchor</strong>=Point(-1,-1), bool <strong>normalize</strong>=true, int <strong>borderType</strong>=BORDER_DEFAULT<span class="sig-paren">)</span><a class="headerlink" href="#Ptr<FilterEngine> createBoxFilter(int srcType, int dstType, Size ksize, Point anchor, bool normalize, int borderType)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="Ptr&lt;BaseRowFilter&gt; getRowSumFilter(int srcType, int sumType, int ksize, int anchor)">
<strong>C++:</strong><code class="descname"> </code>Ptr&lt;BaseRowFilter&gt; <code class="descname">getRowSumFilter</code><span class="sig-paren">(</span>int <strong>srcType</strong>, int <strong>sumType</strong>, int <strong>ksize</strong>, int <strong>anchor</strong>=-1<span class="sig-paren">)</span><a class="headerlink" href="#Ptr<BaseRowFilter> getRowSumFilter(int srcType, int sumType, int ksize, int anchor)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="Ptr&lt;BaseColumnFilter&gt; getColumnSumFilter(int sumType, int dstType, int ksize, int anchor, double scale)">
<strong>C++:</strong><code class="descname"> </code>Ptr&lt;BaseColumnFilter&gt; <code class="descname">getColumnSumFilter</code><span class="sig-paren">(</span>int <strong>sumType</strong>, int <strong>dstType</strong>, int <strong>ksize</strong>, int <strong>anchor</strong>=-1, double <strong>scale</strong>=1<span class="sig-paren">)</span><a class="headerlink" href="#Ptr<BaseColumnFilter> getColumnSumFilter(int sumType, int dstType, int ksize, int anchor, double scale)" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>srcType</strong> &#8211; Source image type.</li>
<li><strong>sumType</strong> &#8211; Intermediate horizontal sum type that must have as many channels as  <code class="docutils literal"><span class="pre">srcType</span></code> .</li>
<li><strong>dstType</strong> &#8211; Destination image type that must have as many channels as  <code class="docutils literal"><span class="pre">srcType</span></code> .</li>
<li><strong>ksize</strong> &#8211; Aperture size.</li>
<li><strong>anchor</strong> &#8211; Anchor position with the kernel. Negative values mean that the anchor is at the kernel center.</li>
<li><strong>normalize</strong> &#8211; Flag specifying whether the sums are normalized or not. See  <a class="reference internal" href="#void boxFilter(InputArray src, OutputArray dst, int ddepth, Size ksize, Point anchor, bool normalize, int borderType)" title="void boxFilter(InputArray src, OutputArray dst, int ddepth, Size ksize, Point anchor, bool normalize, int borderType)"><code class="xref ocv ocv-func docutils literal"><span class="pre">boxFilter()</span></code></a> for details.</li>
<li><strong>scale</strong> &#8211; Another way to specify normalization in lower-level  <code class="docutils literal"><span class="pre">getColumnSumFilter</span></code> .</li>
<li><strong>borderType</strong> &#8211; Border type to use. See  <a class="reference internal" href="#int borderInterpolate(int p, int len, int borderType)" title="int borderInterpolate(int p, int len, int borderType)"><code class="xref ocv ocv-func docutils literal"><span class="pre">borderInterpolate()</span></code></a> .</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<p>The function is a convenience function that retrieves the horizontal sum primitive filter with
<a class="reference internal" href="#Ptr&lt;BaseRowFilter&gt; getRowSumFilter(int srcType, int sumType, int ksize, int anchor)" title="Ptr&lt;BaseRowFilter&gt; getRowSumFilter(int srcType, int sumType, int ksize, int anchor)"><code class="xref ocv ocv-func docutils literal"><span class="pre">getRowSumFilter()</span></code></a> , vertical sum filter with
<a class="reference internal" href="#Ptr&lt;BaseColumnFilter&gt; getColumnSumFilter(int sumType, int dstType, int ksize, int anchor, double scale)" title="Ptr&lt;BaseColumnFilter&gt; getColumnSumFilter(int sumType, int dstType, int ksize, int anchor, double scale)"><code class="xref ocv ocv-func docutils literal"><span class="pre">getColumnSumFilter()</span></code></a> , constructs new
<a class="reference internal" href="#FilterEngine" title="class FilterEngine"><code class="xref ocv ocv-class docutils literal"><span class="pre">FilterEngine</span></code></a> , and passes both of the primitive filters there. The constructed filter engine can be used for image filtering with normalized or unnormalized box filter.</p>
<p>The function itself is used by
<a class="reference internal" href="#void blur(InputArray src, OutputArray dst, Size ksize, Point anchor, int borderType)" title="void blur(InputArray src, OutputArray dst, Size ksize, Point anchor, int borderType)"><code class="xref ocv ocv-func docutils literal"><span class="pre">blur()</span></code></a> and
<a class="reference internal" href="#void boxFilter(InputArray src, OutputArray dst, int ddepth, Size ksize, Point anchor, bool normalize, int borderType)" title="void boxFilter(InputArray src, OutputArray dst, int ddepth, Size ksize, Point anchor, bool normalize, int borderType)"><code class="xref ocv ocv-func docutils literal"><span class="pre">boxFilter()</span></code></a> .</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#FilterEngine" title="class FilterEngine"><code class="xref ocv ocv-class docutils literal"><span class="pre">FilterEngine</span></code></a>,
<a class="reference internal" href="#void blur(InputArray src, OutputArray dst, Size ksize, Point anchor, int borderType)" title="void blur(InputArray src, OutputArray dst, Size ksize, Point anchor, int borderType)"><code class="xref ocv ocv-func docutils literal"><span class="pre">blur()</span></code></a>,
<a class="reference internal" href="#void boxFilter(InputArray src, OutputArray dst, int ddepth, Size ksize, Point anchor, bool normalize, int borderType)" title="void boxFilter(InputArray src, OutputArray dst, int ddepth, Size ksize, Point anchor, bool normalize, int borderType)"><code class="xref ocv ocv-func docutils literal"><span class="pre">boxFilter()</span></code></a></p>
</div>
</div>
<div class="section" id="createderivfilter">
<h2>createDerivFilter<a class="headerlink" href="#createderivfilter" title="Permalink to this headline">¶</a></h2>
<p>Returns an engine for computing image derivatives.</p>
<dl class="function">
<dt id="Ptr&lt;FilterEngine&gt; createDerivFilter(int srcType, int dstType, int dx, int dy, int ksize, int borderType)">
<strong>C++:</strong><code class="descname"> </code>Ptr&lt;FilterEngine&gt; <code class="descname">createDerivFilter</code><span class="sig-paren">(</span>int <strong>srcType</strong>, int <strong>dstType</strong>, int <strong>dx</strong>, int <strong>dy</strong>, int <strong>ksize</strong>, int <strong>borderType</strong>=BORDER_DEFAULT <span class="sig-paren">)</span><a class="headerlink" href="#Ptr<FilterEngine> createDerivFilter(int srcType, int dstType, int dx, int dy, int ksize, int borderType)" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>srcType</strong> &#8211; Source image type.</li>
<li><strong>dstType</strong> &#8211; Destination image type that must have as many channels as  <code class="docutils literal"><span class="pre">srcType</span></code> .</li>
<li><strong>dx</strong> &#8211; Derivative order in respect of x.</li>
<li><strong>dy</strong> &#8211; Derivative order in respect of y.</li>
<li><strong>ksize</strong> &#8211; Aperture size See  <a class="reference internal" href="#void getDerivKernels(OutputArray kx, OutputArray ky, int dx, int dy, int ksize, bool normalize, int ktype)" title="void getDerivKernels(OutputArray kx, OutputArray ky, int dx, int dy, int ksize, bool normalize, int ktype)"><code class="xref ocv ocv-func docutils literal"><span class="pre">getDerivKernels()</span></code></a> .</li>
<li><strong>borderType</strong> &#8211; Border type to use. See  <a class="reference internal" href="#int borderInterpolate(int p, int len, int borderType)" title="int borderInterpolate(int p, int len, int borderType)"><code class="xref ocv ocv-func docutils literal"><span class="pre">borderInterpolate()</span></code></a> .</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<p>The function <a class="reference internal" href="#Ptr&lt;FilterEngine&gt; createDerivFilter(int srcType, int dstType, int dx, int dy, int ksize, int borderType)" title="Ptr&lt;FilterEngine&gt; createDerivFilter(int srcType, int dstType, int dx, int dy, int ksize, int borderType)"><code class="xref ocv ocv-func docutils literal"><span class="pre">createDerivFilter()</span></code></a> is a small convenience function that retrieves linear filter coefficients for computing image derivatives using
<a class="reference internal" href="#void getDerivKernels(OutputArray kx, OutputArray ky, int dx, int dy, int ksize, bool normalize, int ktype)" title="void getDerivKernels(OutputArray kx, OutputArray ky, int dx, int dy, int ksize, bool normalize, int ktype)"><code class="xref ocv ocv-func docutils literal"><span class="pre">getDerivKernels()</span></code></a> and then creates a separable linear filter with
<a class="reference internal" href="#Ptr&lt;FilterEngine&gt; createSeparableLinearFilter(int srcType, int dstType, InputArray rowKernel, InputArray columnKernel, Point anchor, double delta, int rowBorderType, int columnBorderType, const Scalar&amp; borderValue)" title="Ptr&lt;FilterEngine&gt; createSeparableLinearFilter(int srcType, int dstType, InputArray rowKernel, InputArray columnKernel, Point anchor, double delta, int rowBorderType, int columnBorderType, const Scalar&amp; borderValue)"><code class="xref ocv ocv-func docutils literal"><span class="pre">createSeparableLinearFilter()</span></code></a> . The function is used by
<a class="reference internal" href="#void Sobel(InputArray src, OutputArray dst, int ddepth, int dx, int dy, int ksize, double scale, double delta, int borderType)" title="void Sobel(InputArray src, OutputArray dst, int ddepth, int dx, int dy, int ksize, double scale, double delta, int borderType)"><code class="xref ocv ocv-func docutils literal"><span class="pre">Sobel()</span></code></a> and
<a class="reference internal" href="#void Scharr(InputArray src, OutputArray dst, int ddepth, int dx, int dy, double scale, double delta, int borderType)" title="void Scharr(InputArray src, OutputArray dst, int ddepth, int dx, int dy, double scale, double delta, int borderType)"><code class="xref ocv ocv-func docutils literal"><span class="pre">Scharr()</span></code></a> .</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#Ptr&lt;FilterEngine&gt; createSeparableLinearFilter(int srcType, int dstType, InputArray rowKernel, InputArray columnKernel, Point anchor, double delta, int rowBorderType, int columnBorderType, const Scalar&amp; borderValue)" title="Ptr&lt;FilterEngine&gt; createSeparableLinearFilter(int srcType, int dstType, InputArray rowKernel, InputArray columnKernel, Point anchor, double delta, int rowBorderType, int columnBorderType, const Scalar&amp; borderValue)"><code class="xref ocv ocv-func docutils literal"><span class="pre">createSeparableLinearFilter()</span></code></a>,
<a class="reference internal" href="#void getDerivKernels(OutputArray kx, OutputArray ky, int dx, int dy, int ksize, bool normalize, int ktype)" title="void getDerivKernels(OutputArray kx, OutputArray ky, int dx, int dy, int ksize, bool normalize, int ktype)"><code class="xref ocv ocv-func docutils literal"><span class="pre">getDerivKernels()</span></code></a>,
<a class="reference internal" href="#void Scharr(InputArray src, OutputArray dst, int ddepth, int dx, int dy, double scale, double delta, int borderType)" title="void Scharr(InputArray src, OutputArray dst, int ddepth, int dx, int dy, double scale, double delta, int borderType)"><code class="xref ocv ocv-func docutils literal"><span class="pre">Scharr()</span></code></a>,
<a class="reference internal" href="#void Sobel(InputArray src, OutputArray dst, int ddepth, int dx, int dy, int ksize, double scale, double delta, int borderType)" title="void Sobel(InputArray src, OutputArray dst, int ddepth, int dx, int dy, int ksize, double scale, double delta, int borderType)"><code class="xref ocv ocv-func docutils literal"><span class="pre">Sobel()</span></code></a></p>
</div>
</div>
<div class="section" id="creategaussianfilter">
<h2>createGaussianFilter<a class="headerlink" href="#creategaussianfilter" title="Permalink to this headline">¶</a></h2>
<p>Returns an engine for smoothing images with the Gaussian filter.</p>
<dl class="function">
<dt id="Ptr&lt;FilterEngine&gt; createGaussianFilter(int type, Size ksize, double sigma1, double sigma2, int borderType)">
<strong>C++:</strong><code class="descname"> </code>Ptr&lt;FilterEngine&gt; <code class="descname">createGaussianFilter</code><span class="sig-paren">(</span>int <strong>type</strong>, Size <strong>ksize</strong>, double <strong>sigma1</strong>, double <strong>sigma2</strong>=0, int <strong>borderType</strong>=BORDER_DEFAULT <span class="sig-paren">)</span><a class="headerlink" href="#Ptr<FilterEngine> createGaussianFilter(int type, Size ksize, double sigma1, double sigma2, int borderType)" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>type</strong> &#8211; Source and destination image type.</li>
<li><strong>ksize</strong> &#8211; Aperture size. See  <a class="reference internal" href="#Mat getGaussianKernel(int ksize, double sigma, int ktype)" title="Mat getGaussianKernel(int ksize, double sigma, int ktype)"><code class="xref ocv ocv-func docutils literal"><span class="pre">getGaussianKernel()</span></code></a> .</li>
<li><strong>sigma1</strong> &#8211; Gaussian sigma in the horizontal direction. See  <a class="reference internal" href="#Mat getGaussianKernel(int ksize, double sigma, int ktype)" title="Mat getGaussianKernel(int ksize, double sigma, int ktype)"><code class="xref ocv ocv-func docutils literal"><span class="pre">getGaussianKernel()</span></code></a> .</li>
<li><strong>sigma2</strong> &#8211; Gaussian sigma in the vertical direction. If 0, then  <img class="math" src="../../../_images/math/746d45695d9afb38c7654245424b3152d29e956e.png" alt="\texttt{sigma2}\leftarrow\texttt{sigma1}"/> .</li>
<li><strong>borderType</strong> &#8211; Border type to use. See  <a class="reference internal" href="#int borderInterpolate(int p, int len, int borderType)" title="int borderInterpolate(int p, int len, int borderType)"><code class="xref ocv ocv-func docutils literal"><span class="pre">borderInterpolate()</span></code></a> .</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<p>The function <a class="reference internal" href="#Ptr&lt;FilterEngine&gt; createGaussianFilter(int type, Size ksize, double sigma1, double sigma2, int borderType)" title="Ptr&lt;FilterEngine&gt; createGaussianFilter(int type, Size ksize, double sigma1, double sigma2, int borderType)"><code class="xref ocv ocv-func docutils literal"><span class="pre">createGaussianFilter()</span></code></a> computes Gaussian kernel coefficients and then returns a separable linear filter for that kernel. The function is used by
<a class="reference internal" href="#void GaussianBlur(InputArray src, OutputArray dst, Size ksize, double sigmaX, double sigmaY, int borderType)" title="void GaussianBlur(InputArray src, OutputArray dst, Size ksize, double sigmaX, double sigmaY, int borderType)"><code class="xref ocv ocv-func docutils literal"><span class="pre">GaussianBlur()</span></code></a> . Note that while the function takes just one data type, both for input and output, you can pass this limitation by calling
<a class="reference internal" href="#Mat getGaussianKernel(int ksize, double sigma, int ktype)" title="Mat getGaussianKernel(int ksize, double sigma, int ktype)"><code class="xref ocv ocv-func docutils literal"><span class="pre">getGaussianKernel()</span></code></a> and then
<a class="reference internal" href="#Ptr&lt;FilterEngine&gt; createSeparableLinearFilter(int srcType, int dstType, InputArray rowKernel, InputArray columnKernel, Point anchor, double delta, int rowBorderType, int columnBorderType, const Scalar&amp; borderValue)" title="Ptr&lt;FilterEngine&gt; createSeparableLinearFilter(int srcType, int dstType, InputArray rowKernel, InputArray columnKernel, Point anchor, double delta, int rowBorderType, int columnBorderType, const Scalar&amp; borderValue)"><code class="xref ocv ocv-func docutils literal"><span class="pre">createSeparableLinearFilter()</span></code></a> directly.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#Ptr&lt;FilterEngine&gt; createSeparableLinearFilter(int srcType, int dstType, InputArray rowKernel, InputArray columnKernel, Point anchor, double delta, int rowBorderType, int columnBorderType, const Scalar&amp; borderValue)" title="Ptr&lt;FilterEngine&gt; createSeparableLinearFilter(int srcType, int dstType, InputArray rowKernel, InputArray columnKernel, Point anchor, double delta, int rowBorderType, int columnBorderType, const Scalar&amp; borderValue)"><code class="xref ocv ocv-func docutils literal"><span class="pre">createSeparableLinearFilter()</span></code></a>,
<a class="reference internal" href="#Mat getGaussianKernel(int ksize, double sigma, int ktype)" title="Mat getGaussianKernel(int ksize, double sigma, int ktype)"><code class="xref ocv ocv-func docutils literal"><span class="pre">getGaussianKernel()</span></code></a>,
<a class="reference internal" href="#void GaussianBlur(InputArray src, OutputArray dst, Size ksize, double sigmaX, double sigmaY, int borderType)" title="void GaussianBlur(InputArray src, OutputArray dst, Size ksize, double sigmaX, double sigmaY, int borderType)"><code class="xref ocv ocv-func docutils literal"><span class="pre">GaussianBlur()</span></code></a></p>
</div>
</div>
<div class="section" id="createlinearfilter">
<h2>createLinearFilter<a class="headerlink" href="#createlinearfilter" title="Permalink to this headline">¶</a></h2>
<p>Creates a non-separable linear filter engine.</p>
<dl class="function">
<dt id="Ptr&lt;FilterEngine&gt; createLinearFilter(int srcType, int dstType, InputArray kernel, Point _anchor, double delta, int rowBorderType, int columnBorderType, const Scalar&amp; borderValue)">
<strong>C++:</strong><code class="descname"> </code>Ptr&lt;FilterEngine&gt; <code class="descname">createLinearFilter</code><span class="sig-paren">(</span>int <strong>srcType</strong>, int <strong>dstType</strong>, InputArray <strong>kernel</strong>, Point <strong>_anchor</strong>=Point(-1,-1), double <strong>delta</strong>=0, int <strong>rowBorderType</strong>=BORDER_DEFAULT, int <strong>columnBorderType</strong>=-1, const Scalar&amp; <strong>borderValue</strong>=Scalar() <span class="sig-paren">)</span><a class="headerlink" href="#Ptr<FilterEngine> createLinearFilter(int srcType, int dstType, InputArray kernel, Point _anchor, double delta, int rowBorderType, int columnBorderType, const Scalar& borderValue)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="Ptr&lt;BaseFilter&gt; getLinearFilter(int srcType, int dstType, InputArray kernel, Point anchor, double delta, int bits)">
<strong>C++:</strong><code class="descname"> </code>Ptr&lt;BaseFilter&gt; <code class="descname">getLinearFilter</code><span class="sig-paren">(</span>int <strong>srcType</strong>, int <strong>dstType</strong>, InputArray <strong>kernel</strong>, Point <strong>anchor</strong>=Point(-1,-1), double <strong>delta</strong>=0, int <strong>bits</strong>=0<span class="sig-paren">)</span><a class="headerlink" href="#Ptr<BaseFilter> getLinearFilter(int srcType, int dstType, InputArray kernel, Point anchor, double delta, int bits)" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>srcType</strong> &#8211; Source image type.</li>
<li><strong>dstType</strong> &#8211; Destination image type that must have as many channels as  <code class="docutils literal"><span class="pre">srcType</span></code> .</li>
<li><strong>kernel</strong> &#8211; 2D array of filter coefficients.</li>
<li><strong>anchor</strong> &#8211; Anchor point within the kernel. Special value  <code class="docutils literal"><span class="pre">Point(-1,-1)</span></code>  means that the anchor is at the kernel center.</li>
<li><strong>delta</strong> &#8211; Value added to the filtered results before storing them.</li>
<li><strong>bits</strong> &#8211; Number of the fractional bits. The parameter is used when the kernel is an integer matrix representing fixed-point filter coefficients.</li>
<li><strong>rowBorderType</strong> &#8211; Pixel extrapolation method in the vertical direction. For details, see  <a class="reference internal" href="#int borderInterpolate(int p, int len, int borderType)" title="int borderInterpolate(int p, int len, int borderType)"><code class="xref ocv ocv-func docutils literal"><span class="pre">borderInterpolate()</span></code></a>.</li>
<li><strong>columnBorderType</strong> &#8211; Pixel extrapolation method in the horizontal direction.</li>
<li><strong>borderValue</strong> &#8211; Border value used in case of a constant border.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<p>The function returns a pointer to a 2D linear filter for the specified kernel, the source array type, and the destination array type. The function is a higher-level function that calls <code class="docutils literal"><span class="pre">getLinearFilter</span></code> and passes the retrieved 2D filter to the
<a class="reference internal" href="#FilterEngine" title="class FilterEngine"><code class="xref ocv ocv-class docutils literal"><span class="pre">FilterEngine</span></code></a> constructor.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#Ptr&lt;FilterEngine&gt; createSeparableLinearFilter(int srcType, int dstType, InputArray rowKernel, InputArray columnKernel, Point anchor, double delta, int rowBorderType, int columnBorderType, const Scalar&amp; borderValue)" title="Ptr&lt;FilterEngine&gt; createSeparableLinearFilter(int srcType, int dstType, InputArray rowKernel, InputArray columnKernel, Point anchor, double delta, int rowBorderType, int columnBorderType, const Scalar&amp; borderValue)"><code class="xref ocv ocv-func docutils literal"><span class="pre">createSeparableLinearFilter()</span></code></a>,
<a class="reference internal" href="#FilterEngine" title="class FilterEngine"><code class="xref ocv ocv-class docutils literal"><span class="pre">FilterEngine</span></code></a>,
<a class="reference internal" href="#void filter2D(InputArray src, OutputArray dst, int ddepth, InputArray kernel, Point anchor, double delta, int borderType)" title="void filter2D(InputArray src, OutputArray dst, int ddepth, InputArray kernel, Point anchor, double delta, int borderType)"><code class="xref ocv ocv-func docutils literal"><span class="pre">filter2D()</span></code></a></p>
</div>
</div>
<div class="section" id="createmorphologyfilter">
<h2>createMorphologyFilter<a class="headerlink" href="#createmorphologyfilter" title="Permalink to this headline">¶</a></h2>
<p>Creates an engine for non-separable morphological operations.</p>
<dl class="function">
<dt id="Ptr&lt;FilterEngine&gt; createMorphologyFilter(int op, int type, InputArray kernel, Point anchor, int rowBorderType, int columnBorderType, const Scalar&amp; borderValue)">
<strong>C++:</strong><code class="descname"> </code>Ptr&lt;FilterEngine&gt; <code class="descname">createMorphologyFilter</code><span class="sig-paren">(</span>int <strong>op</strong>, int <strong>type</strong>, InputArray <strong>kernel</strong>, Point <strong>anchor</strong>=Point(-1,-1), int <strong>rowBorderType</strong>=BORDER_CONSTANT, int <strong>columnBorderType</strong>=-1, const Scalar&amp; <strong>borderValue</strong>=morphologyDefaultBorderValue() <span class="sig-paren">)</span><a class="headerlink" href="#Ptr<FilterEngine> createMorphologyFilter(int op, int type, InputArray kernel, Point anchor, int rowBorderType, int columnBorderType, const Scalar& borderValue)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="Ptr&lt;BaseFilter&gt; getMorphologyFilter(int op, int type, InputArray kernel, Point anchor)">
<strong>C++:</strong><code class="descname"> </code>Ptr&lt;BaseFilter&gt; <code class="descname">getMorphologyFilter</code><span class="sig-paren">(</span>int <strong>op</strong>, int <strong>type</strong>, InputArray <strong>kernel</strong>, Point <strong>anchor</strong>=Point(-1,-1) <span class="sig-paren">)</span><a class="headerlink" href="#Ptr<BaseFilter> getMorphologyFilter(int op, int type, InputArray kernel, Point anchor)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="Ptr&lt;BaseRowFilter&gt; getMorphologyRowFilter(int op, int type, int ksize, int anchor)">
<strong>C++:</strong><code class="descname"> </code>Ptr&lt;BaseRowFilter&gt; <code class="descname">getMorphologyRowFilter</code><span class="sig-paren">(</span>int <strong>op</strong>, int <strong>type</strong>, int <strong>ksize</strong>, int <strong>anchor</strong>=-1 <span class="sig-paren">)</span><a class="headerlink" href="#Ptr<BaseRowFilter> getMorphologyRowFilter(int op, int type, int ksize, int anchor)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="Ptr&lt;BaseColumnFilter&gt; getMorphologyColumnFilter(int op, int type, int ksize, int anchor)">
<strong>C++:</strong><code class="descname"> </code>Ptr&lt;BaseColumnFilter&gt; <code class="descname">getMorphologyColumnFilter</code><span class="sig-paren">(</span>int <strong>op</strong>, int <strong>type</strong>, int <strong>ksize</strong>, int <strong>anchor</strong>=-1 <span class="sig-paren">)</span><a class="headerlink" href="#Ptr<BaseColumnFilter> getMorphologyColumnFilter(int op, int type, int ksize, int anchor)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="Scalar morphologyDefaultBorderValue()">
<strong>C++:</strong><code class="descname"> </code>Scalar <code class="descname">morphologyDefaultBorderValue</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#Scalar morphologyDefaultBorderValue()" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>op</strong> &#8211; Morphology operation ID,  <code class="docutils literal"><span class="pre">MORPH_ERODE</span></code>  or  <code class="docutils literal"><span class="pre">MORPH_DILATE</span></code> .</li>
<li><strong>type</strong> &#8211; Input/output image type. The number of channels can be arbitrary. The depth should be one of <code class="docutils literal"><span class="pre">CV_8U</span></code>, <code class="docutils literal"><span class="pre">CV_16U</span></code>, <code class="docutils literal"><span class="pre">CV_16S</span></code>,  <code class="docutils literal"><span class="pre">CV_32F`</span> <span class="pre">or</span> <span class="pre">``CV_64F</span></code>.</li>
<li><strong>kernel</strong> &#8211; 2D 8-bit structuring element for a morphological operation. Non-zero elements indicate the pixels that belong to the element.</li>
<li><strong>ksize</strong> &#8211; Horizontal or vertical structuring element size for separable morphological operations.</li>
<li><strong>anchor</strong> &#8211; Anchor position within the structuring element. Negative values mean that the anchor is at the kernel center.</li>
<li><strong>rowBorderType</strong> &#8211; Pixel extrapolation method in the vertical direction. For details, see  <a class="reference internal" href="#int borderInterpolate(int p, int len, int borderType)" title="int borderInterpolate(int p, int len, int borderType)"><code class="xref ocv ocv-func docutils literal"><span class="pre">borderInterpolate()</span></code></a>.</li>
<li><strong>columnBorderType</strong> &#8211; Pixel extrapolation method in the horizontal direction.</li>
<li><strong>borderValue</strong> &#8211; Border value in case of a constant border. The default value,   <code class="docutils literal"><span class="pre">morphologyDefaultBorderValue</span></code> , has a special meaning. It is transformed  <img class="math" src="../../../_images/math/ed4fd226d598bb17a0f6f87082400ff106c88add.png" alt="+\inf"/>  for the erosion and to  <img class="math" src="../../../_images/math/e181301e3d227562d749765e9019b2d8abc824f7.png" alt="-\inf"/>  for the dilation, which means that the minimum (maximum) is effectively computed only over the pixels that are inside the image.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<p>The functions construct primitive morphological filtering operations or a filter engine based on them. Normally it is enough to use
<a class="reference internal" href="#Ptr&lt;FilterEngine&gt; createMorphologyFilter(int op, int type, InputArray kernel, Point anchor, int rowBorderType, int columnBorderType, const Scalar&amp; borderValue)" title="Ptr&lt;FilterEngine&gt; createMorphologyFilter(int op, int type, InputArray kernel, Point anchor, int rowBorderType, int columnBorderType, const Scalar&amp; borderValue)"><code class="xref ocv ocv-func docutils literal"><span class="pre">createMorphologyFilter()</span></code></a> or even higher-level
<a class="reference internal" href="#void erode(InputArray src, OutputArray dst, InputArray kernel, Point anchor, int iterations, int borderType, const Scalar&amp; borderValue)" title="void erode(InputArray src, OutputArray dst, InputArray kernel, Point anchor, int iterations, int borderType, const Scalar&amp; borderValue)"><code class="xref ocv ocv-func docutils literal"><span class="pre">erode()</span></code></a>,
<a class="reference internal" href="#void dilate(InputArray src, OutputArray dst, InputArray kernel, Point anchor, int iterations, int borderType, const Scalar&amp; borderValue)" title="void dilate(InputArray src, OutputArray dst, InputArray kernel, Point anchor, int iterations, int borderType, const Scalar&amp; borderValue)"><code class="xref ocv ocv-func docutils literal"><span class="pre">dilate()</span></code></a> , or
<a class="reference internal" href="#void morphologyEx(InputArray src, OutputArray dst, int op, InputArray kernel, Point anchor, int iterations, int borderType, const Scalar&amp; borderValue)" title="void morphologyEx(InputArray src, OutputArray dst, int op, InputArray kernel, Point anchor, int iterations, int borderType, const Scalar&amp; borderValue)"><code class="xref ocv ocv-func docutils literal"><span class="pre">morphologyEx()</span></code></a> .
Note that
<a class="reference internal" href="#Ptr&lt;FilterEngine&gt; createMorphologyFilter(int op, int type, InputArray kernel, Point anchor, int rowBorderType, int columnBorderType, const Scalar&amp; borderValue)" title="Ptr&lt;FilterEngine&gt; createMorphologyFilter(int op, int type, InputArray kernel, Point anchor, int rowBorderType, int columnBorderType, const Scalar&amp; borderValue)"><code class="xref ocv ocv-func docutils literal"><span class="pre">createMorphologyFilter()</span></code></a> analyzes the structuring element shape and builds a separable morphological filter engine when the structuring element is square.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#void erode(InputArray src, OutputArray dst, InputArray kernel, Point anchor, int iterations, int borderType, const Scalar&amp; borderValue)" title="void erode(InputArray src, OutputArray dst, InputArray kernel, Point anchor, int iterations, int borderType, const Scalar&amp; borderValue)"><code class="xref ocv ocv-func docutils literal"><span class="pre">erode()</span></code></a>,
<a class="reference internal" href="#void dilate(InputArray src, OutputArray dst, InputArray kernel, Point anchor, int iterations, int borderType, const Scalar&amp; borderValue)" title="void dilate(InputArray src, OutputArray dst, InputArray kernel, Point anchor, int iterations, int borderType, const Scalar&amp; borderValue)"><code class="xref ocv ocv-func docutils literal"><span class="pre">dilate()</span></code></a>,
<a class="reference internal" href="#void morphologyEx(InputArray src, OutputArray dst, int op, InputArray kernel, Point anchor, int iterations, int borderType, const Scalar&amp; borderValue)" title="void morphologyEx(InputArray src, OutputArray dst, int op, InputArray kernel, Point anchor, int iterations, int borderType, const Scalar&amp; borderValue)"><code class="xref ocv ocv-func docutils literal"><span class="pre">morphologyEx()</span></code></a>,
<a class="reference internal" href="#FilterEngine" title="class FilterEngine"><code class="xref ocv ocv-class docutils literal"><span class="pre">FilterEngine</span></code></a></p>
</div>
</div>
<div class="section" id="createseparablelinearfilter">
<h2>createSeparableLinearFilter<a class="headerlink" href="#createseparablelinearfilter" title="Permalink to this headline">¶</a></h2>
<p>Creates an engine for a separable linear filter.</p>
<dl class="function">
<dt id="Ptr&lt;FilterEngine&gt; createSeparableLinearFilter(int srcType, int dstType, InputArray rowKernel, InputArray columnKernel, Point anchor, double delta, int rowBorderType, int columnBorderType, const Scalar&amp; borderValue)">
<strong>C++:</strong><code class="descname"> </code>Ptr&lt;FilterEngine&gt; <code class="descname">createSeparableLinearFilter</code><span class="sig-paren">(</span>int <strong>srcType</strong>, int <strong>dstType</strong>, InputArray <strong>rowKernel</strong>, InputArray <strong>columnKernel</strong>, Point <strong>anchor</strong>=Point(-1,-1), double <strong>delta</strong>=0, int <strong>rowBorderType</strong>=BORDER_DEFAULT, int <strong>columnBorderType</strong>=-1, const Scalar&amp; <strong>borderValue</strong>=Scalar() <span class="sig-paren">)</span><a class="headerlink" href="#Ptr<FilterEngine> createSeparableLinearFilter(int srcType, int dstType, InputArray rowKernel, InputArray columnKernel, Point anchor, double delta, int rowBorderType, int columnBorderType, const Scalar& borderValue)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="Ptr&lt;BaseColumnFilter&gt; getLinearColumnFilter(int bufType, int dstType, InputArray kernel, int anchor, int symmetryType, double delta, int bits)">
<strong>C++:</strong><code class="descname"> </code>Ptr&lt;BaseColumnFilter&gt; <code class="descname">getLinearColumnFilter</code><span class="sig-paren">(</span>int <strong>bufType</strong>, int <strong>dstType</strong>, InputArray <strong>kernel</strong>, int <strong>anchor</strong>, int <strong>symmetryType</strong>, double <strong>delta</strong>=0, int <strong>bits</strong>=0 <span class="sig-paren">)</span><a class="headerlink" href="#Ptr<BaseColumnFilter> getLinearColumnFilter(int bufType, int dstType, InputArray kernel, int anchor, int symmetryType, double delta, int bits)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="Ptr&lt;BaseRowFilter&gt; getLinearRowFilter(int srcType, int bufType, InputArray kernel, int anchor, int symmetryType)">
<strong>C++:</strong><code class="descname"> </code>Ptr&lt;BaseRowFilter&gt; <code class="descname">getLinearRowFilter</code><span class="sig-paren">(</span>int <strong>srcType</strong>, int <strong>bufType</strong>, InputArray <strong>kernel</strong>, int <strong>anchor</strong>, int <strong>symmetryType</strong><span class="sig-paren">)</span><a class="headerlink" href="#Ptr<BaseRowFilter> getLinearRowFilter(int srcType, int bufType, InputArray kernel, int anchor, int symmetryType)" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>srcType</strong> &#8211; Source array type.</li>
<li><strong>dstType</strong> &#8211; Destination image type that must have as many channels as  <code class="docutils literal"><span class="pre">srcType</span></code> .</li>
<li><strong>bufType</strong> &#8211; Intermediate buffer type that must have as many channels as  <code class="docutils literal"><span class="pre">srcType</span></code> .</li>
<li><strong>rowKernel</strong> &#8211; Coefficients for filtering each row.</li>
<li><strong>columnKernel</strong> &#8211; Coefficients for filtering each column.</li>
<li><strong>anchor</strong> &#8211; Anchor position within the kernel. Negative values mean that anchor is positioned at the aperture center.</li>
<li><strong>delta</strong> &#8211; Value added to the filtered results before storing them.</li>
<li><strong>bits</strong> &#8211; Number of the fractional bits. The parameter is used when the kernel is an integer matrix representing fixed-point filter coefficients.</li>
<li><strong>rowBorderType</strong> &#8211; Pixel extrapolation method in the vertical direction. For details, see  <a class="reference internal" href="#int borderInterpolate(int p, int len, int borderType)" title="int borderInterpolate(int p, int len, int borderType)"><code class="xref ocv ocv-func docutils literal"><span class="pre">borderInterpolate()</span></code></a>.</li>
<li><strong>columnBorderType</strong> &#8211; Pixel extrapolation method in the horizontal direction.</li>
<li><strong>borderValue</strong> &#8211; Border value used in case of a constant border.</li>
<li><strong>symmetryType</strong> &#8211; Type of each row and column kernel. See  <a class="reference internal" href="#int getKernelType(InputArray kernel, Point anchor)" title="int getKernelType(InputArray kernel, Point anchor)"><code class="xref ocv ocv-func docutils literal"><span class="pre">getKernelType()</span></code></a> .</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<p>The functions construct primitive separable linear filtering operations or a filter engine based on them. Normally it is enough to use
<a class="reference internal" href="#Ptr&lt;FilterEngine&gt; createSeparableLinearFilter(int srcType, int dstType, InputArray rowKernel, InputArray columnKernel, Point anchor, double delta, int rowBorderType, int columnBorderType, const Scalar&amp; borderValue)" title="Ptr&lt;FilterEngine&gt; createSeparableLinearFilter(int srcType, int dstType, InputArray rowKernel, InputArray columnKernel, Point anchor, double delta, int rowBorderType, int columnBorderType, const Scalar&amp; borderValue)"><code class="xref ocv ocv-func docutils literal"><span class="pre">createSeparableLinearFilter()</span></code></a> or even higher-level
<a class="reference internal" href="#void sepFilter2D(InputArray src, OutputArray dst, int ddepth, InputArray kernelX, InputArray kernelY, Point anchor, double delta, int borderType)" title="void sepFilter2D(InputArray src, OutputArray dst, int ddepth, InputArray kernelX, InputArray kernelY, Point anchor, double delta, int borderType)"><code class="xref ocv ocv-func docutils literal"><span class="pre">sepFilter2D()</span></code></a> . The function
<a class="reference internal" href="#Ptr&lt;FilterEngine&gt; createMorphologyFilter(int op, int type, InputArray kernel, Point anchor, int rowBorderType, int columnBorderType, const Scalar&amp; borderValue)" title="Ptr&lt;FilterEngine&gt; createMorphologyFilter(int op, int type, InputArray kernel, Point anchor, int rowBorderType, int columnBorderType, const Scalar&amp; borderValue)"><code class="xref ocv ocv-func docutils literal"><span class="pre">createMorphologyFilter()</span></code></a> is smart enough to figure out the <code class="docutils literal"><span class="pre">symmetryType</span></code> for each of the two kernels, the intermediate <code class="docutils literal"><span class="pre">bufType</span></code>  and, if filtering can be done in integer arithmetics, the number of <code class="docutils literal"><span class="pre">bits</span></code> to encode the filter coefficients. If it does not work for you, it is possible to call <code class="docutils literal"><span class="pre">getLinearColumnFilter</span></code>,``getLinearRowFilter`` directly and then pass them to the
<a class="reference internal" href="#FilterEngine" title="class FilterEngine"><code class="xref ocv ocv-class docutils literal"><span class="pre">FilterEngine</span></code></a> constructor.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#void sepFilter2D(InputArray src, OutputArray dst, int ddepth, InputArray kernelX, InputArray kernelY, Point anchor, double delta, int borderType)" title="void sepFilter2D(InputArray src, OutputArray dst, int ddepth, InputArray kernelX, InputArray kernelY, Point anchor, double delta, int borderType)"><code class="xref ocv ocv-func docutils literal"><span class="pre">sepFilter2D()</span></code></a>,
<a class="reference internal" href="#Ptr&lt;FilterEngine&gt; createLinearFilter(int srcType, int dstType, InputArray kernel, Point _anchor, double delta, int rowBorderType, int columnBorderType, const Scalar&amp; borderValue)" title="Ptr&lt;FilterEngine&gt; createLinearFilter(int srcType, int dstType, InputArray kernel, Point _anchor, double delta, int rowBorderType, int columnBorderType, const Scalar&amp; borderValue)"><code class="xref ocv ocv-func docutils literal"><span class="pre">createLinearFilter()</span></code></a>,
<a class="reference internal" href="#FilterEngine" title="class FilterEngine"><code class="xref ocv ocv-class docutils literal"><span class="pre">FilterEngine</span></code></a>,
<a class="reference internal" href="#int getKernelType(InputArray kernel, Point anchor)" title="int getKernelType(InputArray kernel, Point anchor)"><code class="xref ocv ocv-func docutils literal"><span class="pre">getKernelType()</span></code></a></p>
</div>
</div>
<div class="section" id="dilate">
<h2>dilate<a class="headerlink" href="#dilate" title="Permalink to this headline">¶</a></h2>
<p>Dilates an image by using a specific structuring element.</p>
<dl class="function">
<dt id="void dilate(InputArray src, OutputArray dst, InputArray kernel, Point anchor, int iterations, int borderType, const Scalar&amp; borderValue)">
<strong>C++:</strong><code class="descname"> </code>void <code class="descname">dilate</code><span class="sig-paren">(</span>InputArray <strong>src</strong>, OutputArray <strong>dst</strong>, InputArray <strong>kernel</strong>, Point <strong>anchor</strong>=Point(-1,-1), int <strong>iterations</strong>=1, int <strong>borderType</strong>=BORDER_CONSTANT, const Scalar&amp; <strong>borderValue</strong>=morphologyDefaultBorderValue() <span class="sig-paren">)</span><a class="headerlink" href="#void dilate(InputArray src, OutputArray dst, InputArray kernel, Point anchor, int iterations, int borderType, const Scalar& borderValue)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="pyfunction">
<dt id="cv2.dilate">
<strong>Python:</strong><code class="descname"> </code><code class="descclassname">cv2.</code><code class="descname">dilate</code><span class="sig-paren">(</span>src, kernel<span class="optional">[</span>, dst<span class="optional">[</span>, anchor<span class="optional">[</span>, iterations<span class="optional">[</span>, borderType<span class="optional">[</span>, borderValue<span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span> &rarr; dst<a class="headerlink" href="#cv2.dilate" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="cfunction">
<dt id="void cvDilate(const CvArr* src, CvArr* dst, IplConvKernel* element, int iterations)">
<strong>C:</strong><code class="descname"> </code>void <code class="descname">cvDilate</code><span class="sig-paren">(</span>const CvArr* <strong>src</strong>, CvArr* <strong>dst</strong>, IplConvKernel* <strong>element</strong>=NULL, int <strong>iterations</strong>=1 <span class="sig-paren">)</span><a class="headerlink" href="#void cvDilate(const CvArr* src, CvArr* dst, IplConvKernel* element, int iterations)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="pyoldfunction">
<dt id="cv.Dilate">
<strong>Python:</strong><code class="descname"> </code><code class="descclassname">cv.</code><code class="descname">Dilate</code><span class="sig-paren">(</span>src, dst, element=None, iterations=1<span class="sig-paren">)</span> &rarr; None<a class="headerlink" href="#cv.Dilate" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>src</strong> &#8211; input image; the number of channels can be arbitrary, but the depth should be one of <code class="docutils literal"><span class="pre">CV_8U</span></code>, <code class="docutils literal"><span class="pre">CV_16U</span></code>, <code class="docutils literal"><span class="pre">CV_16S</span></code>,  <code class="docutils literal"><span class="pre">CV_32F`</span> <span class="pre">or</span> <span class="pre">``CV_64F</span></code>.</li>
<li><strong>dst</strong> &#8211; output image of the same size and type as <code class="docutils literal"><span class="pre">src</span></code>.</li>
<li><strong>element</strong> &#8211; structuring element used for dilation; if  <code class="docutils literal"><span class="pre">element=Mat()</span></code> , a  <code class="docutils literal"><span class="pre">3</span> <span class="pre">x</span> <span class="pre">3</span></code> rectangular structuring element is used.</li>
<li><strong>anchor</strong> &#8211; position of the anchor within the element; default value <code class="docutils literal"><span class="pre">(-1,</span> <span class="pre">-1)</span></code> means that the anchor is at the element center.</li>
<li><strong>iterations</strong> &#8211; number of times dilation is applied.</li>
<li><strong>borderType</strong> &#8211; pixel extrapolation method (see  <a class="reference internal" href="#int borderInterpolate(int p, int len, int borderType)" title="int borderInterpolate(int p, int len, int borderType)"><code class="xref ocv ocv-func docutils literal"><span class="pre">borderInterpolate()</span></code></a> for details).</li>
<li><strong>borderValue</strong> &#8211; border value in case of a constant border (see  <a class="reference internal" href="#Ptr&lt;FilterEngine&gt; createMorphologyFilter(int op, int type, InputArray kernel, Point anchor, int rowBorderType, int columnBorderType, const Scalar&amp; borderValue)" title="Ptr&lt;FilterEngine&gt; createMorphologyFilter(int op, int type, InputArray kernel, Point anchor, int rowBorderType, int columnBorderType, const Scalar&amp; borderValue)"><code class="xref ocv ocv-func docutils literal"><span class="pre">createMorphologyFilter()</span></code></a> for details).</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<p>The function dilates the source image using the specified structuring element that determines the shape of a pixel neighborhood over which the maximum is taken:</p>
<div class="math">
<p><img src="../../../_images/math/db0d7a1f9263cf60da5843f93c5c31101af04456.png" alt="\texttt{dst} (x,y) =  \max _{(x',y'):  \, \texttt{element} (x',y') \ne0 } \texttt{src} (x+x',y+y')"/></p>
</div><p>The function supports the in-place mode. Dilation can be applied several ( <code class="docutils literal"><span class="pre">iterations</span></code> ) times. In case of multi-channel images, each channel is processed independently.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#void erode(InputArray src, OutputArray dst, InputArray kernel, Point anchor, int iterations, int borderType, const Scalar&amp; borderValue)" title="void erode(InputArray src, OutputArray dst, InputArray kernel, Point anchor, int iterations, int borderType, const Scalar&amp; borderValue)"><code class="xref ocv ocv-func docutils literal"><span class="pre">erode()</span></code></a>,
<a class="reference internal" href="#void morphologyEx(InputArray src, OutputArray dst, int op, InputArray kernel, Point anchor, int iterations, int borderType, const Scalar&amp; borderValue)" title="void morphologyEx(InputArray src, OutputArray dst, int op, InputArray kernel, Point anchor, int iterations, int borderType, const Scalar&amp; borderValue)"><code class="xref ocv ocv-func docutils literal"><span class="pre">morphologyEx()</span></code></a>,
<a class="reference internal" href="#Ptr&lt;FilterEngine&gt; createMorphologyFilter(int op, int type, InputArray kernel, Point anchor, int rowBorderType, int columnBorderType, const Scalar&amp; borderValue)" title="Ptr&lt;FilterEngine&gt; createMorphologyFilter(int op, int type, InputArray kernel, Point anchor, int rowBorderType, int columnBorderType, const Scalar&amp; borderValue)"><code class="xref ocv ocv-func docutils literal"><span class="pre">createMorphologyFilter()</span></code></a></p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<ul class="last simple">
<li>An example using the morphological dilate operation can be found at opencv_source_code/samples/cpp/morphology2.cpp</li>
</ul>
</div>
</div>
<div class="section" id="erode">
<h2>erode<a class="headerlink" href="#erode" title="Permalink to this headline">¶</a></h2>
<p>Erodes an image by using a specific structuring element.</p>
<dl class="function">
<dt id="void erode(InputArray src, OutputArray dst, InputArray kernel, Point anchor, int iterations, int borderType, const Scalar&amp; borderValue)">
<strong>C++:</strong><code class="descname"> </code>void <code class="descname">erode</code><span class="sig-paren">(</span>InputArray <strong>src</strong>, OutputArray <strong>dst</strong>, InputArray <strong>kernel</strong>, Point <strong>anchor</strong>=Point(-1,-1), int <strong>iterations</strong>=1, int <strong>borderType</strong>=BORDER_CONSTANT, const Scalar&amp; <strong>borderValue</strong>=morphologyDefaultBorderValue() <span class="sig-paren">)</span><a class="headerlink" href="#void erode(InputArray src, OutputArray dst, InputArray kernel, Point anchor, int iterations, int borderType, const Scalar& borderValue)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="pyfunction">
<dt id="cv2.erode">
<strong>Python:</strong><code class="descname"> </code><code class="descclassname">cv2.</code><code class="descname">erode</code><span class="sig-paren">(</span>src, kernel<span class="optional">[</span>, dst<span class="optional">[</span>, anchor<span class="optional">[</span>, iterations<span class="optional">[</span>, borderType<span class="optional">[</span>, borderValue<span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span> &rarr; dst<a class="headerlink" href="#cv2.erode" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="cfunction">
<dt id="void cvErode(const CvArr* src, CvArr* dst, IplConvKernel* element, int iterations)">
<strong>C:</strong><code class="descname"> </code>void <code class="descname">cvErode</code><span class="sig-paren">(</span>const CvArr* <strong>src</strong>, CvArr* <strong>dst</strong>, IplConvKernel* <strong>element</strong>=NULL, int <strong>iterations</strong>=1<span class="sig-paren">)</span><a class="headerlink" href="#void cvErode(const CvArr* src, CvArr* dst, IplConvKernel* element, int iterations)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="pyoldfunction">
<dt id="cv.Erode">
<strong>Python:</strong><code class="descname"> </code><code class="descclassname">cv.</code><code class="descname">Erode</code><span class="sig-paren">(</span>src, dst, element=None, iterations=1<span class="sig-paren">)</span> &rarr; None<a class="headerlink" href="#cv.Erode" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>src</strong> &#8211; input image; the number of channels can be arbitrary, but the depth should be one of <code class="docutils literal"><span class="pre">CV_8U</span></code>, <code class="docutils literal"><span class="pre">CV_16U</span></code>, <code class="docutils literal"><span class="pre">CV_16S</span></code>,  <code class="docutils literal"><span class="pre">CV_32F`</span> <span class="pre">or</span> <span class="pre">``CV_64F</span></code>.</li>
<li><strong>dst</strong> &#8211; output image of the same size and type as <code class="docutils literal"><span class="pre">src</span></code>.</li>
<li><strong>element</strong> &#8211; structuring element used for erosion; if  <code class="docutils literal"><span class="pre">element=Mat()</span></code> , a  <code class="docutils literal"><span class="pre">3</span> <span class="pre">x</span> <span class="pre">3</span></code>  rectangular structuring element is used.</li>
<li><strong>anchor</strong> &#8211; position of the anchor within the element; default value  <code class="docutils literal"><span class="pre">(-1,</span> <span class="pre">-1)</span></code>  means that the anchor is at the element center.</li>
<li><strong>iterations</strong> &#8211; number of times erosion is applied.</li>
<li><strong>borderType</strong> &#8211; pixel extrapolation method (see  <a class="reference internal" href="#int borderInterpolate(int p, int len, int borderType)" title="int borderInterpolate(int p, int len, int borderType)"><code class="xref ocv ocv-func docutils literal"><span class="pre">borderInterpolate()</span></code></a> for details).</li>
<li><strong>borderValue</strong> &#8211; border value in case of a constant border (see <a class="reference internal" href="#Ptr&lt;FilterEngine&gt; createMorphologyFilter(int op, int type, InputArray kernel, Point anchor, int rowBorderType, int columnBorderType, const Scalar&amp; borderValue)" title="Ptr&lt;FilterEngine&gt; createMorphologyFilter(int op, int type, InputArray kernel, Point anchor, int rowBorderType, int columnBorderType, const Scalar&amp; borderValue)"><code class="xref ocv ocv-func docutils literal"><span class="pre">createMorphologyFilter()</span></code></a> for details).</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<p>The function erodes the source image using the specified structuring element that determines the shape of a pixel neighborhood over which the minimum is taken:</p>
<div class="math">
<p><img src="../../../_images/math/d1a0ad401da8de4bf20fa23eed9080ea4ad114c1.png" alt="\texttt{dst} (x,y) =  \min _{(x',y'):  \, \texttt{element} (x',y') \ne0 } \texttt{src} (x+x',y+y')"/></p>
</div><p>The function supports the in-place mode. Erosion can be applied several ( <code class="docutils literal"><span class="pre">iterations</span></code> ) times. In case of multi-channel images, each channel is processed independently.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#void dilate(InputArray src, OutputArray dst, InputArray kernel, Point anchor, int iterations, int borderType, const Scalar&amp; borderValue)" title="void dilate(InputArray src, OutputArray dst, InputArray kernel, Point anchor, int iterations, int borderType, const Scalar&amp; borderValue)"><code class="xref ocv ocv-func docutils literal"><span class="pre">dilate()</span></code></a>,
<a class="reference internal" href="#void morphologyEx(InputArray src, OutputArray dst, int op, InputArray kernel, Point anchor, int iterations, int borderType, const Scalar&amp; borderValue)" title="void morphologyEx(InputArray src, OutputArray dst, int op, InputArray kernel, Point anchor, int iterations, int borderType, const Scalar&amp; borderValue)"><code class="xref ocv ocv-func docutils literal"><span class="pre">morphologyEx()</span></code></a>,
<a class="reference internal" href="#Ptr&lt;FilterEngine&gt; createMorphologyFilter(int op, int type, InputArray kernel, Point anchor, int rowBorderType, int columnBorderType, const Scalar&amp; borderValue)" title="Ptr&lt;FilterEngine&gt; createMorphologyFilter(int op, int type, InputArray kernel, Point anchor, int rowBorderType, int columnBorderType, const Scalar&amp; borderValue)"><code class="xref ocv ocv-func docutils literal"><span class="pre">createMorphologyFilter()</span></code></a></p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<ul class="last simple">
<li>An example using the morphological erode operation can be found at opencv_source_code/samples/cpp/morphology2.cpp</li>
</ul>
</div>
</div>
<div class="section" id="filter2d">
<h2>filter2D<a class="headerlink" href="#filter2d" title="Permalink to this headline">¶</a></h2>
<p>Convolves an image with the kernel.</p>
<dl class="function">
<dt id="void filter2D(InputArray src, OutputArray dst, int ddepth, InputArray kernel, Point anchor, double delta, int borderType)">
<strong>C++:</strong><code class="descname"> </code>void <code class="descname">filter2D</code><span class="sig-paren">(</span>InputArray <strong>src</strong>, OutputArray <strong>dst</strong>, int <strong>ddepth</strong>, InputArray <strong>kernel</strong>, Point <strong>anchor</strong>=Point(-1,-1), double <strong>delta</strong>=0, int <strong>borderType</strong>=BORDER_DEFAULT <span class="sig-paren">)</span><a class="headerlink" href="#void filter2D(InputArray src, OutputArray dst, int ddepth, InputArray kernel, Point anchor, double delta, int borderType)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="pyfunction">
<dt id="cv2.filter2D">
<strong>Python:</strong><code class="descname"> </code><code class="descclassname">cv2.</code><code class="descname">filter2D</code><span class="sig-paren">(</span>src, ddepth, kernel<span class="optional">[</span>, dst<span class="optional">[</span>, anchor<span class="optional">[</span>, delta<span class="optional">[</span>, borderType<span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span> &rarr; dst<a class="headerlink" href="#cv2.filter2D" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="cfunction">
<dt id="void cvFilter2D(const CvArr* src, CvArr* dst, const CvMat* kernel, CvPoint anchor)">
<strong>C:</strong><code class="descname"> </code>void <code class="descname">cvFilter2D</code><span class="sig-paren">(</span>const CvArr* <strong>src</strong>, CvArr* <strong>dst</strong>, const CvMat* <strong>kernel</strong>, CvPoint <strong>anchor</strong>=cvPoint(-1,-1) <span class="sig-paren">)</span><a class="headerlink" href="#void cvFilter2D(const CvArr* src, CvArr* dst, const CvMat* kernel, CvPoint anchor)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="pyoldfunction">
<dt id="cv.Filter2D">
<strong>Python:</strong><code class="descname"> </code><code class="descclassname">cv.</code><code class="descname">Filter2D</code><span class="sig-paren">(</span>src, dst, kernel, anchor=(-1, -1)<span class="sig-paren">)</span> &rarr; None<a class="headerlink" href="#cv.Filter2D" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>src</strong> &#8211; input image.</li>
<li><strong>dst</strong> &#8211; output image of the same size and the same number of channels as <code class="docutils literal"><span class="pre">src</span></code>.</li>
<li><strong>ddepth</strong> &#8211; <dl class="docutils">
<dt>desired depth of the destination image; if it is negative, it will be the same as <code class="docutils literal"><span class="pre">src.depth()</span></code>; the following combinations of <code class="docutils literal"><span class="pre">src.depth()</span></code> and <code class="docutils literal"><span class="pre">ddepth</span></code> are supported:</dt>
<dd><ul class="first last">
<li><code class="docutils literal"><span class="pre">src.depth()</span></code> = <code class="docutils literal"><span class="pre">CV_8U</span></code>, <code class="docutils literal"><span class="pre">ddepth</span></code> = -1/<code class="docutils literal"><span class="pre">CV_16S</span></code>/<code class="docutils literal"><span class="pre">CV_32F</span></code>/<code class="docutils literal"><span class="pre">CV_64F</span></code></li>
<li><code class="docutils literal"><span class="pre">src.depth()</span></code> = <code class="docutils literal"><span class="pre">CV_16U</span></code>/<code class="docutils literal"><span class="pre">CV_16S</span></code>, <code class="docutils literal"><span class="pre">ddepth</span></code> = -1/<code class="docutils literal"><span class="pre">CV_32F</span></code>/<code class="docutils literal"><span class="pre">CV_64F</span></code></li>
<li><code class="docutils literal"><span class="pre">src.depth()</span></code> = <code class="docutils literal"><span class="pre">CV_32F</span></code>, <code class="docutils literal"><span class="pre">ddepth</span></code> = -1/<code class="docutils literal"><span class="pre">CV_32F</span></code>/<code class="docutils literal"><span class="pre">CV_64F</span></code></li>
<li><code class="docutils literal"><span class="pre">src.depth()</span></code> = <code class="docutils literal"><span class="pre">CV_64F</span></code>, <code class="docutils literal"><span class="pre">ddepth</span></code> = -1/<code class="docutils literal"><span class="pre">CV_64F</span></code></li>
</ul>
</dd>
</dl>
<p>when <code class="docutils literal"><span class="pre">ddepth=-1</span></code>, the output image will have the same depth as the source.</p>
</li>
<li><strong>kernel</strong> &#8211; convolution kernel (or rather a correlation kernel), a single-channel floating point matrix; if you want to apply different kernels to different channels, split the image into separate color planes using  <a class="reference internal" href="../../core/doc/operations_on_arrays.html#void split(const Mat&amp; src, Mat* mvbegin)" title="void split(const Mat&amp; src, Mat* mvbegin)"><code class="xref ocv ocv-func docutils literal"><span class="pre">split()</span></code></a>  and process them individually.</li>
<li><strong>anchor</strong> &#8211; anchor of the kernel that indicates the relative position of a filtered point within the kernel; the anchor should lie within the kernel; default value (-1,-1) means that the anchor is at the kernel center.</li>
<li><strong>delta</strong> &#8211; optional value added to the filtered pixels before storing them in <code class="docutils literal"><span class="pre">dst</span></code>.</li>
<li><strong>borderType</strong> &#8211; pixel extrapolation method (see  <a class="reference internal" href="#int borderInterpolate(int p, int len, int borderType)" title="int borderInterpolate(int p, int len, int borderType)"><code class="xref ocv ocv-func docutils literal"><span class="pre">borderInterpolate()</span></code></a> for details).</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<p>The function applies an arbitrary linear filter to an image. In-place operation is supported. When the aperture is partially outside the image, the function interpolates outlier pixel values according to the specified border mode.</p>
<p>The function does actually compute correlation, not the convolution:</p>
<div class="math">
<p><img src="../../../_images/math/930d8a4a72259ace7a4966d4bc1b653eec1b7ce8.png" alt="\texttt{dst} (x,y) =  \sum _{ \stackrel{0\leq x' &lt; \texttt{kernel.cols},}{0\leq y' &lt; \texttt{kernel.rows}} }  \texttt{kernel} (x',y')* \texttt{src} (x+x'- \texttt{anchor.x} ,y+y'- \texttt{anchor.y} )"/></p>
</div><p>That is, the kernel is not mirrored around the anchor point. If you need a real convolution, flip the kernel using
<a class="reference internal" href="../../core/doc/operations_on_arrays.html#void flip(InputArray src, OutputArray dst, int flipCode)" title="void flip(InputArray src, OutputArray dst, int flipCode)"><code class="xref ocv ocv-func docutils literal"><span class="pre">flip()</span></code></a> and set the new anchor to <code class="docutils literal"><span class="pre">(kernel.cols</span> <span class="pre">-</span> <span class="pre">anchor.x</span> <span class="pre">-</span> <span class="pre">1,</span> <span class="pre">kernel.rows</span> <span class="pre">-</span> <span class="pre">anchor.y</span> <span class="pre">-</span> <span class="pre">1)</span></code> .</p>
<p>The function uses the DFT-based algorithm in case of sufficiently large kernels (~``11 x 11`` or larger) and the direct algorithm (that uses the engine retrieved by <a class="reference internal" href="#Ptr&lt;FilterEngine&gt; createLinearFilter(int srcType, int dstType, InputArray kernel, Point _anchor, double delta, int rowBorderType, int columnBorderType, const Scalar&amp; borderValue)" title="Ptr&lt;FilterEngine&gt; createLinearFilter(int srcType, int dstType, InputArray kernel, Point _anchor, double delta, int rowBorderType, int columnBorderType, const Scalar&amp; borderValue)"><code class="xref ocv ocv-func docutils literal"><span class="pre">createLinearFilter()</span></code></a> ) for small kernels.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#void sepFilter2D(InputArray src, OutputArray dst, int ddepth, InputArray kernelX, InputArray kernelY, Point anchor, double delta, int borderType)" title="void sepFilter2D(InputArray src, OutputArray dst, int ddepth, InputArray kernelX, InputArray kernelY, Point anchor, double delta, int borderType)"><code class="xref ocv ocv-func docutils literal"><span class="pre">sepFilter2D()</span></code></a>,
<a class="reference internal" href="#Ptr&lt;FilterEngine&gt; createLinearFilter(int srcType, int dstType, InputArray kernel, Point _anchor, double delta, int rowBorderType, int columnBorderType, const Scalar&amp; borderValue)" title="Ptr&lt;FilterEngine&gt; createLinearFilter(int srcType, int dstType, InputArray kernel, Point _anchor, double delta, int rowBorderType, int columnBorderType, const Scalar&amp; borderValue)"><code class="xref ocv ocv-func docutils literal"><span class="pre">createLinearFilter()</span></code></a>,
<a class="reference internal" href="../../core/doc/operations_on_arrays.html#void dft(InputArray src, OutputArray dst, int flags, int nonzeroRows)" title="void dft(InputArray src, OutputArray dst, int flags, int nonzeroRows)"><code class="xref ocv ocv-func docutils literal"><span class="pre">dft()</span></code></a>,
<a class="reference internal" href="object_detection.html#void matchTemplate(InputArray image, InputArray templ, OutputArray result, int method)" title="void matchTemplate(InputArray image, InputArray templ, OutputArray result, int method)"><code class="xref ocv ocv-func docutils literal"><span class="pre">matchTemplate()</span></code></a></p>
</div>
</div>
<div class="section" id="gaussianblur">
<h2>GaussianBlur<a class="headerlink" href="#gaussianblur" title="Permalink to this headline">¶</a></h2>
<p>Blurs an image using a Gaussian filter.</p>
<dl class="function">
<dt id="void GaussianBlur(InputArray src, OutputArray dst, Size ksize, double sigmaX, double sigmaY, int borderType)">
<strong>C++:</strong><code class="descname"> </code>void <code class="descname">GaussianBlur</code><span class="sig-paren">(</span>InputArray <strong>src</strong>, OutputArray <strong>dst</strong>, Size <strong>ksize</strong>, double <strong>sigmaX</strong>, double <strong>sigmaY</strong>=0, int <strong>borderType</strong>=BORDER_DEFAULT <span class="sig-paren">)</span><a class="headerlink" href="#void GaussianBlur(InputArray src, OutputArray dst, Size ksize, double sigmaX, double sigmaY, int borderType)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="pyfunction">
<dt id="cv2.GaussianBlur">
<strong>Python:</strong><code class="descname"> </code><code class="descclassname">cv2.</code><code class="descname">GaussianBlur</code><span class="sig-paren">(</span>src, ksize, sigmaX<span class="optional">[</span>, dst<span class="optional">[</span>, sigmaY<span class="optional">[</span>, borderType<span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span> &rarr; dst<a class="headerlink" href="#cv2.GaussianBlur" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>src</strong> &#8211; input image; the image can have any number of channels, which are processed independently, but the depth should be <code class="docutils literal"><span class="pre">CV_8U</span></code>, <code class="docutils literal"><span class="pre">CV_16U</span></code>, <code class="docutils literal"><span class="pre">CV_16S</span></code>, <code class="docutils literal"><span class="pre">CV_32F</span></code> or <code class="docutils literal"><span class="pre">CV_64F</span></code>.</li>
<li><strong>dst</strong> &#8211; output image of the same size and type as <code class="docutils literal"><span class="pre">src</span></code>.</li>
<li><strong>ksize</strong> &#8211; Gaussian kernel size.  <code class="docutils literal"><span class="pre">ksize.width</span></code>  and  <code class="docutils literal"><span class="pre">ksize.height</span></code>  can differ but they both must be positive and odd. Or, they can be zero&#8217;s and then they are computed from  <code class="docutils literal"><span class="pre">sigma*</span></code> .</li>
<li><strong>sigmaX</strong> &#8211; Gaussian kernel standard deviation in X direction.</li>
<li><strong>sigmaY</strong> &#8211; Gaussian kernel standard deviation in Y direction; if  <code class="docutils literal"><span class="pre">sigmaY</span></code>  is zero, it is set to be equal to  <code class="docutils literal"><span class="pre">sigmaX</span></code>, if both sigmas are zeros, they are computed from  <code class="docutils literal"><span class="pre">ksize.width</span></code>  and  <code class="docutils literal"><span class="pre">ksize.height</span></code> , respectively (see  <a class="reference internal" href="#Mat getGaussianKernel(int ksize, double sigma, int ktype)" title="Mat getGaussianKernel(int ksize, double sigma, int ktype)"><code class="xref ocv ocv-func docutils literal"><span class="pre">getGaussianKernel()</span></code></a> for details); to fully control the result regardless of possible future modifications of all this semantics, it is recommended to specify all of <code class="docutils literal"><span class="pre">ksize</span></code>, <code class="docutils literal"><span class="pre">sigmaX</span></code>, and <code class="docutils literal"><span class="pre">sigmaY</span></code>.</li>
<li><strong>borderType</strong> &#8211; pixel extrapolation method (see  <a class="reference internal" href="#int borderInterpolate(int p, int len, int borderType)" title="int borderInterpolate(int p, int len, int borderType)"><code class="xref ocv ocv-func docutils literal"><span class="pre">borderInterpolate()</span></code></a> for details).</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<p>The function convolves the source image with the specified Gaussian kernel. In-place filtering is supported.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#void sepFilter2D(InputArray src, OutputArray dst, int ddepth, InputArray kernelX, InputArray kernelY, Point anchor, double delta, int borderType)" title="void sepFilter2D(InputArray src, OutputArray dst, int ddepth, InputArray kernelX, InputArray kernelY, Point anchor, double delta, int borderType)"><code class="xref ocv ocv-func docutils literal"><span class="pre">sepFilter2D()</span></code></a>,
<a class="reference internal" href="#void filter2D(InputArray src, OutputArray dst, int ddepth, InputArray kernel, Point anchor, double delta, int borderType)" title="void filter2D(InputArray src, OutputArray dst, int ddepth, InputArray kernel, Point anchor, double delta, int borderType)"><code class="xref ocv ocv-func docutils literal"><span class="pre">filter2D()</span></code></a>,
<a class="reference internal" href="#void blur(InputArray src, OutputArray dst, Size ksize, Point anchor, int borderType)" title="void blur(InputArray src, OutputArray dst, Size ksize, Point anchor, int borderType)"><code class="xref ocv ocv-func docutils literal"><span class="pre">blur()</span></code></a>,
<a class="reference internal" href="#void boxFilter(InputArray src, OutputArray dst, int ddepth, Size ksize, Point anchor, bool normalize, int borderType)" title="void boxFilter(InputArray src, OutputArray dst, int ddepth, Size ksize, Point anchor, bool normalize, int borderType)"><code class="xref ocv ocv-func docutils literal"><span class="pre">boxFilter()</span></code></a>,
<a class="reference internal" href="#void bilateralFilter(InputArray src, OutputArray dst, int d, double sigmaColor, double sigmaSpace, int borderType)" title="void bilateralFilter(InputArray src, OutputArray dst, int d, double sigmaColor, double sigmaSpace, int borderType)"><code class="xref ocv ocv-func docutils literal"><span class="pre">bilateralFilter()</span></code></a>,
<a class="reference internal" href="#void medianBlur(InputArray src, OutputArray dst, int ksize)" title="void medianBlur(InputArray src, OutputArray dst, int ksize)"><code class="xref ocv ocv-func docutils literal"><span class="pre">medianBlur()</span></code></a></p>
</div>
</div>
<div class="section" id="getderivkernels">
<h2>getDerivKernels<a class="headerlink" href="#getderivkernels" title="Permalink to this headline">¶</a></h2>
<p>Returns filter coefficients for computing spatial image derivatives.</p>
<dl class="function">
<dt id="void getDerivKernels(OutputArray kx, OutputArray ky, int dx, int dy, int ksize, bool normalize, int ktype)">
<strong>C++:</strong><code class="descname"> </code>void <code class="descname">getDerivKernels</code><span class="sig-paren">(</span>OutputArray <strong>kx</strong>, OutputArray <strong>ky</strong>, int <strong>dx</strong>, int <strong>dy</strong>, int <strong>ksize</strong>, bool <strong>normalize</strong>=false, int <strong>ktype</strong>=CV_32F <span class="sig-paren">)</span><a class="headerlink" href="#void getDerivKernels(OutputArray kx, OutputArray ky, int dx, int dy, int ksize, bool normalize, int ktype)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="pyfunction">
<dt id="cv2.getDerivKernels">
<strong>Python:</strong><code class="descname"> </code><code class="descclassname">cv2.</code><code class="descname">getDerivKernels</code><span class="sig-paren">(</span>dx, dy, ksize<span class="optional">[</span>, kx<span class="optional">[</span>, ky<span class="optional">[</span>, normalize<span class="optional">[</span>, ktype<span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span> &rarr; kx, ky<a class="headerlink" href="#cv2.getDerivKernels" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>kx</strong> &#8211; Output matrix of row filter coefficients. It has the type  <code class="docutils literal"><span class="pre">ktype</span></code> .</li>
<li><strong>ky</strong> &#8211; Output matrix of column filter coefficients. It has the type  <code class="docutils literal"><span class="pre">ktype</span></code> .</li>
<li><strong>dx</strong> &#8211; Derivative order in respect of x.</li>
<li><strong>dy</strong> &#8211; Derivative order in respect of y.</li>
<li><strong>ksize</strong> &#8211; Aperture size. It can be  <code class="docutils literal"><span class="pre">CV_SCHARR</span></code> , 1, 3, 5, or 7.</li>
<li><strong>normalize</strong> &#8211; Flag indicating whether to normalize (scale down) the filter coefficients or not. Theoretically, the coefficients should have the denominator  <img class="math" src="../../../_images/math/3859d33afdfacde706ae583ac9f6accbeb578480.png" alt="=2^{ksize*2-dx-dy-2}"/> . If you are going to filter floating-point images, you are likely to use the normalized kernels. But if you compute derivatives of an 8-bit image, store the results in a 16-bit image, and wish to preserve all the fractional bits, you may want to set  <code class="docutils literal"><span class="pre">normalize=false</span></code> .</li>
<li><strong>ktype</strong> &#8211; Type of filter coefficients. It can be  <code class="docutils literal"><span class="pre">CV_32f</span></code>  or  <code class="docutils literal"><span class="pre">CV_64F</span></code> .</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<p>The function computes and returns the filter coefficients for spatial image derivatives. When <code class="docutils literal"><span class="pre">ksize=CV_SCHARR</span></code> , the Scharr
<img class="math" src="../../../_images/math/4e17330236365b9188352f6e0aeef470b1f872f1.png" alt="3 \times 3"/> kernels are generated (see
<a class="reference internal" href="#void Scharr(InputArray src, OutputArray dst, int ddepth, int dx, int dy, double scale, double delta, int borderType)" title="void Scharr(InputArray src, OutputArray dst, int ddepth, int dx, int dy, double scale, double delta, int borderType)"><code class="xref ocv ocv-func docutils literal"><span class="pre">Scharr()</span></code></a> ). Otherwise, Sobel kernels are generated (see
<a class="reference internal" href="#void Sobel(InputArray src, OutputArray dst, int ddepth, int dx, int dy, int ksize, double scale, double delta, int borderType)" title="void Sobel(InputArray src, OutputArray dst, int ddepth, int dx, int dy, int ksize, double scale, double delta, int borderType)"><code class="xref ocv ocv-func docutils literal"><span class="pre">Sobel()</span></code></a> ). The filters are normally passed to
<a class="reference internal" href="#void sepFilter2D(InputArray src, OutputArray dst, int ddepth, InputArray kernelX, InputArray kernelY, Point anchor, double delta, int borderType)" title="void sepFilter2D(InputArray src, OutputArray dst, int ddepth, InputArray kernelX, InputArray kernelY, Point anchor, double delta, int borderType)"><code class="xref ocv ocv-func docutils literal"><span class="pre">sepFilter2D()</span></code></a> or to
<a class="reference internal" href="#Ptr&lt;FilterEngine&gt; createSeparableLinearFilter(int srcType, int dstType, InputArray rowKernel, InputArray columnKernel, Point anchor, double delta, int rowBorderType, int columnBorderType, const Scalar&amp; borderValue)" title="Ptr&lt;FilterEngine&gt; createSeparableLinearFilter(int srcType, int dstType, InputArray rowKernel, InputArray columnKernel, Point anchor, double delta, int rowBorderType, int columnBorderType, const Scalar&amp; borderValue)"><code class="xref ocv ocv-func docutils literal"><span class="pre">createSeparableLinearFilter()</span></code></a> .</p>
</div>
<div class="section" id="getgaussiankernel">
<h2>getGaussianKernel<a class="headerlink" href="#getgaussiankernel" title="Permalink to this headline">¶</a></h2>
<p>Returns Gaussian filter coefficients.</p>
<dl class="function">
<dt id="Mat getGaussianKernel(int ksize, double sigma, int ktype)">
<strong>C++:</strong><code class="descname"> </code>Mat <code class="descname">getGaussianKernel</code><span class="sig-paren">(</span>int <strong>ksize</strong>, double <strong>sigma</strong>, int <strong>ktype</strong>=CV_64F <span class="sig-paren">)</span><a class="headerlink" href="#Mat getGaussianKernel(int ksize, double sigma, int ktype)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="pyfunction">
<dt id="cv2.getGaussianKernel">
<strong>Python:</strong><code class="descname"> </code><code class="descclassname">cv2.</code><code class="descname">getGaussianKernel</code><span class="sig-paren">(</span>ksize, sigma<span class="optional">[</span>, ktype<span class="optional">]</span><span class="sig-paren">)</span> &rarr; retval<a class="headerlink" href="#cv2.getGaussianKernel" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>ksize</strong> &#8211; Aperture size. It should be odd ( <img class="math" src="../../../_images/math/4b027e9fcbcdb06caa88be2b4b87449da64f18a9.png" alt="\texttt{ksize} \mod 2 = 1"/> ) and positive.</li>
<li><strong>sigma</strong> &#8211; Gaussian standard deviation. If it is non-positive, it is computed from  <code class="docutils literal"><span class="pre">ksize</span></code>  as  <code class="docutils literal"><span class="pre">sigma</span> <span class="pre">=</span> <span class="pre">0.3*((ksize-1)*0.5</span> <span class="pre">-</span> <span class="pre">1)</span> <span class="pre">+</span> <span class="pre">0.8</span></code> .</li>
<li><strong>ktype</strong> &#8211; Type of filter coefficients. It can be  <code class="docutils literal"><span class="pre">CV_32f</span></code>  or  <code class="docutils literal"><span class="pre">CV_64F</span></code> .</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<p>The function computes and returns the
<img class="math" src="../../../_images/math/e397d80f4caeeba443c6c02d34e343832cae0be6.png" alt="\texttt{ksize} \times 1"/> matrix of Gaussian filter coefficients:</p>
<div class="math">
<p><img src="../../../_images/math/48fbacc43a8fb2aafe76fd0b4fef4ea7ab03a5e2.png" alt="G_i= \alpha *e^{-(i-( \texttt{ksize} -1)/2)^2/(2* \texttt{sigma}^2 )},"/></p>
</div><p>where
<img class="math" src="../../../_images/math/ab3aa65cf4489374ae82b99590a98c3ca4ba973a.png" alt="i=0..\texttt{ksize}-1"/> and
<img class="math" src="../../../_images/math/69777408db155ee0fca9cc9dee60a269df6d1f96.png" alt="\alpha"/> is the scale factor chosen so that
<img class="math" src="../../../_images/math/21c97359cbc0370cd7bffc7fc27eb1b7d37d38aa.png" alt="\sum_i G_i=1"/>.</p>
<p>Two of such generated kernels can be passed to
<a class="reference internal" href="#void sepFilter2D(InputArray src, OutputArray dst, int ddepth, InputArray kernelX, InputArray kernelY, Point anchor, double delta, int borderType)" title="void sepFilter2D(InputArray src, OutputArray dst, int ddepth, InputArray kernelX, InputArray kernelY, Point anchor, double delta, int borderType)"><code class="xref ocv ocv-func docutils literal"><span class="pre">sepFilter2D()</span></code></a> or to
<a class="reference internal" href="#Ptr&lt;FilterEngine&gt; createSeparableLinearFilter(int srcType, int dstType, InputArray rowKernel, InputArray columnKernel, Point anchor, double delta, int rowBorderType, int columnBorderType, const Scalar&amp; borderValue)" title="Ptr&lt;FilterEngine&gt; createSeparableLinearFilter(int srcType, int dstType, InputArray rowKernel, InputArray columnKernel, Point anchor, double delta, int rowBorderType, int columnBorderType, const Scalar&amp; borderValue)"><code class="xref ocv ocv-func docutils literal"><span class="pre">createSeparableLinearFilter()</span></code></a>. Those functions automatically recognize smoothing kernels (a symmetrical kernel with sum of weights equal to 1) and handle them accordingly. You may also use the higher-level
<a class="reference internal" href="#void GaussianBlur(InputArray src, OutputArray dst, Size ksize, double sigmaX, double sigmaY, int borderType)" title="void GaussianBlur(InputArray src, OutputArray dst, Size ksize, double sigmaX, double sigmaY, int borderType)"><code class="xref ocv ocv-func docutils literal"><span class="pre">GaussianBlur()</span></code></a>.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#void sepFilter2D(InputArray src, OutputArray dst, int ddepth, InputArray kernelX, InputArray kernelY, Point anchor, double delta, int borderType)" title="void sepFilter2D(InputArray src, OutputArray dst, int ddepth, InputArray kernelX, InputArray kernelY, Point anchor, double delta, int borderType)"><code class="xref ocv ocv-func docutils literal"><span class="pre">sepFilter2D()</span></code></a>,
<a class="reference internal" href="#Ptr&lt;FilterEngine&gt; createSeparableLinearFilter(int srcType, int dstType, InputArray rowKernel, InputArray columnKernel, Point anchor, double delta, int rowBorderType, int columnBorderType, const Scalar&amp; borderValue)" title="Ptr&lt;FilterEngine&gt; createSeparableLinearFilter(int srcType, int dstType, InputArray rowKernel, InputArray columnKernel, Point anchor, double delta, int rowBorderType, int columnBorderType, const Scalar&amp; borderValue)"><code class="xref ocv ocv-func docutils literal"><span class="pre">createSeparableLinearFilter()</span></code></a>,
<a class="reference internal" href="#void getDerivKernels(OutputArray kx, OutputArray ky, int dx, int dy, int ksize, bool normalize, int ktype)" title="void getDerivKernels(OutputArray kx, OutputArray ky, int dx, int dy, int ksize, bool normalize, int ktype)"><code class="xref ocv ocv-func docutils literal"><span class="pre">getDerivKernels()</span></code></a>,
<a class="reference internal" href="#Mat getStructuringElement(int shape, Size ksize, Point anchor)" title="Mat getStructuringElement(int shape, Size ksize, Point anchor)"><code class="xref ocv ocv-func docutils literal"><span class="pre">getStructuringElement()</span></code></a>,
<a class="reference internal" href="#void GaussianBlur(InputArray src, OutputArray dst, Size ksize, double sigmaX, double sigmaY, int borderType)" title="void GaussianBlur(InputArray src, OutputArray dst, Size ksize, double sigmaX, double sigmaY, int borderType)"><code class="xref ocv ocv-func docutils literal"><span class="pre">GaussianBlur()</span></code></a></p>
</div>
</div>
<div class="section" id="getkerneltype">
<h2>getKernelType<a class="headerlink" href="#getkerneltype" title="Permalink to this headline">¶</a></h2>
<p>Returns the kernel type.</p>
<dl class="function">
<dt id="int getKernelType(InputArray kernel, Point anchor)">
<strong>C++:</strong><code class="descname"> </code>int <code class="descname">getKernelType</code><span class="sig-paren">(</span>InputArray <strong>kernel</strong>, Point <strong>anchor</strong><span class="sig-paren">)</span><a class="headerlink" href="#int getKernelType(InputArray kernel, Point anchor)" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>kernel</strong> &#8211; 1D array of the kernel coefficients to analyze.</li>
<li><strong>anchor</strong> &#8211; Anchor position within the kernel.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<p>The function analyzes the kernel coefficients and returns the corresponding kernel type:</p>
<blockquote>
<div><ul class="simple">
<li><strong>KERNEL_GENERAL</strong> The kernel is generic. It is used when there is no any type of symmetry or other properties.</li>
<li><strong>KERNEL_SYMMETRICAL</strong> The kernel is symmetrical:  <img class="math" src="../../../_images/math/db73c78fd79ce382e097dd82e7964f31d3a7ebe0.png" alt="\texttt{kernel}_i == \texttt{kernel}_{ksize-i-1}"/> , and the anchor is at the center.</li>
<li><strong>KERNEL_ASYMMETRICAL</strong> The kernel is asymmetrical:  <img class="math" src="../../../_images/math/9617f501f25d4910ddc53dd14e11e7db6238ccb1.png" alt="\texttt{kernel}_i == -\texttt{kernel}_{ksize-i-1}"/> , and the anchor is at the center.</li>
<li><strong>KERNEL_SMOOTH</strong> All the kernel elements are non-negative and summed to 1. For example, the Gaussian kernel is both smooth kernel and symmetrical, so the function returns  <code class="docutils literal"><span class="pre">KERNEL_SMOOTH</span> <span class="pre">|</span> <span class="pre">KERNEL_SYMMETRICAL</span></code> .</li>
<li><strong>KERNEL_INTEGER</strong> All the kernel coefficients are integer numbers. This flag can be combined with  <code class="docutils literal"><span class="pre">KERNEL_SYMMETRICAL</span></code>  or  <code class="docutils literal"><span class="pre">KERNEL_ASYMMETRICAL</span></code> .</li>
</ul>
</div></blockquote>
</div>
<div class="section" id="getstructuringelement">
<h2>getStructuringElement<a class="headerlink" href="#getstructuringelement" title="Permalink to this headline">¶</a></h2>
<p>Returns a structuring element of the specified size and shape for morphological operations.</p>
<dl class="function">
<dt id="Mat getStructuringElement(int shape, Size ksize, Point anchor)">
<strong>C++:</strong><code class="descname"> </code>Mat <code class="descname">getStructuringElement</code><span class="sig-paren">(</span>int <strong>shape</strong>, Size <strong>ksize</strong>, Point <strong>anchor</strong>=Point(-1,-1)<span class="sig-paren">)</span><a class="headerlink" href="#Mat getStructuringElement(int shape, Size ksize, Point anchor)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="pyfunction">
<dt id="cv2.getStructuringElement">
<strong>Python:</strong><code class="descname"> </code><code class="descclassname">cv2.</code><code class="descname">getStructuringElement</code><span class="sig-paren">(</span>shape, ksize<span class="optional">[</span>, anchor<span class="optional">]</span><span class="sig-paren">)</span> &rarr; retval<a class="headerlink" href="#cv2.getStructuringElement" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="cfunction">
<dt id="IplConvKernel* cvCreateStructuringElementEx(int cols, int rows, int anchor_x, int anchor_y, int shape, int* values)">
<strong>C:</strong><code class="descname"> </code>IplConvKernel* <code class="descname">cvCreateStructuringElementEx</code><span class="sig-paren">(</span>int <strong>cols</strong>, int <strong>rows</strong>, int <strong>anchor_x</strong>, int <strong>anchor_y</strong>, int <strong>shape</strong>, int* <strong>values</strong>=NULL <span class="sig-paren">)</span><a class="headerlink" href="#IplConvKernel* cvCreateStructuringElementEx(int cols, int rows, int anchor_x, int anchor_y, int shape, int* values)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="pyoldfunction">
<dt id="cv.CreateStructuringElementEx">
<strong>Python:</strong><code class="descname"> </code><code class="descclassname">cv.</code><code class="descname">CreateStructuringElementEx</code><span class="sig-paren">(</span>cols, rows, anchorX, anchorY, shape, values=None<span class="sig-paren">)</span> &rarr; kernel<a class="headerlink" href="#cv.CreateStructuringElementEx" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>shape</strong> &#8211; <p>Element shape that could be one of the following:</p>
<ul>
<li><strong>MORPH_RECT</strong>         - a rectangular structuring element:<div class="math">
<p><img src="../../../_images/math/bff659811a6db2f7ebe1d6e43d49c673c915893a.png" alt="E_{ij}=1"/></p>
</div></li>
<li><strong>MORPH_ELLIPSE</strong>         - an elliptic structuring element, that is, a filled ellipse inscribed into the rectangle <code class="docutils literal"><span class="pre">Rect(0,</span> <span class="pre">0,</span> <span class="pre">esize.width,</span> <span class="pre">0.esize.height)</span></code></li>
<li><strong>MORPH_CROSS</strong>         - a cross-shaped structuring element:<div class="math">
<p><img src="../../../_images/math/e2301d4305fbc75232435d55ad5e5016190683b9.png" alt="E_{ij} =  \fork{1}{if i=\texttt{anchor.y} or j=\texttt{anchor.x}}{0}{otherwise}"/></p>
</div></li>
<li><strong>CV_SHAPE_CUSTOM</strong>     - custom structuring element (OpenCV 1.x API)</li>
</ul>
</li>
<li><strong>ksize</strong> &#8211; Size of the structuring element.</li>
<li><strong>cols</strong> &#8211; Width of the structuring element</li>
<li><strong>rows</strong> &#8211; Height of the structuring element</li>
<li><strong>anchor</strong> &#8211; Anchor position within the element. The default value  <img class="math" src="../../../_images/math/0e9281a579bcfb594eb2779c88afafb2704dc7fc.png" alt="(-1, -1)"/>  means that the anchor is at the center. Note that only the shape of a cross-shaped element depends on the anchor position. In other cases the anchor just regulates how much the result of the morphological operation is shifted.</li>
<li><strong>anchor_x</strong> &#8211; x-coordinate of the anchor</li>
<li><strong>anchor_y</strong> &#8211; y-coordinate of the anchor</li>
<li><strong>values</strong> &#8211; integer array of <code class="docutils literal"><span class="pre">cols``*``rows</span></code> elements that specifies the custom shape of the structuring element, when <code class="docutils literal"><span class="pre">shape=CV_SHAPE_CUSTOM</span></code>.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<p>The function constructs and returns the structuring element that can be further passed to
<a class="reference internal" href="#Ptr&lt;FilterEngine&gt; createMorphologyFilter(int op, int type, InputArray kernel, Point anchor, int rowBorderType, int columnBorderType, const Scalar&amp; borderValue)" title="Ptr&lt;FilterEngine&gt; createMorphologyFilter(int op, int type, InputArray kernel, Point anchor, int rowBorderType, int columnBorderType, const Scalar&amp; borderValue)"><code class="xref ocv ocv-func docutils literal"><span class="pre">createMorphologyFilter()</span></code></a>,
<a class="reference internal" href="#void erode(InputArray src, OutputArray dst, InputArray kernel, Point anchor, int iterations, int borderType, const Scalar&amp; borderValue)" title="void erode(InputArray src, OutputArray dst, InputArray kernel, Point anchor, int iterations, int borderType, const Scalar&amp; borderValue)"><code class="xref ocv ocv-func docutils literal"><span class="pre">erode()</span></code></a>,
<a class="reference internal" href="#void dilate(InputArray src, OutputArray dst, InputArray kernel, Point anchor, int iterations, int borderType, const Scalar&amp; borderValue)" title="void dilate(InputArray src, OutputArray dst, InputArray kernel, Point anchor, int iterations, int borderType, const Scalar&amp; borderValue)"><code class="xref ocv ocv-func docutils literal"><span class="pre">dilate()</span></code></a> or
<a class="reference internal" href="#void morphologyEx(InputArray src, OutputArray dst, int op, InputArray kernel, Point anchor, int iterations, int borderType, const Scalar&amp; borderValue)" title="void morphologyEx(InputArray src, OutputArray dst, int op, InputArray kernel, Point anchor, int iterations, int borderType, const Scalar&amp; borderValue)"><code class="xref ocv ocv-func docutils literal"><span class="pre">morphologyEx()</span></code></a> . But you can also construct an arbitrary binary mask yourself and use it as the structuring element.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">When using OpenCV 1.x C API, the created structuring element <code class="docutils literal"><span class="pre">IplConvKernel*</span> <span class="pre">element</span></code> must be released in the end using <code class="docutils literal"><span class="pre">cvReleaseStructuringElement(&amp;element)</span></code>.</p>
</div>
</div>
<div class="section" id="medianblur">
<h2>medianBlur<a class="headerlink" href="#medianblur" title="Permalink to this headline">¶</a></h2>
<p>Blurs an image using the median filter.</p>
<dl class="function">
<dt id="void medianBlur(InputArray src, OutputArray dst, int ksize)">
<strong>C++:</strong><code class="descname"> </code>void <code class="descname">medianBlur</code><span class="sig-paren">(</span>InputArray <strong>src</strong>, OutputArray <strong>dst</strong>, int <strong>ksize</strong><span class="sig-paren">)</span><a class="headerlink" href="#void medianBlur(InputArray src, OutputArray dst, int ksize)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="pyfunction">
<dt id="cv2.medianBlur">
<strong>Python:</strong><code class="descname"> </code><code class="descclassname">cv2.</code><code class="descname">medianBlur</code><span class="sig-paren">(</span>src, ksize<span class="optional">[</span>, dst<span class="optional">]</span><span class="sig-paren">)</span> &rarr; dst<a class="headerlink" href="#cv2.medianBlur" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>src</strong> &#8211; input 1-, 3-, or 4-channel image; when  <code class="docutils literal"><span class="pre">ksize</span></code>  is 3 or 5, the image depth should be <code class="docutils literal"><span class="pre">CV_8U</span></code>, <code class="docutils literal"><span class="pre">CV_16U</span></code>, or <code class="docutils literal"><span class="pre">CV_32F</span></code>, for larger aperture sizes, it can only be <code class="docutils literal"><span class="pre">CV_8U</span></code>.</li>
<li><strong>dst</strong> &#8211; destination array of the same size and type as <code class="docutils literal"><span class="pre">src</span></code>.</li>
<li><strong>ksize</strong> &#8211; aperture linear size; it must be odd and greater than 1, for example: 3, 5, 7 ...</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<p>The function smoothes an image using the median filter with the
<img class="math" src="../../../_images/math/9c389d9c70bc7f05f5956fcdd9548afb8453d497.png" alt="\texttt{ksize} \times \texttt{ksize}"/> aperture. Each channel of a multi-channel image is processed independently. In-place operation is supported.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#void bilateralFilter(InputArray src, OutputArray dst, int d, double sigmaColor, double sigmaSpace, int borderType)" title="void bilateralFilter(InputArray src, OutputArray dst, int d, double sigmaColor, double sigmaSpace, int borderType)"><code class="xref ocv ocv-func docutils literal"><span class="pre">bilateralFilter()</span></code></a>,
<a class="reference internal" href="#void blur(InputArray src, OutputArray dst, Size ksize, Point anchor, int borderType)" title="void blur(InputArray src, OutputArray dst, Size ksize, Point anchor, int borderType)"><code class="xref ocv ocv-func docutils literal"><span class="pre">blur()</span></code></a>,
<a class="reference internal" href="#void boxFilter(InputArray src, OutputArray dst, int ddepth, Size ksize, Point anchor, bool normalize, int borderType)" title="void boxFilter(InputArray src, OutputArray dst, int ddepth, Size ksize, Point anchor, bool normalize, int borderType)"><code class="xref ocv ocv-func docutils literal"><span class="pre">boxFilter()</span></code></a>,
<a class="reference internal" href="#void GaussianBlur(InputArray src, OutputArray dst, Size ksize, double sigmaX, double sigmaY, int borderType)" title="void GaussianBlur(InputArray src, OutputArray dst, Size ksize, double sigmaX, double sigmaY, int borderType)"><code class="xref ocv ocv-func docutils literal"><span class="pre">GaussianBlur()</span></code></a></p>
</div>
</div>
<div class="section" id="morphologyex">
<h2>morphologyEx<a class="headerlink" href="#morphologyex" title="Permalink to this headline">¶</a></h2>
<p>Performs advanced morphological transformations.</p>
<dl class="function">
<dt id="void morphologyEx(InputArray src, OutputArray dst, int op, InputArray kernel, Point anchor, int iterations, int borderType, const Scalar&amp; borderValue)">
<strong>C++:</strong><code class="descname"> </code>void <code class="descname">morphologyEx</code><span class="sig-paren">(</span>InputArray <strong>src</strong>, OutputArray <strong>dst</strong>, int <strong>op</strong>, InputArray <strong>kernel</strong>, Point <strong>anchor</strong>=Point(-1,-1), int <strong>iterations</strong>=1, int <strong>borderType</strong>=BORDER_CONSTANT, const Scalar&amp; <strong>borderValue</strong>=morphologyDefaultBorderValue() <span class="sig-paren">)</span><a class="headerlink" href="#void morphologyEx(InputArray src, OutputArray dst, int op, InputArray kernel, Point anchor, int iterations, int borderType, const Scalar& borderValue)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="pyfunction">
<dt id="cv2.morphologyEx">
<strong>Python:</strong><code class="descname"> </code><code class="descclassname">cv2.</code><code class="descname">morphologyEx</code><span class="sig-paren">(</span>src, op, kernel<span class="optional">[</span>, dst<span class="optional">[</span>, anchor<span class="optional">[</span>, iterations<span class="optional">[</span>, borderType<span class="optional">[</span>, borderValue<span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span> &rarr; dst<a class="headerlink" href="#cv2.morphologyEx" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="cfunction">
<dt id="void cvMorphologyEx(const CvArr* src, CvArr* dst, CvArr* temp, IplConvKernel* element, int operation, int iterations)">
<strong>C:</strong><code class="descname"> </code>void <code class="descname">cvMorphologyEx</code><span class="sig-paren">(</span>const CvArr* <strong>src</strong>, CvArr* <strong>dst</strong>, CvArr* <strong>temp</strong>, IplConvKernel* <strong>element</strong>, int <strong>operation</strong>, int <strong>iterations</strong>=1 <span class="sig-paren">)</span><a class="headerlink" href="#void cvMorphologyEx(const CvArr* src, CvArr* dst, CvArr* temp, IplConvKernel* element, int operation, int iterations)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="pyoldfunction">
<dt id="cv.MorphologyEx">
<strong>Python:</strong><code class="descname"> </code><code class="descclassname">cv.</code><code class="descname">MorphologyEx</code><span class="sig-paren">(</span>src, dst, temp, element, operation, iterations=1<span class="sig-paren">)</span> &rarr; None<a class="headerlink" href="#cv.MorphologyEx" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>src</strong> &#8211; Source image. The number of channels can be arbitrary. The depth should be one of <code class="docutils literal"><span class="pre">CV_8U</span></code>, <code class="docutils literal"><span class="pre">CV_16U</span></code>, <code class="docutils literal"><span class="pre">CV_16S</span></code>,  <code class="docutils literal"><span class="pre">CV_32F</span></code> or <code class="docutils literal"><span class="pre">CV_64F</span></code>.</li>
<li><strong>dst</strong> &#8211; Destination image of the same size and type as  <code class="docutils literal"><span class="pre">src</span></code> .</li>
<li><strong>element</strong> &#8211; Structuring element.</li>
<li><strong>op</strong> &#8211; <p>Type of a morphological operation that can be one of the following:</p>
<ul>
<li><strong>MORPH_OPEN</strong> - an opening operation</li>
<li><strong>MORPH_CLOSE</strong> - a closing operation</li>
<li><strong>MORPH_GRADIENT</strong> - a morphological gradient</li>
<li><strong>MORPH_TOPHAT</strong> - &#8220;top hat&#8221;</li>
<li><strong>MORPH_BLACKHAT</strong> - &#8220;black hat&#8221;</li>
<li><strong>MORPH_HITMISS</strong> - &#8220;hit and miss&#8221;</li>
</ul>
</li>
<li><strong>iterations</strong> &#8211; Number of times erosion and dilation are applied.</li>
<li><strong>borderType</strong> &#8211; Pixel extrapolation method. See  <a class="reference internal" href="#int borderInterpolate(int p, int len, int borderType)" title="int borderInterpolate(int p, int len, int borderType)"><code class="xref ocv ocv-func docutils literal"><span class="pre">borderInterpolate()</span></code></a> for details.</li>
<li><strong>borderValue</strong> &#8211; Border value in case of a constant border. The default value has a special meaning. See  <a class="reference internal" href="#Ptr&lt;FilterEngine&gt; createMorphologyFilter(int op, int type, InputArray kernel, Point anchor, int rowBorderType, int columnBorderType, const Scalar&amp; borderValue)" title="Ptr&lt;FilterEngine&gt; createMorphologyFilter(int op, int type, InputArray kernel, Point anchor, int rowBorderType, int columnBorderType, const Scalar&amp; borderValue)"><code class="xref ocv ocv-func docutils literal"><span class="pre">createMorphologyFilter()</span></code></a> for details.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<p>The function can perform advanced morphological transformations using an erosion and dilation as basic operations.</p>
<p>Opening operation:</p>
<div class="math">
<p><img src="../../../_images/math/28abab30a249515f8d3adc12827c17dbabc8954b.png" alt="\texttt{dst} = \mathrm{open} ( \texttt{src} , \texttt{element} )= \mathrm{dilate} ( \mathrm{erode} ( \texttt{src} , \texttt{element} ))"/></p>
</div><p>Closing operation:</p>
<div class="math">
<p><img src="../../../_images/math/2d859333d4b0bdfe8ef8b2655b1212ffcbf37be2.png" alt="\texttt{dst} = \mathrm{close} ( \texttt{src} , \texttt{element} )= \mathrm{erode} ( \mathrm{dilate} ( \texttt{src} , \texttt{element} ))"/></p>
</div><p>Morphological gradient:</p>
<div class="math">
<p><img src="../../../_images/math/ac94d7b594ef0528571597b0bf1f9f3c401b994b.png" alt="\texttt{dst} = \mathrm{morph\_grad} ( \texttt{src} , \texttt{element} )= \mathrm{dilate} ( \texttt{src} , \texttt{element} )- \mathrm{erode} ( \texttt{src} , \texttt{element} )"/></p>
</div><p>&#8220;Top hat&#8221;:</p>
<div class="math">
<p><img src="../../../_images/math/d269e3587e4d6dfc70fcedab8c32c24144fbf037.png" alt="\texttt{dst} = \mathrm{tophat} ( \texttt{src} , \texttt{element} )= \texttt{src} - \mathrm{open} ( \texttt{src} , \texttt{element} )"/></p>
</div><p>&#8220;Black hat&#8221;:</p>
<div class="math">
<p><img src="../../../_images/math/dbe528ca1d36b71bac05626f7a53f6acae725323.png" alt="\texttt{dst} = \mathrm{blackhat} ( \texttt{src} , \texttt{element} )= \mathrm{close} ( \texttt{src} , \texttt{element} )- \texttt{src}"/></p>
</div><p>&#8220;Hit and Miss&#8221;: Only supported for CV_8UC1 binary images. Tutorial can be found in this page: <a class="reference external" href="https://web.archive.org/web/20160316070407/http://opencv-code.com/tutorials/hit-or-miss-transform-in-opencv/">https://web.archive.org/web/20160316070407/http://opencv-code.com/tutorials/hit-or-miss-transform-in-opencv/</a></p>
<p>Any of the operations can be done in-place. In case of multi-channel images, each channel is processed independently.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#void dilate(InputArray src, OutputArray dst, InputArray kernel, Point anchor, int iterations, int borderType, const Scalar&amp; borderValue)" title="void dilate(InputArray src, OutputArray dst, InputArray kernel, Point anchor, int iterations, int borderType, const Scalar&amp; borderValue)"><code class="xref ocv ocv-func docutils literal"><span class="pre">dilate()</span></code></a>,
<a class="reference internal" href="#void erode(InputArray src, OutputArray dst, InputArray kernel, Point anchor, int iterations, int borderType, const Scalar&amp; borderValue)" title="void erode(InputArray src, OutputArray dst, InputArray kernel, Point anchor, int iterations, int borderType, const Scalar&amp; borderValue)"><code class="xref ocv ocv-func docutils literal"><span class="pre">erode()</span></code></a>,
<a class="reference internal" href="#Ptr&lt;FilterEngine&gt; createMorphologyFilter(int op, int type, InputArray kernel, Point anchor, int rowBorderType, int columnBorderType, const Scalar&amp; borderValue)" title="Ptr&lt;FilterEngine&gt; createMorphologyFilter(int op, int type, InputArray kernel, Point anchor, int rowBorderType, int columnBorderType, const Scalar&amp; borderValue)"><code class="xref ocv ocv-func docutils literal"><span class="pre">createMorphologyFilter()</span></code></a></p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<ul class="last simple">
<li>An example using the morphologyEx function for the morphological opening and closing operations can be found at opencv_source_code/samples/cpp/morphology2.cpp</li>
</ul>
</div>
</div>
<div class="section" id="laplacian">
<h2>Laplacian<a class="headerlink" href="#laplacian" title="Permalink to this headline">¶</a></h2>
<p>Calculates the Laplacian of an image.</p>
<dl class="function">
<dt id="void Laplacian(InputArray src, OutputArray dst, int ddepth, int ksize, double scale, double delta, int borderType)">
<strong>C++:</strong><code class="descname"> </code>void <code class="descname">Laplacian</code><span class="sig-paren">(</span>InputArray <strong>src</strong>, OutputArray <strong>dst</strong>, int <strong>ddepth</strong>, int <strong>ksize</strong>=1, double <strong>scale</strong>=1, double <strong>delta</strong>=0, int <strong>borderType</strong>=BORDER_DEFAULT <span class="sig-paren">)</span><a class="headerlink" href="#void Laplacian(InputArray src, OutputArray dst, int ddepth, int ksize, double scale, double delta, int borderType)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="pyfunction">
<dt id="cv2.Laplacian">
<strong>Python:</strong><code class="descname"> </code><code class="descclassname">cv2.</code><code class="descname">Laplacian</code><span class="sig-paren">(</span>src, ddepth<span class="optional">[</span>, dst<span class="optional">[</span>, ksize<span class="optional">[</span>, scale<span class="optional">[</span>, delta<span class="optional">[</span>, borderType<span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span> &rarr; dst<a class="headerlink" href="#cv2.Laplacian" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="cfunction">
<dt id="void cvLaplace(const CvArr* src, CvArr* dst, int aperture_size)">
<strong>C:</strong><code class="descname"> </code>void <code class="descname">cvLaplace</code><span class="sig-paren">(</span>const CvArr* <strong>src</strong>, CvArr* <strong>dst</strong>, int <strong>aperture_size</strong>=3 <span class="sig-paren">)</span><a class="headerlink" href="#void cvLaplace(const CvArr* src, CvArr* dst, int aperture_size)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="pyoldfunction">
<dt id="cv.Laplace">
<strong>Python:</strong><code class="descname"> </code><code class="descclassname">cv.</code><code class="descname">Laplace</code><span class="sig-paren">(</span>src, dst, apertureSize=3<span class="sig-paren">)</span> &rarr; None<a class="headerlink" href="#cv.Laplace" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>src</strong> &#8211; Source image.</li>
<li><strong>dst</strong> &#8211; Destination image of the same size and the same number of channels as  <code class="docutils literal"><span class="pre">src</span></code> .</li>
<li><strong>ddepth</strong> &#8211; Desired depth of the destination image.</li>
<li><strong>ksize</strong> &#8211; Aperture size used to compute the second-derivative filters. See  <a class="reference internal" href="#void getDerivKernels(OutputArray kx, OutputArray ky, int dx, int dy, int ksize, bool normalize, int ktype)" title="void getDerivKernels(OutputArray kx, OutputArray ky, int dx, int dy, int ksize, bool normalize, int ktype)"><code class="xref ocv ocv-func docutils literal"><span class="pre">getDerivKernels()</span></code></a> for details. The size must be positive and odd.</li>
<li><strong>scale</strong> &#8211; Optional scale factor for the computed Laplacian values. By default, no scaling is applied. See  <a class="reference internal" href="#void getDerivKernels(OutputArray kx, OutputArray ky, int dx, int dy, int ksize, bool normalize, int ktype)" title="void getDerivKernels(OutputArray kx, OutputArray ky, int dx, int dy, int ksize, bool normalize, int ktype)"><code class="xref ocv ocv-func docutils literal"><span class="pre">getDerivKernels()</span></code></a> for details.</li>
<li><strong>delta</strong> &#8211; Optional delta value that is added to the results prior to storing them in  <code class="docutils literal"><span class="pre">dst</span></code> .</li>
<li><strong>borderType</strong> &#8211; Pixel extrapolation method. See  <a class="reference internal" href="#int borderInterpolate(int p, int len, int borderType)" title="int borderInterpolate(int p, int len, int borderType)"><code class="xref ocv ocv-func docutils literal"><span class="pre">borderInterpolate()</span></code></a> for details.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<p>The function calculates the Laplacian of the source image by adding up the second x and y derivatives calculated using the Sobel operator:</p>
<div class="math">
<p><img src="../../../_images/math/db37f7e4af1f7d8446b820f9d37bcfb89492d752.png" alt="\texttt{dst} =  \Delta \texttt{src} =  \frac{\partial^2 \texttt{src}}{\partial x^2} +  \frac{\partial^2 \texttt{src}}{\partial y^2}"/></p>
</div><p>This is done when <code class="docutils literal"><span class="pre">ksize</span> <span class="pre">&gt;</span> <span class="pre">1</span></code> . When <code class="docutils literal"><span class="pre">ksize</span> <span class="pre">==</span> <span class="pre">1</span></code> , the Laplacian is computed by filtering the image with the following
<img class="math" src="../../../_images/math/4e17330236365b9188352f6e0aeef470b1f872f1.png" alt="3 \times 3"/> aperture:</p>
<div class="math">
<p><img src="../../../_images/math/d3052236b5720d37daedb53f56ffc43e6bcf8d20.png" alt="\vecthreethree {0}{1}{0}{1}{-4}{1}{0}{1}{0}"/></p>
</div><div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#void Sobel(InputArray src, OutputArray dst, int ddepth, int dx, int dy, int ksize, double scale, double delta, int borderType)" title="void Sobel(InputArray src, OutputArray dst, int ddepth, int dx, int dy, int ksize, double scale, double delta, int borderType)"><code class="xref ocv ocv-func docutils literal"><span class="pre">Sobel()</span></code></a>,
<a class="reference internal" href="#void Scharr(InputArray src, OutputArray dst, int ddepth, int dx, int dy, double scale, double delta, int borderType)" title="void Scharr(InputArray src, OutputArray dst, int ddepth, int dx, int dy, double scale, double delta, int borderType)"><code class="xref ocv ocv-func docutils literal"><span class="pre">Scharr()</span></code></a></p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<ul class="last simple">
<li>An example using the Laplace transformation for edge detection can be found at opencv_source_code/samples/cpp/laplace.cpp</li>
</ul>
</div>
</div>
<div class="section" id="pyrdown">
<h2>pyrDown<a class="headerlink" href="#pyrdown" title="Permalink to this headline">¶</a></h2>
<p>Blurs an image and downsamples it.</p>
<dl class="function">
<dt id="void pyrDown(InputArray src, OutputArray dst, const Size&amp; dstsize, int borderType)">
<strong>C++:</strong><code class="descname"> </code>void <code class="descname">pyrDown</code><span class="sig-paren">(</span>InputArray <strong>src</strong>, OutputArray <strong>dst</strong>, const Size&amp; <strong>dstsize</strong>=Size(), int <strong>borderType</strong>=BORDER_DEFAULT <span class="sig-paren">)</span><a class="headerlink" href="#void pyrDown(InputArray src, OutputArray dst, const Size& dstsize, int borderType)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="pyfunction">
<dt id="cv2.pyrDown">
<strong>Python:</strong><code class="descname"> </code><code class="descclassname">cv2.</code><code class="descname">pyrDown</code><span class="sig-paren">(</span>src<span class="optional">[</span>, dst<span class="optional">[</span>, dstsize<span class="optional">[</span>, borderType<span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span> &rarr; dst<a class="headerlink" href="#cv2.pyrDown" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="cfunction">
<dt id="void cvPyrDown(const CvArr* src, CvArr* dst, int filter)">
<strong>C:</strong><code class="descname"> </code>void <code class="descname">cvPyrDown</code><span class="sig-paren">(</span>const CvArr* <strong>src</strong>, CvArr* <strong>dst</strong>, int <strong>filter</strong>=CV_GAUSSIAN_5x5 <span class="sig-paren">)</span><a class="headerlink" href="#void cvPyrDown(const CvArr* src, CvArr* dst, int filter)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="pyoldfunction">
<dt id="cv.PyrDown">
<strong>Python:</strong><code class="descname"> </code><code class="descclassname">cv.</code><code class="descname">PyrDown</code><span class="sig-paren">(</span>src, dst, filter=CV_GAUSSIAN_5X5<span class="sig-paren">)</span> &rarr; None<a class="headerlink" href="#cv.PyrDown" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>src</strong> &#8211; input image.</li>
<li><strong>dst</strong> &#8211; output image; it has the specified size and the same type as <code class="docutils literal"><span class="pre">src</span></code>.</li>
<li><strong>dstsize</strong> &#8211; size of the output image.</li>
<li><strong>borderType</strong> &#8211; Pixel extrapolation method (BORDER_CONSTANT don&#8217;t supported). See  <a class="reference internal" href="#int borderInterpolate(int p, int len, int borderType)" title="int borderInterpolate(int p, int len, int borderType)"><code class="xref ocv ocv-func docutils literal"><span class="pre">borderInterpolate()</span></code></a> for details.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<p>By default, size of the output image is computed as <code class="docutils literal"><span class="pre">Size((src.cols+1)/2,</span> <span class="pre">(src.rows+1)/2)</span></code>, but in any case, the following conditions should be satisfied:</p>
<div class="math">
<p><img src="../../../_images/math/b03379470ebe836184e7109946e128802a32a588.png" alt="\begin{array}{l}
| \texttt{dstsize.width} *2-src.cols| \leq  2  \\ | \texttt{dstsize.height} *2-src.rows| \leq  2 \end{array}"/></p>
</div><p>The function performs the downsampling step of the Gaussian pyramid construction. First, it convolves the source image with the kernel:</p>
<div class="math">
<p><img src="../../../_images/math/9c3bdf1fb1ce550df9322554b0848bc7959176fa.png" alt="\frac{1}{256} \begin{bmatrix} 1 &amp; 4 &amp; 6 &amp; 4 &amp; 1  \\ 4 &amp; 16 &amp; 24 &amp; 16 &amp; 4  \\ 6 &amp; 24 &amp; 36 &amp; 24 &amp; 6  \\ 4 &amp; 16 &amp; 24 &amp; 16 &amp; 4  \\ 1 &amp; 4 &amp; 6 &amp; 4 &amp; 1 \end{bmatrix}"/></p>
</div><p>Then, it downsamples the image by rejecting even rows and columns.</p>
</div>
<div class="section" id="pyrup">
<h2>pyrUp<a class="headerlink" href="#pyrup" title="Permalink to this headline">¶</a></h2>
<p>Upsamples an image and then blurs it.</p>
<dl class="function">
<dt id="void pyrUp(InputArray src, OutputArray dst, const Size&amp; dstsize, int borderType)">
<strong>C++:</strong><code class="descname"> </code>void <code class="descname">pyrUp</code><span class="sig-paren">(</span>InputArray <strong>src</strong>, OutputArray <strong>dst</strong>, const Size&amp; <strong>dstsize</strong>=Size(), int <strong>borderType</strong>=BORDER_DEFAULT <span class="sig-paren">)</span><a class="headerlink" href="#void pyrUp(InputArray src, OutputArray dst, const Size& dstsize, int borderType)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="pyfunction">
<dt id="cv2.pyrUp">
<strong>Python:</strong><code class="descname"> </code><code class="descclassname">cv2.</code><code class="descname">pyrUp</code><span class="sig-paren">(</span>src<span class="optional">[</span>, dst<span class="optional">[</span>, dstsize<span class="optional">[</span>, borderType<span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span> &rarr; dst<a class="headerlink" href="#cv2.pyrUp" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="cfunction">
<dt id="cvPyrUp(const CvArr* src, CvArr* dst, int filter)">
<strong>C:</strong><code class="descname"> </code> <code class="descname">cvPyrUp</code><span class="sig-paren">(</span>const CvArr* <strong>src</strong>, CvArr* <strong>dst</strong>, int <strong>filter</strong>=CV_GAUSSIAN_5x5 <span class="sig-paren">)</span><a class="headerlink" href="#cvPyrUp(const CvArr* src, CvArr* dst, int filter)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="pyoldfunction">
<dt id="cv.PyrUp">
<strong>Python:</strong><code class="descname"> </code><code class="descclassname">cv.</code><code class="descname">PyrUp</code><span class="sig-paren">(</span>src, dst, filter=CV_GAUSSIAN_5X5<span class="sig-paren">)</span> &rarr; None<a class="headerlink" href="#cv.PyrUp" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>src</strong> &#8211; input image.</li>
<li><strong>dst</strong> &#8211; output image. It has the specified size and the same type as  <code class="docutils literal"><span class="pre">src</span></code> .</li>
<li><strong>dstsize</strong> &#8211; size of the output image.</li>
<li><strong>borderType</strong> &#8211; Pixel extrapolation method (only BORDER_DEFAULT supported). See  <a class="reference internal" href="#int borderInterpolate(int p, int len, int borderType)" title="int borderInterpolate(int p, int len, int borderType)"><code class="xref ocv ocv-func docutils literal"><span class="pre">borderInterpolate()</span></code></a> for details.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<p>By default, size of the output image is computed as <code class="docutils literal"><span class="pre">Size(src.cols*2,</span> <span class="pre">(src.rows*2)</span></code>, but in any case, the following conditions should be satisfied:</p>
<div class="math">
<p><img src="../../../_images/math/16f91de19db68d552701d635e5e45a66ea512f59.png" alt="\begin{array}{l}
| \texttt{dstsize.width} -src.cols*2| \leq  ( \texttt{dstsize.width}   \mod  2)  \\ | \texttt{dstsize.height} -src.rows*2| \leq  ( \texttt{dstsize.height}   \mod  2) \end{array}"/></p>
</div><p>The function performs the upsampling step of the Gaussian pyramid construction, though it can actually be used to construct the Laplacian pyramid. First, it upsamples the source image by injecting even zero rows and columns and then convolves the result with the same kernel as in
<a class="reference internal" href="#void pyrDown(InputArray src, OutputArray dst, const Size&amp; dstsize, int borderType)" title="void pyrDown(InputArray src, OutputArray dst, const Size&amp; dstsize, int borderType)"><code class="xref ocv ocv-func docutils literal"><span class="pre">pyrDown()</span></code></a>  multiplied by 4.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<ul class="last simple">
<li>(Python) An example of Laplacian Pyramid construction and merging can be found at opencv_source_code/samples/python2/lappyr.py</li>
</ul>
</div>
</div>
<div class="section" id="pyrmeanshiftfiltering">
<h2>pyrMeanShiftFiltering<a class="headerlink" href="#pyrmeanshiftfiltering" title="Permalink to this headline">¶</a></h2>
<p>Performs initial step of meanshift segmentation of an image.</p>
<dl class="function">
<dt id="void pyrMeanShiftFiltering(InputArray src, OutputArray dst, double sp, double sr, int maxLevel, TermCriteria termcrit)">
<strong>C++:</strong><code class="descname"> </code>void <code class="descname">pyrMeanShiftFiltering</code><span class="sig-paren">(</span>InputArray <strong>src</strong>, OutputArray <strong>dst</strong>, double <strong>sp</strong>, double <strong>sr</strong>, int <strong>maxLevel</strong>=1, TermCriteria <strong>termcrit</strong>=TermCriteria( TermCriteria::MAX_ITER+TermCriteria::EPS,5,1) <span class="sig-paren">)</span><a class="headerlink" href="#void pyrMeanShiftFiltering(InputArray src, OutputArray dst, double sp, double sr, int maxLevel, TermCriteria termcrit)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="pyfunction">
<dt id="cv2.pyrMeanShiftFiltering">
<strong>Python:</strong><code class="descname"> </code><code class="descclassname">cv2.</code><code class="descname">pyrMeanShiftFiltering</code><span class="sig-paren">(</span>src, sp, sr<span class="optional">[</span>, dst<span class="optional">[</span>, maxLevel<span class="optional">[</span>, termcrit<span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span> &rarr; dst<a class="headerlink" href="#cv2.pyrMeanShiftFiltering" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="cfunction">
<dt id="void cvPyrMeanShiftFiltering(const CvArr* src, CvArr* dst, double sp, double sr, int max_level, CvTermCriteria termcrit)">
<strong>C:</strong><code class="descname"> </code>void <code class="descname">cvPyrMeanShiftFiltering</code><span class="sig-paren">(</span>const CvArr* <strong>src</strong>, CvArr* <strong>dst</strong>, double <strong>sp</strong>, double <strong>sr</strong>, int <strong>max_level</strong>=1, CvTermCriteria <strong>termcrit</strong>=cvTermCriteria(CV_TERMCRIT_ITER+CV_TERMCRIT_EPS,5,1)<span class="sig-paren">)</span><a class="headerlink" href="#void cvPyrMeanShiftFiltering(const CvArr* src, CvArr* dst, double sp, double sr, int max_level, CvTermCriteria termcrit)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="pyoldfunction">
<dt id="cv.PyrMeanShiftFiltering">
<strong>Python:</strong><code class="descname"> </code><code class="descclassname">cv.</code><code class="descname">PyrMeanShiftFiltering</code><span class="sig-paren">(</span>src, dst, sp, sr, max_level=1, termcrit=(CV_TERMCRIT_ITER+CV_TERMCRIT_EPS, 5, 1)<span class="sig-paren">)</span> &rarr; None<a class="headerlink" href="#cv.PyrMeanShiftFiltering" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>src</strong> &#8211; The source 8-bit, 3-channel image.</li>
<li><strong>dst</strong> &#8211; The destination image of the same format and the same size as the source.</li>
<li><strong>sp</strong> &#8211; The spatial window radius.</li>
<li><strong>sr</strong> &#8211; The color window radius.</li>
<li><strong>maxLevel</strong> &#8211; Maximum level of the pyramid for the segmentation.</li>
<li><strong>termcrit</strong> &#8211; Termination criteria: when to stop meanshift iterations.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<p>The function implements the filtering stage of meanshift segmentation, that is, the output of the function is the filtered &#8220;posterized&#8221; image with color gradients and fine-grain texture flattened. At every pixel
<code class="docutils literal"><span class="pre">(X,Y)</span></code> of the input image (or down-sized input image, see below) the function executes meanshift
iterations, that is, the pixel <code class="docutils literal"><span class="pre">(X,Y)</span></code> neighborhood in the joint space-color hyperspace is considered:</p>
<blockquote>
<div><div class="math">
<p><img src="../../../_images/math/9f25ab3ee4c8efa38a33f2ccc22b4a483da734b5.png" alt="(x,y): X- \texttt{sp} \le x  \le X+ \texttt{sp} , Y- \texttt{sp} \le y  \le Y+ \texttt{sp} , ||(R,G,B)-(r,g,b)||   \le \texttt{sr}"/></p>
</div></div></blockquote>
<p>where  <code class="docutils literal"><span class="pre">(R,G,B)</span></code> and  <code class="docutils literal"><span class="pre">(r,g,b)</span></code> are the vectors of color components at <code class="docutils literal"><span class="pre">(X,Y)</span></code> and  <code class="docutils literal"><span class="pre">(x,y)</span></code>, respectively (though, the algorithm does not depend on the color space used, so any 3-component color space can be used instead). Over the neighborhood the average spatial value  <code class="docutils literal"><span class="pre">(X',Y')</span></code> and average color vector  <code class="docutils literal"><span class="pre">(R',G',B')</span></code> are found and they act as the neighborhood center on the next iteration:</p>
<blockquote>
<div><div class="math">
<p><img src="../../../_images/math/9cf68a648676f2927a76e818ddd2f563f662cf22.png" alt="(X,Y)~(X',Y'), (R,G,B)~(R',G',B')."/></p>
</div></div></blockquote>
<p>After the iterations over, the color components of the initial pixel (that is, the pixel from where the iterations started) are set to the final value (average color at the last iteration):</p>
<blockquote>
<div><div class="math">
<p><img src="../../../_images/math/1ed3933179d02d3a96282cde1c3e5d228f2806a7.png" alt="I(X,Y) &lt;- (R*,G*,B*)"/></p>
</div></div></blockquote>
<p>When <code class="docutils literal"><span class="pre">maxLevel</span> <span class="pre">&gt;</span> <span class="pre">0</span></code>, the gaussian pyramid of <code class="docutils literal"><span class="pre">maxLevel+1</span></code> levels is built, and the above procedure is run on the smallest layer first. After that, the results are propagated to the larger layer and the iterations are run again only on those pixels where the layer colors differ by more than <code class="docutils literal"><span class="pre">sr</span></code> from the lower-resolution layer of the pyramid. That makes boundaries of color regions sharper. Note that the results will be actually different from the ones obtained by running the meanshift procedure on the whole original image (i.e. when <code class="docutils literal"><span class="pre">maxLevel==0</span></code>).</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<ul class="last simple">
<li>An example using mean-shift image segmentation can be found at opencv_source_code/samples/cpp/meanshift_segmentation.cpp</li>
</ul>
</div>
</div>
<div class="section" id="sepfilter2d">
<h2>sepFilter2D<a class="headerlink" href="#sepfilter2d" title="Permalink to this headline">¶</a></h2>
<p>Applies a separable linear filter to an image.</p>
<dl class="function">
<dt id="void sepFilter2D(InputArray src, OutputArray dst, int ddepth, InputArray kernelX, InputArray kernelY, Point anchor, double delta, int borderType)">
<strong>C++:</strong><code class="descname"> </code>void <code class="descname">sepFilter2D</code><span class="sig-paren">(</span>InputArray <strong>src</strong>, OutputArray <strong>dst</strong>, int <strong>ddepth</strong>, InputArray <strong>kernelX</strong>, InputArray <strong>kernelY</strong>, Point <strong>anchor</strong>=Point(-1,-1), double <strong>delta</strong>=0, int <strong>borderType</strong>=BORDER_DEFAULT <span class="sig-paren">)</span><a class="headerlink" href="#void sepFilter2D(InputArray src, OutputArray dst, int ddepth, InputArray kernelX, InputArray kernelY, Point anchor, double delta, int borderType)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="pyfunction">
<dt id="cv2.sepFilter2D">
<strong>Python:</strong><code class="descname"> </code><code class="descclassname">cv2.</code><code class="descname">sepFilter2D</code><span class="sig-paren">(</span>src, ddepth, kernelX, kernelY<span class="optional">[</span>, dst<span class="optional">[</span>, anchor<span class="optional">[</span>, delta<span class="optional">[</span>, borderType<span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span> &rarr; dst<a class="headerlink" href="#cv2.sepFilter2D" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>src</strong> &#8211; Source image.</li>
<li><strong>dst</strong> &#8211; Destination image of the same size and the same number of channels as  <code class="docutils literal"><span class="pre">src</span></code> .</li>
<li><strong>ddepth</strong> &#8211; <dl class="docutils">
<dt>Destination image depth. The following combination of <code class="docutils literal"><span class="pre">src.depth()</span></code> and <code class="docutils literal"><span class="pre">ddepth</span></code> are supported:</dt>
<dd><ul class="first last">
<li><code class="docutils literal"><span class="pre">src.depth()</span></code> = <code class="docutils literal"><span class="pre">CV_8U</span></code>, <code class="docutils literal"><span class="pre">ddepth</span></code> = -1/<code class="docutils literal"><span class="pre">CV_16S</span></code>/<code class="docutils literal"><span class="pre">CV_32F</span></code>/<code class="docutils literal"><span class="pre">CV_64F</span></code></li>
<li><code class="docutils literal"><span class="pre">src.depth()</span></code> = <code class="docutils literal"><span class="pre">CV_16U</span></code>/<code class="docutils literal"><span class="pre">CV_16S</span></code>, <code class="docutils literal"><span class="pre">ddepth</span></code> = -1/<code class="docutils literal"><span class="pre">CV_32F</span></code>/<code class="docutils literal"><span class="pre">CV_64F</span></code></li>
<li><code class="docutils literal"><span class="pre">src.depth()</span></code> = <code class="docutils literal"><span class="pre">CV_32F</span></code>, <code class="docutils literal"><span class="pre">ddepth</span></code> = -1/<code class="docutils literal"><span class="pre">CV_32F</span></code>/<code class="docutils literal"><span class="pre">CV_64F</span></code></li>
<li><code class="docutils literal"><span class="pre">src.depth()</span></code> = <code class="docutils literal"><span class="pre">CV_64F</span></code>, <code class="docutils literal"><span class="pre">ddepth</span></code> = -1/<code class="docutils literal"><span class="pre">CV_64F</span></code></li>
</ul>
</dd>
</dl>
<p>when <code class="docutils literal"><span class="pre">ddepth=-1</span></code>, the destination image will have the same depth as the source.</p>
</li>
<li><strong>kernelX</strong> &#8211; Coefficients for filtering each row.</li>
<li><strong>kernelY</strong> &#8211; Coefficients for filtering each column.</li>
<li><strong>anchor</strong> &#8211; Anchor position within the kernel. The default value  <img class="math" src="../../../_images/math/858474f535edf90133448f64918fa8a7c2581739.png" alt="(-1,-1)"/>  means that the anchor is at the kernel center.</li>
<li><strong>delta</strong> &#8211; Value added to the filtered results before storing them.</li>
<li><strong>borderType</strong> &#8211; Pixel extrapolation method. See  <a class="reference internal" href="#int borderInterpolate(int p, int len, int borderType)" title="int borderInterpolate(int p, int len, int borderType)"><code class="xref ocv ocv-func docutils literal"><span class="pre">borderInterpolate()</span></code></a> for details.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<p>The function applies a separable linear filter to the image. That is, first, every row of <code class="docutils literal"><span class="pre">src</span></code> is filtered with the 1D kernel <code class="docutils literal"><span class="pre">kernelX</span></code> . Then, every column of the result is filtered with the 1D kernel <code class="docutils literal"><span class="pre">kernelY</span></code> . The final result shifted by <code class="docutils literal"><span class="pre">delta</span></code> is stored in <code class="docutils literal"><span class="pre">dst</span></code> .</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#Ptr&lt;FilterEngine&gt; createSeparableLinearFilter(int srcType, int dstType, InputArray rowKernel, InputArray columnKernel, Point anchor, double delta, int rowBorderType, int columnBorderType, const Scalar&amp; borderValue)" title="Ptr&lt;FilterEngine&gt; createSeparableLinearFilter(int srcType, int dstType, InputArray rowKernel, InputArray columnKernel, Point anchor, double delta, int rowBorderType, int columnBorderType, const Scalar&amp; borderValue)"><code class="xref ocv ocv-func docutils literal"><span class="pre">createSeparableLinearFilter()</span></code></a>,
<a class="reference internal" href="#void filter2D(InputArray src, OutputArray dst, int ddepth, InputArray kernel, Point anchor, double delta, int borderType)" title="void filter2D(InputArray src, OutputArray dst, int ddepth, InputArray kernel, Point anchor, double delta, int borderType)"><code class="xref ocv ocv-func docutils literal"><span class="pre">filter2D()</span></code></a>,
<a class="reference internal" href="#void Sobel(InputArray src, OutputArray dst, int ddepth, int dx, int dy, int ksize, double scale, double delta, int borderType)" title="void Sobel(InputArray src, OutputArray dst, int ddepth, int dx, int dy, int ksize, double scale, double delta, int borderType)"><code class="xref ocv ocv-func docutils literal"><span class="pre">Sobel()</span></code></a>,
<a class="reference internal" href="#void GaussianBlur(InputArray src, OutputArray dst, Size ksize, double sigmaX, double sigmaY, int borderType)" title="void GaussianBlur(InputArray src, OutputArray dst, Size ksize, double sigmaX, double sigmaY, int borderType)"><code class="xref ocv ocv-func docutils literal"><span class="pre">GaussianBlur()</span></code></a>,
<a class="reference internal" href="#void boxFilter(InputArray src, OutputArray dst, int ddepth, Size ksize, Point anchor, bool normalize, int borderType)" title="void boxFilter(InputArray src, OutputArray dst, int ddepth, Size ksize, Point anchor, bool normalize, int borderType)"><code class="xref ocv ocv-func docutils literal"><span class="pre">boxFilter()</span></code></a>,
<a class="reference internal" href="#void blur(InputArray src, OutputArray dst, Size ksize, Point anchor, int borderType)" title="void blur(InputArray src, OutputArray dst, Size ksize, Point anchor, int borderType)"><code class="xref ocv ocv-func docutils literal"><span class="pre">blur()</span></code></a></p>
</div>
</div>
<div class="section" id="smooth">
<h2>Smooth<a class="headerlink" href="#smooth" title="Permalink to this headline">¶</a></h2>
<p>Smooths the image in one of several ways.</p>
<dl class="cfunction">
<dt id="void cvSmooth(const CvArr* src, CvArr* dst, int smoothtype, int size1, int size2, double sigma1, double sigma2)">
<strong>C:</strong><code class="descname"> </code>void <code class="descname">cvSmooth</code><span class="sig-paren">(</span>const CvArr* <strong>src</strong>, CvArr* <strong>dst</strong>, int <strong>smoothtype</strong>=CV_GAUSSIAN, int <strong>size1</strong>=3, int <strong>size2</strong>=0, double <strong>sigma1</strong>=0, double <strong>sigma2</strong>=0 <span class="sig-paren">)</span><a class="headerlink" href="#void cvSmooth(const CvArr* src, CvArr* dst, int smoothtype, int size1, int size2, double sigma1, double sigma2)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="pyoldfunction">
<dt id="cv.Smooth">
<strong>Python:</strong><code class="descname"> </code><code class="descclassname">cv.</code><code class="descname">Smooth</code><span class="sig-paren">(</span>src, dst, smoothtype=CV_GAUSSIAN, param1=3, param2=0, param3=0, param4=0<span class="sig-paren">)</span> &rarr; None<a class="headerlink" href="#cv.Smooth" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>src</strong> &#8211; The source image</li>
<li><strong>dst</strong> &#8211; The destination image</li>
<li><strong>smoothtype</strong> &#8211; <p>Type of the smoothing:</p>
<ul>
<li><strong>CV_BLUR_NO_SCALE</strong> linear convolution with  <img class="math" src="../../../_images/math/1600da3ebd94222e0a5bdc8e768236e4afb98281.png" alt="\texttt{size1}\times\texttt{size2}"/>  box kernel (all 1&#8217;s). If you want to smooth different pixels with different-size box kernels, you can use the integral image that is computed using  <a class="reference internal" href="miscellaneous_transformations.html#void integral(InputArray src, OutputArray sum, int sdepth)" title="void integral(InputArray src, OutputArray sum, int sdepth)"><code class="xref ocv ocv-func docutils literal"><span class="pre">integral()</span></code></a></li>
<li><strong>CV_BLUR</strong> linear convolution with  <img class="math" src="../../../_images/math/1600da3ebd94222e0a5bdc8e768236e4afb98281.png" alt="\texttt{size1}\times\texttt{size2}"/>  box kernel (all 1&#8217;s) with subsequent scaling by  <img class="math" src="../../../_images/math/db083d1f3dac1c9b7612c66da9f822879303c539.png" alt="1/(\texttt{size1}\cdot\texttt{size2})"/></li>
<li><strong>CV_GAUSSIAN</strong> linear convolution with a  <img class="math" src="../../../_images/math/1600da3ebd94222e0a5bdc8e768236e4afb98281.png" alt="\texttt{size1}\times\texttt{size2}"/>  Gaussian kernel</li>
<li><strong>CV_MEDIAN</strong> median filter with a  <img class="math" src="../../../_images/math/18705ea7991af3fd57db998abfc3b4bf088f5046.png" alt="\texttt{size1}\times\texttt{size1}"/>  square aperture</li>
<li><strong>CV_BILATERAL</strong> bilateral filter with a  <img class="math" src="../../../_images/math/18705ea7991af3fd57db998abfc3b4bf088f5046.png" alt="\texttt{size1}\times\texttt{size1}"/>  square aperture, color sigma= <code class="docutils literal"><span class="pre">sigma1</span></code>  and spatial sigma= <code class="docutils literal"><span class="pre">sigma2</span></code> . If  <code class="docutils literal"><span class="pre">size1=0</span></code> , the aperture square side is set to  <code class="docutils literal"><span class="pre">cvRound(sigma2*1.5)*2+1</span></code> . Information about bilateral filtering can be found at  <a class="reference external" href="http://www.dai.ed.ac.uk/CVonline/LOCAL_COPIES/MANDUCHI1/Bilateral_Filtering.html">http://www.dai.ed.ac.uk/CVonline/LOCAL_COPIES/MANDUCHI1/Bilateral_Filtering.html</a></li>
</ul>
</li>
<li><strong>size1</strong> &#8211; The first parameter of the smoothing operation, the aperture width. Must be a positive odd number (1, 3, 5, ...)</li>
<li><strong>size2</strong> &#8211; The second parameter of the smoothing operation, the aperture height. Ignored by  <code class="docutils literal"><span class="pre">CV_MEDIAN</span></code>  and  <code class="docutils literal"><span class="pre">CV_BILATERAL</span></code>  methods. In the case of simple scaled/non-scaled and Gaussian blur if  <code class="docutils literal"><span class="pre">size2</span></code>  is zero, it is set to  <code class="docutils literal"><span class="pre">size1</span></code> . Otherwise it must be a positive odd number.</li>
<li><strong>sigma1</strong> &#8211; <p>In the case of a Gaussian parameter this parameter may specify Gaussian  <img class="math" src="../../../_images/math/d870df83c0f933473f427ed5b844becd2622c551.png" alt="\sigma"/>  (standard deviation). If it is zero, it is calculated from the kernel size:</p>
<div class="math">
<p><img src="../../../_images/math/e79de1da1ea3311e88d87aff6a726cccff487082.png" alt="\sigma  = 0.3 (n/2 - 1) + 0.8  \quad   \text{where}   \quad  n= \begin{array}{l l} \mbox{\texttt{size1} for horizontal kernel} \\ \mbox{\texttt{size2} for vertical kernel} \end{array}"/></p>
</div><p>Using standard sigma for small kernels ( <img class="math" src="../../../_images/math/268e62297468c4d7ef109727ed4bcbfad953ad61.png" alt="3\times 3"/>  to  <img class="math" src="../../../_images/math/dacf0de3ae2c1cfc54146062197fe1dd0beef1df.png" alt="7\times 7"/> ) gives better speed. If  <code class="docutils literal"><span class="pre">sigma1</span></code>  is not zero, while  <code class="docutils literal"><span class="pre">size1</span></code>  and  <code class="docutils literal"><span class="pre">size2</span></code>  are zeros, the kernel size is calculated from the sigma (to provide accurate enough operation).</p>
</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<p>The function smooths an image using one of several methods. Every of the methods has some features and restrictions listed below:</p>
<blockquote>
<div><ul class="simple">
<li>Blur with no scaling works with single-channel images only and supports accumulation of 8-bit to 16-bit format (similar to <a class="reference internal" href="#void Sobel(InputArray src, OutputArray dst, int ddepth, int dx, int dy, int ksize, double scale, double delta, int borderType)" title="void Sobel(InputArray src, OutputArray dst, int ddepth, int dx, int dy, int ksize, double scale, double delta, int borderType)"><code class="xref ocv ocv-func docutils literal"><span class="pre">Sobel()</span></code></a> and <a class="reference internal" href="#void Laplacian(InputArray src, OutputArray dst, int ddepth, int ksize, double scale, double delta, int borderType)" title="void Laplacian(InputArray src, OutputArray dst, int ddepth, int ksize, double scale, double delta, int borderType)"><code class="xref ocv ocv-func docutils literal"><span class="pre">Laplacian()</span></code></a>) and 32-bit floating point to 32-bit floating-point format.</li>
<li>Simple blur and Gaussian blur support 1- or 3-channel, 8-bit and 32-bit floating point images. These two methods can process images in-place.</li>
<li>Median and bilateral filters work with 1- or 3-channel 8-bit images and can not process images in-place.</li>
</ul>
</div></blockquote>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The function is now obsolete. Use <a class="reference internal" href="#void GaussianBlur(InputArray src, OutputArray dst, Size ksize, double sigmaX, double sigmaY, int borderType)" title="void GaussianBlur(InputArray src, OutputArray dst, Size ksize, double sigmaX, double sigmaY, int borderType)"><code class="xref ocv ocv-func docutils literal"><span class="pre">GaussianBlur()</span></code></a>, <a class="reference internal" href="#void blur(InputArray src, OutputArray dst, Size ksize, Point anchor, int borderType)" title="void blur(InputArray src, OutputArray dst, Size ksize, Point anchor, int borderType)"><code class="xref ocv ocv-func docutils literal"><span class="pre">blur()</span></code></a>, <a class="reference internal" href="#void medianBlur(InputArray src, OutputArray dst, int ksize)" title="void medianBlur(InputArray src, OutputArray dst, int ksize)"><code class="xref ocv ocv-func docutils literal"><span class="pre">medianBlur()</span></code></a> or <a class="reference internal" href="#void bilateralFilter(InputArray src, OutputArray dst, int d, double sigmaColor, double sigmaSpace, int borderType)" title="void bilateralFilter(InputArray src, OutputArray dst, int d, double sigmaColor, double sigmaSpace, int borderType)"><code class="xref ocv ocv-func docutils literal"><span class="pre">bilateralFilter()</span></code></a>.</p>
</div>
</div>
<div class="section" id="sobel">
<h2>Sobel<a class="headerlink" href="#sobel" title="Permalink to this headline">¶</a></h2>
<p>Calculates the first, second, third, or mixed image derivatives using an extended Sobel operator.</p>
<dl class="function">
<dt id="void Sobel(InputArray src, OutputArray dst, int ddepth, int dx, int dy, int ksize, double scale, double delta, int borderType)">
<strong>C++:</strong><code class="descname"> </code>void <code class="descname">Sobel</code><span class="sig-paren">(</span>InputArray <strong>src</strong>, OutputArray <strong>dst</strong>, int <strong>ddepth</strong>, int <strong>dx</strong>, int <strong>dy</strong>, int <strong>ksize</strong>=3, double <strong>scale</strong>=1, double <strong>delta</strong>=0, int <strong>borderType</strong>=BORDER_DEFAULT <span class="sig-paren">)</span><a class="headerlink" href="#void Sobel(InputArray src, OutputArray dst, int ddepth, int dx, int dy, int ksize, double scale, double delta, int borderType)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="pyfunction">
<dt id="cv2.Sobel">
<strong>Python:</strong><code class="descname"> </code><code class="descclassname">cv2.</code><code class="descname">Sobel</code><span class="sig-paren">(</span>src, ddepth, dx, dy<span class="optional">[</span>, dst<span class="optional">[</span>, ksize<span class="optional">[</span>, scale<span class="optional">[</span>, delta<span class="optional">[</span>, borderType<span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span> &rarr; dst<a class="headerlink" href="#cv2.Sobel" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="cfunction">
<dt id="void cvSobel(const CvArr* src, CvArr* dst, int xorder, int yorder, int aperture_size)">
<strong>C:</strong><code class="descname"> </code>void <code class="descname">cvSobel</code><span class="sig-paren">(</span>const CvArr* <strong>src</strong>, CvArr* <strong>dst</strong>, int <strong>xorder</strong>, int <strong>yorder</strong>, int <strong>aperture_size</strong>=3 <span class="sig-paren">)</span><a class="headerlink" href="#void cvSobel(const CvArr* src, CvArr* dst, int xorder, int yorder, int aperture_size)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="pyoldfunction">
<dt id="cv.Sobel">
<strong>Python:</strong><code class="descname"> </code><code class="descclassname">cv.</code><code class="descname">Sobel</code><span class="sig-paren">(</span>src, dst, xorder, yorder, apertureSize=3<span class="sig-paren">)</span> &rarr; None<a class="headerlink" href="#cv.Sobel" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>src</strong> &#8211; input image.</li>
<li><strong>dst</strong> &#8211; output image of the same size and the same number of channels as  <code class="docutils literal"><span class="pre">src</span></code> .</li>
<li><strong>ddepth</strong> &#8211; <dl class="docutils">
<dt>output image depth; the following combinations of <code class="docutils literal"><span class="pre">src.depth()</span></code> and <code class="docutils literal"><span class="pre">ddepth</span></code> are supported:</dt>
<dd><ul class="first last">
<li><code class="docutils literal"><span class="pre">src.depth()</span></code> = <code class="docutils literal"><span class="pre">CV_8U</span></code>, <code class="docutils literal"><span class="pre">ddepth</span></code> = -1/<code class="docutils literal"><span class="pre">CV_16S</span></code>/<code class="docutils literal"><span class="pre">CV_32F</span></code>/<code class="docutils literal"><span class="pre">CV_64F</span></code></li>
<li><code class="docutils literal"><span class="pre">src.depth()</span></code> = <code class="docutils literal"><span class="pre">CV_16U</span></code>/<code class="docutils literal"><span class="pre">CV_16S</span></code>, <code class="docutils literal"><span class="pre">ddepth</span></code> = -1/<code class="docutils literal"><span class="pre">CV_32F</span></code>/<code class="docutils literal"><span class="pre">CV_64F</span></code></li>
<li><code class="docutils literal"><span class="pre">src.depth()</span></code> = <code class="docutils literal"><span class="pre">CV_32F</span></code>, <code class="docutils literal"><span class="pre">ddepth</span></code> = -1/<code class="docutils literal"><span class="pre">CV_32F</span></code>/<code class="docutils literal"><span class="pre">CV_64F</span></code></li>
<li><code class="docutils literal"><span class="pre">src.depth()</span></code> = <code class="docutils literal"><span class="pre">CV_64F</span></code>, <code class="docutils literal"><span class="pre">ddepth</span></code> = -1/<code class="docutils literal"><span class="pre">CV_64F</span></code></li>
</ul>
</dd>
</dl>
<p>when <code class="docutils literal"><span class="pre">ddepth=-1</span></code>, the destination image will have the same depth as the source; in the case of 8-bit input images it will result in truncated derivatives.</p>
</li>
<li><strong>xorder</strong> &#8211; order of the derivative x.</li>
<li><strong>yorder</strong> &#8211; order of the derivative y.</li>
<li><strong>ksize</strong> &#8211; size of the extended Sobel kernel; it must be 1, 3, 5, or 7.</li>
<li><strong>scale</strong> &#8211; optional scale factor for the computed derivative values; by default, no scaling is applied (see  <a class="reference internal" href="#void getDerivKernels(OutputArray kx, OutputArray ky, int dx, int dy, int ksize, bool normalize, int ktype)" title="void getDerivKernels(OutputArray kx, OutputArray ky, int dx, int dy, int ksize, bool normalize, int ktype)"><code class="xref ocv ocv-func docutils literal"><span class="pre">getDerivKernels()</span></code></a> for details).</li>
<li><strong>delta</strong> &#8211; optional delta value that is added to the results prior to storing them in <code class="docutils literal"><span class="pre">dst</span></code>.</li>
<li><strong>borderType</strong> &#8211; pixel extrapolation method (see  <a class="reference internal" href="#int borderInterpolate(int p, int len, int borderType)" title="int borderInterpolate(int p, int len, int borderType)"><code class="xref ocv ocv-func docutils literal"><span class="pre">borderInterpolate()</span></code></a> for details).</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<p>In all cases except one, the
<img class="math" src="../../../_images/math/67ac8e01d254361095b28f8ac83e332f208d1e31.png" alt="\texttt{ksize} \times
\texttt{ksize}"/> separable kernel is used to calculate the
derivative. When
<img class="math" src="../../../_images/math/4daed318cc0381d143ca27f60277e6d1ea50e432.png" alt="\texttt{ksize = 1}"/> , the
<img class="math" src="../../../_images/math/100762acf79bb70bf5737e3a41067c09cb55b050.png" alt="3 \times 1"/> or
<img class="math" src="../../../_images/math/0901cf2fbd419b32993984f209910f744424b80d.png" alt="1 \times 3"/> kernel is used (that is, no Gaussian smoothing is done). <code class="docutils literal"><span class="pre">ksize</span> <span class="pre">=</span> <span class="pre">1</span></code> can only be used for the first or the second x- or y- derivatives.</p>
<p>There is also the special value <code class="docutils literal"><span class="pre">ksize</span> <span class="pre">=</span> <span class="pre">CV_SCHARR</span></code> (-1) that corresponds to the
<img class="math" src="../../../_images/math/913c4034db44a98d07b02c893a2c7dede83be898.png" alt="3\times3"/> Scharr
filter that may give more accurate results than the
<img class="math" src="../../../_images/math/913c4034db44a98d07b02c893a2c7dede83be898.png" alt="3\times3"/> Sobel. The Scharr aperture is</p>
<div class="math">
<p><img src="../../../_images/math/3ab98ff1a5283f63057e5f3ff52c25e49ef01318.png" alt="\vecthreethree{-3}{0}{3}{-10}{0}{10}{-3}{0}{3}"/></p>
</div><p>for the x-derivative, or transposed for the y-derivative.</p>
<p>The function calculates an image derivative by convolving the image with the appropriate kernel:</p>
<div class="math">
<p><img src="../../../_images/math/f6b50963327c57345aabf72f164a3faf10d255a4.png" alt="\texttt{dst} =  \frac{\partial^{xorder+yorder} \texttt{src}}{\partial x^{xorder} \partial y^{yorder}}"/></p>
</div><p>The Sobel operators combine Gaussian smoothing and differentiation,
so the result is more or less resistant to the noise. Most often,
the function is called with ( <code class="docutils literal"><span class="pre">xorder</span></code> = 1, <code class="docutils literal"><span class="pre">yorder</span></code> = 0, <code class="docutils literal"><span class="pre">ksize</span></code> = 3) or ( <code class="docutils literal"><span class="pre">xorder</span></code> = 0, <code class="docutils literal"><span class="pre">yorder</span></code> = 1, <code class="docutils literal"><span class="pre">ksize</span></code> = 3) to calculate the first x- or y- image
derivative. The first case corresponds to a kernel of:</p>
<div class="math">
<p><img src="../../../_images/math/f2531c53069c2dabcab2bcb391518bd65dc535eb.png" alt="\vecthreethree{-1}{0}{1}{-2}{0}{2}{-1}{0}{1}"/></p>
</div><p>The second case corresponds to a kernel of:</p>
<div class="math">
<p><img src="../../../_images/math/03e50d0ac972c69085ccbff5cadd0b53f791fce8.png" alt="\vecthreethree{-1}{-2}{-1}{0}{0}{0}{1}{2}{1}"/></p>
</div><div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#void Scharr(InputArray src, OutputArray dst, int ddepth, int dx, int dy, double scale, double delta, int borderType)" title="void Scharr(InputArray src, OutputArray dst, int ddepth, int dx, int dy, double scale, double delta, int borderType)"><code class="xref ocv ocv-func docutils literal"><span class="pre">Scharr()</span></code></a>,
<a class="reference internal" href="#void Laplacian(InputArray src, OutputArray dst, int ddepth, int ksize, double scale, double delta, int borderType)" title="void Laplacian(InputArray src, OutputArray dst, int ddepth, int ksize, double scale, double delta, int borderType)"><code class="xref ocv ocv-func docutils literal"><span class="pre">Laplacian()</span></code></a>,
<a class="reference internal" href="#void sepFilter2D(InputArray src, OutputArray dst, int ddepth, InputArray kernelX, InputArray kernelY, Point anchor, double delta, int borderType)" title="void sepFilter2D(InputArray src, OutputArray dst, int ddepth, InputArray kernelX, InputArray kernelY, Point anchor, double delta, int borderType)"><code class="xref ocv ocv-func docutils literal"><span class="pre">sepFilter2D()</span></code></a>,
<a class="reference internal" href="#void filter2D(InputArray src, OutputArray dst, int ddepth, InputArray kernel, Point anchor, double delta, int borderType)" title="void filter2D(InputArray src, OutputArray dst, int ddepth, InputArray kernel, Point anchor, double delta, int borderType)"><code class="xref ocv ocv-func docutils literal"><span class="pre">filter2D()</span></code></a>,
<a class="reference internal" href="#void GaussianBlur(InputArray src, OutputArray dst, Size ksize, double sigmaX, double sigmaY, int borderType)" title="void GaussianBlur(InputArray src, OutputArray dst, Size ksize, double sigmaX, double sigmaY, int borderType)"><code class="xref ocv ocv-func docutils literal"><span class="pre">GaussianBlur()</span></code></a>,
<a class="reference internal" href="../../core/doc/operations_on_arrays.html#void cartToPolar(InputArray x, InputArray y, OutputArray magnitude, OutputArray angle, bool angleInDegrees)" title="void cartToPolar(InputArray x, InputArray y, OutputArray magnitude, OutputArray angle, bool angleInDegrees)"><code class="xref ocv ocv-func docutils literal"><span class="pre">cartToPolar()</span></code></a></p>
</div>
</div>
<div class="section" id="scharr">
<h2>Scharr<a class="headerlink" href="#scharr" title="Permalink to this headline">¶</a></h2>
<p>Calculates the first x- or y- image derivative using Scharr operator.</p>
<dl class="function">
<dt id="void Scharr(InputArray src, OutputArray dst, int ddepth, int dx, int dy, double scale, double delta, int borderType)">
<strong>C++:</strong><code class="descname"> </code>void <code class="descname">Scharr</code><span class="sig-paren">(</span>InputArray <strong>src</strong>, OutputArray <strong>dst</strong>, int <strong>ddepth</strong>, int <strong>dx</strong>, int <strong>dy</strong>, double <strong>scale</strong>=1, double <strong>delta</strong>=0, int <strong>borderType</strong>=BORDER_DEFAULT <span class="sig-paren">)</span><a class="headerlink" href="#void Scharr(InputArray src, OutputArray dst, int ddepth, int dx, int dy, double scale, double delta, int borderType)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="pyfunction">
<dt id="cv2.Scharr">
<strong>Python:</strong><code class="descname"> </code><code class="descclassname">cv2.</code><code class="descname">Scharr</code><span class="sig-paren">(</span>src, ddepth, dx, dy<span class="optional">[</span>, dst<span class="optional">[</span>, scale<span class="optional">[</span>, delta<span class="optional">[</span>, borderType<span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span> &rarr; dst<a class="headerlink" href="#cv2.Scharr" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>src</strong> &#8211; input image.</li>
<li><strong>dst</strong> &#8211; output image of the same size and the same number of channels as <code class="docutils literal"><span class="pre">src</span></code>.</li>
<li><strong>ddepth</strong> &#8211; output image depth (see <a class="reference internal" href="#void Sobel(InputArray src, OutputArray dst, int ddepth, int dx, int dy, int ksize, double scale, double delta, int borderType)" title="void Sobel(InputArray src, OutputArray dst, int ddepth, int dx, int dy, int ksize, double scale, double delta, int borderType)"><code class="xref ocv ocv-func docutils literal"><span class="pre">Sobel()</span></code></a> for the list of supported combination of <code class="docutils literal"><span class="pre">src.depth()</span></code> and <code class="docutils literal"><span class="pre">ddepth</span></code>).</li>
<li><strong>dx</strong> &#8211; order of the derivative x.</li>
<li><strong>dy</strong> &#8211; order of the derivative y.</li>
<li><strong>scale</strong> &#8211; optional scale factor for the computed derivative values; by default, no scaling is applied (see  <a class="reference internal" href="#void getDerivKernels(OutputArray kx, OutputArray ky, int dx, int dy, int ksize, bool normalize, int ktype)" title="void getDerivKernels(OutputArray kx, OutputArray ky, int dx, int dy, int ksize, bool normalize, int ktype)"><code class="xref ocv ocv-func docutils literal"><span class="pre">getDerivKernels()</span></code></a> for details).</li>
<li><strong>delta</strong> &#8211; optional delta value that is added to the results prior to storing them in <code class="docutils literal"><span class="pre">dst</span></code>.</li>
<li><strong>borderType</strong> &#8211; pixel extrapolation method (see  <a class="reference internal" href="#int borderInterpolate(int p, int len, int borderType)" title="int borderInterpolate(int p, int len, int borderType)"><code class="xref ocv ocv-func docutils literal"><span class="pre">borderInterpolate()</span></code></a> for details).</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<p>The function computes the first x- or y- spatial image derivative using the Scharr operator. The call</p>
<div class="math">
<p><img src="../../../_images/math/a6696df875d60041177d1aa3f7957d1a007dccfe.png" alt="\texttt{Scharr(src, dst, ddepth, dx, dy, scale, delta, borderType)}"/></p>
</div><p>is equivalent to</p>
<div class="math">
<p><img src="../../../_images/math/880373c032d5ccf21a454e832d9523c3395ca59d.png" alt="\texttt{Sobel(src, dst, ddepth, dx, dy, CV\_SCHARR, scale, delta, borderType)} ."/></p>
</div><div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="../../core/doc/operations_on_arrays.html#void cartToPolar(InputArray x, InputArray y, OutputArray magnitude, OutputArray angle, bool angleInDegrees)" title="void cartToPolar(InputArray x, InputArray y, OutputArray magnitude, OutputArray angle, bool angleInDegrees)"><code class="xref ocv ocv-func docutils literal"><span class="pre">cartToPolar()</span></code></a></p>
</div>
</div>
</div>


          </div>
          <div class="feedback">
              <h2>Help and Feedback</h2>
              You did not find what you were looking for?
              <ul>
                  
                  
                  
                  <li>Ask a question on the <a href="http://answers.opencv.org">Q&A forum</a>.</li>
                  <li>If you think something is missing or wrong in the documentation,
                  please file a <a href="http://code.opencv.org">bug report</a>.</li>
              </ul>
          </div>
        </div>
      </div>

      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../../../index.html">
              <img class="logo" src="../../../_static/opencv-logo-white.png" alt="Logo"/>
            </a></p>
<div id="searchbox" style="display: none">
      <form class="search" action="../../../search.html" method="get">
      <input type="text" name="q" size="18" />
      <input type="submit" value="Search" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
      </p>
    </form>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
  <h3><a href="../../../index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Image Filtering</a><ul>
<li><a class="reference internal" href="#basecolumnfilter">BaseColumnFilter</a></li>
<li><a class="reference internal" href="#basefilter">BaseFilter</a></li>
<li><a class="reference internal" href="#baserowfilter">BaseRowFilter</a></li>
<li><a class="reference internal" href="#filterengine">FilterEngine</a></li>
<li><a class="reference internal" href="#bilateralfilter">bilateralFilter</a></li>
<li><a class="reference internal" href="#adaptivebilateralfilter">adaptiveBilateralFilter</a></li>
<li><a class="reference internal" href="#blur">blur</a></li>
<li><a class="reference internal" href="#borderinterpolate">borderInterpolate</a></li>
<li><a class="reference internal" href="#boxfilter">boxFilter</a></li>
<li><a class="reference internal" href="#buildpyramid">buildPyramid</a></li>
<li><a class="reference internal" href="#copymakeborder">copyMakeBorder</a></li>
<li><a class="reference internal" href="#createboxfilter">createBoxFilter</a></li>
<li><a class="reference internal" href="#createderivfilter">createDerivFilter</a></li>
<li><a class="reference internal" href="#creategaussianfilter">createGaussianFilter</a></li>
<li><a class="reference internal" href="#createlinearfilter">createLinearFilter</a></li>
<li><a class="reference internal" href="#createmorphologyfilter">createMorphologyFilter</a></li>
<li><a class="reference internal" href="#createseparablelinearfilter">createSeparableLinearFilter</a></li>
<li><a class="reference internal" href="#dilate">dilate</a></li>
<li><a class="reference internal" href="#erode">erode</a></li>
<li><a class="reference internal" href="#filter2d">filter2D</a></li>
<li><a class="reference internal" href="#gaussianblur">GaussianBlur</a></li>
<li><a class="reference internal" href="#getderivkernels">getDerivKernels</a></li>
<li><a class="reference internal" href="#getgaussiankernel">getGaussianKernel</a></li>
<li><a class="reference internal" href="#getkerneltype">getKernelType</a></li>
<li><a class="reference internal" href="#getstructuringelement">getStructuringElement</a></li>
<li><a class="reference internal" href="#medianblur">medianBlur</a></li>
<li><a class="reference internal" href="#morphologyex">morphologyEx</a></li>
<li><a class="reference internal" href="#laplacian">Laplacian</a></li>
<li><a class="reference internal" href="#pyrdown">pyrDown</a></li>
<li><a class="reference internal" href="#pyrup">pyrUp</a></li>
<li><a class="reference internal" href="#pyrmeanshiftfiltering">pyrMeanShiftFiltering</a></li>
<li><a class="reference internal" href="#sepfilter2d">sepFilter2D</a></li>
<li><a class="reference internal" href="#smooth">Smooth</a></li>
<li><a class="reference internal" href="#sobel">Sobel</a></li>
<li><a class="reference internal" href="#scharr">Scharr</a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="imgproc.html"
                        title="previous chapter">imgproc. Image Processing</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="geometric_transformations.html"
                        title="next chapter">Geometric Image Transformations</a></p>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../../../_sources/modules/imgproc/doc/filtering.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="geometric_transformations.html" title="Geometric Image Transformations"
             >next</a> |</li>
        <li class="right" >
          <a href="imgproc.html" title="imgproc. Image Processing"
             >previous</a> |</li>
        <li><a href="../../../index.html">OpenCV 2.4.13.7 documentation</a> &raquo;</li>
          <li><a href="../../refman.html" >OpenCV API Reference</a> &raquo;</li>
          <li><a href="imgproc.html" >imgproc. Image Processing</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2011-2014, opencv dev team.
      Last updated on Jul 12, 2018.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.3.6.
    </div>
  </body>
</html>
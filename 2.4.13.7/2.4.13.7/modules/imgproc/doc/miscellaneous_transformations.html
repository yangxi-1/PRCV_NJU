<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<script type="text/javascript">

  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-33108845-1']);
  _gaq.push(['_setDomainName', 'opencv.org']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();

</script>

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Miscellaneous Image Transformations &mdash; OpenCV 2.4.13.7 documentation</title>
    <link rel="stylesheet" href="../../../_static/default.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../../',
        VERSION:     '2.4.13.7',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../../_static/doctools.js"></script>
    <link rel="top" title="OpenCV 2.4.13.7 documentation" href="../../../index.html" />
    <link rel="up" title="imgproc. Image Processing" href="imgproc.html" />
    <link rel="next" title="Histograms" href="histograms.html" />
    <link rel="prev" title="Geometric Image Transformations" href="geometric_transformations.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="histograms.html" title="Histograms"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="geometric_transformations.html" title="Geometric Image Transformations"
             accesskey="P">previous</a> |</li>
        <li><a href="../../../index.html">OpenCV 2.4.13.7 documentation</a> &raquo;</li>
          <li><a href="../../refman.html" >OpenCV API Reference</a> &raquo;</li>
          <li><a href="imgproc.html" accesskey="U">imgproc. Image Processing</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
  
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="miscellaneous-image-transformations">
<h1>Miscellaneous Image Transformations<a class="headerlink" href="#miscellaneous-image-transformations" title="Permalink to this headline">¶</a></h1>
<div class="section" id="adaptivethreshold">
<h2>adaptiveThreshold<a class="headerlink" href="#adaptivethreshold" title="Permalink to this headline">¶</a></h2>
<p>Applies an adaptive threshold to an array.</p>
<dl class="function">
<dt id="void adaptiveThreshold(InputArray src, OutputArray dst, double maxValue, int adaptiveMethod, int thresholdType, int blockSize, double C)">
<strong>C++:</strong><code class="descname"> </code>void <code class="descname">adaptiveThreshold</code><span class="sig-paren">(</span>InputArray <strong>src</strong>, OutputArray <strong>dst</strong>, double <strong>maxValue</strong>, int <strong>adaptiveMethod</strong>, int <strong>thresholdType</strong>, int <strong>blockSize</strong>, double <strong>C</strong><span class="sig-paren">)</span><a class="headerlink" href="#void adaptiveThreshold(InputArray src, OutputArray dst, double maxValue, int adaptiveMethod, int thresholdType, int blockSize, double C)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="pyfunction">
<dt id="cv2.adaptiveThreshold">
<strong>Python:</strong><code class="descname"> </code><code class="descclassname">cv2.</code><code class="descname">adaptiveThreshold</code><span class="sig-paren">(</span>src, maxValue, adaptiveMethod, thresholdType, blockSize, C<span class="optional">[</span>, dst<span class="optional">]</span><span class="sig-paren">)</span> &rarr; dst<a class="headerlink" href="#cv2.adaptiveThreshold" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="cfunction">
<dt id="void cvAdaptiveThreshold(const CvArr* src, CvArr* dst, double max_value, int adaptive_method, int threshold_type, int block_size, double param1)">
<strong>C:</strong><code class="descname"> </code>void <code class="descname">cvAdaptiveThreshold</code><span class="sig-paren">(</span>const CvArr* <strong>src</strong>, CvArr* <strong>dst</strong>, double <strong>max_value</strong>, int <strong>adaptive_method</strong>=CV_ADAPTIVE_THRESH_MEAN_C, int <strong>threshold_type</strong>=CV_THRESH_BINARY, int <strong>block_size</strong>=3, double <strong>param1</strong>=5 <span class="sig-paren">)</span><a class="headerlink" href="#void cvAdaptiveThreshold(const CvArr* src, CvArr* dst, double max_value, int adaptive_method, int threshold_type, int block_size, double param1)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="pyoldfunction">
<dt id="cv.AdaptiveThreshold">
<strong>Python:</strong><code class="descname"> </code><code class="descclassname">cv.</code><code class="descname">AdaptiveThreshold</code><span class="sig-paren">(</span>src, dst, maxValue, adaptive_method=CV_ADAPTIVE_THRESH_MEAN_C, thresholdType=CV_THRESH_BINARY, blockSize=3, param1=5<span class="sig-paren">)</span> &rarr; None<a class="headerlink" href="#cv.AdaptiveThreshold" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>src</strong> &#8211; Source 8-bit single-channel image.</li>
<li><strong>dst</strong> &#8211; Destination image of the same size and the same type as  <code class="docutils literal"><span class="pre">src</span></code> .</li>
<li><strong>maxValue</strong> &#8211; Non-zero value assigned to the pixels for which the condition is satisfied. See the details below.</li>
<li><strong>adaptiveMethod</strong> &#8211; Adaptive thresholding algorithm to use, <code class="docutils literal"><span class="pre">ADAPTIVE_THRESH_MEAN_C</span></code>  or  <code class="docutils literal"><span class="pre">ADAPTIVE_THRESH_GAUSSIAN_C</span></code> . See the details below.</li>
<li><strong>thresholdType</strong> &#8211; Thresholding type that must be either  <code class="docutils literal"><span class="pre">THRESH_BINARY</span></code>  or  <code class="docutils literal"><span class="pre">THRESH_BINARY_INV</span></code> .</li>
<li><strong>blockSize</strong> &#8211; Size of a pixel neighborhood that is used to calculate a threshold value for the pixel: 3, 5, 7, and so on.</li>
<li><strong>C</strong> &#8211; Constant subtracted from the mean or weighted mean (see the details below). Normally, it is positive but may be zero or negative as well.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<p>The function transforms a grayscale image to a binary image according to the formulae:</p>
<blockquote>
<div><ul>
<li><p class="first"><strong>THRESH_BINARY</strong></p>
<blockquote>
<div><div class="math">
<p><img src="../../../_images/math/7df8e198374f12e5e28ff32b34d49ecb2fbdddb4.png" alt="dst(x,y) =  \fork{\texttt{maxValue}}{if $src(x,y) &gt; T(x,y)$}{0}{otherwise}"/></p>
</div></div></blockquote>
</li>
<li><p class="first"><strong>THRESH_BINARY_INV</strong></p>
<blockquote>
<div><div class="math">
<p><img src="../../../_images/math/59b5b25f1acebef583c96c77c49354b22f871560.png" alt="dst(x,y) =  \fork{0}{if $src(x,y) &gt; T(x,y)$}{\texttt{maxValue}}{otherwise}"/></p>
</div></div></blockquote>
</li>
</ul>
</div></blockquote>
<p>where
<img class="math" src="../../../_images/math/5e11673cd01013b82529c8316a1505243cea62ad.png" alt="T(x,y)"/> is a threshold calculated individually for each pixel.</p>
<ul class="simple">
<li>For the method <code class="docutils literal"><span class="pre">ADAPTIVE_THRESH_MEAN_C</span></code>  , the threshold value
<img class="math" src="../../../_images/math/5e11673cd01013b82529c8316a1505243cea62ad.png" alt="T(x,y)"/>     is a mean of the
<img class="math" src="../../../_images/math/91b988f5a3acb7025e903a2b1bc6b7558e5970dd.png" alt="\texttt{blockSize} \times \texttt{blockSize}"/>     neighborhood of
<img class="math" src="../../../_images/math/dee21a914bf9088bc0dfbd38a96c1f859c412ec7.png" alt="(x, y)"/>     minus <code class="docutils literal"><span class="pre">C</span></code>     .</li>
<li>For the method <code class="docutils literal"><span class="pre">ADAPTIVE_THRESH_GAUSSIAN_C</span></code> , the threshold value
<img class="math" src="../../../_images/math/0f2558a6357e54ae9a3cd1799dd33ffc088bf25d.png" alt="T(x, y)"/>     is a weighted sum (cross-correlation with a Gaussian window) of the
<img class="math" src="../../../_images/math/91b988f5a3acb7025e903a2b1bc6b7558e5970dd.png" alt="\texttt{blockSize} \times \texttt{blockSize}"/>     neighborhood of
<img class="math" src="../../../_images/math/dee21a914bf9088bc0dfbd38a96c1f859c412ec7.png" alt="(x, y)"/>      minus <code class="docutils literal"><span class="pre">C</span></code>     . The default sigma (standard deviation) is used for the specified <code class="docutils literal"><span class="pre">blockSize</span></code>   . See
<a class="reference internal" href="filtering.html#Mat getGaussianKernel(int ksize, double sigma, int ktype)" title="Mat getGaussianKernel(int ksize, double sigma, int ktype)"><code class="xref ocv ocv-func docutils literal"><span class="pre">getGaussianKernel()</span></code></a>     .</li>
</ul>
<p>The function can process the image in-place.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#double threshold(InputArray src, OutputArray dst, double thresh, double maxval, int type)" title="double threshold(InputArray src, OutputArray dst, double thresh, double maxval, int type)"><code class="xref ocv ocv-func docutils literal"><span class="pre">threshold()</span></code></a>,
<a class="reference internal" href="filtering.html#void blur(InputArray src, OutputArray dst, Size ksize, Point anchor, int borderType)" title="void blur(InputArray src, OutputArray dst, Size ksize, Point anchor, int borderType)"><code class="xref ocv ocv-func docutils literal"><span class="pre">blur()</span></code></a>,
<a class="reference internal" href="filtering.html#void GaussianBlur(InputArray src, OutputArray dst, Size ksize, double sigmaX, double sigmaY, int borderType)" title="void GaussianBlur(InputArray src, OutputArray dst, Size ksize, double sigmaX, double sigmaY, int borderType)"><code class="xref ocv ocv-func docutils literal"><span class="pre">GaussianBlur()</span></code></a></p>
</div>
</div>
<div class="section" id="cvtcolor">
<h2>cvtColor<a class="headerlink" href="#cvtcolor" title="Permalink to this headline">¶</a></h2>
<p>Converts an image from one color space to another.</p>
<dl class="function">
<dt id="void cvtColor(InputArray src, OutputArray dst, int code, int dstCn)">
<strong>C++:</strong><code class="descname"> </code>void <code class="descname">cvtColor</code><span class="sig-paren">(</span>InputArray <strong>src</strong>, OutputArray <strong>dst</strong>, int <strong>code</strong>, int <strong>dstCn</strong>=0 <span class="sig-paren">)</span><a class="headerlink" href="#void cvtColor(InputArray src, OutputArray dst, int code, int dstCn)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="pyfunction">
<dt id="cv2.cvtColor">
<strong>Python:</strong><code class="descname"> </code><code class="descclassname">cv2.</code><code class="descname">cvtColor</code><span class="sig-paren">(</span>src, code<span class="optional">[</span>, dst<span class="optional">[</span>, dstCn<span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span> &rarr; dst<a class="headerlink" href="#cv2.cvtColor" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="cfunction">
<dt id="void cvCvtColor(const CvArr* src, CvArr* dst, int code)">
<strong>C:</strong><code class="descname"> </code>void <code class="descname">cvCvtColor</code><span class="sig-paren">(</span>const CvArr* <strong>src</strong>, CvArr* <strong>dst</strong>, int <strong>code</strong><span class="sig-paren">)</span><a class="headerlink" href="#void cvCvtColor(const CvArr* src, CvArr* dst, int code)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="pyoldfunction">
<dt id="cv.CvtColor">
<strong>Python:</strong><code class="descname"> </code><code class="descclassname">cv.</code><code class="descname">CvtColor</code><span class="sig-paren">(</span>src, dst, code<span class="sig-paren">)</span> &rarr; None<a class="headerlink" href="#cv.CvtColor" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>src</strong> &#8211; input image: 8-bit unsigned, 16-bit unsigned ( <code class="docutils literal"><span class="pre">CV_16UC...</span></code> ), or single-precision floating-point.</li>
<li><strong>dst</strong> &#8211; output image of the same size and depth as <code class="docutils literal"><span class="pre">src</span></code>.</li>
<li><strong>code</strong> &#8211; color space conversion code (see the description below).</li>
<li><strong>dstCn</strong> &#8211; number of channels in the destination image; if the parameter is 0, the number of the channels is derived automatically from  <code class="docutils literal"><span class="pre">src</span></code>  and   <code class="docutils literal"><span class="pre">code</span></code> .</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<p>The function converts an input image from one color
space to another. In case of a transformation to-from RGB color space, the order of the channels should be specified explicitly (RGB or BGR).
Note that the default color format in OpenCV is often referred to as RGB but it is actually BGR (the bytes are reversed). So the first byte in a standard (24-bit) color image will be an 8-bit Blue component, the second byte will be Green, and the third byte will be Red. The fourth, fifth, and sixth bytes would then be the second pixel (Blue, then Green, then Red), and so on.</p>
<p>The conventional ranges for R, G, and B channel values are:</p>
<ul class="simple">
<li>0 to 255 for <code class="docutils literal"><span class="pre">CV_8U</span></code>     images</li>
<li>0 to 65535 for <code class="docutils literal"><span class="pre">CV_16U</span></code>     images</li>
<li>0 to 1 for <code class="docutils literal"><span class="pre">CV_32F</span></code>     images</li>
</ul>
<p>In case of linear transformations, the range does not matter.
But in case of a non-linear transformation, an input RGB image should be normalized to the proper value range to get the correct results, for example, for RGB
<img class="math" src="../../../_images/math/58b7ec42688624f44250d3934b7d7da5164dae2c.png" alt="\rightarrow"/> L*u*v* transformation. For example, if you have a 32-bit floating-point image directly converted from an 8-bit image without any scaling, then it will have the 0..255 value range instead of 0..1 assumed by the function. So, before calling <code class="docutils literal"><span class="pre">cvtColor</span></code> , you need first to scale the image down:</p>
<div class="highlight-cpp"><div class="highlight"><pre><span class="n">img</span> <span class="o">*=</span> <span class="mf">1.</span><span class="o">/</span><span class="mi">255</span><span class="p">;</span>
<span class="n">cvtColor</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">img</span><span class="p">,</span> <span class="n">CV_BGR2Luv</span><span class="p">);</span>
</pre></div>
</div>
<p>If you use <code class="docutils literal"><span class="pre">cvtColor</span></code> with 8-bit images, the conversion will have some information lost. For many applications, this will not be noticeable but it is recommended to use 32-bit images in applications that need the full range of colors or that convert an image before an operation and then convert back.</p>
<p>If conversion adds the alpha channel, its value will set to the maximum of corresponding channel range: 255 for <code class="docutils literal"><span class="pre">CV_8U</span></code>, 65535 for <code class="docutils literal"><span class="pre">CV_16U</span></code>, 1 for <code class="docutils literal"><span class="pre">CV_32F</span></code>.</p>
<p>The function can do the following transformations:</p>
<ul>
<li><p class="first">RGB <img class="math" src="../../../_images/math/1894d1c8d154f0462cc2f2638ba5792087e8a387.png" alt="\leftrightarrow"/> GRAY ( <code class="docutils literal"><span class="pre">CV_BGR2GRAY,</span> <span class="pre">CV_RGB2GRAY,</span> <span class="pre">CV_GRAY2BGR,</span> <span class="pre">CV_GRAY2RGB</span></code>     )
Transformations within RGB space like adding/removing the alpha channel, reversing the channel order, conversion to/from 16-bit RGB color (R5:G6:B5 or R5:G5:B5), as well as conversion to/from grayscale using:</p>
<div class="math">
<p><img src="../../../_images/math/36b21ba24ff32d923fd71e99849a0a903311e19b.png" alt="\text{RGB[A] to Gray:} \quad Y  \leftarrow 0.299  \cdot R + 0.587  \cdot G + 0.114  \cdot B"/></p>
</div><p>and</p>
<div class="math">
<p><img src="../../../_images/math/1970617ee21613b4418e836ba016e7e94cb065ce.png" alt="\text{Gray to RGB[A]:} \quad R  \leftarrow Y, G  \leftarrow Y, B  \leftarrow Y, A  \leftarrow \max (ChannelRange)"/></p>
</div><p>The conversion from a RGB image to gray is done with:</p>
<div class="highlight-cpp"><div class="highlight"><pre><span class="n">cvtColor</span><span class="p">(</span><span class="n">src</span><span class="p">,</span> <span class="n">bwsrc</span><span class="p">,</span> <span class="n">CV_RGB2GRAY</span><span class="p">);</span>
</pre></div>
</div>
<p>More advanced channel reordering can also be done with
<a class="reference internal" href="../../core/doc/operations_on_arrays.html#void mixChannels(const Mat* src, size_t nsrcs, Mat* dst, size_t ndsts, const int* fromTo, size_t npairs)" title="void mixChannels(const Mat* src, size_t nsrcs, Mat* dst, size_t ndsts, const int* fromTo, size_t npairs)"><code class="xref ocv ocv-func docutils literal"><span class="pre">mixChannels()</span></code></a>     .</p>
</li>
<li><p class="first">RGB
<img class="math" src="../../../_images/math/1894d1c8d154f0462cc2f2638ba5792087e8a387.png" alt="\leftrightarrow"/>     CIE XYZ.Rec 709 with D65 white point ( <code class="docutils literal"><span class="pre">CV_BGR2XYZ,</span> <span class="pre">CV_RGB2XYZ,</span> <span class="pre">CV_XYZ2BGR,</span> <span class="pre">CV_XYZ2RGB</span></code>     ):</p>
<div class="math">
<p><img src="../../../_images/math/1d2bd4711fcf02fe24dd5f04477574f499c760b5.png" alt="\begin{bmatrix} X  \\ Y  \\ Z
  \end{bmatrix} \leftarrow \begin{bmatrix} 0.412453 &amp; 0.357580 &amp; 0.180423 \\ 0.212671 &amp; 0.715160 &amp; 0.072169 \\ 0.019334 &amp; 0.119193 &amp; 0.950227
  \end{bmatrix} \cdot \begin{bmatrix} R  \\ G  \\ B
  \end{bmatrix}"/></p>
</div><div class="math">
<p><img src="../../../_images/math/60cb0d9e0e1284c02e11802d0864a15d893a5dbd.png" alt="\begin{bmatrix} R  \\ G  \\ B
  \end{bmatrix} \leftarrow \begin{bmatrix} 3.240479 &amp; -1.53715 &amp; -0.498535 \\ -0.969256 &amp;  1.875991 &amp; 0.041556 \\ 0.055648 &amp; -0.204043 &amp; 1.057311
  \end{bmatrix} \cdot \begin{bmatrix} X  \\ Y  \\ Z
  \end{bmatrix}"/></p>
</div><p><img class="math" src="../../../_images/math/fafd29e009c7f1dad892ccedf94e8d48d8a94c45.png" alt="X"/>,    <img class="math" src="../../../_images/math/33936c028e3bfe7bd975bfb7f652584dc9f26316.png" alt="Y"/>     and
<img class="math" src="../../../_images/math/7185d39c5663084d0d891f7416d223f32f3b63e2.png" alt="Z"/>     cover the whole value range (in case of floating-point images,
<img class="math" src="../../../_images/math/7185d39c5663084d0d891f7416d223f32f3b63e2.png" alt="Z"/>     may exceed 1).</p>
</li>
<li><p class="first">RGB
<img class="math" src="../../../_images/math/1894d1c8d154f0462cc2f2638ba5792087e8a387.png" alt="\leftrightarrow"/>     YCrCb JPEG (or YCC) ( <code class="docutils literal"><span class="pre">CV_BGR2YCrCb,</span> <span class="pre">CV_RGB2YCrCb,</span> <span class="pre">CV_YCrCb2BGR,</span> <span class="pre">CV_YCrCb2RGB</span></code>     )</p>
<div class="math">
<p><img src="../../../_images/math/76c3f5fad2fceb004b65ff24934b113ed62381b7.png" alt="Y  \leftarrow 0.299  \cdot R + 0.587  \cdot G + 0.114  \cdot B"/></p>
</div><div class="math">
<p><img src="../../../_images/math/6b441940fbf4d16127c8dda6417fe684b74b923b.png" alt="Cr  \leftarrow (R-Y)  \cdot 0.713 + delta"/></p>
</div><div class="math">
<p><img src="../../../_images/math/bddc84de9cfda53191392467beb5a8e3b968d405.png" alt="Cb  \leftarrow (B-Y)  \cdot 0.564 + delta"/></p>
</div><div class="math">
<p><img src="../../../_images/math/785f83d75eae002bfe0f0eaab9e61c4bce453a2e.png" alt="R  \leftarrow Y + 1.403  \cdot (Cr - delta)"/></p>
</div><div class="math">
<p><img src="../../../_images/math/68eb1e7879119380f2c66ac12d177ca3c0d2a4f4.png" alt="G  \leftarrow Y - 0.714  \cdot (Cr - delta) - 0.344  \cdot (Cb - delta)"/></p>
</div><div class="math">
<p><img src="../../../_images/math/d5bc720f4370e483b317ddcf3040e11d0800b778.png" alt="B  \leftarrow Y + 1.773  \cdot (Cb - delta)"/></p>
</div><p>where</p>
<div class="math">
<p><img src="../../../_images/math/d6f3970cdf54f4782f59fb96052d98df88731949.png" alt="delta =  \left \{ \begin{array}{l l} 128 &amp;  \mbox{for 8-bit images} \\ 32768 &amp;  \mbox{for 16-bit images} \\ 0.5 &amp;  \mbox{for floating-point images} \end{array} \right ."/></p>
</div><p>Y, Cr, and Cb cover the whole value range.</p>
</li>
<li><dl class="first docutils">
<dt>RGB <img class="math" src="../../../_images/math/1894d1c8d154f0462cc2f2638ba5792087e8a387.png" alt="\leftrightarrow"/> HSV ( <code class="docutils literal"><span class="pre">CV_BGR2HSV,</span> <span class="pre">CV_RGB2HSV,</span> <span class="pre">CV_HSV2BGR,</span> <span class="pre">CV_HSV2RGB</span></code>     )</dt>
<dd><p class="first last">In case of 8-bit and 16-bit images,
R, G, and B are converted to the floating-point format and scaled to fit the 0 to 1 range.</p>
</dd>
</dl>
<div class="math">
<p><img src="../../../_images/math/7be483aa0fb72e56fa54c7cc754c149c8c1c80b1.png" alt="V  \leftarrow max(R,G,B)"/></p>
</div><div class="math">
<p><img src="../../../_images/math/75071d1d50b8ea1d3d0aa0530d5e848e5748666d.png" alt="S  \leftarrow \fork{\frac{V-min(R,G,B)}{V}}{if $V \neq 0$}{0}{otherwise}"/></p>
</div><div class="math">
<p><img src="../../../_images/math/9208f149119189c111d1250c1b628f452e68e4b2.png" alt="H  \leftarrow \forkthree{{60(G - B)}/{(V-min(R,G,B))}}{if $V=R$}{{120+60(B - R)}/{(V-min(R,G,B))}}{if $V=G$}{{240+60(R - G)}/{(V-min(R,G,B))}}{if $V=B$}"/></p>
</div><p>If
<img class="math" src="../../../_images/math/4b55446180843f63a5fec27942c52ff27fcae5fb.png" alt="H&lt;0"/>     then
<img class="math" src="../../../_images/math/2b5fe43115fa7ed8ed6318177b38a1e8872017a8.png" alt="H \leftarrow H+360"/>  . On output
<img class="math" src="../../../_images/math/951866bd108e73fab9e086712602d5ddce66f58c.png" alt="0 \leq V \leq 1"/>,    <img class="math" src="../../../_images/math/6b298499e31e511303e9ab0f6618457f382acec9.png" alt="0 \leq S \leq 1"/>,    <img class="math" src="../../../_images/math/dd152f0c22d9add7fc402ab209e1709e78aa28d3.png" alt="0 \leq H \leq 360"/>     .</p>
<p>The values are then converted to the destination data type:</p>
<ul>
<li><p class="first">8-bit images</p>
<blockquote>
<div><div class="math">
<p><img src="../../../_images/math/fee43df0bdd78b4fa081423a65c45fb8756a6d55.png" alt="V  \leftarrow 255 V, S  \leftarrow 255 S, H  \leftarrow H/2  \text{(to fit to 0 to 255)}"/></p>
</div></div></blockquote>
</li>
<li><p class="first">16-bit images (currently not supported)</p>
<blockquote>
<div><div class="math">
<p><img src="../../../_images/math/32d179a25ec3ed09a580b92746af3e5c2df8275f.png" alt="V &lt;- 65535 V, S &lt;- 65535 S, H &lt;- H"/></p>
</div></div></blockquote>
</li>
<li><dl class="first docutils">
<dt>32-bit images</dt>
<dd><p class="first last">H, S, and V are left as is</p>
</dd>
</dl>
</li>
</ul>
</li>
<li><dl class="first docutils">
<dt>RGB <img class="math" src="../../../_images/math/1894d1c8d154f0462cc2f2638ba5792087e8a387.png" alt="\leftrightarrow"/> HLS ( <code class="docutils literal"><span class="pre">CV_BGR2HLS,</span> <span class="pre">CV_RGB2HLS,</span> <span class="pre">CV_HLS2BGR,</span> <span class="pre">CV_HLS2RGB</span></code> ).</dt>
<dd><p class="first last">In case of 8-bit and 16-bit images,
R, G, and B are converted to the floating-point format and scaled to fit the 0 to 1 range.</p>
</dd>
</dl>
<div class="math">
<p><img src="../../../_images/math/c53957c2e14819ba58b2c36819265318560bafed.png" alt="V_{max}  \leftarrow {max}(R,G,B)"/></p>
</div><div class="math">
<p><img src="../../../_images/math/4a775f57b71707b736edb37af1b945c7a59238a6.png" alt="V_{min}  \leftarrow {min}(R,G,B)"/></p>
</div><div class="math">
<p><img src="../../../_images/math/2cc20c39cb81730800c53c0aee591ae1fa9c3eeb.png" alt="L  \leftarrow \frac{V_{max} + V_{min}}{2}"/></p>
</div><div class="math">
<p><img src="../../../_images/math/a9c8dafccf4d3869bf5c29be11d3da994f2cae7d.png" alt="S  \leftarrow \fork { \frac{V_{max} - V_{min}}{V_{max} + V_{min}} }{if  $L &lt; 0.5$ }
    { \frac{V_{max} - V_{min}}{2 - (V_{max} + V_{min})} }{if  $L \ge 0.5$ }"/></p>
</div><div class="math">
<p><img src="../../../_images/math/009b2c865204c9e3a13ba53ee1e6a11f0a696623.png" alt="H  \leftarrow \forkthree {{60(G - B)}/{S}}{if  $V_{max}=R$ }
  {{120+60(B - R)}/{S}}{if  $V_{max}=G$ }
  {{240+60(R - G)}/{S}}{if  $V_{max}=B$ }"/></p>
</div><p>If
<img class="math" src="../../../_images/math/4b55446180843f63a5fec27942c52ff27fcae5fb.png" alt="H&lt;0"/>     then
<img class="math" src="../../../_images/math/2b5fe43115fa7ed8ed6318177b38a1e8872017a8.png" alt="H \leftarrow H+360"/>  . On output
<img class="math" src="../../../_images/math/b3e2153e29ab78d8c7078261eee2e2993e558a0c.png" alt="0 \leq L \leq 1"/>,    <img class="math" src="../../../_images/math/6b298499e31e511303e9ab0f6618457f382acec9.png" alt="0 \leq S \leq 1"/>,    <img class="math" src="../../../_images/math/dd152f0c22d9add7fc402ab209e1709e78aa28d3.png" alt="0 \leq H \leq 360"/>     .</p>
<p>The values are then converted to the destination data type:</p>
<ul>
<li><p class="first">8-bit images</p>
<blockquote>
<div><div class="math">
<p><img src="../../../_images/math/91a8336562f1871e42811a1522332517e5407d5b.png" alt="V  \leftarrow 255 \cdot V, S  \leftarrow 255 \cdot S, H  \leftarrow H/2 \; \text{(to fit to 0 to 255)}"/></p>
</div></div></blockquote>
</li>
<li><p class="first">16-bit images (currently not supported)</p>
<blockquote>
<div><div class="math">
<p><img src="../../../_images/math/f19c2ab2c9bec3b0dcf1e65de883faa4412231ea.png" alt="V &lt;- 65535 \cdot V, S &lt;- 65535 \cdot S, H &lt;- H"/></p>
</div></div></blockquote>
</li>
<li><dl class="first docutils">
<dt>32-bit images</dt>
<dd><p class="first last">H, S, V are left as is</p>
</dd>
</dl>
</li>
</ul>
</li>
<li><dl class="first docutils">
<dt>RGB <img class="math" src="../../../_images/math/1894d1c8d154f0462cc2f2638ba5792087e8a387.png" alt="\leftrightarrow"/> CIE L*a*b* ( <code class="docutils literal"><span class="pre">CV_BGR2Lab,</span> <span class="pre">CV_RGB2Lab,</span> <span class="pre">CV_Lab2BGR,</span> <span class="pre">CV_Lab2RGB</span></code> ).</dt>
<dd><p class="first last">In case of 8-bit and 16-bit images,
R, G, and B are converted to the floating-point format and scaled to fit the 0 to 1 range.</p>
</dd>
</dl>
<div class="math">
<p><img src="../../../_images/math/0b40a48524601a0d685d08f6e99494dd2abca9cd.png" alt="\vecthree{X}{Y}{Z} \leftarrow \vecthreethree{0.412453}{0.357580}{0.180423}{0.212671}{0.715160}{0.072169}{0.019334}{0.119193}{0.950227} \cdot \vecthree{R}{G}{B}"/></p>
</div><div class="math">
<p><img src="../../../_images/math/f339c7a01c8c392d83d04dc3cde0627d0d5aee4e.png" alt="X  \leftarrow X/X_n,  \text{where} X_n = 0.950456"/></p>
</div><div class="math">
<p><img src="../../../_images/math/aa85b5b8031add20f0825aa37750dc8b8789aa7a.png" alt="Z  \leftarrow Z/Z_n,  \text{where} Z_n = 1.088754"/></p>
</div><div class="math">
<p><img src="../../../_images/math/45d31c15f8cc5532bd832c00bb99ff1dab790203.png" alt="L  \leftarrow \fork{116*Y^{1/3}-16}{for $Y&gt;0.008856$}{903.3*Y}{for $Y \le 0.008856$}"/></p>
</div><div class="math">
<p><img src="../../../_images/math/3740b66fbff95aa9dfe9b005bd6ad7f28207992b.png" alt="a  \leftarrow 500 (f(X)-f(Y)) + delta"/></p>
</div><div class="math">
<p><img src="../../../_images/math/f882025ffbd219a8826d69c8ecab6e436c5b0b44.png" alt="b  \leftarrow 200 (f(Y)-f(Z)) + delta"/></p>
</div><p>where</p>
<div class="math">
<p><img src="../../../_images/math/a15bb80fffbb76b76ea7869a4665f35ba2915461.png" alt="f(t)= \fork{t^{1/3}}{for $t&gt;0.008856$}{7.787 t+16/116}{for $t\leq 0.008856$}"/></p>
</div><p>and</p>
<div class="math">
<p><img src="../../../_images/math/35fbc56624a7f26f4f1166946578f36449526b23.png" alt="delta =  \fork{128}{for 8-bit images}{0}{for floating-point images}"/></p>
</div><p>This outputs
<img class="math" src="../../../_images/math/4d1470b865aa2ee18820cc9262f414a4c33e9aa1.png" alt="0 \leq L \leq 100"/>,    <img class="math" src="../../../_images/math/15d7fd7d2269c523526dc6f1b252754a6c01e76c.png" alt="-127 \leq a \leq 127"/>,    <img class="math" src="../../../_images/math/7d0ac0b05787b0ac9058cdc66473e92a548ff2a5.png" alt="-127 \leq b \leq 127"/>  . The values are then converted to the destination data type:</p>
<ul>
<li><p class="first">8-bit images</p>
<blockquote>
<div><div class="math">
<p><img src="../../../_images/math/c917221ac2ce71be9d029c48a413c701fe6ff959.png" alt="L  \leftarrow L*255/100, \; a  \leftarrow a + 128, \; b  \leftarrow b + 128"/></p>
</div></div></blockquote>
</li>
<li><dl class="first docutils">
<dt>16-bit images</dt>
<dd><p class="first last">(currently not supported)</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>32-bit images</dt>
<dd><p class="first last">L, a, and b are left as is</p>
</dd>
</dl>
</li>
</ul>
</li>
<li><dl class="first docutils">
<dt>RGB <img class="math" src="../../../_images/math/1894d1c8d154f0462cc2f2638ba5792087e8a387.png" alt="\leftrightarrow"/> CIE L*u*v* ( <code class="docutils literal"><span class="pre">CV_BGR2Luv,</span> <span class="pre">CV_RGB2Luv,</span> <span class="pre">CV_Luv2BGR,</span> <span class="pre">CV_Luv2RGB</span></code> ).</dt>
<dd><p class="first last">In case of 8-bit and 16-bit images,
R, G, and B are converted to the floating-point format and scaled to fit 0 to 1 range.</p>
</dd>
</dl>
<div class="math">
<p><img src="../../../_images/math/0b40a48524601a0d685d08f6e99494dd2abca9cd.png" alt="\vecthree{X}{Y}{Z} \leftarrow \vecthreethree{0.412453}{0.357580}{0.180423}{0.212671}{0.715160}{0.072169}{0.019334}{0.119193}{0.950227} \cdot \vecthree{R}{G}{B}"/></p>
</div><div class="math">
<p><img src="../../../_images/math/2d33078558463fd51061a32889d2fb73d116849b.png" alt="L  \leftarrow \fork{116 Y^{1/3}}{for $Y&gt;0.008856$}{903.3 Y}{for $Y\leq 0.008856$}"/></p>
</div><div class="math">
<p><img src="../../../_images/math/6452868fabc29d9f441f69babb4d6156489cd7cf.png" alt="u'  \leftarrow 4*X/(X + 15*Y + 3 Z)"/></p>
</div><div class="math">
<p><img src="../../../_images/math/faa0c440d4cc6f6bca6f7f42a6e6d7fc2a0ebb56.png" alt="v'  \leftarrow 9*Y/(X + 15*Y + 3 Z)"/></p>
</div><div class="math">
<p><img src="../../../_images/math/ac31cff54fd070c1a966a2b8fcc7d17b34bef0c0.png" alt="u  \leftarrow 13*L*(u' - u_n)  \quad \text{where} \quad u_n=0.19793943"/></p>
</div><div class="math">
<p><img src="../../../_images/math/b680ef8586b4915aa1762f41ee01ae77b92862d0.png" alt="v  \leftarrow 13*L*(v' - v_n)  \quad \text{where} \quad v_n=0.46831096"/></p>
</div><p>This outputs
<img class="math" src="../../../_images/math/4d1470b865aa2ee18820cc9262f414a4c33e9aa1.png" alt="0 \leq L \leq 100"/>,    <img class="math" src="../../../_images/math/dd0983c06db8772505bee5a7c6bcbb731d32b856.png" alt="-134 \leq u \leq 220"/>,    <img class="math" src="../../../_images/math/274f3f04195fad44013a3b21f53f2ec4c8002202.png" alt="-140 \leq v \leq 122"/>     .</p>
<p>The values are then converted to the destination data type:</p>
<ul>
<li><p class="first">8-bit images</p>
<blockquote>
<div><div class="math">
<p><img src="../../../_images/math/160bf619e9144baeb085c9fdc480c147e9689109.png" alt="L  \leftarrow 255/100 L, \; u  \leftarrow 255/354 (u + 134), \; v  \leftarrow 255/262 (v + 140)"/></p>
</div></div></blockquote>
</li>
<li><dl class="first docutils">
<dt>16-bit images</dt>
<dd><p class="first last">(currently not supported)</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>32-bit images</dt>
<dd><p class="first last">L, u, and v are left as is</p>
</dd>
</dl>
</li>
</ul>
<p>The above formulae for converting RGB to/from various color spaces have been taken from multiple sources on the web, primarily from the Charles Poynton site
<a class="reference external" href="http://www.poynton.com/ColorFAQ.html">http://www.poynton.com/ColorFAQ.html</a></p>
</li>
<li><p class="first">Bayer <img class="math" src="../../../_images/math/58b7ec42688624f44250d3934b7d7da5164dae2c.png" alt="\rightarrow"/>     RGB ( <code class="docutils literal"><span class="pre">CV_BayerBG2BGR,</span> <span class="pre">CV_BayerGB2BGR,</span> <span class="pre">CV_BayerRG2BGR,</span> <span class="pre">CV_BayerGR2BGR,</span> <span class="pre">CV_BayerBG2RGB,</span> <span class="pre">CV_BayerGB2RGB,</span> <span class="pre">CV_BayerRG2RGB,</span> <span class="pre">CV_BayerGR2RGB</span></code>     ). The Bayer pattern is widely used in CCD and CMOS cameras. It enables you to get color pictures from a single plane where R,G, and B pixels (sensors of a particular component) are interleaved as follows:</p>
<img alt="../../../_images/bayer.png" src="../../../_images/bayer.png" />
<p>The output RGB components of a pixel are interpolated from 1, 2, or
4 neighbors of the pixel having the same color. There are several
modifications of the above pattern that can be achieved by shifting
the pattern one pixel left and/or one pixel up. The two letters
<img class="math" src="../../../_images/math/7cafcd8c1d62710ea752ea0ab15e0e62551a6b1d.png" alt="C_1"/>     and
<img class="math" src="../../../_images/math/77420e30b02fde3da9c24065c7f25dfe100124d1.png" alt="C_2"/>     in the conversion constants <code class="docutils literal"><span class="pre">CV_Bayer</span></code>     <img class="math" src="../../../_images/math/8d0708db920bce41456ce12d83cfb35e6cac31c9.png" alt="C_1 C_2"/>     <code class="docutils literal"><span class="pre">2BGR</span></code>     and <code class="docutils literal"><span class="pre">CV_Bayer</span></code>     <img class="math" src="../../../_images/math/8d0708db920bce41456ce12d83cfb35e6cac31c9.png" alt="C_1 C_2"/>     <code class="docutils literal"><span class="pre">2RGB</span></code>     indicate the particular pattern
type. These are components from the second row, second and third
columns, respectively. For example, the above pattern has a very
popular &#8220;BG&#8221; type.</p>
</li>
</ul>
</div>
<div class="section" id="distancetransform">
<h2>distanceTransform<a class="headerlink" href="#distancetransform" title="Permalink to this headline">¶</a></h2>
<p>Calculates the distance to the closest zero pixel for each pixel of the source image.</p>
<dl class="function">
<dt id="void distanceTransform(InputArray src, OutputArray dst, int distanceType, int maskSize)">
<strong>C++:</strong><code class="descname"> </code>void <code class="descname">distanceTransform</code><span class="sig-paren">(</span>InputArray <strong>src</strong>, OutputArray <strong>dst</strong>, int <strong>distanceType</strong>, int <strong>maskSize</strong><span class="sig-paren">)</span><a class="headerlink" href="#void distanceTransform(InputArray src, OutputArray dst, int distanceType, int maskSize)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="void distanceTransform(InputArray src, OutputArray dst, OutputArray labels, int distanceType, int maskSize, int labelType)">
<strong>C++:</strong><code class="descname"> </code>void <code class="descname">distanceTransform</code><span class="sig-paren">(</span>InputArray <strong>src</strong>, OutputArray <strong>dst</strong>, OutputArray <strong>labels</strong>, int <strong>distanceType</strong>, int <strong>maskSize</strong>, int <strong>labelType</strong>=DIST_LABEL_CCOMP <span class="sig-paren">)</span><a class="headerlink" href="#void distanceTransform(InputArray src, OutputArray dst, OutputArray labels, int distanceType, int maskSize, int labelType)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="pyfunction">
<dt id="cv2.distanceTransform">
<strong>Python:</strong><code class="descname"> </code><code class="descclassname">cv2.</code><code class="descname">distanceTransform</code><span class="sig-paren">(</span>src, distanceType, maskSize<span class="optional">[</span>, dst<span class="optional">]</span><span class="sig-paren">)</span> &rarr; dst<a class="headerlink" href="#cv2.distanceTransform" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="cfunction">
<dt id="void cvDistTransform(const CvArr* src, CvArr* dst, int distance_type, int mask_size, const float* mask, CvArr* labels, int labelType)">
<strong>C:</strong><code class="descname"> </code>void <code class="descname">cvDistTransform</code><span class="sig-paren">(</span>const CvArr* <strong>src</strong>, CvArr* <strong>dst</strong>, int <strong>distance_type</strong>=CV_DIST_L2, int <strong>mask_size</strong>=3, const float* <strong>mask</strong>=NULL, CvArr* <strong>labels</strong>=NULL, int <strong>labelType</strong>=CV_DIST_LABEL_CCOMP <span class="sig-paren">)</span><a class="headerlink" href="#void cvDistTransform(const CvArr* src, CvArr* dst, int distance_type, int mask_size, const float* mask, CvArr* labels, int labelType)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="pyoldfunction">
<dt id="cv.DistTransform">
<strong>Python:</strong><code class="descname"> </code><code class="descclassname">cv.</code><code class="descname">DistTransform</code><span class="sig-paren">(</span>src, dst, distance_type=CV_DIST_L2, mask_size=3, mask=None, labels=None<span class="sig-paren">)</span> &rarr; None<a class="headerlink" href="#cv.DistTransform" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>src</strong> &#8211; 8-bit, single-channel (binary) source image.</li>
<li><strong>dst</strong> &#8211; Output image with calculated distances. It is a 32-bit floating-point, single-channel image of the same size as  <code class="docutils literal"><span class="pre">src</span></code> .</li>
<li><strong>distanceType</strong> &#8211; Type of distance. It can be  <code class="docutils literal"><span class="pre">CV_DIST_L1,</span> <span class="pre">CV_DIST_L2</span></code> , or  <code class="docutils literal"><span class="pre">CV_DIST_C</span></code> .</li>
<li><strong>maskSize</strong> &#8211; Size of the distance transform mask. It can be 3, 5, or  <code class="docutils literal"><span class="pre">CV_DIST_MASK_PRECISE</span></code>  (the latter option is only supported by the first function). In case of the <code class="docutils literal"><span class="pre">CV_DIST_L1</span></code>  or  <code class="docutils literal"><span class="pre">CV_DIST_C</span></code>  distance type, the parameter is forced to 3 because a  <img class="math" src="../../../_images/math/268e62297468c4d7ef109727ed4bcbfad953ad61.png" alt="3\times 3"/>  mask gives the same result as  <img class="math" src="../../../_images/math/67d155c6af0e36444737e9fa2f782f7d5c9b3f6a.png" alt="5\times 5"/>  or any larger aperture.</li>
<li><strong>labels</strong> &#8211; Optional output 2D array of labels (the discrete Voronoi diagram). It has the type  <code class="docutils literal"><span class="pre">CV_32SC1</span></code>  and the same size as  <code class="docutils literal"><span class="pre">src</span></code> . See the details below.</li>
<li><strong>labelType</strong> &#8211; Type of the label array to build. If <code class="docutils literal"><span class="pre">labelType==DIST_LABEL_CCOMP</span></code> then each connected component of zeros in <code class="docutils literal"><span class="pre">src</span></code> (as well as all the non-zero pixels closest to the connected component) will be assigned the same label. If <code class="docutils literal"><span class="pre">labelType==DIST_LABEL_PIXEL</span></code> then each zero pixel (and all the non-zero pixels closest to it) gets its own label.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<p>The functions <code class="docutils literal"><span class="pre">distanceTransform</span></code> calculate the approximate or precise
distance from every binary image pixel to the nearest zero pixel.
For zero image pixels, the distance will obviously be zero.</p>
<p>When <code class="docutils literal"><span class="pre">maskSize</span> <span class="pre">==</span> <span class="pre">CV_DIST_MASK_PRECISE</span></code> and <code class="docutils literal"><span class="pre">distanceType</span> <span class="pre">==</span> <span class="pre">CV_DIST_L2</span></code> , the function runs the algorithm described in <a class="reference internal" href="#felzenszwalb04" id="id1">[Felzenszwalb04]</a>. This algorithm is parallelized with the TBB library.</p>
<p>In other cases, the algorithm
<a class="reference internal" href="#borgefors86" id="id2">[Borgefors86]</a>
is used. This means that
for a pixel the function finds the shortest path to the nearest zero pixel
consisting of basic shifts: horizontal,
vertical, diagonal, or knight&#8217;s move (the latest is available for a
<img class="math" src="../../../_images/math/67d155c6af0e36444737e9fa2f782f7d5c9b3f6a.png" alt="5\times 5"/> mask). The overall distance is calculated as a sum of these
basic distances. Since the distance function should be symmetric,
all of the horizontal and vertical shifts must have the same cost (denoted as <code class="docutils literal"><span class="pre">a</span></code> ), all the diagonal shifts must have the
same cost (denoted as <code class="docutils literal"><span class="pre">b</span></code> ), and all knight&#8217;s moves must have
the same cost (denoted as <code class="docutils literal"><span class="pre">c</span></code> ). For the <code class="docutils literal"><span class="pre">CV_DIST_C</span></code> and <code class="docutils literal"><span class="pre">CV_DIST_L1</span></code> types, the distance is calculated precisely,
whereas for <code class="docutils literal"><span class="pre">CV_DIST_L2</span></code> (Euclidean distance) the distance
can be calculated only with a relative error (a
<img class="math" src="../../../_images/math/67d155c6af0e36444737e9fa2f782f7d5c9b3f6a.png" alt="5\times 5"/> mask
gives more accurate results). For <code class="docutils literal"><span class="pre">a</span></code>,``b`` , and <code class="docutils literal"><span class="pre">c</span></code> , OpenCV uses the values suggested in the original paper:</p>
<table border="1" class="docutils">
<colgroup>
<col width="25%" />
<col width="35%" />
<col width="40%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head"><code class="docutils literal"><span class="pre">CV_DIST_C</span></code></th>
<th class="head"><img class="math" src="../../../_images/math/30ae08e980037194b4493813f5ecc68089333b81.png" alt="(3\times 3)"/></th>
<th class="head">a = 1, b = 1 </th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><code class="docutils literal"><span class="pre">CV_DIST_L1</span></code></td>
<td><img class="math" src="../../../_images/math/30ae08e980037194b4493813f5ecc68089333b81.png" alt="(3\times 3)"/></td>
<td>a = 1, b = 2 </td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">CV_DIST_L2</span></code></td>
<td><img class="math" src="../../../_images/math/30ae08e980037194b4493813f5ecc68089333b81.png" alt="(3\times 3)"/></td>
<td>a=0.955, b=1.3693 </td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">CV_DIST_L2</span></code></td>
<td><img class="math" src="../../../_images/math/5b71dae7b5bef5e8eec6f932c3f11a705c3e09f3.png" alt="(5\times 5)"/></td>
<td>a=1, b=1.4, c=2.1969 </td>
</tr>
</tbody>
</table>
<p>Typically, for a fast, coarse distance estimation <code class="docutils literal"><span class="pre">CV_DIST_L2</span></code>, a
<img class="math" src="../../../_images/math/268e62297468c4d7ef109727ed4bcbfad953ad61.png" alt="3\times 3"/> mask is used. For a more accurate distance estimation <code class="docutils literal"><span class="pre">CV_DIST_L2</span></code> , a
<img class="math" src="../../../_images/math/67d155c6af0e36444737e9fa2f782f7d5c9b3f6a.png" alt="5\times 5"/> mask or the precise algorithm is used.
Note that both the precise and the approximate algorithms are linear on the number of pixels.</p>
<p>The second variant of the function does not only compute the minimum distance for each pixel
<img class="math" src="../../../_images/math/dee21a914bf9088bc0dfbd38a96c1f859c412ec7.png" alt="(x, y)"/> but also identifies the nearest connected
component consisting of zero pixels (<code class="docutils literal"><span class="pre">labelType==DIST_LABEL_CCOMP</span></code>) or the nearest zero pixel (<code class="docutils literal"><span class="pre">labelType==DIST_LABEL_PIXEL</span></code>). Index of the component/pixel is stored in
<img class="math" src="../../../_images/math/047e269e79d6cf72ddc324582406aeefe3a31c69.png" alt="\texttt{labels}(x, y)"/> .
When <code class="docutils literal"><span class="pre">labelType==DIST_LABEL_CCOMP</span></code>, the function automatically finds connected components of zero pixels in the input image and marks them with distinct labels. When <code class="docutils literal"><span class="pre">labelType==DIST_LABEL_CCOMP</span></code>, the function scans through the input image and marks all the zero pixels with distinct labels.</p>
<p>In this mode, the complexity is still linear.
That is, the function provides a very fast way to compute the Voronoi diagram for a binary image.
Currently, the second variant can use only the approximate distance transform algorithm, i.e. <code class="docutils literal"><span class="pre">maskSize=CV_DIST_MASK_PRECISE</span></code> is not supported yet.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<ul class="last simple">
<li>An example on using the distance transform can be found at opencv_source_code/samples/cpp/distrans.cpp</li>
<li>(Python) An example on using the distance transform can be found at opencv_source/samples/python2/distrans.py</li>
</ul>
</div>
</div>
<div class="section" id="floodfill">
<h2>floodFill<a class="headerlink" href="#floodfill" title="Permalink to this headline">¶</a></h2>
<p>Fills a connected component with the given color.</p>
<dl class="function">
<dt id="int floodFill(InputOutputArray image, Point seedPoint, Scalar newVal, Rect* rect, Scalar loDiff, Scalar upDiff, int flags)">
<strong>C++:</strong><code class="descname"> </code>int <code class="descname">floodFill</code><span class="sig-paren">(</span>InputOutputArray <strong>image</strong>, Point <strong>seedPoint</strong>, Scalar <strong>newVal</strong>, Rect* <strong>rect</strong>=0, Scalar <strong>loDiff</strong>=Scalar(), Scalar <strong>upDiff</strong>=Scalar(), int <strong>flags</strong>=4 <span class="sig-paren">)</span><a class="headerlink" href="#int floodFill(InputOutputArray image, Point seedPoint, Scalar newVal, Rect* rect, Scalar loDiff, Scalar upDiff, int flags)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="int floodFill(InputOutputArray image, InputOutputArray mask, Point seedPoint, Scalar newVal, Rect* rect, Scalar loDiff, Scalar upDiff, int flags)">
<strong>C++:</strong><code class="descname"> </code>int <code class="descname">floodFill</code><span class="sig-paren">(</span>InputOutputArray <strong>image</strong>, InputOutputArray <strong>mask</strong>, Point <strong>seedPoint</strong>, Scalar <strong>newVal</strong>, Rect* <strong>rect</strong>=0, Scalar <strong>loDiff</strong>=Scalar(), Scalar <strong>upDiff</strong>=Scalar(), int <strong>flags</strong>=4 <span class="sig-paren">)</span><a class="headerlink" href="#int floodFill(InputOutputArray image, InputOutputArray mask, Point seedPoint, Scalar newVal, Rect* rect, Scalar loDiff, Scalar upDiff, int flags)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="pyfunction">
<dt id="cv2.floodFill">
<strong>Python:</strong><code class="descname"> </code><code class="descclassname">cv2.</code><code class="descname">floodFill</code><span class="sig-paren">(</span>image, mask, seedPoint, newVal<span class="optional">[</span>, loDiff<span class="optional">[</span>, upDiff<span class="optional">[</span>, flags<span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span> &rarr; retval, rect<a class="headerlink" href="#cv2.floodFill" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="cfunction">
<dt id="void cvFloodFill(CvArr* image, CvPoint seed_point, CvScalar new_val, CvScalar lo_diff, CvScalar up_diff, CvConnectedComp* comp, int flags, CvArr* mask)">
<strong>C:</strong><code class="descname"> </code>void <code class="descname">cvFloodFill</code><span class="sig-paren">(</span>CvArr* <strong>image</strong>, CvPoint <strong>seed_point</strong>, CvScalar <strong>new_val</strong>, CvScalar <strong>lo_diff</strong>=cvScalarAll(0), CvScalar <strong>up_diff</strong>=cvScalarAll(0), CvConnectedComp* <strong>comp</strong>=NULL, int <strong>flags</strong>=4, CvArr* <strong>mask</strong>=NULL <span class="sig-paren">)</span><a class="headerlink" href="#void cvFloodFill(CvArr* image, CvPoint seed_point, CvScalar new_val, CvScalar lo_diff, CvScalar up_diff, CvConnectedComp* comp, int flags, CvArr* mask)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="pyoldfunction">
<dt id="cv.FloodFill">
<strong>Python:</strong><code class="descname"> </code><code class="descclassname">cv.</code><code class="descname">FloodFill</code><span class="sig-paren">(</span>image, seed_point, new_val, lo_diff=(0, 0, 0, 0), up_diff=(0, 0, 0, 0), flags=4, mask=None<span class="sig-paren">)</span> &rarr; comp<a class="headerlink" href="#cv.FloodFill" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>image</strong> &#8211; Input/output 1- or 3-channel, 8-bit, or floating-point image. It is modified by the function unless the  <code class="docutils literal"><span class="pre">FLOODFILL_MASK_ONLY</span></code>  flag is set in the second variant of the function. See the details below.</li>
<li><strong>mask</strong> &#8211; <p>Operation mask that should be a single-channel 8-bit image, 2 pixels wider and 2 pixels taller than <code class="docutils literal"><span class="pre">image</span></code>. Since this is both an input and output parameter, you must take responsibility of initializing it. Flood-filling cannot go across non-zero pixels in the input mask. For example, an edge detector output can be used as a mask to stop filling at edges. On output, pixels in the mask corresponding to filled pixels in the image are set to 1 or to the a value specified in <code class="docutils literal"><span class="pre">flags</span></code> as described below. It is therefore possible to use the same mask in multiple calls to the function to make sure the filled areas do not overlap.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Since the mask is larger than the filled image, a pixel  <img class="math" src="../../../_images/math/dee21a914bf9088bc0dfbd38a96c1f859c412ec7.png" alt="(x, y)"/>  in  <code class="docutils literal"><span class="pre">image</span></code>  corresponds to the pixel  <img class="math" src="../../../_images/math/f6f52fa70d146f3b8fa15fa60db64f961b13cd78.png" alt="(x+1, y+1)"/>  in the  <code class="docutils literal"><span class="pre">mask</span></code> .</p>
</div>
</li>
<li><strong>seedPoint</strong> &#8211; Starting point.</li>
<li><strong>newVal</strong> &#8211; New value of the repainted domain pixels.</li>
<li><strong>loDiff</strong> &#8211; Maximal lower brightness/color difference between the currently observed pixel and one of its neighbors belonging to the component, or a seed pixel being added to the component.</li>
<li><strong>upDiff</strong> &#8211; Maximal upper brightness/color difference between the currently observed pixel and one of its neighbors belonging to the component, or a seed pixel being added to the component.</li>
<li><strong>rect</strong> &#8211; Optional output parameter set by the function to the minimum bounding rectangle of the repainted domain.</li>
<li><strong>flags</strong> &#8211; <p>Operation flags. The first 8 bits contain a connectivity value. The default value of 4 means that only the four nearest neighbor pixels (those that share an edge) are considered. A connectivity value of 8 means that the eight nearest neighbor pixels (those that share a corner) will be considered. The next 8 bits (8-16) contain a value between 1 and 255 with which to fill the <code class="docutils literal"><span class="pre">mask</span></code> (the default value is 1). For example, <code class="docutils literal"><span class="pre">4</span> <span class="pre">|</span> <span class="pre">(</span> <span class="pre">255</span> <span class="pre">&lt;&lt;</span> <span class="pre">8</span> <span class="pre">)</span></code> will consider 4 nearest neighbours and fill the mask with a value of 255. The following additional options occupy higher bits and therefore may be further combined with the connectivity and mask fill values using bit-wise or (<code class="docutils literal"><span class="pre">|</span></code>):</p>
<ul>
<li><strong>FLOODFILL_FIXED_RANGE</strong> If set, the difference between the current pixel and seed pixel is considered. Otherwise, the difference between neighbor pixels is considered (that is, the range is floating).</li>
<li><strong>FLOODFILL_MASK_ONLY</strong>  If set, the function does not change the image ( <code class="docutils literal"><span class="pre">newVal</span></code>  is ignored), and only fills the mask with the value specified in bits 8-16 of <code class="docutils literal"><span class="pre">flags</span></code> as described above.  This option only make sense in function variants that have the <code class="docutils literal"><span class="pre">mask</span></code> parameter.</li>
</ul>
</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<p>The functions <code class="docutils literal"><span class="pre">floodFill</span></code> fill a connected component starting from the seed point with the specified color. The connectivity is determined by the color/brightness closeness of the neighbor pixels. The pixel at
<img class="math" src="../../../_images/math/45b34b73b5a1fed1fd38b3a37ca1ada031de9970.png" alt="(x,y)"/> is considered to belong to the repainted domain if:</p>
<ul>
<li><div class="first math">
<p><img src="../../../_images/math/f5bc06ed04d2da7eb517bfb4e41409995cb93532.png" alt="\texttt{src} (x',y')- \texttt{loDiff} \leq \texttt{src} (x,y)  \leq \texttt{src} (x',y')+ \texttt{upDiff}"/></p>
</div><p>in case of a grayscale image and floating range</p>
</li>
<li><div class="first math">
<p><img src="../../../_images/math/f67280089e076019034831de12f606456569a28b.png" alt="\texttt{src} ( \texttt{seedPoint} .x, \texttt{seedPoint} .y)- \texttt{loDiff} \leq \texttt{src} (x,y)  \leq \texttt{src} ( \texttt{seedPoint} .x, \texttt{seedPoint} .y)+ \texttt{upDiff}"/></p>
</div><p>in case of a grayscale image and fixed range</p>
</li>
<li><div class="first math">
<p><img src="../../../_images/math/7ee7c537a16acfb90ecb81c1959f59d8fe826407.png" alt="\texttt{src} (x',y')_r- \texttt{loDiff} _r \leq \texttt{src} (x,y)_r \leq \texttt{src} (x',y')_r+ \texttt{upDiff} _r,"/></p>
</div><div class="math">
<p><img src="../../../_images/math/5fe3cd71145724afb461254d10fb82971a8e7f4d.png" alt="\texttt{src} (x',y')_g- \texttt{loDiff} _g \leq \texttt{src} (x,y)_g \leq \texttt{src} (x',y')_g+ \texttt{upDiff} _g"/></p>
</div><p>and</p>
<div class="math">
<p><img src="../../../_images/math/595c0f6c89dc4a7ea836bc4fc55dfd74e8297300.png" alt="\texttt{src} (x',y')_b- \texttt{loDiff} _b \leq \texttt{src} (x,y)_b \leq \texttt{src} (x',y')_b+ \texttt{upDiff} _b"/></p>
</div><p>in case of a color image and floating range</p>
</li>
<li><div class="first math">
<p><img src="../../../_images/math/000cba9a89d9d724ad8dabf5af3985518fe201cc.png" alt="\texttt{src} ( \texttt{seedPoint} .x, \texttt{seedPoint} .y)_r- \texttt{loDiff} _r \leq \texttt{src} (x,y)_r \leq \texttt{src} ( \texttt{seedPoint} .x, \texttt{seedPoint} .y)_r+ \texttt{upDiff} _r,"/></p>
</div><div class="math">
<p><img src="../../../_images/math/7bec5131c594e3afa9aae10b4ed9b9506896e826.png" alt="\texttt{src} ( \texttt{seedPoint} .x, \texttt{seedPoint} .y)_g- \texttt{loDiff} _g \leq \texttt{src} (x,y)_g \leq \texttt{src} ( \texttt{seedPoint} .x, \texttt{seedPoint} .y)_g+ \texttt{upDiff} _g"/></p>
</div><p>and</p>
<div class="math">
<p><img src="../../../_images/math/86aad3bedfd741fe5f89c632326f32be8f0038cd.png" alt="\texttt{src} ( \texttt{seedPoint} .x, \texttt{seedPoint} .y)_b- \texttt{loDiff} _b \leq \texttt{src} (x,y)_b \leq \texttt{src} ( \texttt{seedPoint} .x, \texttt{seedPoint} .y)_b+ \texttt{upDiff} _b"/></p>
</div><p>in case of a color image and fixed range</p>
</li>
</ul>
<p>where
<img class="math" src="../../../_images/math/0d90013f209ff624c3808428cbc40422e6436f4d.png" alt="src(x',y')"/> is the value of one of pixel neighbors that is already known to belong to the component. That is, to be added to the connected component, a color/brightness of the pixel should be close enough to:</p>
<ul class="simple">
<li>Color/brightness of one of its neighbors that already belong to the connected component in case of a floating range.</li>
<li>Color/brightness of the seed point in case of a fixed range.</li>
</ul>
<p>Use these functions to either mark a connected component with the specified color in-place, or build a mask and then extract the contour, or copy the region to another image, and so on.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="structural_analysis_and_shape_descriptors.html#void findContours(InputOutputArray image, OutputArrayOfArrays contours, OutputArray hierarchy, int mode, int method, Point offset)" title="void findContours(InputOutputArray image, OutputArrayOfArrays contours, OutputArray hierarchy, int mode, int method, Point offset)"><code class="xref ocv ocv-func docutils literal"><span class="pre">findContours()</span></code></a></p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<ul class="last simple">
<li>An example using the FloodFill technique can be found at opencv_source_code/samples/cpp/ffilldemo.cpp</li>
<li>(Python) An example using the FloodFill technique can be found at opencv_source_code/samples/python2/floodfill.cpp</li>
</ul>
</div>
</div>
<div class="section" id="integral">
<h2>integral<a class="headerlink" href="#integral" title="Permalink to this headline">¶</a></h2>
<p>Calculates the integral of an image.</p>
<dl class="function">
<dt id="void integral(InputArray src, OutputArray sum, int sdepth)">
<strong>C++:</strong><code class="descname"> </code>void <code class="descname">integral</code><span class="sig-paren">(</span>InputArray <strong>src</strong>, OutputArray <strong>sum</strong>, int <strong>sdepth</strong>=-1 <span class="sig-paren">)</span><a class="headerlink" href="#void integral(InputArray src, OutputArray sum, int sdepth)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="void integral(InputArray src, OutputArray sum, OutputArray sqsum, int sdepth)">
<strong>C++:</strong><code class="descname"> </code>void <code class="descname">integral</code><span class="sig-paren">(</span>InputArray <strong>src</strong>, OutputArray <strong>sum</strong>, OutputArray <strong>sqsum</strong>, int <strong>sdepth</strong>=-1 <span class="sig-paren">)</span><a class="headerlink" href="#void integral(InputArray src, OutputArray sum, OutputArray sqsum, int sdepth)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="void integral(InputArray src, OutputArray sum, OutputArray sqsum, OutputArray tilted, int sdepth)">
<strong>C++:</strong><code class="descname"> </code>void <code class="descname">integral</code><span class="sig-paren">(</span>InputArray <strong>src</strong>, OutputArray <strong>sum</strong>, OutputArray <strong>sqsum</strong>, OutputArray <strong>tilted</strong>, int <strong>sdepth</strong>=-1 <span class="sig-paren">)</span><a class="headerlink" href="#void integral(InputArray src, OutputArray sum, OutputArray sqsum, OutputArray tilted, int sdepth)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="pyfunction">
<dt id="cv2.integral">
<strong>Python:</strong><code class="descname"> </code><code class="descclassname">cv2.</code><code class="descname">integral</code><span class="sig-paren">(</span>src<span class="optional">[</span>, sum<span class="optional">[</span>, sdepth<span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span> &rarr; sum<a class="headerlink" href="#cv2.integral" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="pyfunction">
<dt id="cv2.integral2">
<strong>Python:</strong><code class="descname"> </code><code class="descclassname">cv2.</code><code class="descname">integral2</code><span class="sig-paren">(</span>src<span class="optional">[</span>, sum<span class="optional">[</span>, sqsum<span class="optional">[</span>, sdepth<span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span> &rarr; sum, sqsum<a class="headerlink" href="#cv2.integral2" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="pyfunction">
<dt id="cv2.integral3">
<strong>Python:</strong><code class="descname"> </code><code class="descclassname">cv2.</code><code class="descname">integral3</code><span class="sig-paren">(</span>src<span class="optional">[</span>, sum<span class="optional">[</span>, sqsum<span class="optional">[</span>, tilted<span class="optional">[</span>, sdepth<span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span> &rarr; sum, sqsum, tilted<a class="headerlink" href="#cv2.integral3" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="cfunction">
<dt id="void cvIntegral(const CvArr* image, CvArr* sum, CvArr* sqsum, CvArr* tilted_sum)">
<strong>C:</strong><code class="descname"> </code>void <code class="descname">cvIntegral</code><span class="sig-paren">(</span>const CvArr* <strong>image</strong>, CvArr* <strong>sum</strong>, CvArr* <strong>sqsum</strong>=NULL, CvArr* <strong>tilted_sum</strong>=NULL <span class="sig-paren">)</span><a class="headerlink" href="#void cvIntegral(const CvArr* image, CvArr* sum, CvArr* sqsum, CvArr* tilted_sum)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="pyoldfunction">
<dt id="cv.Integral">
<strong>Python:</strong><code class="descname"> </code><code class="descclassname">cv.</code><code class="descname">Integral</code><span class="sig-paren">(</span>image, sum, sqsum=None, tiltedSum=None<span class="sig-paren">)</span> &rarr; None<a class="headerlink" href="#cv.Integral" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>image</strong> &#8211; input image as <img class="math" src="../../../_images/math/e4926c3d97c3f7434c6317ba24b8b9294a0aba64.png" alt="W \times H"/>, 8-bit or floating-point (32f or 64f).</li>
<li><strong>sum</strong> &#8211; integral image as  <img class="math" src="../../../_images/math/ff4c01e62221e96579fb2d7aa374c18be27281d1.png" alt="(W+1)\times (H+1)"/> , 32-bit integer or floating-point (32f or 64f).</li>
<li><strong>sqsum</strong> &#8211; integral image for squared pixel values; it is <img class="math" src="../../../_images/math/ff4c01e62221e96579fb2d7aa374c18be27281d1.png" alt="(W+1)\times (H+1)"/>, double-precision floating-point (64f) array.</li>
<li><strong>tilted</strong> &#8211; integral for the image rotated by 45 degrees; it is <img class="math" src="../../../_images/math/ff4c01e62221e96579fb2d7aa374c18be27281d1.png" alt="(W+1)\times (H+1)"/> array  with the same data type as <code class="docutils literal"><span class="pre">sum</span></code>.</li>
<li><strong>sdepth</strong> &#8211; desired depth of the integral and the tilted integral images,  <code class="docutils literal"><span class="pre">CV_32S</span></code>, <code class="docutils literal"><span class="pre">CV_32F</span></code>,  or  <code class="docutils literal"><span class="pre">CV_64F</span></code>.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<p>The functions calculate one or more integral images for the source image as follows:</p>
<div class="math">
<p><img src="../../../_images/math/f37942c2934d67b75e9dec4011ba05424bb23cff.png" alt="\texttt{sum} (X,Y) =  \sum _{x&lt;X,y&lt;Y}  \texttt{image} (x,y)"/></p>
</div><div class="math">
<p><img src="../../../_images/math/2962e6612f38dc4000e9e1c1e0989a4220422605.png" alt="\texttt{sqsum} (X,Y) =  \sum _{x&lt;X,y&lt;Y}  \texttt{image} (x,y)^2"/></p>
</div><div class="math">
<p><img src="../../../_images/math/93b636ee7f9c745e34a1bbcf1f5b915ddb42d9da.png" alt="\texttt{tilted} (X,Y) =  \sum _{y&lt;Y,abs(x-X+1) \leq Y-y-1}  \texttt{image} (x,y)"/></p>
</div><p>Using these integral images, you can calculate sum, mean, and standard deviation over a specific up-right or rotated rectangular region of the image in a constant time, for example:</p>
<div class="math">
<p><img src="../../../_images/math/d132fdff3e34d4020b5a93a4892b6e9c747181c1.png" alt="\sum _{x_1 \leq x &lt; x_2,  \, y_1  \leq y &lt; y_2}  \texttt{image} (x,y) =  \texttt{sum} (x_2,y_2)- \texttt{sum} (x_1,y_2)- \texttt{sum} (x_2,y_1)+ \texttt{sum} (x_1,y_1)"/></p>
</div><p>It makes possible to do a fast blurring or fast block correlation with a variable window size, for example. In case of multi-channel images, sums for each channel are accumulated independently.</p>
<p>As a practical example, the next figure shows the calculation of the integral of a straight rectangle <code class="docutils literal"><span class="pre">Rect(3,3,3,2)</span></code> and of a tilted rectangle <code class="docutils literal"><span class="pre">Rect(5,1,2,3)</span></code> . The selected pixels in the original <code class="docutils literal"><span class="pre">image</span></code> are shown, as well as the relative pixels in the integral images <code class="docutils literal"><span class="pre">sum</span></code> and <code class="docutils literal"><span class="pre">tilted</span></code> .</p>
<img alt="../../../_images/integral.png" src="../../../_images/integral.png" />
</div>
<div class="section" id="threshold">
<h2>threshold<a class="headerlink" href="#threshold" title="Permalink to this headline">¶</a></h2>
<p>Applies a fixed-level threshold to each array element.</p>
<dl class="function">
<dt id="double threshold(InputArray src, OutputArray dst, double thresh, double maxval, int type)">
<strong>C++:</strong><code class="descname"> </code>double <code class="descname">threshold</code><span class="sig-paren">(</span>InputArray <strong>src</strong>, OutputArray <strong>dst</strong>, double <strong>thresh</strong>, double <strong>maxval</strong>, int <strong>type</strong><span class="sig-paren">)</span><a class="headerlink" href="#double threshold(InputArray src, OutputArray dst, double thresh, double maxval, int type)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="pyfunction">
<dt id="cv2.threshold">
<strong>Python:</strong><code class="descname"> </code><code class="descclassname">cv2.</code><code class="descname">threshold</code><span class="sig-paren">(</span>src, thresh, maxval, type<span class="optional">[</span>, dst<span class="optional">]</span><span class="sig-paren">)</span> &rarr; retval, dst<a class="headerlink" href="#cv2.threshold" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="cfunction">
<dt id="double cvThreshold(const CvArr* src, CvArr* dst, double threshold, double max_value, int threshold_type)">
<strong>C:</strong><code class="descname"> </code>double <code class="descname">cvThreshold</code><span class="sig-paren">(</span>const CvArr* <strong>src</strong>, CvArr* <strong>dst</strong>, double <strong>threshold</strong>, double <strong>max_value</strong>, int <strong>threshold_type</strong><span class="sig-paren">)</span><a class="headerlink" href="#double cvThreshold(const CvArr* src, CvArr* dst, double threshold, double max_value, int threshold_type)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="pyoldfunction">
<dt id="cv.Threshold">
<strong>Python:</strong><code class="descname"> </code><code class="descclassname">cv.</code><code class="descname">Threshold</code><span class="sig-paren">(</span>src, dst, threshold, maxValue, thresholdType<span class="sig-paren">)</span> &rarr; None<a class="headerlink" href="#cv.Threshold" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>src</strong> &#8211; input array (single-channel, 8-bit or 32-bit floating point).</li>
<li><strong>dst</strong> &#8211; output array of the same size and type as <code class="docutils literal"><span class="pre">src</span></code>.</li>
<li><strong>thresh</strong> &#8211; threshold value.</li>
<li><strong>maxval</strong> &#8211; maximum value to use with the <code class="docutils literal"><span class="pre">THRESH_BINARY</span></code> and <code class="docutils literal"><span class="pre">THRESH_BINARY_INV</span></code> thresholding types.</li>
<li><strong>type</strong> &#8211; thresholding type (see the details below).</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<p>The function applies fixed-level thresholding
to a single-channel array. The function is typically used to get a
bi-level (binary) image out of a grayscale image (
<a class="reference internal" href="../../contrib/doc/openfabmap.html#void compare(const Mat&amp; queryImgDescriptor, vector&lt;IMatch&gt;&amp; matches, bool addQuery , const Mat&amp; mask)" title="void compare(const Mat&amp; queryImgDescriptor, vector&lt;IMatch&gt;&amp; matches, bool addQuery , const Mat&amp; mask)"><code class="xref ocv ocv-func docutils literal"><span class="pre">compare()</span></code></a> could
be also used for this purpose) or for removing a noise, that is, filtering
out pixels with too small or too large values. There are several
types of thresholding supported by the function. They are determined by <code class="docutils literal"><span class="pre">type</span></code> :</p>
<blockquote>
<div><ul>
<li><p class="first"><strong>THRESH_BINARY</strong></p>
<blockquote>
<div><div class="math">
<p><img src="../../../_images/math/21dfc802899546a3a9a51794d241330e6377f032.png" alt="\texttt{dst} (x,y) =  \fork{\texttt{maxval}}{if $\texttt{src}(x,y) &gt; \texttt{thresh}$}{0}{otherwise}"/></p>
</div></div></blockquote>
</li>
<li><p class="first"><strong>THRESH_BINARY_INV</strong></p>
<blockquote>
<div><div class="math">
<p><img src="../../../_images/math/2858653b2a9f18e326acd861f4f23476f918e52b.png" alt="\texttt{dst} (x,y) =  \fork{0}{if $\texttt{src}(x,y) &gt; \texttt{thresh}$}{\texttt{maxval}}{otherwise}"/></p>
</div></div></blockquote>
</li>
<li><p class="first"><strong>THRESH_TRUNC</strong></p>
<blockquote>
<div><div class="math">
<p><img src="../../../_images/math/85cd5dfea2f25f50640e7555c4019829859ff661.png" alt="\texttt{dst} (x,y) =  \fork{\texttt{threshold}}{if $\texttt{src}(x,y) &gt; \texttt{thresh}$}{\texttt{src}(x,y)}{otherwise}"/></p>
</div></div></blockquote>
</li>
<li><p class="first"><strong>THRESH_TOZERO</strong></p>
<blockquote>
<div><div class="math">
<p><img src="../../../_images/math/c42e93ea5c713fb2fca2605fa03ccbdf15a98d16.png" alt="\texttt{dst} (x,y) =  \fork{\texttt{src}(x,y)}{if $\texttt{src}(x,y) &gt; \texttt{thresh}$}{0}{otherwise}"/></p>
</div></div></blockquote>
</li>
<li><p class="first"><strong>THRESH_TOZERO_INV</strong></p>
<blockquote>
<div><div class="math">
<p><img src="../../../_images/math/6729a7b61fa189e9ad1a365aa5eb9290b70b023e.png" alt="\texttt{dst} (x,y) =  \fork{0}{if $\texttt{src}(x,y) &gt; \texttt{thresh}$}{\texttt{src}(x,y)}{otherwise}"/></p>
</div></div></blockquote>
</li>
</ul>
</div></blockquote>
<p>Also, the special value <code class="docutils literal"><span class="pre">THRESH_OTSU</span></code> may be combined with
one of the above values. In this case, the function determines the optimal threshold
value using the Otsu&#8217;s algorithm and uses it instead of the specified <code class="docutils literal"><span class="pre">thresh</span></code> .
The function returns the computed threshold value.
Currently, the Otsu&#8217;s method is implemented only for 8-bit images.</p>
<img alt="../../../_images/threshold.png" src="../../../_images/threshold.png" />
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#void adaptiveThreshold(InputArray src, OutputArray dst, double maxValue, int adaptiveMethod, int thresholdType, int blockSize, double C)" title="void adaptiveThreshold(InputArray src, OutputArray dst, double maxValue, int adaptiveMethod, int thresholdType, int blockSize, double C)"><code class="xref ocv ocv-func docutils literal"><span class="pre">adaptiveThreshold()</span></code></a>,
<a class="reference internal" href="structural_analysis_and_shape_descriptors.html#void findContours(InputOutputArray image, OutputArrayOfArrays contours, OutputArray hierarchy, int mode, int method, Point offset)" title="void findContours(InputOutputArray image, OutputArrayOfArrays contours, OutputArray hierarchy, int mode, int method, Point offset)"><code class="xref ocv ocv-func docutils literal"><span class="pre">findContours()</span></code></a>,
<a class="reference internal" href="../../contrib/doc/openfabmap.html#void compare(const Mat&amp; queryImgDescriptor, vector&lt;IMatch&gt;&amp; matches, bool addQuery , const Mat&amp; mask)" title="void compare(const Mat&amp; queryImgDescriptor, vector&lt;IMatch&gt;&amp; matches, bool addQuery , const Mat&amp; mask)"><code class="xref ocv ocv-func docutils literal"><span class="pre">compare()</span></code></a>,
<a class="reference internal" href="../../core/doc/operations_on_arrays.html#MatExpr min(const Mat&amp; a, const Mat&amp; b)" title="MatExpr min(const Mat&amp; a, const Mat&amp; b)"><code class="xref ocv ocv-func docutils literal"><span class="pre">min()</span></code></a>,
<a class="reference internal" href="../../core/doc/operations_on_arrays.html#MatExpr max(const Mat&amp; a, const Mat&amp; b)" title="MatExpr max(const Mat&amp; a, const Mat&amp; b)"><code class="xref ocv ocv-func docutils literal"><span class="pre">max()</span></code></a></p>
</div>
</div>
<div class="section" id="watershed">
<h2>watershed<a class="headerlink" href="#watershed" title="Permalink to this headline">¶</a></h2>
<p>Performs a marker-based image segmentation using the watershed algorithm.</p>
<dl class="function">
<dt id="void watershed(InputArray image, InputOutputArray markers)">
<strong>C++:</strong><code class="descname"> </code>void <code class="descname">watershed</code><span class="sig-paren">(</span>InputArray <strong>image</strong>, InputOutputArray <strong>markers</strong><span class="sig-paren">)</span><a class="headerlink" href="#void watershed(InputArray image, InputOutputArray markers)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="cfunction">
<dt id="void cvWatershed(const CvArr* image, CvArr* markers)">
<strong>C:</strong><code class="descname"> </code>void <code class="descname">cvWatershed</code><span class="sig-paren">(</span>const CvArr* <strong>image</strong>, CvArr* <strong>markers</strong><span class="sig-paren">)</span><a class="headerlink" href="#void cvWatershed(const CvArr* image, CvArr* markers)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="pyfunction">
<dt id="cv2.watershed">
<strong>Python:</strong><code class="descname"> </code><code class="descclassname">cv2.</code><code class="descname">watershed</code><span class="sig-paren">(</span>image, markers<span class="sig-paren">)</span> &rarr; None<a class="headerlink" href="#cv2.watershed" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>image</strong> &#8211; Input 8-bit 3-channel image.</li>
<li><strong>markers</strong> &#8211; Input/output 32-bit single-channel image (map) of markers. It should have the same size as  <code class="docutils literal"><span class="pre">image</span></code> .</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<p>The function implements one of the variants of watershed, non-parametric marker-based segmentation algorithm, described in <a class="reference internal" href="#meyer92" id="id3">[Meyer92]</a>.</p>
<p>Before passing the image to the function, you have to roughly outline the desired regions in the image <code class="docutils literal"><span class="pre">markers</span></code> with positive (<code class="docutils literal"><span class="pre">&gt;0</span></code>) indices. So, every region is represented as one or more connected components with the pixel values 1, 2, 3, and so on. Such markers can be retrieved from a binary mask using <a class="reference internal" href="structural_analysis_and_shape_descriptors.html#void findContours(InputOutputArray image, OutputArrayOfArrays contours, OutputArray hierarchy, int mode, int method, Point offset)" title="void findContours(InputOutputArray image, OutputArrayOfArrays contours, OutputArray hierarchy, int mode, int method, Point offset)"><code class="xref ocv ocv-func docutils literal"><span class="pre">findContours()</span></code></a> and <a class="reference internal" href="structural_analysis_and_shape_descriptors.html#void drawContours(InputOutputArray image, InputArrayOfArrays contours, int contourIdx, const Scalar&amp; color, int thickness, int lineType, InputArray hierarchy, int maxLevel, Point offset)" title="void drawContours(InputOutputArray image, InputArrayOfArrays contours, int contourIdx, const Scalar&amp; color, int thickness, int lineType, InputArray hierarchy, int maxLevel, Point offset)"><code class="xref ocv ocv-func docutils literal"><span class="pre">drawContours()</span></code></a> (see the <code class="docutils literal"><span class="pre">watershed.cpp</span></code> demo). The markers are &#8220;seeds&#8221; of the future image regions. All the other pixels in <code class="docutils literal"><span class="pre">markers</span></code> , whose relation to the outlined regions is not known and should be defined by the algorithm, should be set to 0&#8217;s. In the function output, each pixel in markers is set to a value of the &#8220;seed&#8221; components or to -1 at boundaries between the regions.</p>
<p>Visual demonstration and usage example of the function can be found in the OpenCV samples directory (see the <code class="docutils literal"><span class="pre">watershed.cpp</span></code> demo).</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Any two neighbor connected components are not necessarily separated by a watershed boundary (-1&#8217;s pixels); for example, they can touch each other in the initial marker image passed to the function.</p>
</div>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="structural_analysis_and_shape_descriptors.html#void findContours(InputOutputArray image, OutputArrayOfArrays contours, OutputArray hierarchy, int mode, int method, Point offset)" title="void findContours(InputOutputArray image, OutputArrayOfArrays contours, OutputArray hierarchy, int mode, int method, Point offset)"><code class="xref ocv ocv-func docutils literal"><span class="pre">findContours()</span></code></a></p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<ul class="last simple">
<li>An example using the watershed algorithm can be found at opencv_source_code/samples/cpp/watershed.cpp</li>
<li>(Python) An example using the watershed algorithm can be found at opencv_source_code/samples/python2/watershed.py</li>
</ul>
</div>
</div>
<div class="section" id="grabcut">
<h2>grabCut<a class="headerlink" href="#grabcut" title="Permalink to this headline">¶</a></h2>
<p>Runs the GrabCut algorithm.</p>
<dl class="function">
<dt id="void grabCut(InputArray img, InputOutputArray mask, Rect rect, InputOutputArray bgdModel, InputOutputArray fgdModel, int iterCount, int mode)">
<strong>C++:</strong><code class="descname"> </code>void <code class="descname">grabCut</code><span class="sig-paren">(</span>InputArray <strong>img</strong>, InputOutputArray <strong>mask</strong>, Rect <strong>rect</strong>, InputOutputArray <strong>bgdModel</strong>, InputOutputArray <strong>fgdModel</strong>, int <strong>iterCount</strong>, int <strong>mode</strong>=GC_EVAL <span class="sig-paren">)</span><a class="headerlink" href="#void grabCut(InputArray img, InputOutputArray mask, Rect rect, InputOutputArray bgdModel, InputOutputArray fgdModel, int iterCount, int mode)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="pyfunction">
<dt id="cv2.grabCut">
<strong>Python:</strong><code class="descname"> </code><code class="descclassname">cv2.</code><code class="descname">grabCut</code><span class="sig-paren">(</span>img, mask, rect, bgdModel, fgdModel, iterCount<span class="optional">[</span>, mode<span class="optional">]</span><span class="sig-paren">)</span> &rarr; None<a class="headerlink" href="#cv2.grabCut" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>img</strong> &#8211; Input 8-bit 3-channel image.</li>
<li><strong>mask</strong> &#8211; <p>Input/output 8-bit single-channel mask. The mask is initialized by the function when  <code class="docutils literal"><span class="pre">mode</span></code> is set to <code class="docutils literal"><span class="pre">GC_INIT_WITH_RECT</span></code>. Its elements may have one of following values:</p>
<ul>
<li><strong>GC_BGD</strong> defines an obvious background pixels.</li>
<li><strong>GC_FGD</strong> defines an obvious foreground (object) pixel.</li>
<li><strong>GC_PR_BGD</strong> defines a possible background pixel.</li>
<li><strong>GC_PR_FGD</strong> defines a possible foreground pixel.</li>
</ul>
</li>
<li><strong>rect</strong> &#8211; ROI containing a segmented object. The pixels outside of the ROI are marked as &#8220;obvious background&#8221;. The parameter is only used when  <code class="docutils literal"><span class="pre">mode==GC_INIT_WITH_RECT</span></code> .</li>
<li><strong>bgdModel</strong> &#8211; Temporary array for the background model. Do not modify it while you are processing the same image.</li>
<li><strong>fgdModel</strong> &#8211; Temporary arrays for the foreground model. Do not modify it while you are processing the same image.</li>
<li><strong>iterCount</strong> &#8211; Number of iterations the algorithm should make before returning the result. Note that the result can be refined with further calls with  <code class="docutils literal"><span class="pre">mode==GC_INIT_WITH_MASK</span></code>  or  <code class="docutils literal"><span class="pre">mode==GC_EVAL</span></code> .</li>
<li><strong>mode</strong> &#8211; <p>Operation mode that could be one of the following:</p>
<ul>
<li><strong>GC_INIT_WITH_RECT</strong>     The function initializes the state and the mask using the provided rectangle. After that it runs  <code class="docutils literal"><span class="pre">iterCount</span></code>  iterations of the algorithm.</li>
<li><strong>GC_INIT_WITH_MASK</strong>     The function initializes the state using the provided mask. Note that  <code class="docutils literal"><span class="pre">GC_INIT_WITH_RECT</span></code>  and  <code class="docutils literal"><span class="pre">GC_INIT_WITH_MASK</span></code>  can be combined. Then, all the pixels outside of the ROI are automatically initialized with  <code class="docutils literal"><span class="pre">GC_BGD</span></code> .</li>
<li><strong>GC_EVAL</strong>     The value means that the algorithm should just resume.</li>
</ul>
</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<p>The function implements the <a class="reference external" href="http://en.wikipedia.org/wiki/GrabCut">GrabCut image segmentation algorithm</a>.
See the sample <code class="docutils literal"><span class="pre">grabcut.cpp</span></code> to learn how to use the function.</p>
<table class="docutils citation" frame="void" id="borgefors86" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id2">[Borgefors86]</a></td><td>Borgefors, Gunilla, <em>Distance transformations in digital images</em>. Comput. Vision Graph. Image Process. 34 3, pp 344–371 (1986)</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="felzenszwalb04" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id1">[Felzenszwalb04]</a></td><td>Felzenszwalb, Pedro F. and Huttenlocher, Daniel P. <em>Distance Transforms of Sampled Functions</em>, TR2004-1963, TR2004-1963 (2004)</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="meyer92" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id3">[Meyer92]</a></td><td>Meyer, F. <em>Color Image Segmentation</em>, ICIP92, 1992</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="telea04" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[Telea04]</td><td>Alexandru Telea, <em>An Image Inpainting Technique Based on the Fast Marching Method</em>. Journal of Graphics, GPU, and Game Tools 9 1, pp 23-34 (2004)</td></tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<ul class="last simple">
<li>An example using the GrabCut algorithm can be found at opencv_source_code/samples/cpp/grabcut.cpp</li>
<li>(Python) An example using the GrabCut algorithm can be found at opencv_source_code/samples/python2/grabcut.py</li>
</ul>
</div>
</div>
</div>


          </div>
          <div class="feedback">
              <h2>Help and Feedback</h2>
              You did not find what you were looking for?
              <ul>
                  
                  
                  
                  <li>Ask a question on the <a href="http://answers.opencv.org">Q&A forum</a>.</li>
                  <li>If you think something is missing or wrong in the documentation,
                  please file a <a href="http://code.opencv.org">bug report</a>.</li>
              </ul>
          </div>
        </div>
      </div>

      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../../../index.html">
              <img class="logo" src="../../../_static/opencv-logo-white.png" alt="Logo"/>
            </a></p>
<div id="searchbox" style="display: none">
      <form class="search" action="../../../search.html" method="get">
      <input type="text" name="q" size="18" />
      <input type="submit" value="Search" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
      </p>
    </form>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
  <h3><a href="../../../index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Miscellaneous Image Transformations</a><ul>
<li><a class="reference internal" href="#adaptivethreshold">adaptiveThreshold</a></li>
<li><a class="reference internal" href="#cvtcolor">cvtColor</a></li>
<li><a class="reference internal" href="#distancetransform">distanceTransform</a></li>
<li><a class="reference internal" href="#floodfill">floodFill</a></li>
<li><a class="reference internal" href="#integral">integral</a></li>
<li><a class="reference internal" href="#threshold">threshold</a></li>
<li><a class="reference internal" href="#watershed">watershed</a></li>
<li><a class="reference internal" href="#grabcut">grabCut</a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="geometric_transformations.html"
                        title="previous chapter">Geometric Image Transformations</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="histograms.html"
                        title="next chapter">Histograms</a></p>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../../../_sources/modules/imgproc/doc/miscellaneous_transformations.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="histograms.html" title="Histograms"
             >next</a> |</li>
        <li class="right" >
          <a href="geometric_transformations.html" title="Geometric Image Transformations"
             >previous</a> |</li>
        <li><a href="../../../index.html">OpenCV 2.4.13.7 documentation</a> &raquo;</li>
          <li><a href="../../refman.html" >OpenCV API Reference</a> &raquo;</li>
          <li><a href="imgproc.html" >imgproc. Image Processing</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2011-2014, opencv dev team.
      Last updated on Jul 12, 2018.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.3.6.
    </div>
  </body>
</html>
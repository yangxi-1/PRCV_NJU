<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<script type="text/javascript">

  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-33108845-1']);
  _gaq.push(['_setDomainName', 'opencv.org']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();

</script>

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Feature Detection and Description &mdash; OpenCV 2.4.13.7 documentation</title>
    <link rel="stylesheet" href="../../../_static/default.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../../',
        VERSION:     '2.4.13.7',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../../_static/doctools.js"></script>
    <link rel="top" title="OpenCV 2.4.13.7 documentation" href="../../../index.html" />
    <link rel="up" title="features2d. 2D Features Framework" href="features2d.html" />
    <link rel="next" title="Common Interfaces of Feature Detectors" href="common_interfaces_of_feature_detectors.html" />
    <link rel="prev" title="features2d. 2D Features Framework" href="features2d.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="common_interfaces_of_feature_detectors.html" title="Common Interfaces of Feature Detectors"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="features2d.html" title="features2d. 2D Features Framework"
             accesskey="P">previous</a> |</li>
        <li><a href="../../../index.html">OpenCV 2.4.13.7 documentation</a> &raquo;</li>
          <li><a href="../../refman.html" >OpenCV API Reference</a> &raquo;</li>
          <li><a href="features2d.html" accesskey="U">features2d. 2D Features Framework</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
  
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="feature-detection-and-description">
<h1>Feature Detection and Description<a class="headerlink" href="#feature-detection-and-description" title="Permalink to this headline">¶</a></h1>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<ul class="last simple">
<li>An example explaining keypoint detection and description can be found at opencv_source_code/samples/cpp/descriptor_extractor_matcher.cpp</li>
</ul>
</div>
<div class="section" id="fast">
<h2>FAST<a class="headerlink" href="#fast" title="Permalink to this headline">¶</a></h2>
<p>Detects corners using the FAST algorithm</p>
<dl class="function">
<dt id="void FAST(InputArray image, vector&lt;KeyPoint&gt;&amp; keypoints, int threshold, bool nonmaxSuppression)">
<strong>C++:</strong><code class="descname"> </code>void <code class="descname">FAST</code><span class="sig-paren">(</span>InputArray <strong>image</strong>, vector&lt;KeyPoint&gt;&amp; <strong>keypoints</strong>, int <strong>threshold</strong>, bool <strong>nonmaxSuppression</strong>=true <span class="sig-paren">)</span><a class="headerlink" href="#void FAST(InputArray image, vector<KeyPoint>& keypoints, int threshold, bool nonmaxSuppression)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="void FASTX(InputArray image, vector&lt;KeyPoint&gt;&amp; keypoints, int threshold, bool nonmaxSuppression, int type)">
<strong>C++:</strong><code class="descname"> </code>void <code class="descname">FASTX</code><span class="sig-paren">(</span>InputArray <strong>image</strong>, vector&lt;KeyPoint&gt;&amp; <strong>keypoints</strong>, int <strong>threshold</strong>, bool <strong>nonmaxSuppression</strong>, int <strong>type</strong><span class="sig-paren">)</span><a class="headerlink" href="#void FASTX(InputArray image, vector<KeyPoint>& keypoints, int threshold, bool nonmaxSuppression, int type)" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>image</strong> &#8211; grayscale image where keypoints (corners) are detected.</li>
<li><strong>keypoints</strong> &#8211; keypoints detected on the image.</li>
<li><strong>threshold</strong> &#8211; threshold on difference between intensity of the central pixel and pixels of a circle around this pixel.</li>
<li><strong>nonmaxSuppression</strong> &#8211; if true, non-maximum suppression is applied to detected corners (keypoints).</li>
<li><strong>type</strong> &#8211; one of the three neighborhoods as defined in the paper: <code class="docutils literal"><span class="pre">FastFeatureDetector::TYPE_9_16</span></code>, <code class="docutils literal"><span class="pre">FastFeatureDetector::TYPE_7_12</span></code>, <code class="docutils literal"><span class="pre">FastFeatureDetector::TYPE_5_8</span></code></li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<p>Detects corners using the FAST algorithm by <a class="reference internal" href="#rosten06" id="id1">[Rosten06]</a>.</p>
<table class="docutils citation" frame="void" id="rosten06" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id1">[Rosten06]</a></td><td><ol class="first last upperalpha simple" start="5">
<li>Rosten. Machine Learning for High-speed Corner Detection, 2006.</li>
</ol>
</td></tr>
</tbody>
</table>
</div>
<div class="section" id="mser">
<h2>MSER<a class="headerlink" href="#mser" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="MSER : public FeatureDetector">
<em class="property">class </em><code class="descname">MSER</code> : <em class="property">public</em> <code class="descname">FeatureDetector</code><a class="headerlink" href="#MSER : public FeatureDetector" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p>Maximally stable extremal region extractor.</p>
<div class="highlight-cpp"><div class="highlight"><pre><span class="k">class</span> <span class="nc">MSER</span> <span class="o">:</span> <span class="k">public</span> <span class="n">CvMSERParams</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="c1">// default constructor</span>
    <span class="n">MSER</span><span class="p">();</span>
    <span class="c1">// constructor that initializes all the algorithm parameters</span>
    <span class="n">MSER</span><span class="p">(</span> <span class="kt">int</span> <span class="n">_delta</span><span class="p">,</span> <span class="kt">int</span> <span class="n">_min_area</span><span class="p">,</span> <span class="kt">int</span> <span class="n">_max_area</span><span class="p">,</span>
          <span class="kt">float</span> <span class="n">_max_variation</span><span class="p">,</span> <span class="kt">float</span> <span class="n">_min_diversity</span><span class="p">,</span>
          <span class="kt">int</span> <span class="n">_max_evolution</span><span class="p">,</span> <span class="kt">double</span> <span class="n">_area_threshold</span><span class="p">,</span>
          <span class="kt">double</span> <span class="n">_min_margin</span><span class="p">,</span> <span class="kt">int</span> <span class="n">_edge_blur_size</span> <span class="p">);</span>
    <span class="c1">// runs the extractor on the specified image; returns the MSERs,</span>
    <span class="c1">// each encoded as a contour (vector&lt;Point&gt;, see findContours)</span>
    <span class="c1">// the optional mask marks the area where MSERs are searched for</span>
    <span class="kt">void</span> <span class="nf">operator</span><span class="p">()(</span> <span class="k">const</span> <span class="n">Mat</span><span class="o">&amp;</span> <span class="n">image</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Point</span><span class="o">&gt;</span> <span class="o">&gt;&amp;</span> <span class="n">msers</span><span class="p">,</span> <span class="k">const</span> <span class="n">Mat</span><span class="o">&amp;</span> <span class="n">mask</span> <span class="p">)</span> <span class="k">const</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
<p>The class encapsulates all the parameters of the MSER extraction algorithm (see <a class="reference internal" href="#wiki" id="id2">[wiki]</a> article).</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<ul class="last simple">
<li>there are two different implementation of MSER: one for grey image, one for color image the grey image algorithm is taken from: <a class="reference internal" href="#nister2008linear" id="id3">[nister2008linear]</a> ; the paper claims to be faster than union-find method; it actually get 1.5~2m/s on my centrino L7200 1.2GHz laptop.</li>
<li>the color image algorithm is taken from: <a class="reference internal" href="#forssen2007maximally" id="id4">[forssen2007maximally]</a> ; it should be much slower than grey image method ( 3~4 times ); the chi_table.h file is taken directly from paper&#8217;s source code which is distributed under GPL.</li>
<li>(Python) A complete example showing the use of the MSER detector can be found at opencv_source_code/samples/python2/mser.py</li>
</ul>
</div>
<table class="docutils citation" frame="void" id="wiki" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id2">[wiki]</a></td><td><a class="reference external" href="http://en.wikipedia.org/wiki/Maximally_stable_extremal_regions">http://en.wikipedia.org/wiki/Maximally_stable_extremal_regions</a></td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="nister2008linear" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id3">[nister2008linear]</a></td><td>David Nistér and Henrik Stewénius. Linear time maximally stable extremal regions. In Computer Vision–ECCV 2008, pages 183–196. Springer, 2008.</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="forssen2007maximally" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id4">[forssen2007maximally]</a></td><td>Per-Erik Forssén. Maximally stable colour regions for recognition and matching. In Computer Vision and Pattern Recognition, 2007. CVPR&#8216;07. IEEE Conference on, pages 1–8. IEEE, 2007.</td></tr>
</tbody>
</table>
</div>
<div class="section" id="mser-mser">
<h2>MSER::MSER<a class="headerlink" href="#mser-mser" title="Permalink to this headline">¶</a></h2>
<p>The MSER constructor</p>
<dl class="function">
<dt id="MSER::MSER(int _delta, int _min_area, int _max_area, double _max_variation, double _min_diversity, int _max_evolution, double _area_threshold, double _min_margin, int _edge_blur_size)">
<strong>C++:</strong><code class="descname"> </code> <code class="descclassname">MSER::</code><code class="descname">MSER</code><span class="sig-paren">(</span>int <strong>_delta</strong>=5, int <strong>_min_area</strong>=60, int <strong>_max_area</strong>=14400, double <strong>_max_variation</strong>=0.25, double <strong>_min_diversity</strong>=.2, int <strong>_max_evolution</strong>=200, double <strong>_area_threshold</strong>=1.01, double <strong>_min_margin</strong>=0.003, int <strong>_edge_blur_size</strong>=5<span class="sig-paren">)</span><a class="headerlink" href="#MSER::MSER(int _delta, int _min_area, int _max_area, double _max_variation, double _min_diversity, int _max_evolution, double _area_threshold, double _min_margin, int _edge_blur_size)" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>_delta</strong> &#8211; Compares (sizei - sizei-delta)/sizei-delta</li>
<li><strong>_min_area</strong> &#8211; Prune the area which smaller than minArea</li>
<li><strong>_max_area</strong> &#8211; Prune the area which bigger than maxArea</li>
<li><strong>_max_variation</strong> &#8211; Prune the area have simliar size to its children</li>
<li><strong>_min_diversity</strong> &#8211; For color image, trace back to cut off mser with diversity less than min_diversity</li>
<li><strong>_max_evolution</strong> &#8211; For color image, the evolution steps</li>
<li><strong>_area_threshold</strong> &#8211; For color image, the area threshold to cause re-initialize</li>
<li><strong>_min_margin</strong> &#8211; For color image, ignore too small margin</li>
<li><strong>_edge_blur_size</strong> &#8211; For color image, the aperture size for edge blur</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="mser-operator">
<h2>MSER::operator()<a class="headerlink" href="#mser-operator" title="Permalink to this headline">¶</a></h2>
<p>Detect MSER regions</p>
<dl class="function">
<dt id="void MSER::operator()(const Mat&amp; image, vector&lt;vector&lt;Point&gt; &gt;&amp; msers, const Mat&amp; mask) const">
<strong>C++:</strong><code class="descname"> </code>void <code class="descclassname">MSER::</code><code class="descname">operator()</code><span class="sig-paren">(</span>const Mat&amp; <strong>image</strong>, vector&lt;vector&lt;Point&gt;&gt;&amp; <strong>msers</strong>, const Mat&amp; <strong>mask</strong>=Mat() <span class="sig-paren">)</span><code class="descclassname"> const</code><a class="headerlink" href="#void MSER::operator()(const Mat& image, vector<vector<Point> >& msers, const Mat& mask) const" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>image</strong> &#8211; Input image (8UC1, 8UC3 or 8UC4)</li>
<li><strong>msers</strong> &#8211; Resulting list of point sets</li>
<li><strong>mask</strong> &#8211; The operation mask</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="orb">
<h2>ORB<a class="headerlink" href="#orb" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="ORB : public Feature2D">
<em class="property">class </em><code class="descname">ORB</code> : <em class="property">public</em> <code class="descname">Feature2D</code><a class="headerlink" href="#ORB : public Feature2D" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p>Class implementing the ORB (<em>oriented BRIEF</em>) keypoint detector and descriptor extractor, described in <a class="reference internal" href="#rrkb11" id="id5">[RRKB11]</a>. The algorithm uses FAST in pyramids to detect stable keypoints, selects the strongest features using FAST or Harris response, finds their orientation using first-order moments and computes the descriptors using BRIEF (where the coordinates of random point pairs (or k-tuples) are rotated according to the measured orientation).</p>
<table class="docutils citation" frame="void" id="rrkb11" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id5">[RRKB11]</a></td><td>Ethan Rublee, Vincent Rabaud, Kurt Konolige, Gary R. Bradski: ORB: An efficient alternative to SIFT or SURF. ICCV 2011: 2564-2571.</td></tr>
</tbody>
</table>
</div>
<div class="section" id="orb-orb">
<h2>ORB::ORB<a class="headerlink" href="#orb-orb" title="Permalink to this headline">¶</a></h2>
<p>The ORB constructor</p>
<dl class="function">
<dt id="ORB::ORB(int nfeatures , float scaleFactor , int nlevels , int edgeThreshold , int firstLevel , int WTA_K, int scoreType, int patchSize)">
<strong>C++:</strong><code class="descname"> </code> <code class="descclassname">ORB::</code><code class="descname">ORB</code><span class="sig-paren">(</span>int <strong>nfeatures</strong>=500, float <strong>scaleFactor</strong>=1.2f, int <strong>nlevels</strong>=8, int <strong>edgeThreshold</strong>=31, int <strong>firstLevel</strong>=0, int <strong>WTA_K</strong>=2, int <strong>scoreType</strong>=ORB::HARRIS_SCORE, int <strong>patchSize</strong>=31<span class="sig-paren">)</span><a class="headerlink" href="#ORB::ORB(int nfeatures , float scaleFactor , int nlevels , int edgeThreshold , int firstLevel , int WTA_K, int scoreType, int patchSize)" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>nfeatures</strong> &#8211; The maximum number of features to retain.</li>
<li><strong>scaleFactor</strong> &#8211; Pyramid decimation ratio, greater than 1. <code class="docutils literal"><span class="pre">scaleFactor==2</span></code> means the classical pyramid, where each next level has 4x less pixels than the previous, but such a big scale factor will degrade feature matching scores dramatically. On the other hand, too close to 1 scale factor will mean that to cover certain scale range you will need more pyramid levels and so the speed will suffer.</li>
<li><strong>nlevels</strong> &#8211; The number of pyramid levels. The smallest level will have linear size equal to <code class="docutils literal"><span class="pre">input_image_linear_size/pow(scaleFactor,</span> <span class="pre">nlevels)</span></code>.</li>
<li><strong>edgeThreshold</strong> &#8211; This is size of the border where the features are not detected. It should roughly match the <code class="docutils literal"><span class="pre">patchSize</span></code> parameter.</li>
<li><strong>firstLevel</strong> &#8211; It should be 0 in the current implementation.</li>
<li><strong>WTA_K</strong> &#8211; The number of points that produce each element of the oriented BRIEF descriptor. The default value 2 means the BRIEF where we take a random point pair and compare their brightnesses, so we get 0/1 response. Other possible values are 3 and 4. For example, 3 means that we take 3 random points (of course, those point coordinates are random, but they are generated from the pre-defined seed, so each element of BRIEF descriptor is computed deterministically from the pixel rectangle), find point of maximum brightness and output index of the winner (0, 1 or 2). Such output will occupy 2 bits, and therefore it will need a special variant of Hamming distance, denoted as <code class="docutils literal"><span class="pre">NORM_HAMMING2</span></code> (2 bits per bin).  When <code class="docutils literal"><span class="pre">WTA_K=4</span></code>, we take 4 random points to compute each bin (that will also occupy 2 bits with possible values 0, 1, 2 or 3).</li>
<li><strong>scoreType</strong> &#8211; The default HARRIS_SCORE means that Harris algorithm is used to rank features (the score is written to <code class="docutils literal"><span class="pre">KeyPoint::score</span></code> and is used to retain best <code class="docutils literal"><span class="pre">nfeatures</span></code> features); FAST_SCORE is alternative value of the parameter that produces slightly less stable keypoints, but it is a little faster to compute.</li>
<li><strong>patchSize</strong> &#8211; size of the patch used by the oriented BRIEF descriptor. Of course, on smaller pyramid layers the perceived image area covered by a feature will be larger.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="orb-operator">
<h2>ORB::operator()<a class="headerlink" href="#orb-operator" title="Permalink to this headline">¶</a></h2>
<p>Finds keypoints in an image and computes their descriptors</p>
<dl class="function">
<dt id="void ORB::operator()(InputArray image, InputArray mask, vector&lt;KeyPoint&gt;&amp; keypoints, OutputArray descriptors, bool useProvidedKeypoints) const">
<strong>C++:</strong><code class="descname"> </code>void <code class="descclassname">ORB::</code><code class="descname">operator()</code><span class="sig-paren">(</span>InputArray <strong>image</strong>, InputArray <strong>mask</strong>, vector&lt;KeyPoint&gt;&amp; <strong>keypoints</strong>, OutputArray <strong>descriptors</strong>, bool <strong>useProvidedKeypoints</strong>=false <span class="sig-paren">)</span><code class="descclassname"> const</code><a class="headerlink" href="#void ORB::operator()(InputArray image, InputArray mask, vector<KeyPoint>& keypoints, OutputArray descriptors, bool useProvidedKeypoints) const" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>image</strong> &#8211; The input 8-bit grayscale image.</li>
<li><strong>mask</strong> &#8211; The operation mask.</li>
<li><strong>keypoints</strong> &#8211; The output vector of keypoints.</li>
<li><strong>descriptors</strong> &#8211; The output descriptors. Pass <code class="docutils literal"><span class="pre">cv::noArray()</span></code> if you do not need it.</li>
<li><strong>useProvidedKeypoints</strong> &#8211; If it is true, then the method will use the provided vector of keypoints instead of detecting them.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="brisk">
<h2>BRISK<a class="headerlink" href="#brisk" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="BRISK : public Feature2D">
<em class="property">class </em><code class="descname">BRISK</code> : <em class="property">public</em> <code class="descname">Feature2D</code><a class="headerlink" href="#BRISK : public Feature2D" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p>Class implementing the BRISK keypoint detector and descriptor extractor, described in <a class="reference internal" href="#lcs11" id="id6">[LCS11]</a>.</p>
<table class="docutils citation" frame="void" id="lcs11" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id6">[LCS11]</a></td><td>Stefan Leutenegger, Margarita Chli and Roland Siegwart: BRISK: Binary Robust Invariant Scalable Keypoints. ICCV 2011: 2548-2555.</td></tr>
</tbody>
</table>
</div>
<div class="section" id="brisk-brisk">
<h2>BRISK::BRISK<a class="headerlink" href="#brisk-brisk" title="Permalink to this headline">¶</a></h2>
<p>The BRISK constructor</p>
<dl class="function">
<dt id="BRISK::BRISK(int thresh, int octaves, float patternScale)">
<strong>C++:</strong><code class="descname"> </code> <code class="descclassname">BRISK::</code><code class="descname">BRISK</code><span class="sig-paren">(</span>int <strong>thresh</strong>=30, int <strong>octaves</strong>=3, float <strong>patternScale</strong>=1.0f<span class="sig-paren">)</span><a class="headerlink" href="#BRISK::BRISK(int thresh, int octaves, float patternScale)" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>thresh</strong> &#8211; FAST/AGAST detection threshold score.</li>
<li><strong>octaves</strong> &#8211; detection octaves. Use 0 to do single scale.</li>
<li><strong>patternScale</strong> &#8211; apply this scale to the pattern used for sampling the neighbourhood of a keypoint.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="id7">
<h2>BRISK::BRISK<a class="headerlink" href="#id7" title="Permalink to this headline">¶</a></h2>
<p>The BRISK constructor for a custom pattern</p>
<dl class="function">
<dt id="BRISK::BRISK(std::vector&lt;float&gt; &amp;radiusList, std::vector&lt;int&gt; &amp;numberList, float dMax, float dMin, std::vector&lt;int&gt; indexChange)">
<strong>C++:</strong><code class="descname"> </code> <code class="descclassname">BRISK::</code><code class="descname">BRISK</code><span class="sig-paren">(</span>std::vector&lt;float&gt;&amp; <strong>radiusList</strong>, std::vector&lt;int&gt;&amp; <strong>numberList</strong>, float <strong>dMax</strong>=5.85f, float <strong>dMin</strong>=8.2f, std::vector&lt;int&gt; <strong>indexChange</strong>=std::vector&lt;int&gt;()<span class="sig-paren">)</span><a class="headerlink" href="#BRISK::BRISK(std::vector<float> &radiusList, std::vector<int> &numberList, float dMax, float dMin, std::vector<int> indexChange)" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>radiusList</strong> &#8211; defines the radii (in pixels) where the samples around a keypoint are taken (for keypoint scale 1).</li>
<li><strong>numberList</strong> &#8211; defines the number of sampling points on the sampling circle. Must be the same size as radiusList..</li>
<li><strong>dMax</strong> &#8211; threshold for the short pairings used for descriptor formation (in pixels for keypoint scale 1).</li>
<li><strong>dMin</strong> &#8211; threshold for the long pairings used for orientation determination (in pixels for keypoint scale 1).</li>
<li><strong>indexChanges</strong> &#8211; index remapping of the bits.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="brisk-operator">
<h2>BRISK::operator()<a class="headerlink" href="#brisk-operator" title="Permalink to this headline">¶</a></h2>
<p>Finds keypoints in an image and computes their descriptors</p>
<dl class="function">
<dt id="void BRISK::operator()(InputArray image, InputArray mask, vector&lt;KeyPoint&gt;&amp; keypoints, OutputArray descriptors, bool useProvidedKeypoints) const">
<strong>C++:</strong><code class="descname"> </code>void <code class="descclassname">BRISK::</code><code class="descname">operator()</code><span class="sig-paren">(</span>InputArray <strong>image</strong>, InputArray <strong>mask</strong>, vector&lt;KeyPoint&gt;&amp; <strong>keypoints</strong>, OutputArray <strong>descriptors</strong>, bool <strong>useProvidedKeypoints</strong>=false <span class="sig-paren">)</span><code class="descclassname"> const</code><a class="headerlink" href="#void BRISK::operator()(InputArray image, InputArray mask, vector<KeyPoint>& keypoints, OutputArray descriptors, bool useProvidedKeypoints) const" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>image</strong> &#8211; The input 8-bit grayscale image.</li>
<li><strong>mask</strong> &#8211; The operation mask.</li>
<li><strong>keypoints</strong> &#8211; The output vector of keypoints.</li>
<li><strong>descriptors</strong> &#8211; The output descriptors. Pass <code class="docutils literal"><span class="pre">cv::noArray()</span></code> if you do not need it.</li>
<li><strong>useProvidedKeypoints</strong> &#8211; If it is true, then the method will use the provided vector of keypoints instead of detecting them.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="freak">
<h2>FREAK<a class="headerlink" href="#freak" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="FREAK : public DescriptorExtractor">
<em class="property">class </em><code class="descname">FREAK</code> : <em class="property">public</em> <code class="descname">DescriptorExtractor</code><a class="headerlink" href="#FREAK : public DescriptorExtractor" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p>Class implementing the FREAK (<em>Fast Retina Keypoint</em>) keypoint descriptor, described in <a class="reference internal" href="#aov12" id="id8">[AOV12]</a>. The algorithm propose a novel keypoint descriptor inspired by the human visual system and more precisely the retina, coined Fast Retina Key- point (FREAK). A cascade of binary strings is computed by efficiently comparing image intensities over a retinal sampling pattern. FREAKs are in general faster to compute with lower memory load and also more robust than SIFT, SURF or BRISK. They are competitive alternatives to existing keypoints in particular for embedded applications.</p>
<table class="docutils citation" frame="void" id="aov12" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id8">[AOV12]</a></td><td><ol class="first last upperalpha simple">
<li>Alahi, R. Ortiz, and P. Vandergheynst. FREAK: Fast Retina Keypoint. In IEEE Conference on Computer Vision and Pattern Recognition, 2012. CVPR 2012 Open Source Award Winner.</li>
</ol>
</td></tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<ul class="last simple">
<li>An example on how to use the FREAK descriptor can be found at opencv_source_code/samples/cpp/freak_demo.cpp</li>
</ul>
</div>
</div>
<div class="section" id="freak-freak">
<h2>FREAK::FREAK<a class="headerlink" href="#freak-freak" title="Permalink to this headline">¶</a></h2>
<p>The FREAK constructor</p>
<dl class="function">
<dt id="FREAK::FREAK(bool orientationNormalized, bool scaleNormalized, float patternScale, int nOctaves, const vector&lt;int&gt;&amp; selectedPairs)">
<strong>C++:</strong><code class="descname"> </code> <code class="descclassname">FREAK::</code><code class="descname">FREAK</code><span class="sig-paren">(</span>bool <strong>orientationNormalized</strong>=true, bool <strong>scaleNormalized</strong>=true, float <strong>patternScale</strong>=22.0f, int <strong>nOctaves</strong>=4, const vector&lt;int&gt;&amp; <strong>selectedPairs</strong>=vector&lt;int&gt;() <span class="sig-paren">)</span><a class="headerlink" href="#FREAK::FREAK(bool orientationNormalized, bool scaleNormalized, float patternScale, int nOctaves, const vector<int>& selectedPairs)" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>orientationNormalized</strong> &#8211; Enable orientation normalization.</li>
<li><strong>scaleNormalized</strong> &#8211; Enable scale normalization.</li>
<li><strong>patternScale</strong> &#8211; Scaling of the description pattern.</li>
<li><strong>nOctaves</strong> &#8211; Number of octaves covered by the detected keypoints.</li>
<li><strong>selectedPairs</strong> &#8211; (Optional) user defined selected pairs indexes,</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="freak-selectpairs">
<h2>FREAK::selectPairs<a class="headerlink" href="#freak-selectpairs" title="Permalink to this headline">¶</a></h2>
<p>Select the 512 best description pair indexes from an input (grayscale) image set. FREAK is available with a set of pairs learned off-line. Researchers can run a training process to learn their own set of pair. For more details read section 4.2 in: A. Alahi, R. Ortiz, and P. Vandergheynst. FREAK: Fast Retina Keypoint. In IEEE Conference on Computer Vision and Pattern Recognition, 2012.</p>
<p>We notice that for keypoint matching applications, image content has little effect on the selected pairs unless very specific what does matter is the detector type (blobs, corners,...) and the options used (scale/rotation invariance,...). Reduce corrThresh if not enough pairs are selected (43 points &#8211;&gt; 903 possible pairs)</p>
<dl class="function">
<dt id="vector&lt;int&gt; FREAK::selectPairs(const vector&lt;Mat&gt;&amp; images, vector&lt;vector&lt;KeyPoint&gt; &gt;&amp; keypoints, const double corrThresh , bool verbose)">
<strong>C++:</strong><code class="descname"> </code>vector&lt;int&gt; <code class="descclassname">FREAK::</code><code class="descname">selectPairs</code><span class="sig-paren">(</span>const vector&lt;Mat&gt;&amp; <strong>images</strong>, vector&lt;vector&lt;KeyPoint&gt;&gt;&amp; <strong>keypoints</strong>, const double <strong>corrThresh</strong>=0.7, bool <strong>verbose</strong>=true<span class="sig-paren">)</span><a class="headerlink" href="#vector<int> FREAK::selectPairs(const vector<Mat>& images, vector<vector<KeyPoint> >& keypoints, const double corrThresh , bool verbose)" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>images</strong> &#8211; Grayscale image input set.</li>
<li><strong>keypoints</strong> &#8211; Set of detected keypoints</li>
<li><strong>corrThresh</strong> &#8211; Correlation threshold.</li>
<li><strong>verbose</strong> &#8211; Prints pair selection informations.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
</div>


          </div>
          <div class="feedback">
              <h2>Help and Feedback</h2>
              You did not find what you were looking for?
              <ul>
                  
                  
                  
                  <li>Ask a question on the <a href="http://answers.opencv.org">Q&A forum</a>.</li>
                  <li>If you think something is missing or wrong in the documentation,
                  please file a <a href="http://code.opencv.org">bug report</a>.</li>
              </ul>
          </div>
        </div>
      </div>

      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../../../index.html">
              <img class="logo" src="../../../_static/opencv-logo-white.png" alt="Logo"/>
            </a></p>
<div id="searchbox" style="display: none">
      <form class="search" action="../../../search.html" method="get">
      <input type="text" name="q" size="18" />
      <input type="submit" value="Search" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
      </p>
    </form>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
  <h3><a href="../../../index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Feature Detection and Description</a><ul>
<li><a class="reference internal" href="#fast">FAST</a></li>
<li><a class="reference internal" href="#mser">MSER</a></li>
<li><a class="reference internal" href="#mser-mser">MSER::MSER</a></li>
<li><a class="reference internal" href="#mser-operator">MSER::operator()</a></li>
<li><a class="reference internal" href="#orb">ORB</a></li>
<li><a class="reference internal" href="#orb-orb">ORB::ORB</a></li>
<li><a class="reference internal" href="#orb-operator">ORB::operator()</a></li>
<li><a class="reference internal" href="#brisk">BRISK</a></li>
<li><a class="reference internal" href="#brisk-brisk">BRISK::BRISK</a></li>
<li><a class="reference internal" href="#id7">BRISK::BRISK</a></li>
<li><a class="reference internal" href="#brisk-operator">BRISK::operator()</a></li>
<li><a class="reference internal" href="#freak">FREAK</a></li>
<li><a class="reference internal" href="#freak-freak">FREAK::FREAK</a></li>
<li><a class="reference internal" href="#freak-selectpairs">FREAK::selectPairs</a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="features2d.html"
                        title="previous chapter">features2d. 2D Features Framework</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="common_interfaces_of_feature_detectors.html"
                        title="next chapter">Common Interfaces of Feature Detectors</a></p>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../../../_sources/modules/features2d/doc/feature_detection_and_description.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="common_interfaces_of_feature_detectors.html" title="Common Interfaces of Feature Detectors"
             >next</a> |</li>
        <li class="right" >
          <a href="features2d.html" title="features2d. 2D Features Framework"
             >previous</a> |</li>
        <li><a href="../../../index.html">OpenCV 2.4.13.7 documentation</a> &raquo;</li>
          <li><a href="../../refman.html" >OpenCV API Reference</a> &raquo;</li>
          <li><a href="features2d.html" >features2d. 2D Features Framework</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2011-2014, opencv dev team.
      Last updated on Jul 12, 2018.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.3.6.
    </div>
  </body>
</html>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<script type="text/javascript">

  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-33108845-1']);
  _gaq.push(['_setDomainName', 'opencv.org']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();

</script>

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>How to scan images, lookup tables and time measurement with OpenCV &mdash; OpenCV 2.4.13.7 documentation</title>
    <link rel="stylesheet" href="../../../../_static/default.css" type="text/css" />
    <link rel="stylesheet" href="../../../../_static/pygments.css" type="text/css" />
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../../../',
        VERSION:     '2.4.13.7',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../../../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../../../_static/doctools.js"></script>
    <link rel="top" title="OpenCV 2.4.13.7 documentation" href="../../../../index.html" />
    <link rel="up" title="core module. The Core Functionality" href="../table_of_content_core/table_of_content_core.html" />
    <link rel="next" title="Mask operations on matrices" href="../mat-mask-operations/mat-mask-operations.html" />
    <link rel="prev" title="Mat - The Basic Image Container" href="../mat_the_basic_image_container/mat_the_basic_image_container.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../mat-mask-operations/mat-mask-operations.html" title="Mask operations on matrices"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="../mat_the_basic_image_container/mat_the_basic_image_container.html" title="Mat - The Basic Image Container"
             accesskey="P">previous</a> |</li>
        <li><a href="../../../../index.html">OpenCV 2.4.13.7 documentation</a> &raquo;</li>
          <li><a href="../../tutorials.html" >OpenCV Tutorials</a> &raquo;</li>
          <li><a href="../table_of_content_core/table_of_content_core.html" accesskey="U"><em>core</em> module. The Core Functionality</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
  
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="how-to-scan-images-lookup-tables-and-time-measurement-with-opencv">
<span id="howtoscanimagesopencv"></span><h1>How to scan images, lookup tables and time measurement with OpenCV<a class="headerlink" href="#how-to-scan-images-lookup-tables-and-time-measurement-with-opencv" title="Permalink to this headline">¶</a></h1>
<div class="section" id="goal">
<h2>Goal<a class="headerlink" href="#goal" title="Permalink to this headline">¶</a></h2>
<p>We&#8217;ll seek answers for the following questions:</p>
<div class="enumeratevisibleitemswithsquare container">
<ul class="simple">
<li>How to go through each and every pixel of an image?</li>
<li>How is OpenCV matrix values stored?</li>
<li>How to measure the performance of our algorithm?</li>
<li>What are lookup tables and why use them?</li>
</ul>
</div>
</div>
<div class="section" id="our-test-case">
<h2>Our test case<a class="headerlink" href="#our-test-case" title="Permalink to this headline">¶</a></h2>
<p>Let us consider a simple color reduction method. By using the unsigned char C and C++ type for matrix item storing, a channel of pixel may have up to 256 different values. For a three channel image this can allow the formation of way too many colors (16 million to be exact). Working with so many color shades may give a heavy blow to our algorithm performance. However, sometimes it is enough to work with a lot less of them to get the same final result.</p>
<p>In this cases it&#8217;s common that we make a <em>color space reduction</em>. This means that we divide the color space current value with a new input value to end up with fewer colors. For instance every value between zero and nine takes the new value zero, every value between ten and nineteen the value ten and so on.</p>
<p>When you divide an <em>uchar</em> (unsigned char - aka values between zero and 255) value with an <em>int</em> value the result will be also <em>char</em>. These values may only be char values. Therefore, any fraction will be rounded down. Taking advantage of this fact the upper operation in the <em>uchar</em> domain may be expressed as:</p>
<div class="math">
<p><img src="../../../../_images/math/1b67187c3a505075c1fcf87143f53cb103db91c5.png" alt="I_{new} = (\frac{I_{old}}{10}) * 10"/></p>
</div><p>A simple color space reduction algorithm would consist of just passing through every pixel of an image matrix and applying this formula. It&#8217;s worth noting that we do a divide and a multiplication operation. These operations are bloody expensive for a system. If possible it&#8217;s worth avoiding them by using cheaper operations such as a few subtractions, addition or in best case a simple assignment. Furthermore, note that we only have a limited number of input values for the upper operation. In case of the <em>uchar</em> system this is 256 to be exact.</p>
<p>Therefore, for larger images it would be wise to calculate all possible values beforehand and during the assignment just make the assignment, by using a lookup table. Lookup tables are simple arrays (having one or more dimensions) that for a given input value variation holds the final output value. Its strength lies that we do not need to make the calculation, we just need to read the result.</p>
<p>Our test case program (and the sample presented here) will do the following: read in a console line argument image (that may be either color or gray scale - console line argument too) and apply the reduction with the given console line argument integer value. In OpenCV, at the moment they are three major ways of going through an image pixel by pixel. To make things a little more interesting will make the scanning for each image using all of these methods, and print out how long it took.</p>
<p>You can download the full source code <a class="reference download internal" href="../../../../_downloads/how_to_scan_images.cpp" download=""><code class="xref download docutils literal"><span class="pre">here</span></code></a> or look it up in the samples directory of OpenCV at the cpp tutorial code for the core section. Its basic usage is:</p>
<div class="highlight-bash"><div class="highlight"><pre>how_to_scan_images imageName.jpg intValueToReduce <span class="o">[</span>G<span class="o">]</span>
</pre></div>
</div>
<p>The final argument is optional. If given the image will be loaded in gray scale format, otherwise the BGR color way is used. The first thing is to calculate the lookup table.</p>
<div class="highlight-cpp"><div class="highlight"><pre>    <span class="kt">int</span> <span class="n">divideWith</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">// convert our input string to number - C++ style</span>
    <span class="n">stringstream</span> <span class="n">s</span><span class="p">;</span>
    <span class="n">s</span> <span class="o">&lt;&lt;</span> <span class="n">argv</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
    <span class="n">s</span> <span class="o">&gt;&gt;</span> <span class="n">divideWith</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">s</span> <span class="o">||</span> <span class="o">!</span><span class="n">divideWith</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Invalid number entered for dividing. &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">uchar</span> <span class="n">table</span><span class="p">[</span><span class="mi">256</span><span class="p">];</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">256</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
       <span class="n">table</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">uchar</span><span class="p">)(</span><span class="n">divideWith</span> <span class="o">*</span> <span class="p">(</span><span class="n">i</span><span class="o">/</span><span class="n">divideWith</span><span class="p">));</span>
</pre></div>
</div>
<p>Here we first use the C++ <em>stringstream</em> class to convert the third command line argument from text to an integer format. Then we use a simple look and the upper formula to calculate the lookup table. No OpenCV specific stuff here.</p>
<p>Another issue is how do we measure time? Well OpenCV offers two simple functions to achieve this <a class="reference external" href="http://docs.opencv.org/modules/core/doc/utility_and_system_functions_and_macros.html#gettickcount">getTickCount()</a> and <a class="reference external" href="http://docs.opencv.org/modules/core/doc/utility_and_system_functions_and_macros.html#gettickfrequency">getTickFrequency()</a>. The first returns the number of ticks of your systems CPU from a certain event (like since you booted your system). The second returns how many times your CPU emits a tick during a second. So to measure in seconds the number of time elapsed between two operations is easy as:</p>
<div class="highlight-cpp"><div class="highlight"><pre><span class="kt">double</span> <span class="n">t</span> <span class="o">=</span> <span class="p">(</span><span class="kt">double</span><span class="p">)</span><span class="n">getTickCount</span><span class="p">();</span>
<span class="c1">// do something ...</span>
<span class="n">t</span> <span class="o">=</span> <span class="p">((</span><span class="kt">double</span><span class="p">)</span><span class="n">getTickCount</span><span class="p">()</span> <span class="o">-</span> <span class="n">t</span><span class="p">)</span><span class="o">/</span><span class="n">getTickFrequency</span><span class="p">();</span>
<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Times passed in seconds: &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">t</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</pre></div>
</div>
</div>
<div class="section" id="how-the-image-matrix-is-stored-in-the-memory">
<span id="how-image-stored-memory"></span><h2>How the image matrix is stored in the memory?<a class="headerlink" href="#how-the-image-matrix-is-stored-in-the-memory" title="Permalink to this headline">¶</a></h2>
<p>As you could already read in my <a class="reference internal" href="../mat_the_basic_image_container/mat_the_basic_image_container.html#matthebasicimagecontainer"><span>Mat - The Basic Image Container</span></a> tutorial the size of the matrix depends of the color system used. More accurately, it depends from the number of channels used. In case of a gray scale image we have something like:</p>
<div class="math">
<p><img src="../../../../_images/math/146857cf7bb2f26ce5ef0b4ddff686cf6f945204.png" alt="\newcommand{\tabItG}[1] { \textcolor{black}{#1} \cellcolor[gray]{0.8}}
\begin{tabular} {ccccc}
~ &amp; \multicolumn{1}{c}{Column 0} &amp;   \multicolumn{1}{c}{Column 1} &amp;   \multicolumn{1}{c}{Column ...} &amp; \multicolumn{1}{c}{Column m}\\
Row 0 &amp; \tabItG{0,0} &amp; \tabItG{0,1} &amp; \tabItG{...}  &amp; \tabItG{0, m} \\
Row 1 &amp; \tabItG{1,0} &amp; \tabItG{1,1} &amp; \tabItG{...}  &amp; \tabItG{1, m} \\
Row ... &amp; \tabItG{...,0} &amp; \tabItG{...,1} &amp; \tabItG{...} &amp; \tabItG{..., m} \\
Row n &amp; \tabItG{n,0} &amp; \tabItG{n,1} &amp; \tabItG{n,...} &amp; \tabItG{n, m} \\
\end{tabular}"/></p>
</div><p>For multichannel images the columns contain as many sub columns as the number of channels. For example in case of an BGR color system:</p>
<div class="math">
<p><img src="../../../../_images/math/b6df115410caafea291ceb011f19cc4a19ae6c2c.png" alt="\newcommand{\tabIt}[1] { \textcolor{yellow}{#1} \cellcolor{blue} &amp;  \textcolor{black}{#1} \cellcolor{green} &amp; \textcolor{black}{#1} \cellcolor{red}}
\begin{tabular} {ccccccccccccc}
~ &amp; \multicolumn{3}{c}{Column 0} &amp;   \multicolumn{3}{c}{Column 1} &amp;   \multicolumn{3}{c}{Column ...} &amp; \multicolumn{3}{c}{Column m}\\
Row 0 &amp; \tabIt{0,0} &amp; \tabIt{0,1} &amp; \tabIt{...}  &amp; \tabIt{0, m} \\
Row 1 &amp; \tabIt{1,0} &amp; \tabIt{1,1} &amp; \tabIt{...}  &amp; \tabIt{1, m} \\
Row ... &amp; \tabIt{...,0} &amp; \tabIt{...,1} &amp; \tabIt{...} &amp; \tabIt{..., m} \\
Row n &amp; \tabIt{n,0} &amp; \tabIt{n,1} &amp; \tabIt{n,...} &amp; \tabIt{n, m} \\
\end{tabular}"/></p>
</div><p>Because in many cases the memory is large enough to store the rows in a successive fashion the rows may follow one after another, creating a single long row. Because everything is in a single place following one after another this may help to speed up the scanning process. We can use the <a class="reference external" href="http://docs.opencv.org/modules/core/doc/basic_structures.html#mat-iscontinuous">isContinuous()</a> function to <em>ask</em> the matrix if this is the case. Continue on to the next section to find an example.</p>
</div>
<div class="section" id="the-efficient-way">
<h2>The efficient way<a class="headerlink" href="#the-efficient-way" title="Permalink to this headline">¶</a></h2>
<p>When it comes to performance you cannot beat the classic C style operator[] (pointer) access. Therefore, the most efficient method we can recommend for making the assignment is:</p>
<div class="highlight-cpp"><div class="highlight"><pre><span class="n">Mat</span><span class="o">&amp;</span> <span class="n">ScanImageAndReduceC</span><span class="p">(</span><span class="n">Mat</span><span class="o">&amp;</span> <span class="n">I</span><span class="p">,</span> <span class="k">const</span> <span class="n">uchar</span><span class="o">*</span> <span class="k">const</span> <span class="n">table</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// accept only char type matrices</span>
    <span class="n">CV_Assert</span><span class="p">(</span><span class="n">I</span><span class="p">.</span><span class="n">depth</span><span class="p">()</span> <span class="o">==</span> <span class="n">CV_8U</span><span class="p">);</span>

    <span class="kt">int</span> <span class="n">channels</span> <span class="o">=</span> <span class="n">I</span><span class="p">.</span><span class="n">channels</span><span class="p">();</span>

    <span class="kt">int</span> <span class="n">nRows</span> <span class="o">=</span> <span class="n">I</span><span class="p">.</span><span class="n">rows</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">nCols</span> <span class="o">=</span> <span class="n">I</span><span class="p">.</span><span class="n">cols</span> <span class="o">*</span> <span class="n">channels</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">I</span><span class="p">.</span><span class="n">isContinuous</span><span class="p">())</span>
    <span class="p">{</span>
        <span class="n">nCols</span> <span class="o">*=</span> <span class="n">nRows</span><span class="p">;</span>
        <span class="n">nRows</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="kt">int</span> <span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">;</span>
    <span class="n">uchar</span><span class="o">*</span> <span class="n">p</span><span class="p">;</span>
    <span class="k">for</span><span class="p">(</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nRows</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">p</span> <span class="o">=</span> <span class="n">I</span><span class="p">.</span><span class="n">ptr</span><span class="o">&lt;</span><span class="n">uchar</span><span class="o">&gt;</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
        <span class="k">for</span> <span class="p">(</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">nCols</span><span class="p">;</span> <span class="o">++</span><span class="n">j</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">p</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">table</span><span class="p">[</span><span class="n">p</span><span class="p">[</span><span class="n">j</span><span class="p">]];</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">I</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Here we basically just acquire a pointer to the start of each row and go through it until it ends. In the special case that the matrix is stored in a continues manner we only need to request the pointer a single time and go all the way to the end. We need to look out for color images: we have three channels so we need to pass through three times more items in each row.</p>
<p>There&#8217;s another way of this. The <em>data</em> data member of a <em>Mat</em> object returns the pointer to the first row, first column. If this pointer is null you have no valid input in that object. Checking this is the simplest method to check if your image loading was a success. In case the storage is continues we can use this to go through the whole data pointer. In case of a gray scale image this would look like:</p>
<div class="highlight-cpp"><div class="highlight"><pre><span class="n">uchar</span><span class="o">*</span> <span class="n">p</span> <span class="o">=</span> <span class="n">I</span><span class="p">.</span><span class="n">data</span><span class="p">;</span>

<span class="k">for</span><span class="p">(</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">ncol</span><span class="o">*</span><span class="n">nrows</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
    <span class="o">*</span><span class="n">p</span><span class="o">++</span> <span class="o">=</span> <span class="n">table</span><span class="p">[</span><span class="o">*</span><span class="n">p</span><span class="p">];</span>
</pre></div>
</div>
<p>You would get the same result. However, this code is a lot harder to read later on. It gets even harder if you have some more advanced technique there. Moreover, in practice I&#8217;ve observed you&#8217;ll get the same performance result (as most of the modern compilers will probably make this small optimization trick automatically for you).</p>
</div>
<div class="section" id="the-iterator-safe-method">
<h2>The iterator (safe) method<a class="headerlink" href="#the-iterator-safe-method" title="Permalink to this headline">¶</a></h2>
<p>In case of the efficient way making sure that you pass through the right amount of <em>uchar</em> fields and to skip the gaps that may occur between the rows was your responsibility. The iterator method is considered a safer way as it takes over these tasks from the user. All you need to do is ask the begin and the end of the image matrix and then just increase the begin iterator until you reach the end. To acquire the value <em>pointed</em> by the iterator use the * operator (add it before it).</p>
<div class="highlight-cpp"><div class="highlight"><pre><span class="n">Mat</span><span class="o">&amp;</span> <span class="n">ScanImageAndReduceIterator</span><span class="p">(</span><span class="n">Mat</span><span class="o">&amp;</span> <span class="n">I</span><span class="p">,</span> <span class="k">const</span> <span class="n">uchar</span><span class="o">*</span> <span class="k">const</span> <span class="n">table</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// accept only char type matrices</span>
    <span class="n">CV_Assert</span><span class="p">(</span><span class="n">I</span><span class="p">.</span><span class="n">depth</span><span class="p">()</span> <span class="o">==</span> <span class="n">CV_8U</span><span class="p">);</span>

    <span class="k">const</span> <span class="kt">int</span> <span class="n">channels</span> <span class="o">=</span> <span class="n">I</span><span class="p">.</span><span class="n">channels</span><span class="p">();</span>
    <span class="k">switch</span><span class="p">(</span><span class="n">channels</span><span class="p">)</span>
    <span class="p">{</span>
    <span class="k">case</span> <span class="mi">1</span><span class="o">:</span>
        <span class="p">{</span>
            <span class="n">MatIterator_</span><span class="o">&lt;</span><span class="n">uchar</span><span class="o">&gt;</span> <span class="n">it</span><span class="p">,</span> <span class="n">end</span><span class="p">;</span>
            <span class="k">for</span><span class="p">(</span> <span class="n">it</span> <span class="o">=</span> <span class="n">I</span><span class="p">.</span><span class="n">begin</span><span class="o">&lt;</span><span class="n">uchar</span><span class="o">&gt;</span><span class="p">(),</span> <span class="n">end</span> <span class="o">=</span> <span class="n">I</span><span class="p">.</span><span class="n">end</span><span class="o">&lt;</span><span class="n">uchar</span><span class="o">&gt;</span><span class="p">();</span> <span class="n">it</span> <span class="o">!=</span> <span class="n">end</span><span class="p">;</span> <span class="o">++</span><span class="n">it</span><span class="p">)</span>
                <span class="o">*</span><span class="n">it</span> <span class="o">=</span> <span class="n">table</span><span class="p">[</span><span class="o">*</span><span class="n">it</span><span class="p">];</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="k">case</span> <span class="mi">3</span><span class="o">:</span>
        <span class="p">{</span>
            <span class="n">MatIterator_</span><span class="o">&lt;</span><span class="n">Vec3b</span><span class="o">&gt;</span> <span class="n">it</span><span class="p">,</span> <span class="n">end</span><span class="p">;</span>
            <span class="k">for</span><span class="p">(</span> <span class="n">it</span> <span class="o">=</span> <span class="n">I</span><span class="p">.</span><span class="n">begin</span><span class="o">&lt;</span><span class="n">Vec3b</span><span class="o">&gt;</span><span class="p">(),</span> <span class="n">end</span> <span class="o">=</span> <span class="n">I</span><span class="p">.</span><span class="n">end</span><span class="o">&lt;</span><span class="n">Vec3b</span><span class="o">&gt;</span><span class="p">();</span> <span class="n">it</span> <span class="o">!=</span> <span class="n">end</span><span class="p">;</span> <span class="o">++</span><span class="n">it</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="p">(</span><span class="o">*</span><span class="n">it</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">table</span><span class="p">[(</span><span class="o">*</span><span class="n">it</span><span class="p">)[</span><span class="mi">0</span><span class="p">]];</span>
                <span class="p">(</span><span class="o">*</span><span class="n">it</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">table</span><span class="p">[(</span><span class="o">*</span><span class="n">it</span><span class="p">)[</span><span class="mi">1</span><span class="p">]];</span>
                <span class="p">(</span><span class="o">*</span><span class="n">it</span><span class="p">)[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">table</span><span class="p">[(</span><span class="o">*</span><span class="n">it</span><span class="p">)[</span><span class="mi">2</span><span class="p">]];</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="n">I</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>In case of color images we have three uchar items per column. This may be considered a short vector of uchar items, that has been baptized in OpenCV with the <em>Vec3b</em> name. To access the n-th sub column we use simple operator[] access. It&#8217;s important to remember that OpenCV iterators go through the columns and automatically skip to the next row. Therefore in case of color images if you use a simple <em>uchar</em> iterator you&#8217;ll be able to access only the blue channel values.</p>
</div>
<div class="section" id="on-the-fly-address-calculation-with-reference-returning">
<h2>On-the-fly address calculation with reference returning<a class="headerlink" href="#on-the-fly-address-calculation-with-reference-returning" title="Permalink to this headline">¶</a></h2>
<p>The final method isn&#8217;t recommended for scanning. It was made to acquire or modify somehow random elements in the image. Its basic usage is to specify the row and column number of the item you want to access. During our earlier scanning methods you could already observe that is important through what type we are looking at the image. It&#8217;s no different here as you need manually to specify what type to use at the automatic lookup. You can observe this in case of the gray scale images for the following source code (the usage of the + <a class="reference external" href="http://docs.opencv.org/modules/core/doc/basic_structures.html#mat-at">at()</a> function):</p>
<div class="highlight-cpp"><div class="highlight"><pre><span class="n">Mat</span><span class="o">&amp;</span> <span class="n">ScanImageAndReduceRandomAccess</span><span class="p">(</span><span class="n">Mat</span><span class="o">&amp;</span> <span class="n">I</span><span class="p">,</span> <span class="k">const</span> <span class="n">uchar</span><span class="o">*</span> <span class="k">const</span> <span class="n">table</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// accept only char type matrices</span>
    <span class="n">CV_Assert</span><span class="p">(</span><span class="n">I</span><span class="p">.</span><span class="n">depth</span><span class="p">()</span> <span class="o">==</span> <span class="n">CV_8U</span><span class="p">);</span>

    <span class="k">const</span> <span class="kt">int</span> <span class="n">channels</span> <span class="o">=</span> <span class="n">I</span><span class="p">.</span><span class="n">channels</span><span class="p">();</span>
    <span class="k">switch</span><span class="p">(</span><span class="n">channels</span><span class="p">)</span>
    <span class="p">{</span>
    <span class="k">case</span> <span class="mi">1</span><span class="o">:</span>
        <span class="p">{</span>
            <span class="k">for</span><span class="p">(</span> <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">I</span><span class="p">.</span><span class="n">rows</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
                <span class="k">for</span><span class="p">(</span> <span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">I</span><span class="p">.</span><span class="n">cols</span><span class="p">;</span> <span class="o">++</span><span class="n">j</span> <span class="p">)</span>
                    <span class="n">I</span><span class="p">.</span><span class="n">at</span><span class="o">&lt;</span><span class="n">uchar</span><span class="o">&gt;</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">)</span> <span class="o">=</span> <span class="n">table</span><span class="p">[</span><span class="n">I</span><span class="p">.</span><span class="n">at</span><span class="o">&lt;</span><span class="n">uchar</span><span class="o">&gt;</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">)];</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="k">case</span> <span class="mi">3</span><span class="o">:</span>
        <span class="p">{</span>
         <span class="n">Mat_</span><span class="o">&lt;</span><span class="n">Vec3b</span><span class="o">&gt;</span> <span class="n">_I</span> <span class="o">=</span> <span class="n">I</span><span class="p">;</span>

         <span class="k">for</span><span class="p">(</span> <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">I</span><span class="p">.</span><span class="n">rows</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
            <span class="k">for</span><span class="p">(</span> <span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">I</span><span class="p">.</span><span class="n">cols</span><span class="p">;</span> <span class="o">++</span><span class="n">j</span> <span class="p">)</span>
               <span class="p">{</span>
                   <span class="n">_I</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">table</span><span class="p">[</span><span class="n">_I</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">)[</span><span class="mi">0</span><span class="p">]];</span>
                   <span class="n">_I</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">table</span><span class="p">[</span><span class="n">_I</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">)[</span><span class="mi">1</span><span class="p">]];</span>
                   <span class="n">_I</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">)[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">table</span><span class="p">[</span><span class="n">_I</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">)[</span><span class="mi">2</span><span class="p">]];</span>
            <span class="p">}</span>
         <span class="n">I</span> <span class="o">=</span> <span class="n">_I</span><span class="p">;</span>
         <span class="k">break</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="n">I</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The functions takes your input type and coordinates and calculates on the fly the address of the queried item. Then returns a reference to that. This may be a constant when you <em>get</em> the value and non-constant when you <em>set</em> the value. As a safety step in <strong>debug mode only*</strong> there is performed a check that your input coordinates are valid and does exist. If this isn&#8217;t the case you&#8217;ll get a nice output message of this on the standard error output stream. Compared to the efficient way in release mode the only difference in using this is that for every element of the image you&#8217;ll get a new row pointer for what we use the C operator[] to acquire the column element.</p>
<p>If you need to multiple lookups using this method for an image it may be troublesome and time consuming to enter the type and the at keyword for each of the accesses. To solve this problem OpenCV has a <a class="reference external" href="http://docs.opencv.org/modules/core/doc/basic_structures.html#id3">Mat_</a> data type. It&#8217;s the same as Mat with the extra need that at definition you need to specify the data type through what to look at the data matrix, however in return you can use the operator() for fast access of items. To make things even better this is easily convertible from and to the usual <a class="reference external" href="http://docs.opencv.org/modules/core/doc/basic_structures.html#id3">Mat</a> data type. A sample usage of this you can see in case of the color images of the upper function. Nevertheless, it&#8217;s important to note that the same operation (with the same runtime speed) could have been done with the <a class="reference external" href="http://docs.opencv.org/modules/core/doc/basic_structures.html#mat-at">at()</a> function. It&#8217;s just a less to write for the lazy programmer trick.</p>
</div>
<div class="section" id="the-core-function">
<h2>The Core Function<a class="headerlink" href="#the-core-function" title="Permalink to this headline">¶</a></h2>
<p>This is a bonus method of achieving lookup table modification in an image. Because in image processing it&#8217;s quite common that you want to replace all of a given image value to some other value OpenCV has a function that makes the modification without the need from you to write the scanning of the image. We use the <a class="reference external" href="http://docs.opencv.org/modules/core/doc/operations_on_arrays.html#lut">LUT()</a> function of the core module. First we build a Mat type of the lookup table:</p>
<div class="highlight-cpp"><div class="highlight"><pre>    <span class="n">Mat</span> <span class="nf">lookUpTable</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">256</span><span class="p">,</span> <span class="n">CV_8U</span><span class="p">);</span>
    <span class="n">uchar</span><span class="o">*</span> <span class="n">p</span> <span class="o">=</span> <span class="n">lookUpTable</span><span class="p">.</span><span class="n">data</span><span class="p">;</span>
    <span class="k">for</span><span class="p">(</span> <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">256</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
        <span class="n">p</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">table</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
</pre></div>
</div>
<p>Finally call the function (I is our input image and J the output one):</p>
<div class="highlight-cpp"><div class="highlight"><pre>        <span class="n">LUT</span><span class="p">(</span><span class="n">I</span><span class="p">,</span> <span class="n">lookUpTable</span><span class="p">,</span> <span class="n">J</span><span class="p">);</span>
</pre></div>
</div>
</div>
<div class="section" id="performance-difference">
<h2>Performance Difference<a class="headerlink" href="#performance-difference" title="Permalink to this headline">¶</a></h2>
<p>For the best result compile the program and run it on your own speed. For showing off better the differences I&#8217;ve used a quite large (2560 X 1600) image. The performance presented here are for color images. For a more accurate value I&#8217;ve averaged the value I got from the call of the function for hundred times.</p>
<table border="1" class="docutils">
<colgroup>
<col width="39%" />
<col width="61%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>Efficient Way</td>
<td>79.4717 milliseconds</td>
</tr>
<tr class="row-even"><td>Iterator</td>
<td>83.7201 milliseconds</td>
</tr>
<tr class="row-odd"><td>On-The-Fly RA</td>
<td>93.7878 milliseconds</td>
</tr>
<tr class="row-even"><td>LUT function</td>
<td>32.5759 milliseconds</td>
</tr>
</tbody>
</table>
<p>We can conclude a couple of things. If possible, use the already made functions of OpenCV (instead reinventing these). The fastest method turns out to be the LUT function. This is because the OpenCV library is multi-thread enabled via Intel Threaded Building Blocks. However, if you need to write a simple image scan prefer the pointer method. The iterator is a safer bet, however quite slower. Using the on-the-fly reference access method for full image scan is the most costly in debug mode. In the release mode it may beat the iterator approach or not, however it surely sacrifices for this the safety trait of iterators.</p>
<p>Finally, you may watch a sample run of the program on the <a class="reference external" href="https://www.youtube.com/watch?v=fB3AN5fjgwc">video posted</a> on our YouTube channel.</p>
<div align="center">
<iframe title="How to scan images in OpenCV?" width="560" height="349" src="https://www.youtube.com/embed/fB3AN5fjgwc?rel=0&loop=1" frameborder="0" allowfullscreen align="middle"></iframe>
</div></div>
</div>


          </div>
          <div class="feedback">
              <h2>Help and Feedback</h2>
              You did not find what you were looking for?
              <ul>
                  
                  
                  
                  <li>Ask a question on the <a href="http://answers.opencv.org">Q&A forum</a>.</li>
                  <li>If you think something is missing or wrong in the documentation,
                  please file a <a href="http://code.opencv.org">bug report</a>.</li>
              </ul>
          </div>
        </div>
      </div>

      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../../../../index.html">
              <img class="logo" src="../../../../_static/opencv-logo-white.png" alt="Logo"/>
            </a></p>
<div id="searchbox" style="display: none">
      <form class="search" action="../../../../search.html" method="get">
      <input type="text" name="q" size="18" />
      <input type="submit" value="Search" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
      </p>
    </form>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
  <h3><a href="../../../../index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">How to scan images, lookup tables and time measurement with OpenCV</a><ul>
<li><a class="reference internal" href="#goal">Goal</a></li>
<li><a class="reference internal" href="#our-test-case">Our test case</a></li>
<li><a class="reference internal" href="#how-the-image-matrix-is-stored-in-the-memory">How the image matrix is stored in the memory?</a></li>
<li><a class="reference internal" href="#the-efficient-way">The efficient way</a></li>
<li><a class="reference internal" href="#the-iterator-safe-method">The iterator (safe) method</a></li>
<li><a class="reference internal" href="#on-the-fly-address-calculation-with-reference-returning">On-the-fly address calculation with reference returning</a></li>
<li><a class="reference internal" href="#the-core-function">The Core Function</a></li>
<li><a class="reference internal" href="#performance-difference">Performance Difference</a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="../mat_the_basic_image_container/mat_the_basic_image_container.html"
                        title="previous chapter">Mat - The Basic Image Container</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="../mat-mask-operations/mat-mask-operations.html"
                        title="next chapter">Mask operations on matrices</a></p>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../../../../_sources/doc/tutorials/core/how_to_scan_images/how_to_scan_images.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../mat-mask-operations/mat-mask-operations.html" title="Mask operations on matrices"
             >next</a> |</li>
        <li class="right" >
          <a href="../mat_the_basic_image_container/mat_the_basic_image_container.html" title="Mat - The Basic Image Container"
             >previous</a> |</li>
        <li><a href="../../../../index.html">OpenCV 2.4.13.7 documentation</a> &raquo;</li>
          <li><a href="../../tutorials.html" >OpenCV Tutorials</a> &raquo;</li>
          <li><a href="../table_of_content_core/table_of_content_core.html" ><em>core</em> module. The Core Functionality</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2011-2014, opencv dev team.
      Last updated on Jul 12, 2018.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.3.6.
    </div>
  </body>
</html>

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<script type="text/javascript">

  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-33108845-1']);
  _gaq.push(['_setDomainName', 'opencv.org']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();

</script>

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Index &mdash; OpenCV 2.4.13.7 documentation</title>
    <link rel="stylesheet" href="_static/default.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '2.4.13.7',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <link rel="top" title="OpenCV 2.4.13.7 documentation" href="index.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="#" title="General Index"
             accesskey="I">index</a></li>
        <li><a href="index.html">OpenCV 2.4.13.7 documentation</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
  
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            

<h1 id="index">Index</h1>

<div class="genindex-jumpbox">
 <a href="#Symbols"><strong>Symbols</strong></a>
 | <a href="#A"><strong>A</strong></a>
 | <a href="#B"><strong>B</strong></a>
 | <a href="#C"><strong>C</strong></a>
 | <a href="#D"><strong>D</strong></a>
 | <a href="#E"><strong>E</strong></a>
 | <a href="#F"><strong>F</strong></a>
 | <a href="#G"><strong>G</strong></a>
 | <a href="#H"><strong>H</strong></a>
 | <a href="#I"><strong>I</strong></a>
 | <a href="#K"><strong>K</strong></a>
 | <a href="#L"><strong>L</strong></a>
 | <a href="#M"><strong>M</strong></a>
 | <a href="#N"><strong>N</strong></a>
 | <a href="#O"><strong>O</strong></a>
 | <a href="#P"><strong>P</strong></a>
 | <a href="#Q"><strong>Q</strong></a>
 | <a href="#R"><strong>R</strong></a>
 | <a href="#S"><strong>S</strong></a>
 | <a href="#T"><strong>T</strong></a>
 | <a href="#U"><strong>U</strong></a>
 | <a href="#V"><strong>V</strong></a>
 | <a href="#W"><strong>W</strong></a>
 | <a href="#X"><strong>X</strong></a>
 
</div>
<h2 id="Symbols">Symbols</h2>
<table style="width: 100%" class="indextable genindextable"><tr>
  <td style="width: 33%" valign="top"><dl>
      
  <dt><a href="modules/imgproc/doc/geometric_transformations.html#CvMat* cv2DRotationMatrix(CvPoint2D32f center, double angle, double scale, CvMat* map_matrix)"><strong>2DRotationMatrix (C function)</strong></a>
  </dt>

  </dl></td>
</tr></table>

<h2 id="A">A</h2>
<table style="width: 100%" class="indextable genindextable"><tr>
  <td style="width: 33%" valign="top"><dl>
      
  <dt><a href="modules/core/doc/operations_on_arrays.html#MatExpr abs(const Mat& m)"><strong>abs (C++ function)</strong></a>, <a href="modules/core/doc/operations_on_arrays.html#MatExpr abs(const MatExpr& e)"><strong>[1]</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#void cvAbsDiff(const CvArr* src1, const CvArr* src2, CvArr* dst)"><strong>AbsDiff (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#void absdiff(InputArray src1, InputArray src2, OutputArray dst)"><strong>absdiff (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#cv.AbsDiff"><strong>AbsDiff() (Python function in cv)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#cv2.absdiff"><strong>absdiff() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#void cvAbsDiffS(const CvArr* src, CvArr* dst, CvScalar value)"><strong>AbsDiffS (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#cv.AbsDiffS"><strong>AbsDiffS() (Python function in cv)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/motion_analysis_and_object_tracking.html#void cvAcc(const CvArr* image, CvArr* sum, const CvArr* mask)"><strong>Acc (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/motion_analysis_and_object_tracking.html#cv.Acc"><strong>Acc() (Python function in cv)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/motion_analysis_and_object_tracking.html#void accumulate(InputArray src, InputOutputArray dst, InputArray mask)"><strong>accumulate (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/motion_analysis_and_object_tracking.html#cv2.accumulate"><strong>accumulate() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/motion_analysis_and_object_tracking.html#void accumulateProduct(InputArray src1, InputArray src2, InputOutputArray dst, InputArray mask)"><strong>accumulateProduct (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/motion_analysis_and_object_tracking.html#cv2.accumulateProduct"><strong>accumulateProduct() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/motion_analysis_and_object_tracking.html#void accumulateSquare(InputArray src, InputOutputArray dst, InputArray mask)"><strong>accumulateSquare (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/motion_analysis_and_object_tracking.html#cv2.accumulateSquare"><strong>accumulateSquare() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/motion_analysis_and_object_tracking.html#void accumulateWeighted(InputArray src, InputOutputArray dst, double alpha, InputArray mask)"><strong>accumulateWeighted (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/motion_analysis_and_object_tracking.html#cv2.accumulateWeighted"><strong>accumulateWeighted() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/filtering.html#void adaptiveBilateralFilter(InputArray src, OutputArray dst, Size ksize, double sigmaSpace, double maxSigmaColor , Point anchor, int borderType)"><strong>adaptiveBilateralFilter (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/filtering.html#cv2.adaptiveBilateralFilter"><strong>adaptiveBilateralFilter() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/miscellaneous_transformations.html#void cvAdaptiveThreshold(const CvArr* src, CvArr* dst, double max_value, int adaptive_method, int threshold_type, int block_size, double param1)"><strong>AdaptiveThreshold (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/miscellaneous_transformations.html#void adaptiveThreshold(InputArray src, OutputArray dst, double maxValue, int adaptiveMethod, int thresholdType, int blockSize, double C)"><strong>adaptiveThreshold (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/miscellaneous_transformations.html#cv.AdaptiveThreshold"><strong>AdaptiveThreshold() (Python function in cv)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/miscellaneous_transformations.html#cv2.adaptiveThreshold"><strong>adaptiveThreshold() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#void cvAdd(const CvArr* src1, const CvArr* src2, CvArr* dst, const CvArr* mask)"><strong>Add (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/contrib/doc/openfabmap.html#virtual void add(const Mat& queryImgDescriptor)"><strong>add (C++ function)</strong></a>, <a href="modules/contrib/doc/openfabmap.html#virtual void add(const vector<Mat>& queryImgDescriptors)"><strong>[1]</strong></a>, <a href="modules/core/doc/operations_on_arrays.html#void add(InputArray src1, InputArray src2, OutputArray dst, InputArray mask, int dtype)"><strong>[2]</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#cv.Add"><strong>Add() (Python function in cv)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#cv2.add"><strong>add() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/viz/doc/widget.html#void addCloud(InputArray cloud, InputArray colors, const Affine3d &pose)"><strong>addCloud (C++ function)</strong></a>, <a href="modules/viz/doc/widget.html#void addCloud(InputArray cloud, const Color &color , const Affine3d &pose)"><strong>[1]</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#void cvAddS(const CvArr* src, CvScalar value, CvArr* dst, const CvArr* mask)"><strong>AddS (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#cv.AddS"><strong>AddS() (Python function in cv)</strong></a>
  </dt>

      
  <dt><a href="modules/highgui/doc/qt_new_functions.html#void cvAddText(const CvArr* img, const char* text, CvPoint org, CvFont * arg2)"><strong>AddText (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/highgui/doc/qt_new_functions.html#void addText(const Mat& img, const string& text, Point org, CvFont font)"><strong>addText (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/contrib/doc/openfabmap.html#virtual void addTraining(const Mat& queryImgDescriptor)"><strong>addTraining (C++ function)</strong></a>, <a href="modules/contrib/doc/openfabmap.html#virtual void addTraining(const vector<Mat>& queryImgDescriptors)"><strong>[1]</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#void cvAddWeighted(const CvArr* src1, double alpha, const CvArr* src2, double beta, double gamma, CvArr* dst)"><strong>AddWeighted (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#void addWeighted(InputArray src1, double alpha, InputArray src2, double beta, double gamma, OutputArray dst, int dtype)"><strong>addWeighted (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#cv.AddWeighted"><strong>AddWeighted() (Python function in cv)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#cv2.addWeighted"><strong>addWeighted() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/viz/doc/widget.html#void addWidget(const Widget3D& widget, const Affine3d &pose)"><strong>addWidget (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/features2d/doc/common_interfaces_of_feature_detectors.html#AdjusterAdapter : public FeatureDetector"><strong>AdjusterAdapter (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/features2d/doc/common_interfaces_of_feature_detectors.html#Ptr<AdjusterAdapter> AdjusterAdapter::create(const string& detectorType)"><strong>AdjusterAdapter::create (C++ function)</strong></a>
  </dt>

  </dl></td>
  <td style="width: 33%" valign="top"><dl>
      
  <dt><a href="modules/features2d/doc/common_interfaces_of_feature_detectors.html#bool AdjusterAdapter::good() const"><strong>AdjusterAdapter::good (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/features2d/doc/common_interfaces_of_feature_detectors.html#void AdjusterAdapter::tooFew(int min, int n_detected)"><strong>AdjusterAdapter::tooFew (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/features2d/doc/common_interfaces_of_feature_detectors.html#void AdjusterAdapter::tooMany(int max, int n_detected)"><strong>AdjusterAdapter::tooMany (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/basic_structures.html#Algorithm"><strong>Algorithm (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/basic_structures.html#template<typename _Tp> Ptr<_Tp> Algorithm::create(const string& name)"><strong>Algorithm::create (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/basic_structures.html#template<typename _Tp> typename ParamType<_Tp>::member_type Algorithm::get(const string& name) const"><strong>Algorithm::get (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/basic_structures.html#void Algorithm::getList(vector<string>& algorithms)"><strong>Algorithm::getList (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/basic_structures.html#string Algorithm::name() const"><strong>Algorithm::name (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/basic_structures.html#void Algorithm::read(const FileNode& fn)"><strong>Algorithm::read (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/basic_structures.html#void Algorithm::set(const string& name, bool value)"><strong>Algorithm::set (C++ function)</strong></a>, <a href="modules/core/doc/basic_structures.html#void Algorithm::set(const string& name, const Mat& value)"><strong>[1]</strong></a>, <a href="modules/core/doc/basic_structures.html#void Algorithm::set(const string& name, const Ptr<Algorithm>& value)"><strong>[2]</strong></a>, <a href="modules/core/doc/basic_structures.html#void Algorithm::set(const string& name, const string& value)"><strong>[3]</strong></a>, <a href="modules/core/doc/basic_structures.html#void Algorithm::set(const string& name, const vector<Mat>& value)"><strong>[4]</strong></a>, <a href="modules/core/doc/basic_structures.html#void Algorithm::set(const string& name, double value)"><strong>[5]</strong></a>, <a href="modules/core/doc/basic_structures.html#void Algorithm::set(const string& name, int value)"><strong>[6]</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/basic_structures.html#void Algorithm::write(FileStorage& fs) const"><strong>Algorithm::write (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/utility_and_system_functions_and_macros.html#template<typename _Tp> _Tp* alignPtr(_Tp* ptr, int n)"><strong>alignPtr (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/utility_and_system_functions_and_macros.html#size_t alignSize(size_t sz, int n)"><strong>alignSize (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/utility_and_system_functions_and_macros.html#void* cvAlloc(size_t size)"><strong>Alloc (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/utility_and_system_functions_and_macros.html#template<typename _Tp> _Tp* allocate(size_t n)"><strong>allocate (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#void cvAnd(const CvArr* src1, const CvArr* src2, CvArr* dst, const CvArr* mask)"><strong>And (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#cv.And"><strong>And() (Python function in cv)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#void cvAndS(const CvArr* src, CvScalar value, CvArr* dst, const CvArr* mask)"><strong>AndS (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#cv.AndS"><strong>AndS() (Python function in cv)</strong></a>
  </dt>

      
  <dt><a href="modules/ml/doc/neural_networks.html#cv2.ANN_MLP"><strong>ANN_MLP() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/ml/doc/neural_networks.html#cv2.ANN_MLP.create"><strong>ANN_MLP.create() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/ml/doc/neural_networks.html#cv2.ANN_MLP.predict"><strong>ANN_MLP.predict() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/ml/doc/neural_networks.html#cv2.ANN_MLP.train"><strong>ANN_MLP.train() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/contrib/doc/facerec/colormaps.html#void applyColorMap(InputArray src, OutputArray dst, int colormap)"><strong>applyColorMap (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/viz/doc/widget.html#void applyTransform(const Affine3d &transform)"><strong>applyTransform (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/structural_analysis_and_shape_descriptors.html#CvSeq* cvApproxChains(CvSeq* src_seq, CvMemStorage* storage, int method, double parameter, int minimal_perimeter, int recursive)"><strong>ApproxChains (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/structural_analysis_and_shape_descriptors.html#cv.ApproxChains"><strong>ApproxChains() (Python function in cv)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/structural_analysis_and_shape_descriptors.html#CvSeq* cvApproxPoly(const void* src_seq, int header_size, CvMemStorage* storage, int method, double eps, int recursive)"><strong>ApproxPoly (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/structural_analysis_and_shape_descriptors.html#void approxPolyDP(InputArray curve, OutputArray approxCurve, double epsilon, bool closed)"><strong>approxPolyDP (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/structural_analysis_and_shape_descriptors.html#cv2.approxPolyDP"><strong>approxPolyDP() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/structural_analysis_and_shape_descriptors.html#double cvArcLength(const void* curve, CvSlice slice, int is_closed)"><strong>ArcLength (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/structural_analysis_and_shape_descriptors.html#double arcLength(InputArray curve, bool closed)"><strong>arcLength (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/structural_analysis_and_shape_descriptors.html#cv.ArcLength"><strong>ArcLength() (Python function in cv)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/structural_analysis_and_shape_descriptors.html#cv2.arcLength"><strong>arcLength() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/drawing_functions.html#void arrowedLine(Mat& img, Point pt1, Point pt2, const Scalar& color, int thickness, int line_type, int shift, double tipLength)"><strong>arrowedLine (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#CvScalar cvAvg(const CvArr* arr, const CvArr* mask)"><strong>Avg (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#cv.Avg"><strong>Avg() (Python function in cv)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#void cvAvgSdv(const CvArr* arr, CvScalar* mean, CvScalar* std_dev, const CvArr* mask)"><strong>AvgSdv (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#cv.AvgSdv"><strong>AvgSdv() (Python function in cv)</strong></a>
  </dt>

  </dl></td>
</tr></table>

<h2 id="B">B</h2>
<table style="width: 100%" class="indextable genindextable"><tr>
  <td style="width: 33%" valign="top"><dl>
      
  <dt><a href="modules/video/doc/motion_analysis_and_object_tracking.html#BackgroundSubtractor : public Algorithm"><strong>BackgroundSubtractor (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/video/doc/motion_analysis_and_object_tracking.html#cv2.BackgroundSubtractor.apply"><strong>BackgroundSubtractor.apply() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/video/doc/motion_analysis_and_object_tracking.html#void BackgroundSubtractor::getBackgroundImage(OutputArray backgroundImage) const"><strong>BackgroundSubtractor::getBackgroundImage (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/video/doc/motion_analysis_and_object_tracking.html#void BackgroundSubtractor::operator()(InputArray image, OutputArray fgmask, double learningRate)"><strong>BackgroundSubtractor::operator() (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/video/doc/motion_analysis_and_object_tracking.html#BackgroundSubtractorMOG : public BackgroundSubtractor"><strong>BackgroundSubtractorMOG (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/video/doc/motion_analysis_and_object_tracking.html#cv2.BackgroundSubtractorMOG"><strong>BackgroundSubtractorMOG() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/video/doc/motion_analysis_and_object_tracking.html#BackgroundSubtractorMOG2 : public BackgroundSubtractor"><strong>BackgroundSubtractorMOG2 (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/video/doc/motion_analysis_and_object_tracking.html#float backgroundRatio"><strong>BackgroundSubtractorMOG2::backgroundRatio (C++ member)</strong></a>
  </dt>

      
  <dt><a href="modules/video/doc/motion_analysis_and_object_tracking.html#BackgroundSubtractorMOG2::BackgroundSubtractorMOG2()"><strong>BackgroundSubtractorMOG2::BackgroundSubtractorMOG2 (C++ function)</strong></a>, <a href="modules/video/doc/motion_analysis_and_object_tracking.html#BackgroundSubtractorMOG2::BackgroundSubtractorMOG2(int history, float varThreshold, bool bShadowDetection)"><strong>[1]</strong></a>
  </dt>

      
  <dt><a href="modules/video/doc/motion_analysis_and_object_tracking.html#float fCT"><strong>BackgroundSubtractorMOG2::fCT (C++ member)</strong></a>
  </dt>

      
  <dt><a href="modules/video/doc/motion_analysis_and_object_tracking.html#float fTau"><strong>BackgroundSubtractorMOG2::fTau (C++ member)</strong></a>
  </dt>

      
  <dt><a href="modules/video/doc/motion_analysis_and_object_tracking.html#float fVarInit"><strong>BackgroundSubtractorMOG2::fVarInit (C++ member)</strong></a>
  </dt>

      
  <dt><a href="modules/video/doc/motion_analysis_and_object_tracking.html#float fVarMax"><strong>BackgroundSubtractorMOG2::fVarMax (C++ member)</strong></a>
  </dt>

      
  <dt><a href="modules/video/doc/motion_analysis_and_object_tracking.html#float fVarMin"><strong>BackgroundSubtractorMOG2::fVarMin (C++ member)</strong></a>
  </dt>

      
  <dt><a href="modules/video/doc/motion_analysis_and_object_tracking.html#void BackgroundSubtractorMOG2::getBackgroundImage(OutputArray backgroundImage)"><strong>BackgroundSubtractorMOG2::getBackgroundImage (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/video/doc/motion_analysis_and_object_tracking.html#int nmixtures"><strong>BackgroundSubtractorMOG2::nmixtures (C++ member)</strong></a>
  </dt>

      
  <dt><a href="modules/video/doc/motion_analysis_and_object_tracking.html#uchar nShadowDetection"><strong>BackgroundSubtractorMOG2::nShadowDetection (C++ member)</strong></a>
  </dt>

      
  <dt><a href="modules/video/doc/motion_analysis_and_object_tracking.html#void BackgroundSubtractorMOG2::operator()(InputArray image, OutputArray fgmask, double learningRate)"><strong>BackgroundSubtractorMOG2::operator() (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/video/doc/motion_analysis_and_object_tracking.html#float varThresholdGen"><strong>BackgroundSubtractorMOG2::varThresholdGen (C++ member)</strong></a>
  </dt>

      
  <dt><a href="modules/video/doc/motion_analysis_and_object_tracking.html#BackgroundSubtractorMOG::BackgroundSubtractorMOG()"><strong>BackgroundSubtractorMOG::BackgroundSubtractorMOG (C++ function)</strong></a>, <a href="modules/video/doc/motion_analysis_and_object_tracking.html#BackgroundSubtractorMOG::BackgroundSubtractorMOG(int history, int nmixtures, double backgroundRatio, double noiseSigma)"><strong>[1]</strong></a>
  </dt>

      
  <dt><a href="modules/video/doc/motion_analysis_and_object_tracking.html#void BackgroundSubtractorMOG::operator()(InputArray image, OutputArray fgmask, double learningRate)"><strong>BackgroundSubtractorMOG::operator() (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/filtering.html#BaseColumnFilter"><strong>BaseColumnFilter (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/filtering.html#BaseFilter"><strong>BaseFilter (C++ class)</strong></a>
  </dt>

      
  <dt><a href="platforms/android/service/doc/BaseLoaderCallback.html#BaseLoaderCallback">BaseLoaderCallback (built-in class)</a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/filtering.html#BaseRowFilter"><strong>BaseRowFilter (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/features2d/doc/common_interfaces_of_descriptor_matchers.html#BFMatcher : public DescriptorMatcher"><strong>BFMatcher (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/features2d/doc/common_interfaces_of_descriptor_matchers.html#BFMatcher::BFMatcher(int normType, bool crossCheck)"><strong>BFMatcher::BFMatcher (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/filtering.html#void bilateralFilter(InputArray src, OutputArray dst, int d, double sigmaColor, double sigmaSpace, int borderType)"><strong>bilateralFilter (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/filtering.html#cv2.bilateralFilter"><strong>bilateralFilter() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#void bitwise_and(InputArray src1, InputArray src2, OutputArray dst, InputArray mask)"><strong>bitwise_and (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#cv2.bitwise_and"><strong>bitwise_and() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#void bitwise_not(InputArray src, OutputArray dst, InputArray mask)"><strong>bitwise_not (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#cv2.bitwise_not"><strong>bitwise_not() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#void bitwise_or(InputArray src1, InputArray src2, OutputArray dst, InputArray mask)"><strong>bitwise_or (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#cv2.bitwise_or"><strong>bitwise_or() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#void bitwise_xor(InputArray src1, InputArray src2, OutputArray dst, InputArray mask)"><strong>bitwise_xor (C++ function)</strong></a>
  </dt>

  </dl></td>
  <td style="width: 33%" valign="top"><dl>
      
  <dt><a href="modules/core/doc/operations_on_arrays.html#cv2.bitwise_xor"><strong>bitwise_xor() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/filtering.html#void blur(InputArray src, OutputArray dst, Size ksize, Point anchor, int borderType)"><strong>blur (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/filtering.html#cv2.blur"><strong>blur() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/ml/doc/boosting.html#cv2.Boost"><strong>Boost() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/ml/doc/boosting.html#cv2.Boost.predict"><strong>Boost.predict() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/ml/doc/boosting.html#cv2.Boost.prune"><strong>Boost.prune() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/ml/doc/boosting.html#cv2.Boost.train"><strong>Boost.train() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/filtering.html#int borderInterpolate(int p, int len, int borderType)"><strong>borderInterpolate (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/filtering.html#cv2.borderInterpolate"><strong>borderInterpolate() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/structural_analysis_and_shape_descriptors.html#CvRect cvBoundingRect(CvArr* points, int update)"><strong>BoundingRect (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/structural_analysis_and_shape_descriptors.html#Rect boundingRect(InputArray points)"><strong>boundingRect (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/structural_analysis_and_shape_descriptors.html#cv.BoundingRect"><strong>BoundingRect() (Python function in cv)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/structural_analysis_and_shape_descriptors.html#cv2.boundingRect"><strong>boundingRect() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/features2d/doc/object_categorization.html#BOWImgDescriptorExtractor"><strong>BOWImgDescriptorExtractor (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/features2d/doc/object_categorization.html#BOWImgDescriptorExtractor::BOWImgDescriptorExtractor(const Ptr<DescriptorExtractor>& dextractor, const Ptr<DescriptorMatcher>& dmatcher)"><strong>BOWImgDescriptorExtractor::BOWImgDescriptorExtractor (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/features2d/doc/object_categorization.html#void BOWImgDescriptorExtractor::compute(const Mat& image, vector<KeyPoint>& keypoints, Mat& imgDescriptor, vector<vector<int> >* pointIdxsOfClusters, Mat* descriptors)"><strong>BOWImgDescriptorExtractor::compute (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/features2d/doc/object_categorization.html#int BOWImgDescriptorExtractor::descriptorSize() const"><strong>BOWImgDescriptorExtractor::descriptorSize (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/features2d/doc/object_categorization.html#int BOWImgDescriptorExtractor::descriptorType() const"><strong>BOWImgDescriptorExtractor::descriptorType (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/features2d/doc/object_categorization.html#const Mat& BOWImgDescriptorExtractor::getVocabulary() const"><strong>BOWImgDescriptorExtractor::getVocabulary (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/features2d/doc/object_categorization.html#void BOWImgDescriptorExtractor::setVocabulary(const Mat& vocabulary)"><strong>BOWImgDescriptorExtractor::setVocabulary (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/features2d/doc/object_categorization.html#BOWKMeansTrainer : public BOWTrainer"><strong>BOWKMeansTrainer (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/features2d/doc/object_categorization.html#BOWKMeansTrainer::BOWKMeansTrainer(int clusterCount, const TermCriteria& termcrit, int attempts, int flags)"><strong>BOWKMeansTrainer::BOWKMeansTrainer (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/features2d/doc/object_categorization.html#BOWTrainer"><strong>BOWTrainer (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/features2d/doc/object_categorization.html#void BOWTrainer::add(const Mat& descriptors)"><strong>BOWTrainer::add (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/features2d/doc/object_categorization.html#Mat BOWTrainer::cluster() const"><strong>BOWTrainer::cluster (C++ function)</strong></a>, <a href="modules/features2d/doc/object_categorization.html#Mat BOWTrainer::cluster(const Mat& descriptors) const"><strong>[1]</strong></a>
  </dt>

      
  <dt><a href="modules/features2d/doc/object_categorization.html#int BOWTrainer::descripotorsCount() const"><strong>BOWTrainer::descripotorsCount (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/features2d/doc/object_categorization.html#const vector<Mat>& BOWTrainer::getDescriptors() const"><strong>BOWTrainer::getDescriptors (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/filtering.html#void boxFilter(InputArray src, OutputArray dst, int ddepth, Size ksize, Point anchor, bool normalize, int borderType)"><strong>boxFilter (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/filtering.html#cv2.boxFilter"><strong>boxFilter() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/features2d/doc/common_interfaces_of_descriptor_extractors.html#BriefDescriptorExtractor : public DescriptorExtractor"><strong>BriefDescriptorExtractor (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/features2d/doc/feature_detection_and_description.html#BRISK : public Feature2D"><strong>BRISK (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/features2d/doc/feature_detection_and_description.html#BRISK::BRISK(int thresh, int octaves, float patternScale)"><strong>BRISK::BRISK (C++ function)</strong></a>, <a href="modules/features2d/doc/feature_detection_and_description.html#BRISK::BRISK(std::vector<float> &radiusList, std::vector<int> &numberList, float dMax, float dMin, std::vector<int> indexChange)"><strong>[1]</strong></a>
  </dt>

      
  <dt><a href="modules/features2d/doc/feature_detection_and_description.html#void BRISK::operator()(InputArray image, InputArray mask, vector<KeyPoint>& keypoints, OutputArray descriptors, bool useProvidedKeypoints) const"><strong>BRISK::operator() (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/video/doc/motion_analysis_and_object_tracking.html#int buildOpticalFlowPyramid(InputArray img, OutputArrayOfArrays pyramid, Size winSize, int maxLevel, bool withDerivatives , int pyrBorder , int derivBorder , bool tryReuseInputImage)"><strong>buildOpticalFlowPyramid (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/video/doc/motion_analysis_and_object_tracking.html#cv2.buildOpticalFlowPyramid"><strong>buildOpticalFlowPyramid() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/filtering.html#void buildPyramid(InputArray src, OutputArrayOfArrays dst, int maxlevel, int borderType)"><strong>buildPyramid (C++ function)</strong></a>
  </dt>

  </dl></td>
</tr></table>

<h2 id="C">C</h2>
<table style="width: 100%" class="indextable genindextable"><tr>
  <td style="width: 33%" valign="top"><dl>
      
  <dt><a href="modules/imgproc/doc/histograms.html#void cvCalcBackProject(IplImage** image, CvArr* backProject, const CvHistogram* hist)"><strong>CalcBackProject (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/histograms.html#void calcBackProject(const Mat* images, int nimages, const int* channels, InputArray hist, OutputArray backProject, const float** ranges, double scale, bool uniform)"><strong>calcBackProject (C++ function)</strong></a>, <a href="modules/imgproc/doc/histograms.html#void calcBackProject(const Mat* images, int nimages, const int* channels, const SparseMat& hist, OutputArray backProject, const float** ranges, double scale, bool uniform)"><strong>[1]</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/histograms.html#cv.CalcBackProject"><strong>CalcBackProject() (Python function in cv)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/histograms.html#cv2.calcBackProject"><strong>calcBackProject() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/histograms.html#void cvCalcBackProjectPatch(IplImage** images, CvArr* dst, CvSize patch_size, CvHistogram* hist, int method, double factor)"><strong>CalcBackProjectPatch (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/histograms.html#cv.CalcBackProjectPatch"><strong>CalcBackProjectPatch() (Python function in cv)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#void cvCalcCovarMatrix(const CvArr** vects, int count, CvArr* cov_mat, CvArr* avg, int flags)"><strong>CalcCovarMatrix (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#void calcCovarMatrix(InputArray samples, OutputArray covar, OutputArray mean, int flags, int ctype)"><strong>calcCovarMatrix (C++ function)</strong></a>, <a href="modules/core/doc/operations_on_arrays.html#void calcCovarMatrix(const Mat* samples, int nsamples, Mat& covar, Mat& mean, int flags, int ctype)"><strong>[1]</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#cv.CalcCovarMatrix"><strong>CalcCovarMatrix() (Python function in cv)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#cv2.calcCovarMatrix"><strong>calcCovarMatrix() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/histograms.html#float cvCalcEMD2(const CvArr* signature1, const CvArr* signature2, int distance_type, CvDistanceFunction distance_func, const CvArr* cost_matrix, CvArr* flow, float* lower_bound, void* userdata)"><strong>CalcEMD2 (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/histograms.html#cv.CalcEMD2"><strong>CalcEMD2() (Python function in cv)</strong></a>
  </dt>

      
  <dt><a href="modules/video/doc/motion_analysis_and_object_tracking.html#double cvCalcGlobalOrientation(const CvArr* orientation, const CvArr* mask, const CvArr* mhi, double timestamp, double duration)"><strong>CalcGlobalOrientation (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/video/doc/motion_analysis_and_object_tracking.html#double calcGlobalOrientation(InputArray orientation, InputArray mask, InputArray mhi, double timestamp, double duration)"><strong>calcGlobalOrientation (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/video/doc/motion_analysis_and_object_tracking.html#cv.CalcGlobalOrientation"><strong>CalcGlobalOrientation() (Python function in cv)</strong></a>
  </dt>

      
  <dt><a href="modules/video/doc/motion_analysis_and_object_tracking.html#cv2.calcGlobalOrientation"><strong>calcGlobalOrientation() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/histograms.html#void cvCalcHist(IplImage** image, CvHistogram* hist, int accumulate, const CvArr* mask)"><strong>CalcHist (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/histograms.html#void calcHist(const Mat* images, int nimages, const int* channels, InputArray mask, OutputArray hist, int dims, const int* histSize, const float** ranges, bool uniform, bool accumulate)"><strong>calcHist (C++ function)</strong></a>, <a href="modules/imgproc/doc/histograms.html#void calcHist(const Mat* images, int nimages, const int* channels, InputArray mask, SparseMat& hist, int dims, const int* histSize, const float** ranges, bool uniform, bool accumulate)"><strong>[1]</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/histograms.html#cv.CalcHist"><strong>CalcHist() (Python function in cv)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/histograms.html#cv2.calcHist"><strong>calcHist() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/video/doc/motion_analysis_and_object_tracking.html#void cvCalcMotionGradient(const CvArr* mhi, CvArr* mask, CvArr* orientation, double delta1, double delta2, int aperture_size)"><strong>CalcMotionGradient (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/video/doc/motion_analysis_and_object_tracking.html#void calcMotionGradient(InputArray mhi, OutputArray mask, OutputArray orientation, double delta1, double delta2, int apertureSize)"><strong>calcMotionGradient (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/video/doc/motion_analysis_and_object_tracking.html#cv.CalcMotionGradient"><strong>CalcMotionGradient() (Python function in cv)</strong></a>
  </dt>

      
  <dt><a href="modules/video/doc/motion_analysis_and_object_tracking.html#cv2.calcMotionGradient"><strong>calcMotionGradient() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/legacy/doc/motion_analysis.html#void cvCalcOpticalFlowBM(const CvArr* prev, const CvArr* curr, CvSize block_size, CvSize shift_size, CvSize max_range, int use_previous, CvArr* velx, CvArr* vely)"><strong>CalcOpticalFlowBM (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/legacy/doc/motion_analysis.html#cv.CalcOpticalFlowBM"><strong>CalcOpticalFlowBM() (Python function in cv)</strong></a>
  </dt>

      
  <dt><a href="modules/video/doc/motion_analysis_and_object_tracking.html#void cvCalcOpticalFlowFarneback(const CvArr* prev, const CvArr* next, CvArr* flow, double pyr_scale, int levels, int winsize, int iterations, int poly_n, double poly_sigma, int flags)"><strong>CalcOpticalFlowFarneback (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/video/doc/motion_analysis_and_object_tracking.html#void calcOpticalFlowFarneback(InputArray prev, InputArray next, InputOutputArray flow, double pyr_scale, int levels, int winsize, int iterations, int poly_n, double poly_sigma, int flags)"><strong>calcOpticalFlowFarneback (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/video/doc/motion_analysis_and_object_tracking.html#cv2.calcOpticalFlowFarneback"><strong>calcOpticalFlowFarneback() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/legacy/doc/motion_analysis.html#void cvCalcOpticalFlowHS(const CvArr* prev, const CvArr* curr, int use_previous, CvArr* velx, CvArr* vely, double lambda, CvTermCriteria criteria)"><strong>CalcOpticalFlowHS (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/legacy/doc/motion_analysis.html#cv.CalcOpticalFlowHS"><strong>CalcOpticalFlowHS() (Python function in cv)</strong></a>
  </dt>

      
  <dt><a href="modules/legacy/doc/motion_analysis.html#void cvCalcOpticalFlowLK(const CvArr* prev, const CvArr* curr, CvSize win_size, CvArr* velx, CvArr* vely)"><strong>CalcOpticalFlowLK (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/legacy/doc/motion_analysis.html#cv.CalcOpticalFlowLK"><strong>CalcOpticalFlowLK() (Python function in cv)</strong></a>
  </dt>

      
  <dt><a href="modules/video/doc/motion_analysis_and_object_tracking.html#void cvCalcOpticalFlowPyrLK(const CvArr* prev, const CvArr* curr, CvArr* prev_pyr, CvArr* curr_pyr, const CvPoint2D32f* prev_features, CvPoint2D32f* curr_features, int count, CvSize win_size, int level, char* status, float* track_error, CvTermCriteria criteria, int flags)"><strong>CalcOpticalFlowPyrLK (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/video/doc/motion_analysis_and_object_tracking.html#void calcOpticalFlowPyrLK(InputArray prevImg, InputArray nextImg, InputArray prevPts, InputOutputArray nextPts, OutputArray status, OutputArray err, Size winSize, int maxLevel, TermCriteria criteria, int flags, double minEigThreshold)"><strong>calcOpticalFlowPyrLK (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/video/doc/motion_analysis_and_object_tracking.html#cv.CalcOpticalFlowPyrLK"><strong>CalcOpticalFlowPyrLK() (Python function in cv)</strong></a>
  </dt>

      
  <dt><a href="modules/video/doc/motion_analysis_and_object_tracking.html#cv2.calcOpticalFlowPyrLK"><strong>calcOpticalFlowPyrLK() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/video/doc/motion_analysis_and_object_tracking.html#void calcOpticalFlowSF(Mat& from, Mat& to, Mat& flow, int layers, int averaging_block_size, int max_flow)"><strong>calcOpticalFlowSF (C++ function)</strong></a>, <a href="modules/video/doc/motion_analysis_and_object_tracking.html#void calcOpticalFlowSF(Mat& from, Mat& to, Mat& flow, int layers, int averaging_block_size, int max_flow, double sigma_dist, double sigma_color, int postprocess_window, double sigma_dist_fix, double sigma_color_fix, double occ_thr, int upscale_averaging_radius, double upscale_sigma_dist, double upscale_sigma_color, double speed_up_thr)"><strong>[1]</strong></a>
  </dt>

      
  <dt><a href="modules/legacy/doc/histograms.html#void cvCalcPGH(const CvSeq* contour, CvHistogram* hist)"><strong>CalcPGH (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/histograms.html#void cvCalcProbDensity(const CvHistogram* hist1, const CvHistogram* hist2, CvHistogram* dst_hist, double scale)"><strong>CalcProbDensity (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/histograms.html#cv.CalcProbDensity"><strong>CalcProbDensity() (Python function in cv)</strong></a>
  </dt>

      
  <dt><a href="modules/legacy/doc/planar_subdivisions.html#void cvCalcSubdivVoronoi2D(CvSubdiv2D* subdiv)"><strong>CalcSubdivVoronoi2D (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/legacy/doc/planar_subdivisions.html#cv.CalcSubdivVoronoi2D"><strong>CalcSubdivVoronoi2D() (Python function in cv)</strong></a>
  </dt>

      
  <dt><a href="modules/calib3d/doc/camera_calibration_and_3d_reconstruction.html#double calibrateCamera(InputArrayOfArrays objectPoints, InputArrayOfArrays imagePoints, Size imageSize, InputOutputArray cameraMatrix, InputOutputArray distCoeffs, OutputArrayOfArrays rvecs, OutputArrayOfArrays tvecs, int flags, TermCriteria criteria)"><strong>calibrateCamera (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/calib3d/doc/camera_calibration_and_3d_reconstruction.html#cv2.calibrateCamera"><strong>calibrateCamera() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/calib3d/doc/camera_calibration_and_3d_reconstruction.html#double cvCalibrateCamera2(const CvMat* object_points, const CvMat* image_points, const CvMat* point_counts, CvSize image_size, CvMat* camera_matrix, CvMat* distortion_coeffs, CvMat* rotation_vectors, CvMat* translation_vectors, int flags, CvTermCriteria term_crit)"><strong>CalibrateCamera2 (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/calib3d/doc/camera_calibration_and_3d_reconstruction.html#cv.CalibrateCamera2"><strong>CalibrateCamera2() (Python function in cv)</strong></a>
  </dt>

      
  <dt><a href="modules/calib3d/doc/camera_calibration_and_3d_reconstruction.html#void calibrationMatrixValues(InputArray cameraMatrix, Size imageSize, double apertureWidth, double apertureHeight, double& fovx, double& fovy, double& focalLength, Point2d& principalPoint, double& aspectRatio)"><strong>calibrationMatrixValues (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/calib3d/doc/camera_calibration_and_3d_reconstruction.html#cv2.calibrationMatrixValues"><strong>calibrationMatrixValues() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/legacy/doc/common_interfaces_of_descriptor_extractors.html#CalonderDescriptorExtractor : public DescriptorExtractor"><strong>CalonderDescriptorExtractor (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/viz/doc/viz3d.html#Camera"><strong>Camera (C++ class)</strong></a>
  </dt>

      <dd><dl>
        
  <dt><a href="modules/viz/doc/viz3d.html#Camera(const Matx33d &K, const Size &window_size)"><strong>(C++ function)</strong></a>, <a href="modules/viz/doc/viz3d.html#Camera(const Matx44d &proj, const Size &window_size)"><strong>[1]</strong></a>, <a href="modules/viz/doc/viz3d.html#Camera(const Vec2d &fov, const Size &window_size)"><strong>[2]</strong></a>, <a href="modules/viz/doc/viz3d.html#Camera(double f_x, double f_y, double c_x, double c_y, const Size &window_size)"><strong>[3]</strong></a>
  </dt>

      </dl></dd>
      
  <dt><a href="modules/video/doc/motion_analysis_and_object_tracking.html#int cvCamShift(const CvArr* prob_image, CvRect window, CvTermCriteria criteria, CvConnectedComp* comp, CvBox2D* box)"><strong>CamShift (C function)</strong></a>
  </dt>

      <dd><dl>
        
  <dt><a href="modules/video/doc/motion_analysis_and_object_tracking.html#RotatedRect CamShift(InputArray probImage, Rect& window, TermCriteria criteria)"><strong>(C++ function)</strong></a>
  </dt>

      </dl></dd>
      
  <dt><a href="modules/video/doc/motion_analysis_and_object_tracking.html#cv.CamShift"><strong>CamShift() (Python function in cv)</strong></a>
  </dt>

      <dd><dl>
        
  <dt><a href="modules/video/doc/motion_analysis_and_object_tracking.html#cv2.CamShift"><strong>(Python function in cv2)</strong></a>
  </dt>

      </dl></dd>
      
  <dt><a href="modules/imgproc/doc/feature_detection.html#void cvCanny(const CvArr* image, CvArr* edges, double threshold1, double threshold2, int aperture_size)"><strong>Canny (C function)</strong></a>
  </dt>

      <dd><dl>
        
  <dt><a href="modules/imgproc/doc/feature_detection.html#void Canny(InputArray image, OutputArray edges, double threshold1, double threshold2, int apertureSize, bool L2gradient)"><strong>(C++ function)</strong></a>
  </dt>

      </dl></dd>
      
  <dt><a href="modules/imgproc/doc/feature_detection.html#cv.Canny"><strong>Canny() (Python function in cv)</strong></a>
  </dt>

      <dd><dl>
        
  <dt><a href="modules/imgproc/doc/feature_detection.html#cv2.Canny"><strong>(Python function in cv2)</strong></a>
  </dt>

      </dl></dd>
      
  <dt><a href="modules/highgui/doc/reading_and_writing_images_and_video.html#CvCapture* cvCaptureFromCAM(int device)"><strong>CaptureFromCAM (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/highgui/doc/reading_and_writing_images_and_video.html#cv.CaptureFromCAM"><strong>CaptureFromCAM() (Python function in cv)</strong></a>
  </dt>

      
  <dt><a href="modules/highgui/doc/reading_and_writing_images_and_video.html#CvCapture* cvCaptureFromFile(const char* filename)"><strong>CaptureFromFile (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/highgui/doc/reading_and_writing_images_and_video.html#cv.CaptureFromFile"><strong>CaptureFromFile() (Python function in cv)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#void cvCartToPolar(const CvArr* x, const CvArr* y, CvArr* magnitude, CvArr* angle, int angle_in_degrees)"><strong>CartToPolar (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#void cartToPolar(InputArray x, InputArray y, OutputArray magnitude, OutputArray angle, bool angleInDegrees)"><strong>cartToPolar (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#cv.CartToPolar"><strong>CartToPolar() (Python function in cv)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#cv2.cartToPolar"><strong>cartToPolar() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/objdetect/doc/cascade_classification.html#CascadeClassifier"><strong>CascadeClassifier (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/objdetect/doc/cascade_classification.html#cv2.CascadeClassifier"><strong>CascadeClassifier() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/objdetect/doc/cascade_classification.html#cv2.CascadeClassifier.detectMultiScale"><strong>CascadeClassifier.detectMultiScale() (Python function in cv2)</strong></a>, <a href="modules/objdetect/doc/cascade_classification.html#cv2.CascadeClassifier.detectMultiScale"><strong>[1]</strong></a>
  </dt>

      
  <dt><a href="modules/objdetect/doc/cascade_classification.html#cv2.CascadeClassifier.empty"><strong>CascadeClassifier.empty() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/objdetect/doc/cascade_classification.html#cv2.CascadeClassifier.load"><strong>CascadeClassifier.load() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/objdetect/doc/cascade_classification.html#CascadeClassifier::CascadeClassifier(const string& filename)"><strong>CascadeClassifier::CascadeClassifier (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/objdetect/doc/cascade_classification.html#void CascadeClassifier::detectMultiScale(const Mat& image, vector<Rect>& objects, double scaleFactor, int minNeighbors, int flags, Size minSize, Size maxSize)"><strong>CascadeClassifier::detectMultiScale (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/objdetect/doc/cascade_classification.html#bool CascadeClassifier::empty() const"><strong>CascadeClassifier::empty (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/objdetect/doc/cascade_classification.html#bool CascadeClassifier::load(const string& filename)"><strong>CascadeClassifier::load (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/objdetect/doc/cascade_classification.html#bool CascadeClassifier::read(const FileNode& node)"><strong>CascadeClassifier::read (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/objdetect/doc/cascade_classification.html#int CascadeClassifier::runAt(Ptr<FeatureEvaluator>& feval, Point pt, double& weight)"><strong>CascadeClassifier::runAt (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/objdetect/doc/cascade_classification.html#bool CascadeClassifier::setImage(Ptr<FeatureEvaluator>& feval, const Mat& image)"><strong>CascadeClassifier::setImage (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/viz/doc/widget.html#template<typename _W> _W cast()"><strong>cast (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/utility_and_system_functions_and_macros.html#float cvCbrt(float value)"><strong>Cbrt (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/utility_and_system_functions_and_macros.html#cv.Cbrt"><strong>Cbrt() (Python function in cv)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/utility_and_system_functions_and_macros.html#int cvCeil(double value)"><strong>Ceil (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/utility_and_system_functions_and_macros.html#cv.Ceil"><strong>Ceil() (Python function in cv)</strong></a>
  </dt>

      
  <dt><a href="modules/calib3d/doc/camera_calibration_and_3d_reconstruction.html#center">center (built-in class)</a>, <a href="modules/calib3d/doc/camera_calibration_and_3d_reconstruction.html#center">[1]</a>, <a href="modules/calib3d/doc/camera_calibration_and_3d_reconstruction.html#center">[2]</a>, <a href="modules/calib3d/doc/camera_calibration_and_3d_reconstruction.html#center">[3]</a>, <a href="modules/calib3d/doc/camera_calibration_and_3d_reconstruction.html#center">[4]</a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/structural_analysis_and_shape_descriptors.html#int cvCheckContourConvexity(const CvArr* contour)"><strong>CheckContourConvexity (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/structural_analysis_and_shape_descriptors.html#cv.CheckContourConvexity"><strong>CheckContourConvexity() (Python function in cv)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/utility_and_system_functions_and_macros.html#int cvCheckHardwareSupport(int feature)"><strong>CheckHardwareSupport (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/utility_and_system_functions_and_macros.html#bool checkHardwareSupport(int feature)"><strong>checkHardwareSupport (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/utility_and_system_functions_and_macros.html#cv2.checkHardwareSupport"><strong>checkHardwareSupport() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#bool checkRange(InputArray a, bool quiet, Point* pos, double minVal, double maxVal)"><strong>checkRange (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#cv2.checkRange"><strong>checkRange() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/drawing_functions.html#void cvCircle(CvArr* img, CvPoint center, int radius, CvScalar color, int thickness, int line_type, int shift)"><strong>Circle (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/drawing_functions.html#void circle(Mat& img, Point center, int radius, const Scalar& color, int thickness, int lineType, int shift)"><strong>circle (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/drawing_functions.html#cv.Circle"><strong>Circle() (Python function in cv)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/drawing_functions.html#cv2.circle"><strong>circle() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/dynamic_structures.html#void cvClearGraph(CvGraph* graph)"><strong>ClearGraph (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/histograms.html#void cvClearHist(CvHistogram* hist)"><strong>ClearHist (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/histograms.html#cv.ClearHist"><strong>ClearHist() (Python function in cv)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/dynamic_structures.html#void cvClearMemStorage(CvMemStorage* storage)"><strong>ClearMemStorage (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_basic_structures.html#void cvClearND(CvArr* arr, const int* idx)"><strong>ClearND (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_basic_structures.html#cv.ClearND"><strong>ClearND() (Python function in cv)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/dynamic_structures.html#void cvClearSeq(CvSeq* seq)"><strong>ClearSeq (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/dynamic_structures.html#void cvClearSet(CvSet* set_header)"><strong>ClearSet (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/legacy/doc/planar_subdivisions.html#void cvClearSubdivVoronoi2D(CvSubdiv2D* subdiv)"><strong>ClearSubdivVoronoi2D (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/legacy/doc/planar_subdivisions.html#cv.ClearSubdivVoronoi2D"><strong>ClearSubdivVoronoi2D() (Python function in cv)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/drawing_functions.html#int cvClipLine(CvSize img_size, CvPoint* pt1, CvPoint* pt2)"><strong>ClipLine (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/drawing_functions.html#bool clipLine(Rect imgRect, Point& pt1, Point& pt2)"><strong>clipLine (C++ function)</strong></a>, <a href="modules/core/doc/drawing_functions.html#bool clipLine(Size imgSize, Point& pt1, Point& pt2)"><strong>[1]</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/drawing_functions.html#cv.ClipLine"><strong>ClipLine() (Python function in cv)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/drawing_functions.html#cv2.clipLine"><strong>clipLine() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_xml_yaml_persistence.html#void* cvClone(const void* struct_ptr)"><strong>Clone (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/dynamic_structures.html#CvGraph* cvCloneGraph(const CvGraph* graph, CvMemStorage* storage)"><strong>CloneGraph (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_basic_structures.html#IplImage* cvCloneImage(const IplImage* image)"><strong>CloneImage (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_basic_structures.html#cv.CloneImage"><strong>CloneImage() (Python function in cv)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_basic_structures.html#CvMat* cvCloneMat(const CvMat* mat)"><strong>CloneMat (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_basic_structures.html#cv.CloneMat"><strong>CloneMat() (Python function in cv)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_basic_structures.html#CvMatND* cvCloneMatND(const CvMatND* mat)"><strong>CloneMatND (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_basic_structures.html#cv.CloneMatND"><strong>CloneMatND() (Python function in cv)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/dynamic_structures.html#CvSeq* cvCloneSeq(const CvSeq* seq, CvMemStorage* storage)"><strong>CloneSeq (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/dynamic_structures.html#cv.CloneSeq"><strong>CloneSeq() (Python function in cv)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_basic_structures.html#CvSparseMat* cvCloneSparseMat(const CvSparseMat* mat)"><strong>CloneSparseMat (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#void cvCmp(const CvArr* src1, const CvArr* src2, CvArr* dst, int cmp_op)"><strong>Cmp (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#cv.Cmp"><strong>Cmp() (Python function in cv)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#void cvCmpS(const CvArr* src, double value, CvArr* dst, int cmp_op)"><strong>CmpS (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#cv.CmpS"><strong>CmpS() (Python function in cv)</strong></a>
  </dt>

      
  <dt><a href="modules/viz/doc/viz3d.html#Color"><strong>Color (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/contrib/doc/openfabmap.html#void compare(const Mat& queryImgDescriptor, const Mat& testImgDescriptors, vector<IMatch>& matches, const Mat& mask)"><strong>compare (C++ function)</strong></a>, <a href="modules/contrib/doc/openfabmap.html#void compare(const Mat& queryImgDescriptor, const vector<Mat>& testImgDescriptors, vector<IMatch>& matches, const Mat& mask)"><strong>[1]</strong></a>, <a href="modules/contrib/doc/openfabmap.html#void compare(const Mat& queryImgDescriptor, vector<IMatch>& matches, bool addQuery , const Mat& mask)"><strong>[2]</strong></a>, <a href="modules/contrib/doc/openfabmap.html#void compare(const vector<Mat>& queryImgDescriptors, const vector<Mat>& testImgDescriptors, vector<IMatch>& matches, const Mat& mask)"><strong>[3]</strong></a>, <a href="modules/contrib/doc/openfabmap.html#void compare(const vector<Mat>& queryImgDescriptors, vector<IMatch>& matches, bool addQuery , const Mat& mask)"><strong>[4]</strong></a>, <a href="modules/core/doc/operations_on_arrays.html#void compare(InputArray src1, InputArray src2, OutputArray dst, int cmpop)"><strong>[5]</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#cv2.compare"><strong>compare() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/histograms.html#double cvCompareHist(const CvHistogram* hist1, const CvHistogram* hist2, int method)"><strong>CompareHist (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/histograms.html#double compareHist(InputArray H1, InputArray H2, int method)"><strong>compareHist (C++ function)</strong></a>, <a href="modules/imgproc/doc/histograms.html#double compareHist(const SparseMat& H1, const SparseMat& H2, int method)"><strong>[1]</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/histograms.html#cv.CompareHist"><strong>CompareHist() (Python function in cv)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/histograms.html#cv2.compareHist"><strong>compareHist() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#void completeSymm(InputOutputArray mtx, bool lowerToUpper)"><strong>completeSymm (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#cv2.completeSymm"><strong>completeSymm() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/calib3d/doc/camera_calibration_and_3d_reconstruction.html#void composeRT(InputArray rvec1, InputArray tvec1, InputArray rvec2, InputArray tvec2, OutputArray rvec3, OutputArray tvec3, OutputArray dr3dr1, OutputArray dr3dt1, OutputArray dr3dr2, OutputArray dr3dt2, OutputArray dt3dr1, OutputArray dt3dt1, OutputArray dt3dr2, OutputArray dt3dt2)"><strong>composeRT (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/calib3d/doc/camera_calibration_and_3d_reconstruction.html#cv2.composeRT"><strong>composeRT() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/calib3d/doc/camera_calibration_and_3d_reconstruction.html#void cvComputeCorrespondEpilines(const CvMat* points, int which_image, const CvMat* fundamental_matrix, CvMat* correspondent_lines)"><strong>ComputeCorrespondEpilines (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/calib3d/doc/camera_calibration_and_3d_reconstruction.html#void computeCorrespondEpilines(InputArray points, int whichImage, InputArray F, OutputArray lines)"><strong>computeCorrespondEpilines (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/calib3d/doc/camera_calibration_and_3d_reconstruction.html#cv.ComputeCorrespondEpilines"><strong>ComputeCorrespondEpilines() (Python function in cv)</strong></a>
  </dt>

      
  <dt><a href="modules/viz/doc/viz3d.html#void computeProjectionMatrix(Matx44d &proj) const"><strong>computeProjectionMatrix (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/structural_analysis_and_shape_descriptors.html#double cvContourArea(const CvArr* contour, CvSlice slice, int oriented)"><strong>ContourArea (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/structural_analysis_and_shape_descriptors.html#double contourArea(InputArray contour, bool oriented)"><strong>contourArea (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/structural_analysis_and_shape_descriptors.html#cv.ContourArea"><strong>ContourArea() (Python function in cv)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/structural_analysis_and_shape_descriptors.html#cv2.contourArea"><strong>contourArea() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_basic_structures.html#cv.Convert"><strong>Convert() (Python function in cv)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/geometric_transformations.html#void convertMaps(InputArray map1, InputArray map2, OutputArray dstmap1, OutputArray dstmap2, int dstmap1type, bool nninterpolation)"><strong>convertMaps (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/geometric_transformations.html#cv2.convertMaps"><strong>convertMaps() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/viz/doc/viz3d.html#void converTo3DRay(const Point3d &window_coord, Point3d &origin, Vec3d &direction)"><strong>converTo3DRay (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/calib3d/doc/camera_calibration_and_3d_reconstruction.html#void convertPointsFromHomogeneous(InputArray src, OutputArray dst)"><strong>convertPointsFromHomogeneous (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/calib3d/doc/camera_calibration_and_3d_reconstruction.html#cv2.convertPointsFromHomogeneous"><strong>convertPointsFromHomogeneous() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/calib3d/doc/camera_calibration_and_3d_reconstruction.html#void cvConvertPointsHomogeneous(const CvMat* src, CvMat* dst)"><strong>ConvertPointsHomogeneous (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/calib3d/doc/camera_calibration_and_3d_reconstruction.html#void convertPointsHomogeneous(InputArray src, OutputArray dst)"><strong>convertPointsHomogeneous (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/calib3d/doc/camera_calibration_and_3d_reconstruction.html#cv.ConvertPointsHomogeneous"><strong>ConvertPointsHomogeneous() (Python function in cv)</strong></a>
  </dt>

      
  <dt><a href="modules/calib3d/doc/camera_calibration_and_3d_reconstruction.html#void convertPointsToHomogeneous(InputArray src, OutputArray dst)"><strong>convertPointsToHomogeneous (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/calib3d/doc/camera_calibration_and_3d_reconstruction.html#cv2.convertPointsToHomogeneous"><strong>convertPointsToHomogeneous() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_basic_structures.html#void cvConvertScale(const CvArr* src, CvArr* dst, double scale, double shift)"><strong>ConvertScale (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_basic_structures.html#cv.ConvertScale"><strong>ConvertScale() (Python function in cv)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#void cvConvertScaleAbs(const CvArr* src, CvArr* dst, double scale, double shift)"><strong>ConvertScaleAbs (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#void convertScaleAbs(InputArray src, OutputArray dst, double alpha, double beta)"><strong>convertScaleAbs (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#cv.ConvertScaleAbs"><strong>ConvertScaleAbs() (Python function in cv)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#cv2.convertScaleAbs"><strong>convertScaleAbs() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/viz/doc/viz3d.html#void convertToWindowCoordinates(const Point3d &pt, Point3d &window_coord)"><strong>convertToWindowCoordinates (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/structural_analysis_and_shape_descriptors.html#void convexHull(InputArray points, OutputArray hull, bool clockwise, bool returnPoints)"><strong>convexHull (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/structural_analysis_and_shape_descriptors.html#cv2.convexHull"><strong>convexHull() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/structural_analysis_and_shape_descriptors.html#CvSeq* cvConvexHull2(const CvArr* input, void* hull_storage, int orientation, int return_points)"><strong>ConvexHull2 (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/structural_analysis_and_shape_descriptors.html#cv.ConvexHull2"><strong>ConvexHull2() (Python function in cv)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/structural_analysis_and_shape_descriptors.html#CvSeq* cvConvexityDefects(const CvArr* contour, const CvArr* convexhull, CvMemStorage* storage)"><strong>ConvexityDefects (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/structural_analysis_and_shape_descriptors.html#void convexityDefects(InputArray contour, InputArray convexhull, OutputArray convexityDefects)"><strong>convexityDefects (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/structural_analysis_and_shape_descriptors.html#cv.ConvexityDefects"><strong>ConvexityDefects() (Python function in cv)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/structural_analysis_and_shape_descriptors.html#cv2.convexityDefects"><strong>convexityDefects() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_basic_structures.html#void cvCopy(const CvArr* src, CvArr* dst, const CvArr* mask)"><strong>Copy (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_basic_structures.html#cv.Copy"><strong>Copy() (Python function in cv)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/histograms.html#void cvCopyHist(const CvHistogram* src, CvHistogram** dst)"><strong>CopyHist (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/filtering.html#void cvCopyMakeBorder(const CvArr* src, CvArr* dst, CvPoint offset, int bordertype, CvScalar value)"><strong>CopyMakeBorder (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/filtering.html#void copyMakeBorder(InputArray src, OutputArray dst, int top, int bottom, int left, int right, int borderType, const Scalar& value)"><strong>copyMakeBorder (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/filtering.html#cv.CopyMakeBorder"><strong>CopyMakeBorder() (Python function in cv)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/filtering.html#cv2.copyMakeBorder"><strong>copyMakeBorder() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/feature_detection.html#void cvCornerEigenValsAndVecs(const CvArr* image, CvArr* eigenvv, int block_size, int aperture_size)"><strong>CornerEigenValsAndVecs (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/feature_detection.html#void cornerEigenValsAndVecs(InputArray src, OutputArray dst, int blockSize, int ksize, int borderType)"><strong>cornerEigenValsAndVecs (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/feature_detection.html#cv.CornerEigenValsAndVecs"><strong>CornerEigenValsAndVecs() (Python function in cv)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/feature_detection.html#cv2.cornerEigenValsAndVecs"><strong>cornerEigenValsAndVecs() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/feature_detection.html#void cvCornerHarris(const CvArr* image, CvArr* harris_response, int block_size, int aperture_size, double k)"><strong>CornerHarris (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/feature_detection.html#void cornerHarris(InputArray src, OutputArray dst, int blockSize, int ksize, double k, int borderType)"><strong>cornerHarris (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/feature_detection.html#cv.CornerHarris"><strong>CornerHarris() (Python function in cv)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/feature_detection.html#cv2.cornerHarris"><strong>cornerHarris() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/feature_detection.html#void cvCornerMinEigenVal(const CvArr* image, CvArr* eigenval, int block_size, int aperture_size)"><strong>CornerMinEigenVal (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/feature_detection.html#void cornerMinEigenVal(InputArray src, OutputArray dst, int blockSize, int ksize, int borderType)"><strong>cornerMinEigenVal (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/feature_detection.html#cv.CornerMinEigenVal"><strong>CornerMinEigenVal() (Python function in cv)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/feature_detection.html#cv2.cornerMinEigenVal"><strong>cornerMinEigenVal() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/feature_detection.html#void cornerSubPix(InputArray image, InputOutputArray corners, Size winSize, Size zeroZone, TermCriteria criteria)"><strong>cornerSubPix (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/feature_detection.html#cv2.cornerSubPix"><strong>cornerSubPix() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/calib3d/doc/camera_calibration_and_3d_reconstruction.html#void cvCorrectMatches(CvMat* F, CvMat* points1, CvMat* points2, CvMat* new_points1, CvMat* new_points2)"><strong>CorrectMatches (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/calib3d/doc/camera_calibration_and_3d_reconstruction.html#void correctMatches(InputArray F, InputArray points1, InputArray points2, OutputArray newPoints1, OutputArray newPoints2)"><strong>correctMatches (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/calib3d/doc/camera_calibration_and_3d_reconstruction.html#cv2.correctMatches"><strong>correctMatches() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#int cvCountNonZero(const CvArr* arr)"><strong>CountNonZero (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#int countNonZero(InputArray src)"><strong>countNonZero (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#cv.CountNonZero"><strong>CountNonZero() (Python function in cv)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#cv2.countNonZero"><strong>countNonZero() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/filtering.html#Ptr<FilterEngine> createBoxFilter(int srcType, int dstType, Size ksize, Point anchor, bool normalize, int borderType)"><strong>createBoxFilter (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/highgui/doc/qt_new_functions.html#int cvCreateButton(const char* button_name, CvButtonCallback on_change, void* userdata, int button_type, int initial_button_state)"><strong>CreateButton (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/highgui/doc/qt_new_functions.html#int createButton(const string& bar_name, ButtonCallback on_change, void* userdata, int type, bool initial_button_state)"><strong>createButton (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/dynamic_structures.html#CvMemStorage* cvCreateChildMemStorage(CvMemStorage* parent)"><strong>CreateChildMemStorage (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_basic_structures.html#void cvCreateData(CvArr* arr)"><strong>CreateData (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_basic_structures.html#cv.CreateData"><strong>CreateData() (Python function in cv)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/filtering.html#Ptr<FilterEngine> createDerivFilter(int srcType, int dstType, int dx, int dy, int ksize, int borderType)"><strong>createDerivFilter (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/contrib/doc/facerec/facerec_api.html#Ptr<FaceRecognizer> createEigenFaceRecognizer(int num_components , double threshold)"><strong>createEigenFaceRecognizer (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/contrib/doc/facerec/facerec_api.html#Ptr<FaceRecognizer> createFisherFaceRecognizer(int num_components , double threshold)"><strong>createFisherFaceRecognizer (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/filtering.html#Ptr<FilterEngine> createGaussianFilter(int type, Size ksize, double sigma1, double sigma2, int borderType)"><strong>createGaussianFilter (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/dynamic_structures.html#CvGraph* cvCreateGraph(int graph_flags, int header_size, int vtx_size, int edge_size, CvMemStorage* storage)"><strong>CreateGraph (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/dynamic_structures.html#CvGraphScanner* cvCreateGraphScanner(CvGraph* graph, CvGraphVtx* vtx, int mask)"><strong>CreateGraphScanner (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/motion_analysis_and_object_tracking.html#void createHanningWindow(OutputArray dst, Size winSize, int type)"><strong>createHanningWindow (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/histograms.html#CvHistogram* cvCreateHist(int dims, int* sizes, int type, float** ranges, int uniform)"><strong>CreateHist (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/histograms.html#cv.CreateHist"><strong>CreateHist() (Python function in cv)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_basic_structures.html#IplImage* cvCreateImage(CvSize size, int depth, int channels)"><strong>CreateImage (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_basic_structures.html#cv.CreateImage"><strong>CreateImage() (Python function in cv)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_basic_structures.html#IplImage* cvCreateImageHeader(CvSize size, int depth, int channels)"><strong>CreateImageHeader (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_basic_structures.html#cv.CreateImageHeader"><strong>CreateImageHeader() (Python function in cv)</strong></a>
  </dt>

      
  <dt><a href="modules/video/doc/motion_analysis_and_object_tracking.html#CvKalman* cvCreateKalman(int dynam_params, int measure_params, int control_params)"><strong>CreateKalman (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/video/doc/motion_analysis_and_object_tracking.html#cv.CreateKalman"><strong>CreateKalman() (Python function in cv)</strong></a>
  </dt>

      
  <dt><a href="modules/contrib/doc/facerec/facerec_api.html#Ptr<FaceRecognizer> createLBPHFaceRecognizer(int radius, int neighbors, int grid_x, int grid_y, double threshold)"><strong>createLBPHFaceRecognizer (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/filtering.html#Ptr<FilterEngine> createLinearFilter(int srcType, int dstType, InputArray kernel, Point _anchor, double delta, int rowBorderType, int columnBorderType, const Scalar& borderValue)"><strong>createLinearFilter (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_basic_structures.html#CvMat* cvCreateMat(int rows, int cols, int type)"><strong>CreateMat (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_basic_structures.html#cv.CreateMat"><strong>CreateMat() (Python function in cv)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_basic_structures.html#CvMat* cvCreateMatHeader(int rows, int cols, int type)"><strong>CreateMatHeader (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_basic_structures.html#cv.CreateMatHeader"><strong>CreateMatHeader() (Python function in cv)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_basic_structures.html#CvMatND* cvCreateMatND(int dims, const int* sizes, int type)"><strong>CreateMatND (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_basic_structures.html#cv.CreateMatND"><strong>CreateMatND() (Python function in cv)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_basic_structures.html#CvMatND* cvCreateMatNDHeader(int dims, const int* sizes, int type)"><strong>CreateMatNDHeader (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_basic_structures.html#cv.CreateMatNDHeader"><strong>CreateMatNDHeader() (Python function in cv)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/dynamic_structures.html#CvMemStorage* cvCreateMemStorage(int block_size)"><strong>CreateMemStorage (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/dynamic_structures.html#cv.CreateMemStorage"><strong>CreateMemStorage() (Python function in cv)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/filtering.html#Ptr<FilterEngine> createMorphologyFilter(int op, int type, InputArray kernel, Point anchor, int rowBorderType, int columnBorderType, const Scalar& borderValue)"><strong>createMorphologyFilter (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/video/doc/motion_analysis_and_object_tracking.html#Ptr<DenseOpticalFlow> createOptFlow_DualTVL1()"><strong>createOptFlow_DualTVL1 (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/video/doc/motion_analysis_and_object_tracking.html#double epsilon"><strong>createOptFlow_DualTVL1::epsilon (C++ member)</strong></a>
  </dt>

      
  <dt><a href="modules/video/doc/motion_analysis_and_object_tracking.html#int iterations"><strong>createOptFlow_DualTVL1::iterations (C++ member)</strong></a>
  </dt>

      
  <dt><a href="modules/video/doc/motion_analysis_and_object_tracking.html#double lambda"><strong>createOptFlow_DualTVL1::lambda (C++ member)</strong></a>
  </dt>

      
  <dt><a href="modules/video/doc/motion_analysis_and_object_tracking.html#int nscales"><strong>createOptFlow_DualTVL1::nscales (C++ member)</strong></a>
  </dt>

      
  <dt><a href="modules/video/doc/motion_analysis_and_object_tracking.html#double tau"><strong>createOptFlow_DualTVL1::tau (C++ member)</strong></a>
  </dt>

      
  <dt><a href="modules/video/doc/motion_analysis_and_object_tracking.html#double theta"><strong>createOptFlow_DualTVL1::theta (C++ member)</strong></a>
  </dt>

      
  <dt><a href="modules/video/doc/motion_analysis_and_object_tracking.html#int warps"><strong>createOptFlow_DualTVL1::warps (C++ member)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/filtering.html#Ptr<FilterEngine> createSeparableLinearFilter(int srcType, int dstType, InputArray rowKernel, InputArray columnKernel, Point anchor, double delta, int rowBorderType, int columnBorderType, const Scalar& borderValue)"><strong>createSeparableLinearFilter (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/dynamic_structures.html#CvSeq* cvCreateSeq(int seq_flags, size_t header_size, size_t elem_size, CvMemStorage* storage)"><strong>CreateSeq (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/dynamic_structures.html#CvSet* cvCreateSet(int set_flags, int header_size, int elem_size, CvMemStorage* storage)"><strong>CreateSet (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_basic_structures.html#CvSparseMat* cvCreateSparseMat(int dims, const int* sizes, int type)"><strong>CreateSparseMat (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/calib3d/doc/camera_calibration_and_3d_reconstruction.html#CvStereoBMState* cvCreateStereoBMState(int preset, int numberOfDisparities)"><strong>CreateStereoBMState (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/calib3d/doc/camera_calibration_and_3d_reconstruction.html#cv.CreateStereoBMState"><strong>CreateStereoBMState() (Python function in cv)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/filtering.html#IplConvKernel* cvCreateStructuringElementEx(int cols, int rows, int anchor_x, int anchor_y, int shape, int* values)"><strong>CreateStructuringElementEx (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/filtering.html#cv.CreateStructuringElementEx"><strong>CreateStructuringElementEx() (Python function in cv)</strong></a>
  </dt>

      
  <dt><a href="modules/legacy/doc/planar_subdivisions.html#CvSubdiv2D* cvCreateSubdivDelaunay2D(CvRect rect, CvMemStorage* storage)"><strong>CreateSubdivDelaunay2D (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/legacy/doc/planar_subdivisions.html#cv.CreateSubdivDelaunay2D"><strong>CreateSubdivDelaunay2D() (Python function in cv)</strong></a>
  </dt>

      
  <dt><a href="modules/highgui/doc/user_interface.html#int cvCreateTrackbar(const char* trackbar_name, const char* window_name, int* value, int count, CvTrackbarCallback on_change)"><strong>CreateTrackbar (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/highgui/doc/user_interface.html#int createTrackbar(const string& trackbarname, const string& winname, int* value, int count, TrackbarCallback onChange, void* userdata)"><strong>createTrackbar (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/highgui/doc/user_interface.html#cv.CreateTrackbar"><strong>CreateTrackbar() (Python function in cv)</strong></a>
  </dt>

      
  <dt><a href="modules/highgui/doc/reading_and_writing_images_and_video.html#CvVideoWriter* cvCreateVideoWriter(const char* filename, int fourcc, double fps, CvSize frame_size, int is_color)"><strong>CreateVideoWriter (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/highgui/doc/reading_and_writing_images_and_video.html#cv.CreateVideoWriter"><strong>CreateVideoWriter() (Python function in cv)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_basic_structures.html#void cvCrossProduct(const CvArr* src1, const CvArr* src2, CvArr* dst)"><strong>CrossProduct (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_basic_structures.html#cv.CrossProduct"><strong>CrossProduct() (Python function in cv)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/utility_and_system_functions_and_macros.html#float cubeRoot(float val)"><strong>cubeRoot (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/utility_and_system_functions_and_macros.html#cv2.cubeRoot"><strong>cubeRoot() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/utility_and_system_functions_and_macros.html#CV_Assert(expr)"><strong>CV_Assert (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/ml/doc/neural_networks.html#CvANN_MLP : public CvStatModel"><strong>CvANN_MLP (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/ml/doc/neural_networks.html#void CvANN_MLP::create(const CvMat* layerSizes, int activateFunc, double fparam1, double fparam2)"><strong>CvANN_MLP::create (C++ function)</strong></a>, <a href="modules/ml/doc/neural_networks.html#void CvANN_MLP::create(const Mat& layerSizes, int activateFunc, double fparam1, double fparam2)"><strong>[1]</strong></a>
  </dt>

      
  <dt><a href="modules/ml/doc/neural_networks.html#CvANN_MLP::CvANN_MLP()"><strong>CvANN_MLP::CvANN_MLP (C++ function)</strong></a>, <a href="modules/ml/doc/neural_networks.html#CvANN_MLP::CvANN_MLP(const CvMat* layerSizes, int activateFunc, double fparam1, double fparam2)"><strong>[1]</strong></a>
  </dt>

      
  <dt><a href="modules/ml/doc/neural_networks.html#int CvANN_MLP::get_layer_count()"><strong>CvANN_MLP::get_layer_count (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/ml/doc/neural_networks.html#const CvMat* CvANN_MLP::get_layer_sizes()"><strong>CvANN_MLP::get_layer_sizes (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/ml/doc/neural_networks.html#double* CvANN_MLP::get_weights(int layer)"><strong>CvANN_MLP::get_weights (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/ml/doc/neural_networks.html#float CvANN_MLP::predict(const CvMat* inputs, CvMat* outputs) const"><strong>CvANN_MLP::predict (C++ function)</strong></a>, <a href="modules/ml/doc/neural_networks.html#float CvANN_MLP::predict(const Mat& inputs, Mat& outputs) const"><strong>[1]</strong></a>
  </dt>

      
  <dt><a href="modules/ml/doc/neural_networks.html#int CvANN_MLP::train(const CvMat* inputs, const CvMat* outputs, const CvMat* sampleWeights, const CvMat* sampleIdx, CvANN_MLP_TrainParams params , int flags)"><strong>CvANN_MLP::train (C++ function)</strong></a>, <a href="modules/ml/doc/neural_networks.html#int CvANN_MLP::train(const Mat& inputs, const Mat& outputs, const Mat& sampleWeights, const Mat& sampleIdx, CvANN_MLP_TrainParams params , int flags)"><strong>[1]</strong></a>
  </dt>

      
  <dt><a href="modules/ml/doc/neural_networks.html#CvANN_MLP_TrainParams"><strong>CvANN_MLP_TrainParams (C++ structure)</strong></a>
  </dt>

      
  <dt><a href="modules/ml/doc/neural_networks.html#double bp_dw_scale"><strong>CvANN_MLP_TrainParams::bp_dw_scale (C++ member)</strong></a>
  </dt>

  </dl></td>
  <td style="width: 33%" valign="top"><dl>
      
  <dt><a href="modules/ml/doc/neural_networks.html#double bp_moment_scale"><strong>CvANN_MLP_TrainParams::bp_moment_scale (C++ member)</strong></a>
  </dt>

      
  <dt><a href="modules/ml/doc/neural_networks.html#CvANN_MLP_TrainParams::CvANN_MLP_TrainParams()"><strong>CvANN_MLP_TrainParams::CvANN_MLP_TrainParams (C++ function)</strong></a>, <a href="modules/ml/doc/neural_networks.html#CvANN_MLP_TrainParams::CvANN_MLP_TrainParams(CvTermCriteria term_crit, int train_method, double param1, double param2)"><strong>[1]</strong></a>
  </dt>

      
  <dt><a href="modules/ml/doc/neural_networks.html#double rp_dw0"><strong>CvANN_MLP_TrainParams::rp_dw0 (C++ member)</strong></a>
  </dt>

      
  <dt><a href="modules/ml/doc/neural_networks.html#double rp_dw_max"><strong>CvANN_MLP_TrainParams::rp_dw_max (C++ member)</strong></a>
  </dt>

      
  <dt><a href="modules/ml/doc/neural_networks.html#double rp_dw_min"><strong>CvANN_MLP_TrainParams::rp_dw_min (C++ member)</strong></a>
  </dt>

      
  <dt><a href="modules/ml/doc/neural_networks.html#double rp_dw_minus"><strong>CvANN_MLP_TrainParams::rp_dw_minus (C++ member)</strong></a>
  </dt>

      
  <dt><a href="modules/ml/doc/neural_networks.html#double rp_dw_plus"><strong>CvANN_MLP_TrainParams::rp_dw_plus (C++ member)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_basic_structures.html#CvArr"><strong>CvArr (C++ structure)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#Mat cvarrToMat(const CvArr* arr, bool copyData, bool allowND, int coiMode)"><strong>cvarrToMat (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_xml_yaml_persistence.html#CvAttrList"><strong>CvAttrList (C++ structure)</strong></a>
  </dt>

      
  <dt><a href="modules/ml/doc/boosting.html#CvBoost : public CvStatModel"><strong>CvBoost (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/ml/doc/boosting.html#float CvBoost::calc_error(CvMLData* _data, int type , std::vector<float> *resp)"><strong>CvBoost::calc_error (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/ml/doc/boosting.html#CvBoost::CvBoost()"><strong>CvBoost::CvBoost (C++ function)</strong></a>, <a href="modules/ml/doc/boosting.html#CvBoost::CvBoost(const CvMat* trainData, int tflag, const CvMat* responses, const CvMat* varIdx, const CvMat* sampleIdx, const CvMat* varType, const CvMat* missingDataMask, CvBoostParams params)"><strong>[1]</strong></a>, <a href="modules/ml/doc/boosting.html#CvBoost::CvBoost(const Mat& trainData, int tflag, const Mat& responses, const Mat& varIdx, const Mat& sampleIdx, const Mat& varType, const Mat& missingDataMask, CvBoostParams params)"><strong>[2]</strong></a>
  </dt>

      
  <dt><a href="modules/ml/doc/boosting.html#const CvDTreeTrainData* CvBoost::get_data() const"><strong>CvBoost::get_data (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/ml/doc/boosting.html#const CvBoostParams& CvBoost::get_params() const"><strong>CvBoost::get_params (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/ml/doc/boosting.html#CvSeq* CvBoost::get_weak_predictors()"><strong>CvBoost::get_weak_predictors (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/ml/doc/boosting.html#float CvBoost::predict(const CvMat* sample, const CvMat* missing, CvMat* weak_responses, CvSlice slice, bool raw_mode, bool return_sum) const"><strong>CvBoost::predict (C++ function)</strong></a>, <a href="modules/ml/doc/boosting.html#float CvBoost::predict(const cv::Mat& sample, const cv::Mat& missing, const cv::Range& slice, bool rawMode, bool returnSum) const"><strong>[1]</strong></a>
  </dt>

      
  <dt><a href="modules/ml/doc/boosting.html#void CvBoost::prune(CvSlice slice)"><strong>CvBoost::prune (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/ml/doc/boosting.html#bool CvBoost::train(CvMLData* data, CvBoostParams params, bool update)"><strong>CvBoost::train (C++ function)</strong></a>, <a href="modules/ml/doc/boosting.html#bool CvBoost::train(const CvMat* trainData, int tflag, const CvMat* responses, const CvMat* varIdx, const CvMat* sampleIdx, const CvMat* varType, const CvMat* missingDataMask, CvBoostParams params, bool update)"><strong>[1]</strong></a>, <a href="modules/ml/doc/boosting.html#bool CvBoost::train(const Mat& trainData, int tflag, const Mat& responses, const Mat& varIdx, const Mat& sampleIdx, const Mat& varType, const Mat& missingDataMask, CvBoostParams params, bool update)"><strong>[2]</strong></a>
  </dt>

      
  <dt><a href="modules/ml/doc/boosting.html#CvBoostParams : public CvDTreeParams"><strong>CvBoostParams (C++ structure)</strong></a>
  </dt>

      
  <dt><a href="modules/ml/doc/boosting.html#CvBoostParams::CvBoostParams()"><strong>CvBoostParams::CvBoostParams (C++ function)</strong></a>, <a href="modules/ml/doc/boosting.html#CvBoostParams::CvBoostParams(int boost_type, int weak_count, double weight_trim_rate, int max_depth, bool use_surrogates, const float* priors)"><strong>[1]</strong></a>
  </dt>

      
  <dt><a href="modules/ml/doc/boosting.html#int split_criteria"><strong>CvBoostParams::split_criteria (C++ member)</strong></a>
  </dt>

      
  <dt><a href="modules/ml/doc/boosting.html#CvBoostTree : public CvDTree"><strong>CvBoostTree (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_basic_structures.html#CvBox2D"><strong>CvBox2D (C++ structure)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_basic_structures.html#float angle"><strong>CvBox2D::angle (C++ member)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_basic_structures.html#CvPoint2D32f center"><strong>CvBox2D::center (C++ member)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_basic_structures.html#CvSize2D32f size"><strong>CvBox2D::size (C++ member)</strong></a>
  </dt>

      
  <dt><a href="modules/ml/doc/decision_trees.html#CvDTree : public CvStatModel"><strong>CvDTree (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/ml/doc/decision_trees.html#float CvDTree::calc_error(CvMLData* trainData, int type, std::vector<float> *resp)"><strong>CvDTree::calc_error (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/ml/doc/decision_trees.html#CvDTreeTrainData* CvDTree::get_data() const"><strong>CvDTree::get_data (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/ml/doc/decision_trees.html#int CvDTree::get_pruned_tree_idx() const"><strong>CvDTree::get_pruned_tree_idx (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/ml/doc/decision_trees.html#const CvDTreeNode* CvDTree::get_root() const"><strong>CvDTree::get_root (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/ml/doc/decision_trees.html#const CvMat* CvDTree::get_var_importance()"><strong>CvDTree::get_var_importance (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/ml/doc/decision_trees.html#Mat CvDTree::getVarImportance()"><strong>CvDTree::getVarImportance (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/ml/doc/decision_trees.html#CvDTreeNode* CvDTree::predict(const CvMat* sample, const CvMat* missingDataMask, bool preprocessedInput) const"><strong>CvDTree::predict (C++ function)</strong></a>, <a href="modules/ml/doc/decision_trees.html#CvDTreeNode* CvDTree::predict(const Mat& sample, const Mat& missingDataMask, bool preprocessedInput) const"><strong>[1]</strong></a>
  </dt>

      
  <dt><a href="modules/ml/doc/decision_trees.html#bool CvDTree::train(CvDTreeTrainData* trainData, const CvMat* subsampleIdx)"><strong>CvDTree::train (C++ function)</strong></a>, <a href="modules/ml/doc/decision_trees.html#bool CvDTree::train(CvMLData* trainData, CvDTreeParams params)"><strong>[1]</strong></a>, <a href="modules/ml/doc/decision_trees.html#bool CvDTree::train(const CvMat* trainData, int tflag, const CvMat* responses, const CvMat* varIdx, const CvMat* sampleIdx, const CvMat* varType, const CvMat* missingDataMask, CvDTreeParams params)"><strong>[2]</strong></a>, <a href="modules/ml/doc/decision_trees.html#bool CvDTree::train(const Mat& trainData, int tflag, const Mat& responses, const Mat& varIdx, const Mat& sampleIdx, const Mat& varType, const Mat& missingDataMask, CvDTreeParams params)"><strong>[3]</strong></a>
  </dt>

      
  <dt><a href="modules/ml/doc/decision_trees.html#CvDTreeNode"><strong>CvDTreeNode (C++ structure)</strong></a>
  </dt>

      
  <dt><a href="modules/ml/doc/decision_trees.html#int class_idx"><strong>CvDTreeNode::class_idx (C++ member)</strong></a>
  </dt>

      
  <dt><a href="modules/ml/doc/decision_trees.html#int depth"><strong>CvDTreeNode::depth (C++ member)</strong></a>
  </dt>

      
  <dt><a href="modules/ml/doc/decision_trees.html#CvDTreeNode* left"><strong>CvDTreeNode::left (C++ member)</strong></a>
  </dt>

      
  <dt><a href="modules/ml/doc/decision_trees.html#CvDTreeNode* parent"><strong>CvDTreeNode::parent (C++ member)</strong></a>
  </dt>

      
  <dt><a href="modules/ml/doc/decision_trees.html#CvDTreeNode* right"><strong>CvDTreeNode::right (C++ member)</strong></a>
  </dt>

      
  <dt><a href="modules/ml/doc/decision_trees.html#int sample_count"><strong>CvDTreeNode::sample_count (C++ member)</strong></a>
  </dt>

      
  <dt><a href="modules/ml/doc/decision_trees.html#CvDTreeSplit* split"><strong>CvDTreeNode::split (C++ member)</strong></a>
  </dt>

      
  <dt><a href="modules/ml/doc/decision_trees.html#int Tn"><strong>CvDTreeNode::Tn (C++ member)</strong></a>
  </dt>

      
  <dt><a href="modules/ml/doc/decision_trees.html#double value"><strong>CvDTreeNode::value (C++ member)</strong></a>
  </dt>

      
  <dt><a href="modules/ml/doc/decision_trees.html#CvDTreeParams"><strong>CvDTreeParams (C++ structure)</strong></a>
  </dt>

      
  <dt><a href="modules/ml/doc/decision_trees.html#CvDTreeParams::CvDTreeParams()"><strong>CvDTreeParams::CvDTreeParams (C++ function)</strong></a>, <a href="modules/ml/doc/decision_trees.html#CvDTreeParams::CvDTreeParams(int max_depth, int min_sample_count, float regression_accuracy, bool use_surrogates, int max_categories, int cv_folds, bool use_1se_rule, bool truncate_pruned_tree, const float* priors)"><strong>[1]</strong></a>
  </dt>

      
  <dt><a href="modules/ml/doc/decision_trees.html#CvDTreeSplit"><strong>CvDTreeSplit (C++ structure)</strong></a>
  </dt>

      
  <dt><a href="modules/ml/doc/decision_trees.html#int inversed"><strong>CvDTreeSplit::inversed (C++ member)</strong></a>
  </dt>

      
  <dt><a href="modules/ml/doc/decision_trees.html#CvDTreeSplit* next"><strong>CvDTreeSplit::next (C++ member)</strong></a>
  </dt>

      
  <dt><a href="modules/ml/doc/decision_trees.html#float ord::c"><strong>CvDTreeSplit::ord::c (C++ member)</strong></a>
  </dt>

      
  <dt><a href="modules/ml/doc/decision_trees.html#int ord::split_point"><strong>CvDTreeSplit::ord::split_point (C++ member)</strong></a>
  </dt>

      
  <dt><a href="modules/ml/doc/decision_trees.html#float quality"><strong>CvDTreeSplit::quality (C++ member)</strong></a>
  </dt>

      
  <dt><a href="modules/ml/doc/decision_trees.html#int[] subset"><strong>CvDTreeSplit::subset (C++ member)</strong></a>
  </dt>

      
  <dt><a href="modules/ml/doc/decision_trees.html#int var_idx"><strong>CvDTreeSplit::var_idx (C++ member)</strong></a>
  </dt>

      
  <dt><a href="modules/ml/doc/decision_trees.html#CvDTreeTrainData"><strong>CvDTreeTrainData (C++ structure)</strong></a>
  </dt>

      
  <dt><a href="modules/legacy/doc/expectation_maximization.html#CvEM : public CvStatModel"><strong>CvEM (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/legacy/doc/expectation_maximization.html#const CvMat** CvEM::get_covs() const"><strong>CvEM::get_covs (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/legacy/doc/expectation_maximization.html#double CvEM::get_log_likelihood() const"><strong>CvEM::get_log_likelihood (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/legacy/doc/expectation_maximization.html#const CvMat* CvEM::get_means() const"><strong>CvEM::get_means (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/legacy/doc/expectation_maximization.html#int CvEM::get_nclusters() const"><strong>CvEM::get_nclusters (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/legacy/doc/expectation_maximization.html#const CvMat* CvEM::get_probs() const"><strong>CvEM::get_probs (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/legacy/doc/expectation_maximization.html#const CvMat* CvEM::get_weights() const"><strong>CvEM::get_weights (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/legacy/doc/expectation_maximization.html#void CvEM::getCovs(std::vector<cv::Mat>& covs) const"><strong>CvEM::getCovs (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/legacy/doc/expectation_maximization.html#double CvEM::getLikelihood() const"><strong>CvEM::getLikelihood (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/legacy/doc/expectation_maximization.html#Mat CvEM::getMeans() const"><strong>CvEM::getMeans (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/legacy/doc/expectation_maximization.html#int CvEM::getNClusters() const"><strong>CvEM::getNClusters (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/legacy/doc/expectation_maximization.html#Mat CvEM::getProbs() const"><strong>CvEM::getProbs (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/legacy/doc/expectation_maximization.html#Mat CvEM::getWeights() const"><strong>CvEM::getWeights (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/legacy/doc/expectation_maximization.html#float CvEM::predict(const CvMat* sample, CvMat* probs) const"><strong>CvEM::predict (C++ function)</strong></a>, <a href="modules/legacy/doc/expectation_maximization.html#float CvEM::predict(const Mat& sample, Mat* probs) const"><strong>[1]</strong></a>
  </dt>

      
  <dt><a href="modules/legacy/doc/expectation_maximization.html#void CvEM::read(CvFileStorage* fs, CvFileNode* node)"><strong>CvEM::read (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/legacy/doc/expectation_maximization.html#bool CvEM::train(const CvMat* samples, const CvMat* sampleIdx, CvEMParams params, CvMat* labels)"><strong>CvEM::train (C++ function)</strong></a>, <a href="modules/legacy/doc/expectation_maximization.html#bool CvEM::train(const Mat& samples, const Mat& sampleIdx, CvEMParams params, Mat* labels)"><strong>[1]</strong></a>
  </dt>

      
  <dt><a href="modules/legacy/doc/expectation_maximization.html#void CvEM::write(CvFileStorage* fs, const char* name) const"><strong>CvEM::write (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/legacy/doc/expectation_maximization.html#CvEMParams"><strong>CvEMParams (C++ structure)</strong></a>
  </dt>

      
  <dt><a href="modules/legacy/doc/expectation_maximization.html#CvEMParams::CvEMParams()"><strong>CvEMParams::CvEMParams (C++ function)</strong></a>, <a href="modules/legacy/doc/expectation_maximization.html#CvEMParams::CvEMParams(int nclusters, int cov_mat_type, int start_step, CvTermCriteria term_crit, const CvMat* probs, const CvMat* weights, const CvMat* means, const CvMat** covs)"><strong>[1]</strong></a>
  </dt>

      
  <dt><a href="modules/ml/doc/ertrees.html#CvERTrees : public CvRTrees"><strong>CvERTrees (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_xml_yaml_persistence.html#CvFileNode"><strong>CvFileNode (C++ structure)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_xml_yaml_persistence.html#union data"><strong>CvFileNode::data (C++ member)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_xml_yaml_persistence.html#CvTypeInfo* info"><strong>CvFileNode::info (C++ member)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_xml_yaml_persistence.html#int tag"><strong>CvFileNode::tag (C++ member)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_xml_yaml_persistence.html#CvFileStorage"><strong>CvFileStorage (C++ structure)</strong></a>
  </dt>

      
  <dt><a href="modules/ml/doc/gradient_boosted_trees.html#CvGBTrees : public CvStatModel"><strong>CvGBTrees (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/ml/doc/gradient_boosted_trees.html#float CvGBTrees::calc_error(CvMLData* _data, int type, std::vector<float> *resp)"><strong>CvGBTrees::calc_error (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/ml/doc/gradient_boosted_trees.html#void CvGBTrees::clear()"><strong>CvGBTrees::clear (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/ml/doc/gradient_boosted_trees.html#CvGBTrees::CvGBTrees()"><strong>CvGBTrees::CvGBTrees (C++ function)</strong></a>, <a href="modules/ml/doc/gradient_boosted_trees.html#CvGBTrees::CvGBTrees(const CvMat* trainData, int tflag, const CvMat* responses, const CvMat* varIdx, const CvMat* sampleIdx, const CvMat* varType, const CvMat* missingDataMask, CvGBTreesParams params)"><strong>[1]</strong></a>, <a href="modules/ml/doc/gradient_boosted_trees.html#CvGBTrees::CvGBTrees(const Mat& trainData, int tflag, const Mat& responses, const Mat& varIdx, const Mat& sampleIdx, const Mat& varType, const Mat& missingDataMask, CvGBTreesParams params)"><strong>[2]</strong></a>
  </dt>

      
  <dt><a href="modules/ml/doc/gradient_boosted_trees.html#float CvGBTrees::predict(const CvMat* sample, const CvMat* missing, CvMat* weakResponses, CvSlice slice , int k) const"><strong>CvGBTrees::predict (C++ function)</strong></a>, <a href="modules/ml/doc/gradient_boosted_trees.html#float CvGBTrees::predict(const Mat& sample, const Mat& missing, const Range& slice , int k) const"><strong>[1]</strong></a>
  </dt>

      
  <dt><a href="modules/ml/doc/gradient_boosted_trees.html#bool CvGBTrees::train(CvMLData* data, CvGBTreesParams params, bool update)"><strong>CvGBTrees::train (C++ function)</strong></a>, <a href="modules/ml/doc/gradient_boosted_trees.html#bool CvGBTrees::train(const CvMat* trainData, int tflag, const CvMat* responses, const CvMat* varIdx, const CvMat* sampleIdx, const CvMat* varType, const CvMat* missingDataMask, CvGBTreesParams params, bool update)"><strong>[1]</strong></a>, <a href="modules/ml/doc/gradient_boosted_trees.html#bool CvGBTrees::train(const Mat& trainData, int tflag, const Mat& responses, const Mat& varIdx, const Mat& sampleIdx, const Mat& varType, const Mat& missingDataMask, CvGBTreesParams params, bool update)"><strong>[2]</strong></a>
  </dt>

      
  <dt><a href="modules/ml/doc/gradient_boosted_trees.html#CvGBTreesParams : public CvDTreeParams"><strong>CvGBTreesParams (C++ structure)</strong></a>
  </dt>

      
  <dt><a href="modules/ml/doc/gradient_boosted_trees.html#CvGBTreesParams::CvGBTreesParams()"><strong>CvGBTreesParams::CvGBTreesParams (C++ function)</strong></a>, <a href="modules/ml/doc/gradient_boosted_trees.html#CvGBTreesParams::CvGBTreesParams(int loss_function_type, int weak_count, float shrinkage, float subsample_portion, int max_depth, bool use_surrogates)"><strong>[1]</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/dynamic_structures.html#CvGraph"><strong>CvGraph (C++ structure)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/dynamic_structures.html#CvGraphEdge"><strong>CvGraphEdge (C++ structure)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/dynamic_structures.html#CvGraphScanner"><strong>CvGraphScanner (C++ structure)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/dynamic_structures.html#CvGraphVtx"><strong>CvGraphVtx (C++ structure)</strong></a>
  </dt>

      
  <dt><a href="modules/ml/doc/k_nearest_neighbors.html#CvKNearest : public CvStatModel"><strong>CvKNearest (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/ml/doc/k_nearest_neighbors.html#CvKNearest::CvKNearest()"><strong>CvKNearest::CvKNearest (C++ function)</strong></a>, <a href="modules/ml/doc/k_nearest_neighbors.html#CvKNearest::CvKNearest(const CvMat* trainData, const CvMat* responses, const CvMat* sampleIdx, bool isRegression, int max_k)"><strong>[1]</strong></a>, <a href="modules/ml/doc/k_nearest_neighbors.html#CvKNearest::CvKNearest(const Mat& trainData, const Mat& responses, const Mat& sampleIdx, bool isRegression, int max_k)"><strong>[2]</strong></a>
  </dt>

      
  <dt><a href="modules/ml/doc/k_nearest_neighbors.html#float CvKNearest::find_nearest(const CvMat* samples, int k, CvMat* results, const float** neighbors, CvMat* neighborResponses, CvMat* dist) const"><strong>CvKNearest::find_nearest (C++ function)</strong></a>, <a href="modules/ml/doc/k_nearest_neighbors.html#float CvKNearest::find_nearest(const Mat& samples, int k, Mat& results, Mat& neighborResponses, Mat& dists) const"><strong>[1]</strong></a>, <a href="modules/ml/doc/k_nearest_neighbors.html#float CvKNearest::find_nearest(const Mat& samples, int k, Mat* results, const float** neighbors, Mat* neighborResponses, Mat* dist) const"><strong>[2]</strong></a>
  </dt>

      
  <dt><a href="modules/ml/doc/k_nearest_neighbors.html#int CvKNearest::get_max_k() const"><strong>CvKNearest::get_max_k (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/ml/doc/k_nearest_neighbors.html#int CvKNearest::get_sample_count() const"><strong>CvKNearest::get_sample_count (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/ml/doc/k_nearest_neighbors.html#int CvKNearest::get_var_count() const"><strong>CvKNearest::get_var_count (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/ml/doc/k_nearest_neighbors.html#bool CvKNearest::is_regression() const"><strong>CvKNearest::is_regression (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/ml/doc/k_nearest_neighbors.html#bool CvKNearest::train(const CvMat* trainData, const CvMat* responses, const CvMat* sampleIdx, bool is_regression, int maxK, bool updateBase)"><strong>CvKNearest::train (C++ function)</strong></a>, <a href="modules/ml/doc/k_nearest_neighbors.html#bool CvKNearest::train(const Mat& trainData, const Mat& responses, const Mat& sampleIdx, bool isRegression, int maxK, bool updateBase)"><strong>[1]</strong></a>
  </dt>

      
  <dt><a href="modules/objdetect/doc/latent_svm.html#CvSeq* cvLatentSvmDetectObjects(IplImage* image, CvLatentSvmDetector* detector, CvMemStorage* storage, float overlap_threshold, int numThreads)"><strong>cvLatentSvmDetectObjects (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/objdetect/doc/latent_svm.html#CvLatentSvmDetector"><strong>CvLatentSvmDetector (C++ structure)</strong></a>
  </dt>

      
  <dt><a href="modules/objdetect/doc/latent_svm.html#float* b"><strong>CvLatentSvmDetector::b (C++ member)</strong></a>
  </dt>

      
  <dt><a href="modules/objdetect/doc/latent_svm.html#CvLSVMFilterObject** filters"><strong>CvLatentSvmDetector::filters (C++ member)</strong></a>
  </dt>

      
  <dt><a href="modules/objdetect/doc/latent_svm.html#int num_components"><strong>CvLatentSvmDetector::num_components (C++ member)</strong></a>
  </dt>

      
  <dt><a href="modules/objdetect/doc/latent_svm.html#int num_filters"><strong>CvLatentSvmDetector::num_filters (C++ member)</strong></a>
  </dt>

      
  <dt><a href="modules/objdetect/doc/latent_svm.html#int* num_part_filters"><strong>CvLatentSvmDetector::num_part_filters (C++ member)</strong></a>
  </dt>

      
  <dt><a href="modules/objdetect/doc/latent_svm.html#float score_threshold"><strong>CvLatentSvmDetector::score_threshold (C++ member)</strong></a>
  </dt>

      
  <dt><a href="modules/objdetect/doc/latent_svm.html#CvLatentSvmDetector* cvLoadLatentSvmDetector(const char* filename)"><strong>cvLoadLatentSvmDetector (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/objdetect/doc/latent_svm.html#CvLSVMFilterObject"><strong>CvLSVMFilterObject (C++ structure)</strong></a>
  </dt>

      
  <dt><a href="modules/objdetect/doc/latent_svm.html#float fineFunction[4]"><strong>CvLSVMFilterObject::fineFunction[4] (C++ member)</strong></a>
  </dt>

      
  <dt><a href="modules/objdetect/doc/latent_svm.html#float *H"><strong>CvLSVMFilterObject::H (C++ member)</strong></a>
  </dt>

      
  <dt><a href="modules/objdetect/doc/latent_svm.html#int numFeatures"><strong>CvLSVMFilterObject::numFeatures (C++ member)</strong></a>
  </dt>

      
  <dt><a href="modules/objdetect/doc/latent_svm.html#int sizeX"><strong>CvLSVMFilterObject::sizeX (C++ member)</strong></a>
  </dt>

      
  <dt><a href="modules/objdetect/doc/latent_svm.html#int sizeY"><strong>CvLSVMFilterObject::sizeY (C++ member)</strong></a>
  </dt>

      
  <dt><a href="modules/objdetect/doc/latent_svm.html#CvLSVMFilterPosition V"><strong>CvLSVMFilterObject::V (C++ member)</strong></a>
  </dt>

      
  <dt><a href="modules/objdetect/doc/latent_svm.html#CvLSVMFilterPosition"><strong>CvLSVMFilterPosition (C++ structure)</strong></a>
  </dt>

      
  <dt><a href="modules/objdetect/doc/latent_svm.html#unsigned int l"><strong>CvLSVMFilterPosition::l (C++ member)</strong></a>
  </dt>

      
  <dt><a href="modules/objdetect/doc/latent_svm.html#unsigned int x"><strong>CvLSVMFilterPosition::x (C++ member)</strong></a>
  </dt>

      
  <dt><a href="modules/objdetect/doc/latent_svm.html#unsigned int y"><strong>CvLSVMFilterPosition::y (C++ member)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_basic_structures.html#CvMat"><strong>CvMat (C++ structure)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_basic_structures.html#int cols"><strong>CvMat::cols (C++ member)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_basic_structures.html#union data"><strong>CvMat::data (C++ member)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_basic_structures.html#int* refcount"><strong>CvMat::refcount (C++ member)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_basic_structures.html#int rows"><strong>CvMat::rows (C++ member)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_basic_structures.html#int step"><strong>CvMat::step (C++ member)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_basic_structures.html#int type"><strong>CvMat::type (C++ member)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_basic_structures.html#CvMatND"><strong>CvMatND (C++ structure)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_basic_structures.html#union data"><strong>CvMatND::data (C++ member)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_basic_structures.html#array dim"><strong>CvMatND::dim (C++ member)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_basic_structures.html#int dims"><strong>CvMatND::dims (C++ member)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_basic_structures.html#int* refcount"><strong>CvMatND::refcount (C++ member)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_basic_structures.html#int type"><strong>CvMatND::type (C++ member)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/dynamic_structures.html#CvMemBlock"><strong>CvMemBlock (C++ structure)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/dynamic_structures.html#CvMemStorage"><strong>CvMemStorage (C++ structure)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/dynamic_structures.html#int block_size"><strong>CvMemStorage::block_size (C++ member)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/dynamic_structures.html#CvMemBlock* bottom"><strong>CvMemStorage::bottom (C++ member)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/dynamic_structures.html#int free_space"><strong>CvMemStorage::free_space (C++ member)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/dynamic_structures.html#CvMemStorage* parent"><strong>CvMemStorage::parent (C++ member)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/dynamic_structures.html#CvMemBlock* top"><strong>CvMemStorage::top (C++ member)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/dynamic_structures.html#CvMemStoragePos"><strong>CvMemStoragePos (C++ structure)</strong></a>
  </dt>

      
  <dt><a href="modules/ml/doc/mldata.html#CvMLData"><strong>CvMLData (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/ml/doc/mldata.html#void CvMLData::change_var_idx(int vi, bool state)"><strong>CvMLData::change_var_idx (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/ml/doc/mldata.html#void CvMLData::change_var_type(int var_idx, int type)"><strong>CvMLData::change_var_type (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/ml/doc/mldata.html#const std::map<std::string, int>& CvMLData::get_class_labels_map() const"><strong>CvMLData::get_class_labels_map (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/ml/doc/mldata.html#char CvMLData::get_delimiter() const"><strong>CvMLData::get_delimiter (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/ml/doc/mldata.html#char CvMLData::get_miss_ch() const"><strong>CvMLData::get_miss_ch (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/ml/doc/mldata.html#const CvMat* CvMLData::get_missing() const"><strong>CvMLData::get_missing (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/ml/doc/mldata.html#int CvMLData::get_response_idx() const"><strong>CvMLData::get_response_idx (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/ml/doc/mldata.html#const CvMat* CvMLData::get_responses()"><strong>CvMLData::get_responses (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/ml/doc/mldata.html#const CvMat* CvMLData::get_test_sample_idx() const"><strong>CvMLData::get_test_sample_idx (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/ml/doc/mldata.html#const CvMat* CvMLData::get_train_sample_idx() const"><strong>CvMLData::get_train_sample_idx (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/ml/doc/mldata.html#const CvMat* CvMLData::get_values() const"><strong>CvMLData::get_values (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/ml/doc/mldata.html#const CvMat* CvMLData::get_var_idx()"><strong>CvMLData::get_var_idx (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/ml/doc/mldata.html#int CvMLData::get_var_type(int var_idx) const"><strong>CvMLData::get_var_type (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/ml/doc/mldata.html#const CvMat* CvMLData::get_var_types()"><strong>CvMLData::get_var_types (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/ml/doc/mldata.html#void CvMLData::mix_train_and_test_idx()"><strong>CvMLData::mix_train_and_test_idx (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/ml/doc/mldata.html#int CvMLData::read_csv(const char* filename)"><strong>CvMLData::read_csv (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/ml/doc/mldata.html#void CvMLData::set_delimiter(char ch)"><strong>CvMLData::set_delimiter (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/ml/doc/mldata.html#void CvMLData::set_miss_ch(char ch)"><strong>CvMLData::set_miss_ch (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/ml/doc/mldata.html#void CvMLData::set_response_idx(int idx)"><strong>CvMLData::set_response_idx (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/ml/doc/mldata.html#void CvMLData::set_train_test_split(const CvTrainTestSplit * spl)"><strong>CvMLData::set_train_test_split (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/ml/doc/mldata.html#void CvMLData::set_var_types(const char* str)"><strong>CvMLData::set_var_types (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/ml/doc/normal_bayes_classifier.html#CvNormalBayesClassifier : public CvStatModel"><strong>CvNormalBayesClassifier (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/ml/doc/normal_bayes_classifier.html#CvNormalBayesClassifier::CvNormalBayesClassifier()"><strong>CvNormalBayesClassifier::CvNormalBayesClassifier (C++ function)</strong></a>, <a href="modules/ml/doc/normal_bayes_classifier.html#CvNormalBayesClassifier::CvNormalBayesClassifier(const CvMat* trainData, const CvMat* responses, const CvMat* varIdx, const CvMat* sampleIdx)"><strong>[1]</strong></a>, <a href="modules/ml/doc/normal_bayes_classifier.html#CvNormalBayesClassifier::CvNormalBayesClassifier(const Mat& trainData, const Mat& responses, const Mat& varIdx, const Mat& sampleIdx)"><strong>[2]</strong></a>
  </dt>

      
  <dt><a href="modules/ml/doc/normal_bayes_classifier.html#float CvNormalBayesClassifier::predict(const CvMat* samples, CvMat* results) const"><strong>CvNormalBayesClassifier::predict (C++ function)</strong></a>, <a href="modules/ml/doc/normal_bayes_classifier.html#float CvNormalBayesClassifier::predict(const Mat& samples, Mat* results) const"><strong>[1]</strong></a>
  </dt>

      
  <dt><a href="modules/ml/doc/normal_bayes_classifier.html#bool CvNormalBayesClassifier::train(const CvMat* trainData, const CvMat* responses, const CvMat* varIdx , const CvMat* sampleIdx, bool update)"><strong>CvNormalBayesClassifier::train (C++ function)</strong></a>, <a href="modules/ml/doc/normal_bayes_classifier.html#bool CvNormalBayesClassifier::train(const Mat& trainData, const Mat& responses, const Mat& varIdx , const Mat& sampleIdx, bool update)"><strong>[1]</strong></a>
  </dt>

      
  <dt><a href="modules/objdetect/doc/latent_svm.html#CvObjectDetection"><strong>CvObjectDetection (C++ structure)</strong></a>
  </dt>

      
  <dt><a href="modules/objdetect/doc/latent_svm.html#CvRect rect"><strong>CvObjectDetection::rect (C++ member)</strong></a>
  </dt>

      
  <dt><a href="modules/objdetect/doc/latent_svm.html#float score"><strong>CvObjectDetection::score (C++ member)</strong></a>
  </dt>

      
  <dt><a href="modules/ml/doc/support_vector_machines.html#CvParamGrid"><strong>CvParamGrid (C++ structure)</strong></a>
  </dt>

      
  <dt><a href="modules/ml/doc/support_vector_machines.html#bool CvParamGrid::check()"><strong>CvParamGrid::check (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/ml/doc/support_vector_machines.html#CvParamGrid::CvParamGrid()"><strong>CvParamGrid::CvParamGrid (C++ function)</strong></a>, <a href="modules/ml/doc/support_vector_machines.html#CvParamGrid::CvParamGrid(double min_val, double max_val, double log_step)"><strong>[1]</strong></a>
  </dt>

      
  <dt><a href="modules/ml/doc/support_vector_machines.html#double CvParamGrid::max_val"><strong>CvParamGrid::CvParamGrid::max_val (C++ member)</strong></a>
  </dt>

      
  <dt><a href="modules/ml/doc/support_vector_machines.html#double CvParamGrid::min_val"><strong>CvParamGrid::CvParamGrid::min_val (C++ member)</strong></a>
  </dt>

      
  <dt><a href="modules/ml/doc/support_vector_machines.html#double CvParamGrid::step"><strong>CvParamGrid::CvParamGrid::step (C++ member)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_basic_structures.html#CvPoint"><strong>CvPoint (C++ structure)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_basic_structures.html#CvPoint2D32f"><strong>CvPoint2D32f (C++ structure)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_basic_structures.html#CvPoint2D64f"><strong>CvPoint2D64f (C++ structure)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_basic_structures.html#CvPoint3D32f"><strong>CvPoint3D32f (C++ structure)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_basic_structures.html#CvPoint3D64f"><strong>CvPoint3D64f (C++ structure)</strong></a>
  </dt>

      
  <dt><a href="modules/legacy/doc/planar_subdivisions.html#CvQuadEdge2D"><strong>CvQuadEdge2D (C++ structure)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_basic_structures.html#CvRect"><strong>CvRect (C++ structure)</strong></a>
  </dt>

      
  <dt><a href="modules/objdetect/doc/latent_svm.html#void cvReleaseLatentSvmDetector(CvLatentSvmDetector** detector)"><strong>cvReleaseLatentSvmDetector (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/ml/doc/random_trees.html#CvRTParams : public CvDTreeParams"><strong>CvRTParams (C++ structure)</strong></a>
  </dt>

      
  <dt><a href="modules/ml/doc/random_trees.html#CvRTParams::CvRTParams()"><strong>CvRTParams::CvRTParams (C++ function)</strong></a>, <a href="modules/ml/doc/random_trees.html#CvRTParams::CvRTParams(int max_depth, int min_sample_count, float regression_accuracy, bool use_surrogates, int max_categories, const float* priors, bool calc_var_importance, int nactive_vars, int max_num_of_trees_in_the_forest, float forest_accuracy, int termcrit_type)"><strong>[1]</strong></a>
  </dt>

      
  <dt><a href="modules/ml/doc/random_trees.html#CvRTrees : public CvStatModel"><strong>CvRTrees (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/ml/doc/random_trees.html#float CvRTrees::calc_error(CvMLData* data, int type, std::vector<float>* resp)"><strong>CvRTrees::calc_error (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/ml/doc/random_trees.html#float CvRTrees::get_proximity(const CvMat* sample1, const CvMat* sample2, const CvMat* missing1 , const CvMat* missing2) const"><strong>CvRTrees::get_proximity (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/ml/doc/random_trees.html#CvRNG* CvRTrees::get_rng()"><strong>CvRTrees::get_rng (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/ml/doc/random_trees.html#float CvRTrees::get_train_error()"><strong>CvRTrees::get_train_error (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/ml/doc/random_trees.html#CvForestTree* CvRTrees::get_tree(int i) const"><strong>CvRTrees::get_tree (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/ml/doc/random_trees.html#int CvRTrees::get_tree_count() const"><strong>CvRTrees::get_tree_count (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/ml/doc/random_trees.html#const CvMat* CvRTrees::get_var_importance()"><strong>CvRTrees::get_var_importance (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/ml/doc/random_trees.html#Mat CvRTrees::getVarImportance()"><strong>CvRTrees::getVarImportance (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/ml/doc/random_trees.html#float CvRTrees::predict(const CvMat* sample, const CvMat* missing) const"><strong>CvRTrees::predict (C++ function)</strong></a>, <a href="modules/ml/doc/random_trees.html#float CvRTrees::predict(const Mat& sample, const Mat& missing) const"><strong>[1]</strong></a>
  </dt>

      
  <dt><a href="modules/ml/doc/random_trees.html#float CvRTrees::predict_prob(const CvMat* sample, const CvMat* missing) const"><strong>CvRTrees::predict_prob (C++ function)</strong></a>, <a href="modules/ml/doc/random_trees.html#float CvRTrees::predict_prob(const cv::Mat& sample, const cv::Mat& missing) const"><strong>[1]</strong></a>
  </dt>

      
  <dt><a href="modules/ml/doc/random_trees.html#bool CvRTrees::train(CvMLData* data, CvRTParams params)"><strong>CvRTrees::train (C++ function)</strong></a>, <a href="modules/ml/doc/random_trees.html#bool CvRTrees::train(const CvMat* trainData, int tflag, const CvMat* responses, const CvMat* varIdx, const CvMat* sampleIdx, const CvMat* varType, const CvMat* missingDataMask, CvRTParams params)"><strong>[1]</strong></a>, <a href="modules/ml/doc/random_trees.html#bool CvRTrees::train(const Mat& trainData, int tflag, const Mat& responses, const Mat& varIdx, const Mat& sampleIdx, const Mat& varType, const Mat& missingDataMask, CvRTParams params)"><strong>[2]</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_basic_structures.html#CvScalar"><strong>CvScalar (C++ structure)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_basic_structures.html#double[4] val"><strong>CvScalar::val (C++ member)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/dynamic_structures.html#CvSeq"><strong>CvSeq (C++ structure)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/dynamic_structures.html#int elem_size"><strong>CvSeq::elem_size (C++ member)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/dynamic_structures.html#CvSeqBlock* first"><strong>CvSeq::first (C++ member)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/dynamic_structures.html#int flags"><strong>CvSeq::flags (C++ member)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/dynamic_structures.html#CvSeq* h_next"><strong>CvSeq::h_next (C++ member)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/dynamic_structures.html#CvSeq* h_prev"><strong>CvSeq::h_prev (C++ member)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/dynamic_structures.html#int header_size"><strong>CvSeq::header_size (C++ member)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/dynamic_structures.html#CvMemStorage* storage"><strong>CvSeq::storage (C++ member)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/dynamic_structures.html#int total"><strong>CvSeq::total (C++ member)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/dynamic_structures.html#CvSeq* v_next"><strong>CvSeq::v_next (C++ member)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/dynamic_structures.html#CvSeq* v_prev"><strong>CvSeq::v_prev (C++ member)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/dynamic_structures.html#CvSet"><strong>CvSet (C++ structure)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/dynamic_structures.html#CvSetElem"><strong>CvSetElem (C++ structure)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_basic_structures.html#CvSize"><strong>CvSize (C++ structure)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_basic_structures.html#CvSize2D32f"><strong>CvSize2D32f (C++ structure)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/dynamic_structures.html#CvSlice"><strong>CvSlice (C++ structure)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/dynamic_structures.html#int end_index"><strong>CvSlice::end_index (C++ member)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/dynamic_structures.html#int start_index"><strong>CvSlice::start_index (C++ member)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_basic_structures.html#CvSparseMat"><strong>CvSparseMat (C++ structure)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_basic_structures.html#int dims"><strong>CvSparseMat::dims (C++ member)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_basic_structures.html#int hashsize"><strong>CvSparseMat::hashsize (C++ member)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_basic_structures.html#void** hashtable"><strong>CvSparseMat::hashtable (C++ member)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_basic_structures.html#CvSet* heap"><strong>CvSparseMat::heap (C++ member)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_basic_structures.html#int* refcount"><strong>CvSparseMat::refcount (C++ member)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_basic_structures.html#int[] size"><strong>CvSparseMat::size (C++ member)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_basic_structures.html#int type"><strong>CvSparseMat::type (C++ member)</strong></a>
  </dt>

      
  <dt><a href="modules/ml/doc/statistical_models.html#index-0">CvStatModel</a>
  </dt>

      <dd><dl>
        
  <dt><a href="modules/ml/doc/statistical_models.html#CvStatModel"><strong>(C++ class)</strong></a>
  </dt>

      </dl></dd>
      
  <dt><a href="modules/ml/doc/statistical_models.html#void CvStatModel::clear()"><strong>CvStatModel::clear (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/ml/doc/statistical_models.html#CvStatModel::CvStatModel()"><strong>CvStatModel::CvStatModel (C++ function)</strong></a>, <a href="modules/ml/doc/statistical_models.html#CvStatModel::CvStatModel()"><strong>[1]</strong></a>
  </dt>

      
  <dt><a href="modules/ml/doc/statistical_models.html#void CvStatModel::load(const char* filename, const char* name)"><strong>CvStatModel::load (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/ml/doc/statistical_models.html#float CvStatModel::predict(const Mat& sample, ...) const"><strong>CvStatModel::predict (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/ml/doc/statistical_models.html#void CvStatModel::read(CvFileStorage* storage, CvFileNode* node)"><strong>CvStatModel::read (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/ml/doc/statistical_models.html#void CvStatModel::save(const char* filename, const char* name)"><strong>CvStatModel::save (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/ml/doc/statistical_models.html#bool CvStatModel::train(const Mat& train_data, [int tflag,] ..., const Mat& responses, ..., [const Mat& var_idx,] ..., [const Mat& sample_idx,] ... [const Mat& var_type,] ..., [const Mat& missing_mask,] <misc_training_alg_params> ...)"><strong>CvStatModel::train (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/ml/doc/statistical_models.html#void CvStatModel::write(CvFileStorage* storage, const char* name)"><strong>CvStatModel::write (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/ml/doc/statistical_models.html#CvStatModel::~CvStatModel()"><strong>CvStatModel::~CvStatModel (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/legacy/doc/planar_subdivisions.html#CvSubdiv2D"><strong>CvSubdiv2D (C++ structure)</strong></a>
  </dt>

      
  <dt><a href="modules/legacy/doc/planar_subdivisions.html#CvSubdiv2DPoint"><strong>CvSubdiv2DPoint (C++ structure)</strong></a>
  </dt>

      
  <dt><a href="modules/ml/doc/support_vector_machines.html#CvSVM : public CvStatModel"><strong>CvSVM (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/ml/doc/support_vector_machines.html#CvSVM::CvSVM()"><strong>CvSVM::CvSVM (C++ function)</strong></a>, <a href="modules/ml/doc/support_vector_machines.html#CvSVM::CvSVM(const CvMat* trainData, const CvMat* responses, const CvMat* varIdx, const CvMat* sampleIdx, CvSVMParams params)"><strong>[1]</strong></a>, <a href="modules/ml/doc/support_vector_machines.html#CvSVM::CvSVM(const Mat& trainData, const Mat& responses, const Mat& varIdx, const Mat& sampleIdx, CvSVMParams params)"><strong>[2]</strong></a>
  </dt>

      
  <dt><a href="modules/ml/doc/support_vector_machines.html#CvParamGrid CvSVM::get_default_grid(int param_id)"><strong>CvSVM::get_default_grid (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/ml/doc/support_vector_machines.html#CvSVMParams CvSVM::get_params() const"><strong>CvSVM::get_params (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/ml/doc/support_vector_machines.html#const float* CvSVM::get_support_vector(int i) const"><strong>CvSVM::get_support_vector (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/ml/doc/support_vector_machines.html#int CvSVM::get_support_vector_count() const"><strong>CvSVM::get_support_vector_count (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/ml/doc/support_vector_machines.html#int CvSVM::get_var_count() const"><strong>CvSVM::get_var_count (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/ml/doc/support_vector_machines.html#float CvSVM::predict(const CvMat* sample, bool returnDFVal) const"><strong>CvSVM::predict (C++ function)</strong></a>, <a href="modules/ml/doc/support_vector_machines.html#float CvSVM::predict(const CvMat* samples, CvMat* results) const"><strong>[1]</strong></a>, <a href="modules/ml/doc/support_vector_machines.html#float CvSVM::predict(const Mat& sample, bool returnDFVal) const"><strong>[2]</strong></a>
  </dt>

      
  <dt><a href="modules/ml/doc/support_vector_machines.html#bool CvSVM::train(const CvMat* trainData, const CvMat* responses, const CvMat* varIdx, const CvMat* sampleIdx, CvSVMParams params)"><strong>CvSVM::train (C++ function)</strong></a>, <a href="modules/ml/doc/support_vector_machines.html#bool CvSVM::train(const Mat& trainData, const Mat& responses, const Mat& varIdx, const Mat& sampleIdx, CvSVMParams params)"><strong>[1]</strong></a>
  </dt>

      
  <dt><a href="modules/ml/doc/support_vector_machines.html#bool CvSVM::train_auto(const CvMat* trainData, const CvMat* responses, const CvMat* varIdx, const CvMat* sampleIdx, CvSVMParams params, int kfold , CvParamGrid Cgrid , CvParamGrid gammaGrid , CvParamGrid pGrid , CvParamGrid nuGrid , CvParamGrid coeffGrid , CvParamGrid degreeGrid , bool balanced)"><strong>CvSVM::train_auto (C++ function)</strong></a>, <a href="modules/ml/doc/support_vector_machines.html#bool CvSVM::train_auto(const Mat& trainData, const Mat& responses, const Mat& varIdx, const Mat& sampleIdx, CvSVMParams params, int k_fold , CvParamGrid Cgrid , CvParamGrid gammaGrid , CvParamGrid pGrid , CvParamGrid nuGrid , CvParamGrid coeffGrid , CvParamGrid degreeGrid , bool balanced)"><strong>[1]</strong></a>
  </dt>

      
  <dt><a href="modules/ml/doc/support_vector_machines.html#CvSVMParams"><strong>CvSVMParams (C++ structure)</strong></a>
  </dt>

      
  <dt><a href="modules/ml/doc/support_vector_machines.html#CvSVMParams::CvSVMParams()"><strong>CvSVMParams::CvSVMParams (C++ function)</strong></a>, <a href="modules/ml/doc/support_vector_machines.html#CvSVMParams::CvSVMParams(int svm_type, int kernel_type, double degree, double gamma, double coef0, double Cvalue, double nu, double p, CvMat* class_weights, CvTermCriteria term_crit)"><strong>[1]</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/miscellaneous_transformations.html#void cvCvtColor(const CvArr* src, CvArr* dst, int code)"><strong>CvtColor (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/miscellaneous_transformations.html#void cvtColor(InputArray src, OutputArray dst, int code, int dstCn)"><strong>cvtColor (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/miscellaneous_transformations.html#cv.CvtColor"><strong>CvtColor() (Python function in cv)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/miscellaneous_transformations.html#cv2.cvtColor"><strong>cvtColor() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_basic_structures.html#CvTermCriteria"><strong>CvTermCriteria (C++ structure)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_basic_structures.html#double epsilon"><strong>CvTermCriteria::epsilon (C++ member)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_basic_structures.html#int max_iter"><strong>CvTermCriteria::max_iter (C++ member)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_basic_structures.html#int type"><strong>CvTermCriteria::type (C++ member)</strong></a>
  </dt>

      
  <dt><a href="modules/ml/doc/mldata.html#CvTrainTestSplit"><strong>CvTrainTestSplit (C++ structure)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/dynamic_structures.html#CvTreeNodeIterator"><strong>CvTreeNodeIterator (C++ structure)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/dynamic_structures.html#void* cvCvtSeqToArray(const CvSeq* seq, void* elements, CvSlice slice)"><strong>CvtSeqToArray (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_xml_yaml_persistence.html#CvTypeInfo"><strong>CvTypeInfo (C++ structure)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/utility_and_system_functions_and_macros.html#int cvUseOptimized(int on_off)"><strong>cvUseOptimized (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/stitching/doc/high_level.html#CylindricalWarper : public WarperCreator"><strong>CylindricalWarper (C++ class)</strong></a>
  </dt>

  </dl></td>
</tr></table>

<h2 id="D">D</h2>
<table style="width: 100%" class="indextable genindextable"><tr>
  <td style="width: 33%" valign="top"><dl>
      
  <dt><a href="modules/core/doc/basic_structures.html#DataType"><strong>DataType (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#void cvDCT(const CvArr* src, CvArr* dst, int flags)"><strong>DCT (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#void dct(InputArray src, OutputArray dst, int flags)"><strong>dct (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#cv.DCT"><strong>DCT() (Python function in cv)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#cv2.dct"><strong>dct() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/utility_and_system_functions_and_macros.html#template<typename _Tp> void deallocate(_Tp* ptr, size_t n)"><strong>deallocate (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/highgui/doc/reading_and_writing_images_and_video.html#IplImage* cvDecodeImage(const CvMat* buf, int iscolor)"><strong>DecodeImage (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/highgui/doc/reading_and_writing_images_and_video.html#CvMat* cvDecodeImageM(const CvMat* buf, int iscolor)"><strong>DecodeImageM (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/calib3d/doc/camera_calibration_and_3d_reconstruction.html#void cvDecomposeProjectionMatrix(const CvMat * projMatr, CvMat * calibMatr, CvMat * rotMatr, CvMat * posVect, CvMat * rotMatrX, CvMat * rotMatrY, CvMat * rotMatrZ, CvPoint3D64f * eulerAngles)"><strong>DecomposeProjectionMatrix (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/calib3d/doc/camera_calibration_and_3d_reconstruction.html#void decomposeProjectionMatrix(InputArray projMatrix, OutputArray cameraMatrix, OutputArray rotMatrix, OutputArray transVect, OutputArray rotMatrixX, OutputArray rotMatrixY, OutputArray rotMatrixZ, OutputArray eulerAngles)"><strong>decomposeProjectionMatrix (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/calib3d/doc/camera_calibration_and_3d_reconstruction.html#cv.DecomposeProjectionMatrix"><strong>DecomposeProjectionMatrix() (Python function in cv)</strong></a>
  </dt>

      
  <dt><a href="modules/calib3d/doc/camera_calibration_and_3d_reconstruction.html#cv2.decomposeProjectionMatrix"><strong>decomposeProjectionMatrix() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_basic_structures.html#void cvDecRefData(CvArr* arr)"><strong>DecRefData (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/features2d/doc/common_interfaces_of_feature_detectors.html#DenseFeatureDetector : public FeatureDetector"><strong>DenseFeatureDetector (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/video/doc/motion_analysis_and_object_tracking.html#void DenseOpticalFlow::calc(InputArray I0, InputArray I1, InputOutputArray flow)"><strong>DenseOpticalFlow::calc (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/video/doc/motion_analysis_and_object_tracking.html#void DenseOpticalFlow::collectGarbage()"><strong>DenseOpticalFlow::collectGarbage (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/features2d/doc/common_interfaces_of_descriptor_extractors.html#DescriptorExtractor : public Algorithm"><strong>DescriptorExtractor (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/features2d/doc/common_interfaces_of_descriptor_extractors.html#void DescriptorExtractor::compute(const Mat& image, vector<KeyPoint>& keypoints, Mat& descriptors) const"><strong>DescriptorExtractor::compute (C++ function)</strong></a>, <a href="modules/features2d/doc/common_interfaces_of_descriptor_extractors.html#void DescriptorExtractor::compute(const vector<Mat>& images, vector<vector<KeyPoint> >& keypoints, vector<Mat>& descriptors) const"><strong>[1]</strong></a>
  </dt>

      
  <dt><a href="modules/features2d/doc/common_interfaces_of_descriptor_extractors.html#Ptr<DescriptorExtractor> DescriptorExtractor::create(const string& descriptorExtractorType)"><strong>DescriptorExtractor::create (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/features2d/doc/common_interfaces_of_descriptor_matchers.html#DescriptorMatcher : public Algorithm"><strong>DescriptorMatcher (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/features2d/doc/common_interfaces_of_descriptor_matchers.html#void DescriptorMatcher::add(const vector<Mat>& descriptors)"><strong>DescriptorMatcher::add (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/features2d/doc/common_interfaces_of_descriptor_matchers.html#void DescriptorMatcher::clear()"><strong>DescriptorMatcher::clear (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/features2d/doc/common_interfaces_of_descriptor_matchers.html#Ptr<DescriptorMatcher> DescriptorMatcher::clone(bool emptyTrainData)"><strong>DescriptorMatcher::clone (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/features2d/doc/common_interfaces_of_descriptor_matchers.html#Ptr<DescriptorMatcher> DescriptorMatcher::create(const string& descriptorMatcherType)"><strong>DescriptorMatcher::create (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/features2d/doc/common_interfaces_of_descriptor_matchers.html#bool DescriptorMatcher::empty() const"><strong>DescriptorMatcher::empty (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/features2d/doc/common_interfaces_of_descriptor_matchers.html#const vector<Mat>& DescriptorMatcher::getTrainDescriptors() const"><strong>DescriptorMatcher::getTrainDescriptors (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/features2d/doc/common_interfaces_of_descriptor_matchers.html#bool DescriptorMatcher::isMaskSupported()"><strong>DescriptorMatcher::isMaskSupported (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/features2d/doc/common_interfaces_of_descriptor_matchers.html#void DescriptorMatcher::knnMatch(const Mat& queryDescriptors, const Mat& trainDescriptors, vector<vector<DMatch> >& matches, int k, const Mat& mask, bool compactResult) const"><strong>DescriptorMatcher::knnMatch (C++ function)</strong></a>, <a href="modules/features2d/doc/common_interfaces_of_descriptor_matchers.html#void DescriptorMatcher::knnMatch(const Mat& queryDescriptors, vector<vector<DMatch> >& matches, int k, const vector<Mat>& masks, bool compactResult)"><strong>[1]</strong></a>
  </dt>

      
  <dt><a href="modules/features2d/doc/common_interfaces_of_descriptor_matchers.html#void DescriptorMatcher::match(const Mat& queryDescriptors, const Mat& trainDescriptors, vector<DMatch>& matches, const Mat& mask) const"><strong>DescriptorMatcher::match (C++ function)</strong></a>, <a href="modules/features2d/doc/common_interfaces_of_descriptor_matchers.html#void DescriptorMatcher::match(const Mat& queryDescriptors, vector<DMatch>& matches, const vector<Mat>& masks)"><strong>[1]</strong></a>
  </dt>

      
  <dt><a href="modules/features2d/doc/common_interfaces_of_descriptor_matchers.html#void DescriptorMatcher::radiusMatch(const Mat& queryDescriptors, const Mat& trainDescriptors, vector<vector<DMatch> >& matches, float maxDistance, const Mat& mask, bool compactResult) const"><strong>DescriptorMatcher::radiusMatch (C++ function)</strong></a>, <a href="modules/features2d/doc/common_interfaces_of_descriptor_matchers.html#void DescriptorMatcher::radiusMatch(const Mat& queryDescriptors, vector<vector<DMatch> >& matches, float maxDistance, const vector<Mat>& masks, bool compactResult)"><strong>[1]</strong></a>
  </dt>

      
  <dt><a href="modules/features2d/doc/common_interfaces_of_descriptor_matchers.html#void DescriptorMatcher::train()"><strong>DescriptorMatcher::train (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/highgui/doc/user_interface.html#void cvDestroyAllWindows()"><strong>DestroyAllWindows (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/highgui/doc/user_interface.html#void destroyAllWindows()"><strong>destroyAllWindows (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/highgui/doc/user_interface.html#cv.DestroyAllWindows"><strong>DestroyAllWindows() (Python function in cv)</strong></a>
  </dt>

      
  <dt><a href="modules/highgui/doc/user_interface.html#cv2.destroyAllWindows"><strong>destroyAllWindows() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/highgui/doc/user_interface.html#void cvDestroyWindow(const char* name)"><strong>DestroyWindow (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/highgui/doc/user_interface.html#void destroyWindow(const string& winname)"><strong>destroyWindow (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/highgui/doc/user_interface.html#cv.DestroyWindow"><strong>DestroyWindow() (Python function in cv)</strong></a>
  </dt>

      
  <dt><a href="modules/highgui/doc/user_interface.html#cv2.destroyWindow"><strong>destroyWindow() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#double cvDet(const CvArr* mat)"><strong>Det (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#cv.Det"><strong>Det() (Python function in cv)</strong></a>
  </dt>

      
  <dt><a href="modules/stitching/doc/matching.html#detail::BestOf2NearestMatcher : public detail::FeaturesMatcher"><strong>detail::BestOf2NearestMatcher (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/stitching/doc/matching.html#detail::BestOf2NearestMatcher::BestOf2NearestMatcher(bool try_use_gpu , float match_conf , int num_matches_thresh1 , int num_matches_thresh2)"><strong>detail::BestOf2NearestMatcher::BestOf2NearestMatcher (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/stitching/doc/blenders.html#detail::Blender"><strong>detail::Blender (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/stitching/doc/blenders.html#void detail::Blender::blend(Mat &dst, Mat &dst_mask)"><strong>detail::Blender::blend (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/stitching/doc/blenders.html#void detail::Blender::feed(const Mat &img, const Mat &mask, Point tl)"><strong>detail::Blender::feed (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/stitching/doc/blenders.html#void detail::Blender::prepare(const std::vector<Point> &corners, const std::vector<Size> &sizes)"><strong>detail::Blender::prepare (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/stitching/doc/exposure_compensation.html#detail::BlocksGainCompensator : public detail::ExposureCompensator"><strong>detail::BlocksGainCompensator (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/stitching/doc/motion_estimation.html#detail::BundleAdjusterBase : public detail::Estimator"><strong>detail::BundleAdjusterBase (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/stitching/doc/motion_estimation.html#detail::BundleAdjusterBase::BundleAdjusterBase(int num_params_per_cam, int num_errs_per_measurement)"><strong>detail::BundleAdjusterBase::BundleAdjusterBase (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/stitching/doc/motion_estimation.html#void detail::BundleAdjusterBase::calcError(Mat &err)"><strong>detail::BundleAdjusterBase::calcError (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/stitching/doc/motion_estimation.html#void detail::BundleAdjusterBase::calcJacobian(Mat &jac)"><strong>detail::BundleAdjusterBase::calcJacobian (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/stitching/doc/motion_estimation.html#void detail::BundleAdjusterBase::obtainRefinedCameraParams(std::vector<CameraParams> &cameras) const"><strong>detail::BundleAdjusterBase::obtainRefinedCameraParams (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/stitching/doc/motion_estimation.html#void detail::BundleAdjusterBase::setUpInitialCameraParams(const std::vector<CameraParams> &cameras)"><strong>detail::BundleAdjusterBase::setUpInitialCameraParams (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/stitching/doc/motion_estimation.html#detail::BundleAdjusterRay : public detail::BundleAdjusterBase"><strong>detail::BundleAdjusterRay (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/stitching/doc/motion_estimation.html#detail::BundleAdjusterReproj : public detail::BundleAdjusterBase"><strong>detail::BundleAdjusterReproj (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/stitching/doc/camera.html#detail::CameraParams"><strong>detail::CameraParams (C++ structure)</strong></a>
  </dt>

      
  <dt><a href="modules/stitching/doc/warpers.html#detail::CylindricalWarper : public detail::RotationWarperBase<CylindricalProjector>"><strong>detail::CylindricalWarper (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/stitching/doc/warpers.html#void detail::CylindricalWarper::CylindricalWarper(float scale)"><strong>detail::CylindricalWarper::CylindricalWarper (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/stitching/doc/autocalib.html#void detail::estimateFocal(const std::vector<ImageFeatures> &features, const std::vector<MatchesInfo> &pairwise_matches, std::vector<double> &focals)"><strong>detail::estimateFocal (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/stitching/doc/motion_estimation.html#detail::Estimator"><strong>detail::Estimator (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/stitching/doc/motion_estimation.html#void detail::Estimator::estimate(const std::vector<ImageFeatures> &features, const std::vector<MatchesInfo> &pairwise_matches, std::vector<CameraParams> &cameras)"><strong>detail::Estimator::estimate (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/stitching/doc/motion_estimation.html#detail::Estimator::operator ()(const std::vector<ImageFeatures> &features, const std::vector<MatchesInfo> &pairwise_matches, std::vector<CameraParams> &cameras)"><strong>detail::Estimator::operator() (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/stitching/doc/exposure_compensation.html#detail::ExposureCompensator"><strong>detail::ExposureCompensator (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/stitching/doc/exposure_compensation.html#void detail::ExposureCompensator::apply(int index, Point corner, Mat &image, const Mat &mask)"><strong>detail::ExposureCompensator::apply (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/stitching/doc/exposure_compensation.html#void detail::ExposureCompensator::feed(const std::vector<Point> &corners, const std::vector<Mat> &images, const std::vector<Mat> &masks)"><strong>detail::ExposureCompensator::feed (C++ function)</strong></a>, <a href="modules/stitching/doc/exposure_compensation.html#void detail::ExposureCompensator::feed(const std::vector<Point> &corners, const std::vector<Mat> &images, const std::vector<std::pair<Mat,uchar> > &masks)"><strong>[1]</strong></a>
  </dt>

      
  <dt><a href="modules/stitching/doc/blenders.html#detail::FeatherBlender : public detail::Blender"><strong>detail::FeatherBlender (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/stitching/doc/matching.html#detail::FeaturesFinder"><strong>detail::FeaturesFinder (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/stitching/doc/matching.html#void detail::FeaturesFinder::collectGarbage()"><strong>detail::FeaturesFinder::collectGarbage (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/stitching/doc/matching.html#void detail::FeaturesFinder::find(const Mat &image, ImageFeatures &features)"><strong>detail::FeaturesFinder::find (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/stitching/doc/matching.html#void detail::FeaturesFinder::operator ()(const Mat &image, ImageFeatures &features)"><strong>detail::FeaturesFinder::operator() (C++ function)</strong></a>, <a href="modules/stitching/doc/matching.html#void detail::FeaturesFinder::operator ()(const Mat &image, ImageFeatures &features, const std::vector<cv::Rect> &rois)"><strong>[1]</strong></a>
  </dt>

      
  <dt><a href="modules/stitching/doc/matching.html#detail::FeaturesMatcher"><strong>detail::FeaturesMatcher (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/stitching/doc/matching.html#void detail::FeaturesMatcher::collectGarbage()"><strong>detail::FeaturesMatcher::collectGarbage (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/stitching/doc/matching.html#bool detail::FeaturesMatcher::isThreadSafe() const"><strong>detail::FeaturesMatcher::isThreadSafe (C++ function)</strong></a>
  </dt>

  </dl></td>
  <td style="width: 33%" valign="top"><dl>
      
  <dt><a href="modules/stitching/doc/matching.html#void detail::FeaturesMatcher::match(const ImageFeatures &features1, const ImageFeatures &features2, MatchesInfo& matches_info)"><strong>detail::FeaturesMatcher::match (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/stitching/doc/matching.html#void detail::FeaturesMatcher::operator ()(const ImageFeatures &features1, const ImageFeatures &features2, MatchesInfo& matches_info)"><strong>detail::FeaturesMatcher::operator() (C++ function)</strong></a>, <a href="modules/stitching/doc/matching.html#void detail::FeaturesMatcher::operator ()(const std::vector<ImageFeatures> & features, std::vector<MatchesInfo> & pairwise_matches, const Mat & mask)"><strong>[1]</strong></a>
  </dt>

      
  <dt><a href="modules/stitching/doc/autocalib.html#void detail::focalsFromHomography(const Mat &H, double &f0, double &f1, bool &f0_ok, bool &f1_ok)"><strong>detail::focalsFromHomography (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/stitching/doc/exposure_compensation.html#detail::GainCompensator : public detail::ExposureCompensator"><strong>detail::GainCompensator (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/stitching/doc/seam_estimation.html#detail::GraphCutSeamFinder : public detail::GraphCutSeamFinderBase, public detail::SeamFinder"><strong>detail::GraphCutSeamFinder (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/stitching/doc/seam_estimation.html#detail::GraphCutSeamFinderBase"><strong>detail::GraphCutSeamFinderBase (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/stitching/doc/motion_estimation.html#detail::HomographyBasedEstimator : public detail::Estimator"><strong>detail::HomographyBasedEstimator (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/stitching/doc/matching.html#detail::ImageFeatures"><strong>detail::ImageFeatures (C++ structure)</strong></a>
  </dt>

      
  <dt><a href="modules/stitching/doc/matching.html#detail::MatchesInfo"><strong>detail::MatchesInfo (C++ structure)</strong></a>
  </dt>

      
  <dt><a href="modules/stitching/doc/blenders.html#detail::MultiBandBlender : public detail::Blender"><strong>detail::MultiBandBlender (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/stitching/doc/exposure_compensation.html#detail::NoExposureCompensator : public detail::ExposureCompensator"><strong>detail::NoExposureCompensator (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/stitching/doc/seam_estimation.html#detail::NoSeamFinder : public detail::SeamFinder"><strong>detail::NoSeamFinder (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/stitching/doc/matching.html#detail::OrbFeaturesFinder : public detail::FeaturesFinder"><strong>detail::OrbFeaturesFinder (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/stitching/doc/seam_estimation.html#detail::PairwiseSeamFinder : public detail::SeamFinder"><strong>detail::PairwiseSeamFinder (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/stitching/doc/seam_estimation.html#void detail::PairwiseSeamFinder::findInPair(size_t first, size_t second, Rect roi)"><strong>detail::PairwiseSeamFinder::findInPair (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/stitching/doc/warpers.html#detail::PlaneWarper : public detail::RotationWarperBase<PlaneProjector>"><strong>detail::PlaneWarper (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/stitching/doc/warpers.html#void detail::PlaneWarper::PlaneWarper(float scale)"><strong>detail::PlaneWarper::PlaneWarper (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/stitching/doc/warpers.html#detail::ProjectorBase"><strong>detail::ProjectorBase (C++ structure)</strong></a>
  </dt>

      
  <dt><a href="modules/stitching/doc/warpers.html#detail::RotationWarper"><strong>detail::RotationWarper (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/stitching/doc/warpers.html#Rect detail::RotationWarper::buildMaps(Size src_size, const Mat &K, const Mat &R, Mat &xmap, Mat &ymap)"><strong>detail::RotationWarper::buildMaps (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/stitching/doc/warpers.html#Point detail::RotationWarper::warp(const Mat &src, const Mat &K, const Mat &R, int interp_mode, int border_mode, Mat &dst)"><strong>detail::RotationWarper::warp (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/stitching/doc/warpers.html#void detail::RotationWarper::warpBackward(const Mat &src, const Mat &K, const Mat &R, int interp_mode, int border_mode, Size dst_size, Mat &dst)"><strong>detail::RotationWarper::warpBackward (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/stitching/doc/warpers.html#Point2f detail::RotationWarper::warpPoint(const Point2f &pt, const Mat &K, const Mat &R)"><strong>detail::RotationWarper::warpPoint (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/stitching/doc/warpers.html#Rect detail::RotationWarper::warpRoi(Size src_size, const Mat &K, const Mat &R)"><strong>detail::RotationWarper::warpRoi (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/stitching/doc/warpers.html#detail::RotationWarperBase"><strong>detail::RotationWarperBase (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/stitching/doc/seam_estimation.html#detail::SeamFinder"><strong>detail::SeamFinder (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/stitching/doc/seam_estimation.html#void detail::SeamFinder::find(const std::vector<Mat> &src, const std::vector<Point> &corners, std::vector<Mat> &masks)"><strong>detail::SeamFinder::find (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/stitching/doc/warpers.html#detail::SphericalWarper : public detail::RotationWarperBase<SphericalProjector>"><strong>detail::SphericalWarper (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/stitching/doc/warpers.html#void detail::SphericalWarper::SphericalWarper(float scale)"><strong>detail::SphericalWarper::SphericalWarper (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/stitching/doc/matching.html#detail::SurfFeaturesFinder : public detail::FeaturesFinder"><strong>detail::SurfFeaturesFinder (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/stitching/doc/seam_estimation.html#detail::VoronoiSeamFinder : public detail::PairwiseSeamFinder"><strong>detail::VoronoiSeamFinder (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/stitching/doc/motion_estimation.html#void detail::waveCorrect(std::vector<Mat> &rmats, WaveCorrectKind kind)"><strong>detail::waveCorrect (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/stitching/doc/motion_estimation.html#detail::WaveCorrectKind"><strong>detail::WaveCorrectKind (enum)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#double determinant(InputArray mtx)"><strong>determinant (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#cv2.determinant"><strong>determinant() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#void cvDFT(const CvArr* src, CvArr* dst, int flags, int nonzero_rows)"><strong>DFT (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#void dft(InputArray src, OutputArray dst, int flags, int nonzeroRows)"><strong>dft (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#cv.DFT"><strong>DFT() (Python function in cv)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#cv2.dft"><strong>dft() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/filtering.html#void cvDilate(const CvArr* src, CvArr* dst, IplConvKernel* element, int iterations)"><strong>Dilate (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/filtering.html#void dilate(InputArray src, OutputArray dst, InputArray kernel, Point anchor, int iterations, int borderType, const Scalar& borderValue)"><strong>dilate (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/filtering.html#cv.Dilate"><strong>Dilate() (Python function in cv)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/filtering.html#cv2.dilate"><strong>dilate() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/highgui/doc/qt_new_functions.html#index-0">displayOverlay</a>
  </dt>

      
  <dt><a href="modules/highgui/doc/qt_new_functions.html#void cvDisplayOverlay(const char* name, const char* text, int delayms)"><strong>DisplayOverlay (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/highgui/doc/qt_new_functions.html#void displayOverlay(const string& winname, const string& text, int delayms)"><strong>displayOverlay (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/highgui/doc/qt_new_functions.html#void cvDisplayStatusBar(const char* name, const char* text, int delayms)"><strong>DisplayStatusBar (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/highgui/doc/qt_new_functions.html#void displayStatusBar(const string& winname, const string& text, int delayms)"><strong>displayStatusBar (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/miscellaneous_transformations.html#void distanceTransform(InputArray src, OutputArray dst, OutputArray labels, int distanceType, int maskSize, int labelType)"><strong>distanceTransform (C++ function)</strong></a>, <a href="modules/imgproc/doc/miscellaneous_transformations.html#void distanceTransform(InputArray src, OutputArray dst, int distanceType, int maskSize)"><strong>[1]</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/miscellaneous_transformations.html#cv2.distanceTransform"><strong>distanceTransform() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/miscellaneous_transformations.html#void cvDistTransform(const CvArr* src, CvArr* dst, int distance_type, int mask_size, const float* mask, CvArr* labels, int labelType)"><strong>DistTransform (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/miscellaneous_transformations.html#cv.DistTransform"><strong>DistTransform() (Python function in cv)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#void cvDiv(const CvArr* src1, const CvArr* src2, CvArr* dst, double scale)"><strong>Div (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#cv.Div"><strong>Div() (Python function in cv)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#void divide(InputArray src1, InputArray src2, OutputArray dst, double scale, int dtype)"><strong>divide (C++ function)</strong></a>, <a href="modules/core/doc/operations_on_arrays.html#void divide(double scale, InputArray src2, OutputArray dst, int dtype)"><strong>[1]</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#cv2.divide"><strong>divide() (Python function in cv2)</strong></a>, <a href="modules/core/doc/operations_on_arrays.html#cv2.divide"><strong>[1]</strong></a>
  </dt>

      
  <dt><a href="modules/features2d/doc/common_interfaces_of_descriptor_matchers.html#DMatch"><strong>DMatch (C++ structure)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_basic_structures.html#double cvDotProduct(const CvArr* src1, const CvArr* src2)"><strong>DotProduct (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_basic_structures.html#cv.DotProduct"><strong>DotProduct() (Python function in cv)</strong></a>
  </dt>

      
  <dt><a href="modules/calib3d/doc/camera_calibration_and_3d_reconstruction.html#void cvDrawChessboardCorners(CvArr* image, CvSize pattern_size, CvPoint2D32f* corners, int count, int pattern_was_found)"><strong>DrawChessboardCorners (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/calib3d/doc/camera_calibration_and_3d_reconstruction.html#void drawChessboardCorners(InputOutputArray image, Size patternSize, InputArray corners, bool patternWasFound)"><strong>drawChessboardCorners (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/calib3d/doc/camera_calibration_and_3d_reconstruction.html#cv.DrawChessboardCorners"><strong>DrawChessboardCorners() (Python function in cv)</strong></a>
  </dt>

      
  <dt><a href="modules/calib3d/doc/camera_calibration_and_3d_reconstruction.html#cv2.drawChessboardCorners"><strong>drawChessboardCorners() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/structural_analysis_and_shape_descriptors.html#void cvDrawContours(CvArr *img, CvSeq* contour, CvScalar externalColor, CvScalar holeColor, int maxLevel, int thickness, int lineType)"><strong>DrawContours (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/structural_analysis_and_shape_descriptors.html#void drawContours(InputOutputArray image, InputArrayOfArrays contours, int contourIdx, const Scalar& color, int thickness, int lineType, InputArray hierarchy, int maxLevel, Point offset)"><strong>drawContours (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/structural_analysis_and_shape_descriptors.html#cv.DrawContours"><strong>DrawContours() (Python function in cv)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/structural_analysis_and_shape_descriptors.html#cv2.drawContours"><strong>drawContours() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/features2d/doc/drawing_function_of_keypoints_and_matches.html#void drawKeypoints(const Mat& image, const vector<KeyPoint>& keypoints, Mat& outImage, const Scalar& color, int flags)"><strong>drawKeypoints (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/features2d/doc/drawing_function_of_keypoints_and_matches.html#void drawMatches(const Mat& img1, const vector<KeyPoint>& keypoints1, const Mat& img2, const vector<KeyPoint>& keypoints2, const vector<DMatch>& matches1to2, Mat& outImg, const Scalar& matchColor, const Scalar& singlePointColor, const vector<char>& matchesMask, int flags)"><strong>drawMatches (C++ function)</strong></a>, <a href="modules/features2d/doc/drawing_function_of_keypoints_and_matches.html#void drawMatches(const Mat& img1, const vector<KeyPoint>& keypoints1, const Mat& img2, const vector<KeyPoint>& keypoints2, const vector<vector<DMatch> >& matches1to2, Mat& outImg, const Scalar& matchColor, const Scalar& singlePointColor, const vector<vector<char> >& matchesMask, int flags)"><strong>[1]</strong></a>
  </dt>

      
  <dt><a href="modules/ml/doc/decision_trees.html#cv2.DTree.getVarImportance"><strong>DTree.getVarImportance() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/ml/doc/decision_trees.html#cv2.DTree.predict"><strong>DTree.predict() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/ml/doc/decision_trees.html#cv2.DTree.train"><strong>DTree.train() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/features2d/doc/common_interfaces_of_feature_detectors.html#DynamicAdaptedFeatureDetector : public FeatureDetector"><strong>DynamicAdaptedFeatureDetector (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/features2d/doc/common_interfaces_of_feature_detectors.html#DynamicAdaptedFeatureDetector::DynamicAdaptedFeatureDetector(const Ptr<AdjusterAdapter>& adjuster, int min_features, int max_features, int max_iters)"><strong>DynamicAdaptedFeatureDetector::DynamicAdaptedFeatureDetector (C++ function)</strong></a>
  </dt>

  </dl></td>
</tr></table>

<h2 id="E">E</h2>
<table style="width: 100%" class="indextable genindextable"><tr>
  <td style="width: 33%" valign="top"><dl>
      
  <dt><a href="modules/core/doc/operations_on_arrays.html#bool eigen(InputArray src, OutputArray eigenvalues, OutputArray eigenvectors, int lowindex,int highindex)"><strong>eigen (C++ function)</strong></a>, <a href="modules/core/doc/operations_on_arrays.html#bool eigen(InputArray src, OutputArray eigenvalues, int lowindex, int highindex)"><strong>[1]</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#cv2.eigen"><strong>eigen() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#void cvEigenVV(CvArr* mat, CvArr* evects, CvArr* evals, double eps, int lowindex, int highindex)"><strong>EigenVV (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#cv.EigenVV"><strong>EigenVV() (Python function in cv)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/drawing_functions.html#void cvEllipse(CvArr* img, CvPoint center, CvSize axes, double angle, double start_angle, double end_angle, CvScalar color, int thickness, int line_type, int shift)"><strong>Ellipse (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/drawing_functions.html#void ellipse(Mat& img, Point center, Size axes, double angle, double startAngle, double endAngle, const Scalar& color, int thickness, int lineType, int shift)"><strong>ellipse (C++ function)</strong></a>, <a href="modules/core/doc/drawing_functions.html#void ellipse(Mat& img, const RotatedRect& box, const Scalar& color, int thickness, int lineType)"><strong>[1]</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/drawing_functions.html#cv.Ellipse"><strong>Ellipse() (Python function in cv)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/drawing_functions.html#cv2.ellipse"><strong>ellipse() (Python function in cv2)</strong></a>, <a href="modules/core/doc/drawing_functions.html#cv2.ellipse"><strong>[1]</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/drawing_functions.html#void ellipse2Poly(Point center, Size axes, int angle, int arcStart, int arcEnd, int delta, vector<Point>& pts)"><strong>ellipse2Poly (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/drawing_functions.html#cv2.ellipse2Poly"><strong>ellipse2Poly() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/drawing_functions.html#void cvEllipseBox(CvArr* img, CvBox2D box, CvScalar color, int thickness, int line_type, int shift)"><strong>EllipseBox (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/drawing_functions.html#cv.EllipseBox"><strong>EllipseBox() (Python function in cv)</strong></a>
  </dt>

      
  <dt><a href="modules/ml/doc/expectation_maximization.html#EM : public Algorithm"><strong>EM (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/ml/doc/expectation_maximization.html#cv2.EM"><strong>EM() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/ml/doc/expectation_maximization.html#cv2.EM.isTrained"><strong>EM.isTrained() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/ml/doc/expectation_maximization.html#cv2.EM.predict"><strong>EM.predict() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/ml/doc/expectation_maximization.html#cv2.EM.train"><strong>EM.train() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/ml/doc/expectation_maximization.html#cv2.EM.trainE"><strong>EM.trainE() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/ml/doc/expectation_maximization.html#cv2.EM.trainM"><strong>EM.trainM() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/ml/doc/expectation_maximization.html#EM::EM(int nclusters, int covMatType, const TermCriteria& termCrit)"><strong>EM::EM (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/ml/doc/expectation_maximization.html#bool EM::isTrained() const"><strong>EM::isTrained (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/ml/doc/expectation_maximization.html#Vec2d EM::predict(InputArray sample, OutputArray probs) const"><strong>EM::predict (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/ml/doc/expectation_maximization.html#bool EM::train(InputArray samples, OutputArray logLikelihoods, OutputArray labels, OutputArray probs)"><strong>EM::train (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/ml/doc/expectation_maximization.html#bool EM::trainE(InputArray samples, InputArray means0, InputArray covs0, InputArray weights0, OutputArray logLikelihoods, OutputArray labels, OutputArray probs)"><strong>EM::trainE (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/ml/doc/expectation_maximization.html#bool EM::trainM(InputArray samples, InputArray probs0, OutputArray logLikelihoods, OutputArray labels, OutputArray probs)"><strong>EM::trainM (C++ function)</strong></a>
  </dt>

  </dl></td>
  <td style="width: 33%" valign="top"><dl>
      
  <dt><a href="modules/imgproc/doc/histograms.html#float EMD(InputArray signature1, InputArray signature2, int distType, InputArray cost, float* lowerBound, OutputArray flow)"><strong>EMD (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/highgui/doc/reading_and_writing_images_and_video.html#CvMat* cvEncodeImage(const char* ext, const CvArr* image, const int* params)"><strong>EncodeImage (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/dynamic_structures.html#CvSeq* cvEndWriteSeq(CvSeqWriter* writer)"><strong>EndWriteSeq (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_xml_yaml_persistence.html#void cvEndWriteStruct(CvFileStorage* fs)"><strong>EndWriteStruct (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/histograms.html#void cvEqualizeHist(const CvArr* src, CvArr* dst)"><strong>EqualizeHist (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/histograms.html#void equalizeHist(InputArray src, OutputArray dst)"><strong>equalizeHist (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/histograms.html#cv2.equalizeHist"><strong>equalizeHist() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/filtering.html#void cvErode(const CvArr* src, CvArr* dst, IplConvKernel* element, int iterations)"><strong>Erode (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/filtering.html#void erode(InputArray src, OutputArray dst, InputArray kernel, Point anchor, int iterations, int borderType, const Scalar& borderValue)"><strong>erode (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/filtering.html#cv.Erode"><strong>Erode() (Python function in cv)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/filtering.html#cv2.erode"><strong>erode() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/utility_and_system_functions_and_macros.html#void cvError(int status, const char* func_name, const char* err_msg, const char* file_name, int line)"><strong>Error (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/utility_and_system_functions_and_macros.html#void error(const Exception& exc)"><strong>error (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/calib3d/doc/camera_calibration_and_3d_reconstruction.html#int estimateAffine3D(InputArray src, InputArray dst, OutputArray out, OutputArray inliers, double ransacThreshold , double confidence)"><strong>estimateAffine3D (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/calib3d/doc/camera_calibration_and_3d_reconstruction.html#cv2.estimateAffine3D"><strong>estimateAffine3D() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/video/doc/motion_analysis_and_object_tracking.html#Mat estimateRigidTransform(InputArray src, InputArray dst, bool fullAffine)"><strong>estimateRigidTransform (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/video/doc/motion_analysis_and_object_tracking.html#cv2.estimateRigidTransform"><strong>estimateRigidTransform() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/utility_and_system_functions_and_macros.html#Exception : public std::exception"><strong>Exception (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#void cvExp(const CvArr* src, CvArr* dst)"><strong>Exp (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#void exp(InputArray src, OutputArray dst)"><strong>exp (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#cv.Exp"><strong>Exp() (Python function in cv)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#cv2.exp"><strong>exp() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#void extractImageCOI(const CvArr* arr, OutputArray coiimg, int coi)"><strong>extractImageCOI (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/nonfree/doc/feature_detection.html#void cvExtractSURF(const CvArr* image, const CvArr* mask, CvSeq** keypoints, CvSeq** descriptors, CvMemStorage* storage, CvSURFParams params)"><strong>ExtractSURF (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/nonfree/doc/feature_detection.html#cv.ExtractSURF"><strong>ExtractSURF() (Python function in cv)</strong></a>
  </dt>

  </dl></td>
</tr></table>

<h2 id="F">F</h2>
<table style="width: 100%" class="indextable genindextable"><tr>
  <td style="width: 33%" valign="top"><dl>
      
  <dt><a href="modules/contrib/doc/openfabmap.html#FabMap1 : public FabMap"><strong>FabMap1 (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/contrib/doc/openfabmap.html#FabMap1::FabMap1(const Mat& clTree, double PzGe, double PzGNe, int flags, int numSamples)"><strong>FabMap1::FabMap1 (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/contrib/doc/openfabmap.html#FabMap2 : public FabMap"><strong>FabMap2 (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/contrib/doc/openfabmap.html#FabMap2::FabMap2(const Mat& clTree, double PzGe, double PzGNe, int flags)"><strong>FabMap2::FabMap2 (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/contrib/doc/openfabmap.html#FabMapFBO : public FabMap"><strong>FabMapFBO (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/contrib/doc/openfabmap.html#FabMapFBO::FabMapFBO(const Mat& clTree, double PzGe, double PzGNe, int flags, int numSamples , double rejectionThreshold , double PsGd , int bisectionStart , int bisectionIts)"><strong>FabMapFBO::FabMapFBO (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/contrib/doc/openfabmap.html#FabMapLUT : public FabMap"><strong>FabMapLUT (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/contrib/doc/openfabmap.html#FabMapLUT::FabMapLUT(const Mat& clTree, double PzGe, double PzGNe, int flags, int numSamples , int precision)"><strong>FabMapLUT::FabMapLUT (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/contrib/doc/facerec/facerec_api.html#FaceRecognizer : public Algorithm"><strong>FaceRecognizer (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/contrib/doc/facerec/facerec_api.html#vector<int> FaceRecognizer::getLabelsByString(const string& str)"><strong>FaceRecognizer::getLabelsByString (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/contrib/doc/facerec/facerec_api.html#void FaceRecognizer::load(const FileStorage& fs) = 0"><strong>FaceRecognizer::load (C++ function)</strong></a>, <a href="modules/contrib/doc/facerec/facerec_api.html#void FaceRecognizer::load(const string& filename)"><strong>[1]</strong></a>
  </dt>

      
  <dt><a href="modules/contrib/doc/facerec/facerec_api.html#int FaceRecognizer::predict(InputArray src) const = 0"><strong>FaceRecognizer::predict (C++ function)</strong></a>, <a href="modules/contrib/doc/facerec/facerec_api.html#void FaceRecognizer::predict(InputArray src, int & label, double & confidence) const = 0"><strong>[1]</strong></a>
  </dt>

      
  <dt><a href="modules/contrib/doc/facerec/facerec_api.html#void FaceRecognizer::save(FileStorage& fs) const"><strong>FaceRecognizer::save (C++ function)</strong></a>, <a href="modules/contrib/doc/facerec/facerec_api.html#void FaceRecognizer::save(const string& filename) const"><strong>[1]</strong></a>
  </dt>

      
  <dt><a href="modules/contrib/doc/facerec/facerec_api.html#void FaceRecognizer::train(InputArrayOfArrays src, InputArray labels) = 0"><strong>FaceRecognizer::train (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/contrib/doc/facerec/facerec_api.html#void FaceRecognizer::update(InputArrayOfArrays src, InputArray labels)"><strong>FaceRecognizer::update (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/features2d/doc/feature_detection_and_description.html#void FAST(InputArray image, vector<KeyPoint>& keypoints, int threshold, bool nonmaxSuppression)"><strong>FAST (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/features2d/doc/common_interfaces_of_feature_detectors.html#FastAdjuster : public AdjusterAdapter"><strong>FastAdjuster (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/utility_and_system_functions_and_macros.html#float cvFastArctan(float y, float x)"><strong>FastArctan (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/utility_and_system_functions_and_macros.html#cv.FastArctan"><strong>FastArctan() (Python function in cv)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/utility_and_system_functions_and_macros.html#float fastAtan2(float y, float x)"><strong>fastAtan2 (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/utility_and_system_functions_and_macros.html#cv2.fastAtan2"><strong>fastAtan2() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/features2d/doc/common_interfaces_of_feature_detectors.html#FastFeatureDetector : public FeatureDetector"><strong>FastFeatureDetector (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/utility_and_system_functions_and_macros.html#void fastFree(void* ptr)"><strong>fastFree (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/utility_and_system_functions_and_macros.html#void* fastMalloc(size_t bufSize)"><strong>fastMalloc (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/photo/doc/denoising.html#void fastNlMeansDenoising(InputArray src, OutputArray dst, float h, int templateWindowSize, int searchWindowSize)"><strong>fastNlMeansDenoising (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/photo/doc/denoising.html#void fastNlMeansDenoisingColored(InputArray src, OutputArray dst, float h, float hColor, int templateWindowSize, int searchWindowSize)"><strong>fastNlMeansDenoisingColored (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/photo/doc/denoising.html#void fastNlMeansDenoisingColoredMulti(InputArrayOfArrays srcImgs, OutputArray dst, int imgToDenoiseIndex, int temporalWindowSize, float h, float hColor, int templateWindowSize, int searchWindowSize)"><strong>fastNlMeansDenoisingColoredMulti (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/photo/doc/denoising.html#void fastNlMeansDenoisingMulti(InputArrayOfArrays srcImgs, OutputArray dst, int imgToDenoiseIndex, int temporalWindowSize, float h, int templateWindowSize, int searchWindowSize)"><strong>fastNlMeansDenoisingMulti (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/features2d/doc/feature_detection_and_description.html#void FASTX(InputArray image, vector<KeyPoint>& keypoints, int threshold, bool nonmaxSuppression, int type)"><strong>FASTX (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/features2d/doc/common_interfaces_of_feature_detectors.html#FeatureDetector : public Algorithm"><strong>FeatureDetector (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/features2d/doc/common_interfaces_of_feature_detectors.html#Ptr<FeatureDetector> FeatureDetector::create(const string& detectorType)"><strong>FeatureDetector::create (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/features2d/doc/common_interfaces_of_feature_detectors.html#void FeatureDetector::detect(const Mat& image, vector<KeyPoint>& keypoints, const Mat& mask) const"><strong>FeatureDetector::detect (C++ function)</strong></a>, <a href="modules/features2d/doc/common_interfaces_of_feature_detectors.html#void FeatureDetector::detect(const vector<Mat>& images, vector<vector<KeyPoint> >& keypoints, const vector<Mat>& masks) const"><strong>[1]</strong></a>
  </dt>

      
  <dt><a href="modules/objdetect/doc/cascade_classification.html#FeatureEvaluator"><strong>FeatureEvaluator (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/objdetect/doc/cascade_classification.html#int FeatureEvaluator::calcCat(int featureIdx) const"><strong>FeatureEvaluator::calcCat (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/objdetect/doc/cascade_classification.html#double FeatureEvaluator::calcOrd(int featureIdx) const"><strong>FeatureEvaluator::calcOrd (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/objdetect/doc/cascade_classification.html#Ptr<FeatureEvaluator> FeatureEvaluator::clone() const"><strong>FeatureEvaluator::clone (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/objdetect/doc/cascade_classification.html#Ptr<FeatureEvaluator> FeatureEvaluator::create(int type)"><strong>FeatureEvaluator::create (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/objdetect/doc/cascade_classification.html#int FeatureEvaluator::getFeatureType() const"><strong>FeatureEvaluator::getFeatureType (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/objdetect/doc/cascade_classification.html#bool FeatureEvaluator::read(const FileNode& node)"><strong>FeatureEvaluator::read (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/objdetect/doc/cascade_classification.html#bool FeatureEvaluator::setImage(const Mat& img, Size origWinSize)"><strong>FeatureEvaluator::setImage (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/objdetect/doc/cascade_classification.html#bool FeatureEvaluator::setWindow(Point p)"><strong>FeatureEvaluator::setWindow (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/legacy/doc/common_interfaces_of_generic_descriptor_matchers.html#FernClassifier"><strong>FernClassifier (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/legacy/doc/common_interfaces_of_generic_descriptor_matchers.html#FernDescriptorMatcher : public GenericDescriptorMatcher"><strong>FernDescriptorMatcher (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/xml_yaml_persistence.html#FileNode"><strong>FileNode (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/xml_yaml_persistence.html#FileNodeIterator FileNode::begin() const"><strong>FileNode::begin (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/xml_yaml_persistence.html#bool FileNode::empty() const"><strong>FileNode::empty (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/xml_yaml_persistence.html#FileNodeIterator FileNode::end() const"><strong>FileNode::end (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/xml_yaml_persistence.html#FileNode::FileNode()"><strong>FileNode::FileNode (C++ function)</strong></a>, <a href="modules/core/doc/xml_yaml_persistence.html#FileNode::FileNode(const CvFileStorage* fs, const CvFileNode* node)"><strong>[1]</strong></a>, <a href="modules/core/doc/xml_yaml_persistence.html#FileNode::FileNode(const FileNode& node)"><strong>[2]</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/xml_yaml_persistence.html#bool FileNode::isInt() const"><strong>FileNode::isInt (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/xml_yaml_persistence.html#bool FileNode::isMap() const"><strong>FileNode::isMap (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/xml_yaml_persistence.html#bool FileNode::isNamed() const"><strong>FileNode::isNamed (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/xml_yaml_persistence.html#bool FileNode::isNone() const"><strong>FileNode::isNone (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/xml_yaml_persistence.html#bool FileNode::isReal() const"><strong>FileNode::isReal (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/xml_yaml_persistence.html#bool FileNode::isSeq() const"><strong>FileNode::isSeq (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/xml_yaml_persistence.html#bool FileNode::isString() const"><strong>FileNode::isString (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/xml_yaml_persistence.html#string FileNode::name() const"><strong>FileNode::name (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/xml_yaml_persistence.html#FileNode::operator double() const"><strong>FileNode::operator double (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/xml_yaml_persistence.html#FileNode::operator float() const"><strong>FileNode::operator float (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/xml_yaml_persistence.html#FileNode::operator int() const"><strong>FileNode::operator int (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/xml_yaml_persistence.html#FileNode::operator string() const"><strong>FileNode::operator string (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/xml_yaml_persistence.html#CvFileNode* FileNode::operator *()"><strong>FileNode::operator* (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/xml_yaml_persistence.html#FileNode FileNode::operator[](const char* nodename) const"><strong>FileNode::operator[] (C++ function)</strong></a>, <a href="modules/core/doc/xml_yaml_persistence.html#FileNode FileNode::operator[](const string& nodename) const"><strong>[1]</strong></a>, <a href="modules/core/doc/xml_yaml_persistence.html#FileNode FileNode::operator[](int i) const"><strong>[2]</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/xml_yaml_persistence.html#void* FileNode::readObj() const"><strong>FileNode::readObj (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/xml_yaml_persistence.html#void FileNode::readRaw(const string& fmt, uchar* vec, size_t len) const"><strong>FileNode::readRaw (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/xml_yaml_persistence.html#size_t FileNode::size() const"><strong>FileNode::size (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/xml_yaml_persistence.html#int FileNode::type() const"><strong>FileNode::type (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/xml_yaml_persistence.html#FileNodeIterator"><strong>FileNodeIterator (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/xml_yaml_persistence.html#FileNodeIterator::FileNodeIterator()"><strong>FileNodeIterator::FileNodeIterator (C++ function)</strong></a>, <a href="modules/core/doc/xml_yaml_persistence.html#FileNodeIterator::FileNodeIterator(const CvFileStorage* fs, const CvFileNode* node, size_t ofs)"><strong>[1]</strong></a>, <a href="modules/core/doc/xml_yaml_persistence.html#FileNodeIterator::FileNodeIterator(const FileNodeIterator& it)"><strong>[2]</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/xml_yaml_persistence.html#FileNode FileNodeIterator::operator *() const"><strong>FileNodeIterator::operator* (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/xml_yaml_persistence.html#FileNodeIterator FileNodeIterator::operator ++ (int)"><strong>FileNodeIterator::operator++ (C++ function)</strong></a>, <a href="modules/core/doc/xml_yaml_persistence.html#FileNodeIterator& FileNodeIterator::operator ++ ()"><strong>[1]</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/xml_yaml_persistence.html#FileNodeIterator& FileNodeIterator::operator +=(int ofs)"><strong>FileNodeIterator::operator+= (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/xml_yaml_persistence.html#FileNodeIterator FileNodeIterator::operator -- (int)"><strong>FileNodeIterator::operator-- (C++ function)</strong></a>, <a href="modules/core/doc/xml_yaml_persistence.html#FileNodeIterator& FileNodeIterator::operator -- ()"><strong>[1]</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/xml_yaml_persistence.html#FileNodeIterator& FileNodeIterator::operator -=(int ofs)"><strong>FileNodeIterator::operator-= (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/xml_yaml_persistence.html#FileNode FileNodeIterator::operator ->() const"><strong>FileNodeIterator::operator-&gt; (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/xml_yaml_persistence.html#FileNodeIterator& FileNodeIterator::readRaw(const string& fmt, uchar* vec, size_t maxCount=(size_t)INT_MAX)"><strong>FileNodeIterator::readRaw (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/xml_yaml_persistence.html#FileStorage"><strong>FileStorage (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/xml_yaml_persistence.html#FileStorage::FileStorage()"><strong>FileStorage::FileStorage (C++ function)</strong></a>, <a href="modules/core/doc/xml_yaml_persistence.html#FileStorage::FileStorage(const string& source, int flags, const string& encoding)"><strong>[1]</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/xml_yaml_persistence.html#static string FileStorage::getDefaultObjectName(const string& filename)"><strong>FileStorage::getDefaultObjectName (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/xml_yaml_persistence.html#FileNode FileStorage::getFirstTopLevelNode() const"><strong>FileStorage::getFirstTopLevelNode (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/xml_yaml_persistence.html#bool FileStorage::isOpened() const"><strong>FileStorage::isOpened (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/xml_yaml_persistence.html#bool FileStorage::open(const string& filename, int flags, const string& encoding)"><strong>FileStorage::open (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/xml_yaml_persistence.html#CvFileStorage* FileStorage::operator *()"><strong>FileStorage::operator* (C++ function)</strong></a>, <a href="modules/core/doc/xml_yaml_persistence.html#const CvFileStorage* FileStorage::operator *() const"><strong>[1]</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/xml_yaml_persistence.html#FileNode FileStorage::operator[](const char* nodename) const"><strong>FileStorage::operator[] (C++ function)</strong></a>, <a href="modules/core/doc/xml_yaml_persistence.html#FileNode FileStorage::operator[](const string& nodename) const"><strong>[1]</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/xml_yaml_persistence.html#void FileStorage::release()"><strong>FileStorage::release (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/xml_yaml_persistence.html#string FileStorage::releaseAndGetString()"><strong>FileStorage::releaseAndGetString (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/xml_yaml_persistence.html#FileNode FileStorage::root(int streamidx) const"><strong>FileStorage::root (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/xml_yaml_persistence.html#void FileStorage::writeObj(const string& name, const void* obj)"><strong>FileStorage::writeObj (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/xml_yaml_persistence.html#void FileStorage::writeRaw(const string& fmt, const uchar* vec, size_t len)"><strong>FileStorage::writeRaw (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/drawing_functions.html#void cvFillConvexPoly(CvArr* img, const CvPoint* pts, int npts, CvScalar color, int line_type, int shift)"><strong>FillConvexPoly (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/drawing_functions.html#void fillConvexPoly(Mat& img, const Point* pts, int npts, const Scalar& color, int lineType, int shift)"><strong>fillConvexPoly (C++ function)</strong></a>
  </dt>

  </dl></td>
  <td style="width: 33%" valign="top"><dl>
      
  <dt><a href="modules/core/doc/drawing_functions.html#cv.FillConvexPoly"><strong>FillConvexPoly() (Python function in cv)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/drawing_functions.html#cv2.fillConvexPoly"><strong>fillConvexPoly() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/drawing_functions.html#void cvFillPoly(CvArr* img, CvPoint** pts, const int* npts, int contours, CvScalar color, int line_type, int shift)"><strong>FillPoly (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/drawing_functions.html#void fillPoly(Mat& img, const Point** pts, const int* npts, int ncontours, const Scalar& color, int lineType, int shift, Point offset)"><strong>fillPoly (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/drawing_functions.html#cv.FillPoly"><strong>FillPoly() (Python function in cv)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/drawing_functions.html#cv2.fillPoly"><strong>fillPoly() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/filtering.html#void cvFilter2D(const CvArr* src, CvArr* dst, const CvMat* kernel, CvPoint anchor)"><strong>Filter2D (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/filtering.html#void filter2D(InputArray src, OutputArray dst, int ddepth, InputArray kernel, Point anchor, double delta, int borderType)"><strong>filter2D (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/filtering.html#cv.Filter2D"><strong>Filter2D() (Python function in cv)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/filtering.html#cv2.filter2D"><strong>filter2D() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/filtering.html#FilterEngine"><strong>FilterEngine (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/calib3d/doc/camera_calibration_and_3d_reconstruction.html#void filterSpeckles(InputOutputArray img, double newVal, int maxSpeckleSize, double maxDiff, InputOutputArray buf)"><strong>filterSpeckles (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/calib3d/doc/camera_calibration_and_3d_reconstruction.html#cv2.filterSpeckles"><strong>filterSpeckles() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/viz/doc/widget.html#void finalize()"><strong>finalize (C++ function)</strong></a>, <a href="modules/viz/doc/widget.html#void finalize()"><strong>[1]</strong></a>
  </dt>

      
  <dt><a href="modules/calib3d/doc/camera_calibration_and_3d_reconstruction.html#int cvFindChessboardCorners(const void* image, CvSize pattern_size, CvPoint2D32f* corners, int* corner_count, int flags)"><strong>FindChessboardCorners (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/calib3d/doc/camera_calibration_and_3d_reconstruction.html#bool findChessboardCorners(InputArray image, Size patternSize, OutputArray corners, int flags)"><strong>findChessboardCorners (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/calib3d/doc/camera_calibration_and_3d_reconstruction.html#cv.FindChessboardCorners"><strong>FindChessboardCorners() (Python function in cv)</strong></a>
  </dt>

      
  <dt><a href="modules/calib3d/doc/camera_calibration_and_3d_reconstruction.html#cv2.findChessboardCorners"><strong>findChessboardCorners() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/calib3d/doc/camera_calibration_and_3d_reconstruction.html#bool findCirclesGrid(InputArray image, Size patternSize, OutputArray centers, int flags, const Ptr<FeatureDetector> &blobDetector)"><strong>findCirclesGrid (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/calib3d/doc/camera_calibration_and_3d_reconstruction.html#cv2.findCirclesGridDefault"><strong>findCirclesGridDefault() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/structural_analysis_and_shape_descriptors.html#int cvFindContours(CvArr* image, CvMemStorage* storage, CvSeq** first_contour, int header_size, int mode, int method, CvPoint offset)"><strong>FindContours (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/structural_analysis_and_shape_descriptors.html#void findContours(InputOutputArray image, OutputArrayOfArrays contours, OutputArray hierarchy, int mode, int method, Point offset)"><strong>findContours (C++ function)</strong></a>, <a href="modules/imgproc/doc/structural_analysis_and_shape_descriptors.html#void findContours(InputOutputArray image, OutputArrayOfArrays contours, int mode, int method, Point offset)"><strong>[1]</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/structural_analysis_and_shape_descriptors.html#cv.FindContours"><strong>FindContours() (Python function in cv)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/structural_analysis_and_shape_descriptors.html#cv2.findContours"><strong>findContours() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/feature_detection.html#void cvFindCornerSubPix(const CvArr* image, CvPoint2D32f* corners, int count, CvSize win, CvSize zero_zone, CvTermCriteria criteria)"><strong>FindCornerSubPix (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/feature_detection.html#cv.FindCornerSubPix"><strong>FindCornerSubPix() (Python function in cv)</strong></a>
  </dt>

      
  <dt><a href="modules/calib3d/doc/camera_calibration_and_3d_reconstruction.html#void cvFindExtrinsicCameraParams2(const CvMat* object_points, const CvMat* image_points, const CvMat* camera_matrix, const CvMat* distortion_coeffs, CvMat* rotation_vector, CvMat* translation_vector, int use_extrinsic_guess)"><strong>FindExtrinsicCameraParams2 (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/calib3d/doc/camera_calibration_and_3d_reconstruction.html#cv.FindExtrinsicCameraParams2"><strong>FindExtrinsicCameraParams2() (Python function in cv)</strong></a>
  </dt>

      
  <dt><a href="modules/calib3d/doc/camera_calibration_and_3d_reconstruction.html#int cvFindFundamentalMat(const CvMat* points1, const CvMat* points2, CvMat* fundamental_matrix, int method, double param1, double param2, CvMat* status)"><strong>FindFundamentalMat (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/calib3d/doc/camera_calibration_and_3d_reconstruction.html#Mat findFundamentalMat(InputArray points1, InputArray points2, int method, double param1, double param2, OutputArray mask)"><strong>findFundamentalMat (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/calib3d/doc/camera_calibration_and_3d_reconstruction.html#cv.FindFundamentalMat"><strong>FindFundamentalMat() (Python function in cv)</strong></a>
  </dt>

      
  <dt><a href="modules/calib3d/doc/camera_calibration_and_3d_reconstruction.html#cv2.findFundamentalMat"><strong>findFundamentalMat() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/dynamic_structures.html#CvGraphEdge* cvFindGraphEdge(const CvGraph* graph, int start_idx, int end_idx)"><strong>FindGraphEdge (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/dynamic_structures.html#CvGraphEdge* cvFindGraphEdgeByPtr(const CvGraph* graph, const CvGraphVtx* start_vtx, const CvGraphVtx* end_vtx)"><strong>FindGraphEdgeByPtr (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/calib3d/doc/camera_calibration_and_3d_reconstruction.html#int cvFindHomography(const CvMat* src_points, const CvMat* dst_points, CvMat* homography, int method, double ransacReprojThreshold, CvMat* mask)"><strong>FindHomography (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/calib3d/doc/camera_calibration_and_3d_reconstruction.html#Mat findHomography(InputArray srcPoints, InputArray dstPoints, int method, double ransacReprojThreshold, OutputArray mask)"><strong>findHomography (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/calib3d/doc/camera_calibration_and_3d_reconstruction.html#cv.FindHomography"><strong>FindHomography() (Python function in cv)</strong></a>
  </dt>

      
  <dt><a href="modules/calib3d/doc/camera_calibration_and_3d_reconstruction.html#cv2.findHomography"><strong>findHomography() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/legacy/doc/planar_subdivisions.html#CvSubdiv2DPoint* cvFindNearestPoint2D(CvSubdiv2D* subdiv, CvPoint2D32f pt)"><strong>FindNearestPoint2D (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/legacy/doc/planar_subdivisions.html#cv.FindNearestPoint2D"><strong>FindNearestPoint2D() (Python function in cv)</strong></a>
  </dt>

      
  <dt><a href="modules/calib3d/doc/camera_calibration_and_3d_reconstruction.html#void cvFindStereoCorrespondenceBM(const CvArr* left, const CvArr* right, CvArr* disparity, CvStereoBMState* state)"><strong>FindStereoCorrespondenceBM (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/calib3d/doc/camera_calibration_and_3d_reconstruction.html#cv.FindStereoCorrespondenceBM"><strong>FindStereoCorrespondenceBM() (Python function in cv)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_xml_yaml_persistence.html#CvTypeInfo* cvFindType(const char* type_name)"><strong>FindType (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_xml_yaml_persistence.html#CvTypeInfo* cvFirstType(void)"><strong>FirstType (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/calib3d/doc/camera_calibration_and_3d_reconstruction.html#double fisheye::calibrate(InputArrayOfArrays objectPoints, InputArrayOfArrays imagePoints, const Size& image_size, InputOutputArray K, InputOutputArray D, OutputArrayOfArrays rvecs, OutputArrayOfArrays tvecs, int flags , TermCriteria criteria)"><strong>fisheye::calibrate (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/calib3d/doc/camera_calibration_and_3d_reconstruction.html#void fisheye::distortPoints(InputArray undistorted, OutputArray distorted, InputArray K, InputArray D, double alpha)"><strong>fisheye::distortPoints (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/calib3d/doc/camera_calibration_and_3d_reconstruction.html#void fisheye::estimateNewCameraMatrixForUndistortRectify(InputArray K, InputArray D, const Size &image_size, InputArray R, OutputArray P, double balance , const Size& new_size , double fov_scale)"><strong>fisheye::estimateNewCameraMatrixForUndistortRectify (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/calib3d/doc/camera_calibration_and_3d_reconstruction.html#void fisheye::initUndistortRectifyMap(InputArray K, InputArray D, InputArray R, InputArray P, const cv::Size& size, int m1type, OutputArray map1, OutputArray map2)"><strong>fisheye::initUndistortRectifyMap (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/calib3d/doc/camera_calibration_and_3d_reconstruction.html#void fisheye::projectPoints(InputArray objectPoints, OutputArray imagePoints, InputArray rvec, InputArray tvec, InputArray K, InputArray D, double alpha , OutputArray jacobian)"><strong>fisheye::projectPoints (C++ function)</strong></a>, <a href="modules/calib3d/doc/camera_calibration_and_3d_reconstruction.html#void fisheye::projectPoints(InputArray objectPoints, OutputArray imagePoints, const Affine3d& affine, InputArray K, InputArray D, double alpha , OutputArray jacobian)"><strong>[1]</strong></a>
  </dt>

      
  <dt><a href="modules/calib3d/doc/camera_calibration_and_3d_reconstruction.html#double fisheye::stereoCalibrate(InputArrayOfArrays objectPoints, InputArrayOfArrays imagePoints1, InputArrayOfArrays imagePoints2, InputOutputArray K1, InputOutputArray D1, InputOutputArray K2, InputOutputArray D2, Size imageSize, OutputArray R, OutputArray T, int flags , TermCriteria criteria)"><strong>fisheye::stereoCalibrate (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/calib3d/doc/camera_calibration_and_3d_reconstruction.html#void fisheye::stereoRectify(InputArray K1, InputArray D1, InputArray K2, InputArray D2, const Size &imageSize, InputArray R, InputArray tvec, OutputArray R1, OutputArray R2, OutputArray P1, OutputArray P2, OutputArray Q, int flags, const Size &newImageSize , double balance , double fov_scale)"><strong>fisheye::stereoRectify (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/calib3d/doc/camera_calibration_and_3d_reconstruction.html#void fisheye::undistortImage(InputArray distorted, OutputArray undistorted, InputArray K, InputArray D, InputArray Knew , const Size& new_size)"><strong>fisheye::undistortImage (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/calib3d/doc/camera_calibration_and_3d_reconstruction.html#void fisheye::undistortPoints(InputArray distorted, OutputArray undistorted, InputArray K, InputArray D, InputArray R , InputArray P)"><strong>fisheye::undistortPoints (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/structural_analysis_and_shape_descriptors.html#RotatedRect fitEllipse(InputArray points)"><strong>fitEllipse (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/structural_analysis_and_shape_descriptors.html#cv2.fitEllipse"><strong>fitEllipse() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/structural_analysis_and_shape_descriptors.html#CvBox2D cvFitEllipse2(const CvArr* points)"><strong>FitEllipse2 (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/structural_analysis_and_shape_descriptors.html#cv.FitEllipse2"><strong>FitEllipse2() (Python function in cv)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/structural_analysis_and_shape_descriptors.html#void cvFitLine(const CvArr* points, int dist_type, double param, double reps, double aeps, float* line)"><strong>FitLine (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/structural_analysis_and_shape_descriptors.html#void fitLine(InputArray points, OutputArray line, int distType, double param, double reps, double aeps)"><strong>fitLine (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/structural_analysis_and_shape_descriptors.html#cv.FitLine"><strong>FitLine() (Python function in cv)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/structural_analysis_and_shape_descriptors.html#cv2.fitLine"><strong>fitLine() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/flann/doc/flann_clustering.html#template<typename Distance> int flann::hierarchicalClustering(const Mat& features, Mat& centers, const cvflann::KMeansIndexParams& params, Distance d)"><strong>flann::hierarchicalClustering (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/flann/doc/flann_fast_approximate_nearest_neighbor_search.html#flann::Index_"><strong>flann::Index_ (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/flann/doc/flann_fast_approximate_nearest_neighbor_search.html#const IndexParams* flann::Index_<T>::getIndexParameters()"><strong>flann::Index_&lt;T&gt;::getIndexParameters (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/flann/doc/flann_fast_approximate_nearest_neighbor_search.html#flann::Index_<T>::Index_(const Mat& features, const IndexParams& params)"><strong>flann::Index_&lt;T&gt;::Index_ (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/flann/doc/flann_fast_approximate_nearest_neighbor_search.html#void flann::Index_<T>::knnSearch(const Mat& queries, Mat& indices, Mat& dists, int knn, const SearchParams& params)"><strong>flann::Index_&lt;T&gt;::knnSearch (C++ function)</strong></a>, <a href="modules/flann/doc/flann_fast_approximate_nearest_neighbor_search.html#void flann::Index_<T>::knnSearch(const vector<T>& query, vector<int>& indices, vector<float>& dists, int knn, const SearchParams& params)"><strong>[1]</strong></a>
  </dt>

      
  <dt><a href="modules/flann/doc/flann_fast_approximate_nearest_neighbor_search.html#int flann::Index_<T>::radiusSearch(const Mat& query, Mat& indices, Mat& dists, float radius, const SearchParams& params)"><strong>flann::Index_&lt;T&gt;::radiusSearch (C++ function)</strong></a>, <a href="modules/flann/doc/flann_fast_approximate_nearest_neighbor_search.html#int flann::Index_<T>::radiusSearch(const vector<T>& query, vector<int>& indices, vector<float>& dists, float radius, const SearchParams& params)"><strong>[1]</strong></a>
  </dt>

      
  <dt><a href="modules/flann/doc/flann_fast_approximate_nearest_neighbor_search.html#void flann::Index_<T>::save(std::string filename)"><strong>flann::Index_&lt;T&gt;::save (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/features2d/doc/common_interfaces_of_descriptor_matchers.html#FlannBasedMatcher : public DescriptorMatcher"><strong>FlannBasedMatcher (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#void cvFlip(const CvArr* src, CvArr* dst, int flip_mode)"><strong>Flip (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#void flip(InputArray src, OutputArray dst, int flipCode)"><strong>flip (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#cv.Flip"><strong>Flip() (Python function in cv)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#cv2.flip"><strong>flip() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/miscellaneous_transformations.html#void cvFloodFill(CvArr* image, CvPoint seed_point, CvScalar new_val, CvScalar lo_diff, CvScalar up_diff, CvConnectedComp* comp, int flags, CvArr* mask)"><strong>FloodFill (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/miscellaneous_transformations.html#int floodFill(InputOutputArray image, InputOutputArray mask, Point seedPoint, Scalar newVal, Rect* rect, Scalar loDiff, Scalar upDiff, int flags)"><strong>floodFill (C++ function)</strong></a>, <a href="modules/imgproc/doc/miscellaneous_transformations.html#int floodFill(InputOutputArray image, Point seedPoint, Scalar newVal, Rect* rect, Scalar loDiff, Scalar upDiff, int flags)"><strong>[1]</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/miscellaneous_transformations.html#cv.FloodFill"><strong>FloodFill() (Python function in cv)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/miscellaneous_transformations.html#cv2.floodFill"><strong>floodFill() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/utility_and_system_functions_and_macros.html#int cvFloor(double value)"><strong>Floor (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/utility_and_system_functions_and_macros.html#cv.Floor"><strong>Floor() (Python function in cv)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/dynamic_structures.html#void cvFlushSeqWriter(CvSeqWriter* writer)"><strong>FlushSeqWriter (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/highgui/doc/qt_new_functions.html#CvFont cvFontQt(const char* nameFont, int pointSize, CvScalar color, int weight, int style, int spacing)"><strong>FontQt (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/highgui/doc/qt_new_functions.html#CvFont fontQt(const string& nameFont, int pointSize , Scalar color , int weight , int style , int spacing)"><strong>fontQt (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/utility_and_system_functions_and_macros.html#string format(const char* fmt, ...)"><strong>format (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/features2d/doc/feature_detection_and_description.html#FREAK : public DescriptorExtractor"><strong>FREAK (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/features2d/doc/feature_detection_and_description.html#FREAK::FREAK(bool orientationNormalized, bool scaleNormalized, float patternScale, int nOctaves, const vector<int>& selectedPairs)"><strong>FREAK::FREAK (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/features2d/doc/feature_detection_and_description.html#vector<int> FREAK::selectPairs(const vector<Mat>& images, vector<vector<KeyPoint> >& keypoints, const double corrThresh , bool verbose)"><strong>FREAK::selectPairs (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/utility_and_system_functions_and_macros.html#void cvFree(void** pptr)"><strong>Free (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_basic_structures.html#cv.fromarray"><strong>fromarray() (Python function in cv)</strong></a>
  </dt>

      
  <dt><a href="modules/viz/doc/widget.html#static Widget fromPlyFile(const String &file_name)"><strong>fromPlyFile (C++ function)</strong></a>
  </dt>

  </dl></td>
</tr></table>

<h2 id="G">G</h2>
<table style="width: 100%" class="indextable genindextable"><tr>
  <td style="width: 33%" valign="top"><dl>
      
  <dt><a href="modules/imgproc/doc/filtering.html#void GaussianBlur(InputArray src, OutputArray dst, Size ksize, double sigmaX, double sigmaY, int borderType)"><strong>GaussianBlur (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/filtering.html#cv2.GaussianBlur"><strong>GaussianBlur() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/ml/doc/gradient_boosted_trees.html#cv2.GBTrees"><strong>GBTrees() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/ml/doc/gradient_boosted_trees.html#cv2.GBTrees.clear"><strong>GBTrees.clear() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/ml/doc/gradient_boosted_trees.html#cv2.GBTrees.predict"><strong>GBTrees.predict() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/ml/doc/gradient_boosted_trees.html#cv2.GBTrees.train"><strong>GBTrees.train() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#void cvGEMM(const CvArr* src1, const CvArr* src2, double alpha, const CvArr* src3, double beta, CvArr* dst, int tABC)"><strong>GEMM (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#void gemm(InputArray src1, InputArray src2, double alpha, InputArray src3, double beta, OutputArray dst, int flags)"><strong>gemm (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#cv.GEMM"><strong>GEMM() (Python function in cv)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#cv2.gemm"><strong>gemm() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/features2d/doc/common_interfaces_of_generic_descriptor_matchers.html#GenericDescriptorMatcher"><strong>GenericDescriptorMatcher (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/features2d/doc/common_interfaces_of_generic_descriptor_matchers.html#void GenericDescriptorMatcher::add(const vector<Mat>& images, vector<vector<KeyPoint> >& keypoints)"><strong>GenericDescriptorMatcher::add (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/features2d/doc/common_interfaces_of_generic_descriptor_matchers.html#void GenericDescriptorMatcher::classify(const Mat& queryImage, vector<KeyPoint>& queryKeypoints)"><strong>GenericDescriptorMatcher::classify (C++ function)</strong></a>, <a href="modules/features2d/doc/common_interfaces_of_generic_descriptor_matchers.html#void GenericDescriptorMatcher::classify(const Mat& queryImage, vector<KeyPoint>& queryKeypoints, const Mat& trainImage, vector<KeyPoint>& trainKeypoints) const"><strong>[1]</strong></a>
  </dt>

      
  <dt><a href="modules/features2d/doc/common_interfaces_of_generic_descriptor_matchers.html#void GenericDescriptorMatcher::clear()"><strong>GenericDescriptorMatcher::clear (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/features2d/doc/common_interfaces_of_generic_descriptor_matchers.html#Ptr<GenericDescriptorMatcher> GenericDescriptorMatcher::clone(bool emptyTrainData) const"><strong>GenericDescriptorMatcher::clone (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/features2d/doc/common_interfaces_of_generic_descriptor_matchers.html#const vector<Mat>& GenericDescriptorMatcher::getTrainImages() const"><strong>GenericDescriptorMatcher::getTrainImages (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/features2d/doc/common_interfaces_of_generic_descriptor_matchers.html#const vector<vector<KeyPoint> >& GenericDescriptorMatcher::getTrainKeypoints() const"><strong>GenericDescriptorMatcher::getTrainKeypoints (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/features2d/doc/common_interfaces_of_generic_descriptor_matchers.html#bool GenericDescriptorMatcher::isMaskSupported()"><strong>GenericDescriptorMatcher::isMaskSupported (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/features2d/doc/common_interfaces_of_generic_descriptor_matchers.html#void GenericDescriptorMatcher::knnMatch(const Mat& queryImage, vector<KeyPoint>& queryKeypoints, const Mat& trainImage, vector<KeyPoint>& trainKeypoints, vector<vector<DMatch> >& matches, int k, const Mat& mask, bool compactResult) const"><strong>GenericDescriptorMatcher::knnMatch (C++ function)</strong></a>, <a href="modules/features2d/doc/common_interfaces_of_generic_descriptor_matchers.html#void GenericDescriptorMatcher::knnMatch(const Mat& queryImage, vector<KeyPoint>& queryKeypoints, vector<vector<DMatch> >& matches, int k, const vector<Mat>& masks, bool compactResult)"><strong>[1]</strong></a>
  </dt>

      
  <dt><a href="modules/features2d/doc/common_interfaces_of_generic_descriptor_matchers.html#void GenericDescriptorMatcher::match(const Mat& queryImage, vector<KeyPoint>& queryKeypoints, const Mat& trainImage, vector<KeyPoint>& trainKeypoints, vector<DMatch>& matches, const Mat& mask) const"><strong>GenericDescriptorMatcher::match (C++ function)</strong></a>, <a href="modules/features2d/doc/common_interfaces_of_generic_descriptor_matchers.html#void GenericDescriptorMatcher::match(const Mat& queryImage, vector<KeyPoint>& queryKeypoints, vector<DMatch>& matches, const vector<Mat>& masks)"><strong>[1]</strong></a>
  </dt>

      
  <dt><a href="modules/features2d/doc/common_interfaces_of_generic_descriptor_matchers.html#void GenericDescriptorMatcher::radiusMatch(const Mat& queryImage, vector<KeyPoint>& queryKeypoints, const Mat& trainImage, vector<KeyPoint>& trainKeypoints, vector<vector<DMatch> >& matches, float maxDistance, const Mat& mask, bool compactResult) const"><strong>GenericDescriptorMatcher::radiusMatch (C++ function)</strong></a>, <a href="modules/features2d/doc/common_interfaces_of_generic_descriptor_matchers.html#void GenericDescriptorMatcher::radiusMatch(const Mat& queryImage, vector<KeyPoint>& queryKeypoints, vector<vector<DMatch> >& matches, float maxDistance, const vector<Mat>& masks, bool compactResult)"><strong>[1]</strong></a>
  </dt>

      
  <dt><a href="modules/features2d/doc/common_interfaces_of_generic_descriptor_matchers.html#void GenericDescriptorMatcher::read(const FileNode& fn)"><strong>GenericDescriptorMatcher::read (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/features2d/doc/common_interfaces_of_generic_descriptor_matchers.html#void GenericDescriptorMatcher::train()"><strong>GenericDescriptorMatcher::train (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/features2d/doc/common_interfaces_of_generic_descriptor_matchers.html#void GenericDescriptorMatcher::write(FileStorage& fs) const"><strong>GenericDescriptorMatcher::write (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_basic_structures.html#CvScalar cvGet1D(const CvArr* arr, int idx0)"><strong>Get1D (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_basic_structures.html#cv.Get1D"><strong>Get1D() (Python function in cv)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_basic_structures.html#CvScalar cvGet2D(const CvArr* arr, int idx0, int idx1)"><strong>Get2D (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_basic_structures.html#cv.Get2D"><strong>Get2D() (Python function in cv)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_basic_structures.html#CvScalar cvGet3D(const CvArr* arr, int idx0, int idx1, int idx2)"><strong>Get3D (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_basic_structures.html#cv.Get3D"><strong>Get3D() (Python function in cv)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/geometric_transformations.html#CvMat* cvGetAffineTransform(const CvPoint2D32f * src, const CvPoint2D32f * dst, CvMat * map_matrix)"><strong>GetAffineTransform (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/geometric_transformations.html#Mat getAffineTransform(InputArray src, InputArray dst)"><strong>getAffineTransform (C++ function)</strong></a>, <a href="modules/imgproc/doc/geometric_transformations.html#Mat getAffineTransform(const Point2f src[], const Point2f dst[])"><strong>[1]</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/geometric_transformations.html#cv.GetAffineTransform"><strong>GetAffineTransform() (Python function in cv)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/geometric_transformations.html#cv2.getAffineTransform"><strong>getAffineTransform() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/utility_and_system_functions_and_macros.html#const std::string& getBuildInformation()"><strong>getBuildInformation (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/viz/doc/viz3d.html#Camera getCamera() const"><strong>getCamera (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/highgui/doc/reading_and_writing_images_and_video.html#double cvGetCaptureProperty(CvCapture* capture, int property_id)"><strong>GetCaptureProperty (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/highgui/doc/reading_and_writing_images_and_video.html#cv.GetCaptureProperty"><strong>GetCaptureProperty() (Python function in cv)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_basic_structures.html#CvMat* cvGetCol(const CvArr* arr, CvMat* submat, int col)"><strong>GetCol (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_basic_structures.html#cv.GetCol"><strong>GetCol() (Python function in cv)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_basic_structures.html#CvMat* cvGetCols(const CvArr* arr, CvMat* submat, int start_col, int end_col)"><strong>GetCols (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_basic_structures.html#cv.GetCols"><strong>GetCols() (Python function in cv)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/filtering.html#Ptr<BaseColumnFilter> getColumnSumFilter(int sumType, int dstType, int ksize, int anchor, double scale)"><strong>getColumnSumFilter (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#ConvertData getConvertElem(int fromType, int toType)"><strong>getConvertElem (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#ConvertScaleData getConvertScaleElem(int fromType, int toType)"><strong>getConvertScaleElem (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/utility_and_system_functions_and_macros.html#int64 getCPUTickCount()"><strong>getCPUTickCount (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/utility_and_system_functions_and_macros.html#cv2.getCPUTickCount"><strong>getCPUTickCount() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/geometric_transformations.html#Mat getDefaultNewCameraMatrix(InputArray cameraMatrix, Size imgsize, bool centerPrincipalPoint)"><strong>getDefaultNewCameraMatrix (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/geometric_transformations.html#cv2.getDefaultNewCameraMatrix"><strong>getDefaultNewCameraMatrix() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/filtering.html#void getDerivKernels(OutputArray kx, OutputArray ky, int dx, int dy, int ksize, bool normalize, int ktype)"><strong>getDerivKernels (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/filtering.html#cv2.getDerivKernels"><strong>getDerivKernels() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_basic_structures.html#CvMat* cvGetDiag(const CvArr* arr, CvMat* submat, int diag)"><strong>GetDiag (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_basic_structures.html#cv.GetDiag"><strong>GetDiag() (Python function in cv)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_basic_structures.html#int cvGetDims(const CvArr* arr, int* sizes)"><strong>GetDims (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_basic_structures.html#cv.GetDims"><strong>GetDims() (Python function in cv)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_basic_structures.html#int cvGetDimSize(const CvArr* arr, int index)"><strong>GetDimSize (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_basic_structures.html#int cvGetElemType(const CvArr* arr)"><strong>GetElemType (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_basic_structures.html#cv.GetElemType"><strong>GetElemType() (Python function in cv)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_xml_yaml_persistence.html#CvFileNode* cvGetFileNode(CvFileStorage* fs, CvFileNode* map, const CvStringHashNode* key, int create_missing)"><strong>GetFileNode (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_xml_yaml_persistence.html#CvFileNode* cvGetFileNodeByName(const CvFileStorage* fs, const CvFileNode* map, const char* name)"><strong>GetFileNodeByName (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_xml_yaml_persistence.html#const char* cvGetFileNodeName(const CvFileNode* node)"><strong>GetFileNodeName (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/filtering.html#Mat getGaussianKernel(int ksize, double sigma, int ktype)"><strong>getGaussianKernel (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/filtering.html#cv2.getGaussianKernel"><strong>getGaussianKernel() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/dynamic_structures.html#CvGraphVtx* cvGetGraphVtx(CvGraph* graph, int vtx_idx)"><strong>GetGraphVtx (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_xml_yaml_persistence.html#CvStringHashNode* cvGetHashedKey(CvFileStorage* fs, const char* name, int len, int create_missing)"><strong>GetHashedKey (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/legacy/doc/histograms.html#float cvGetHistValue_1D(CvHistogram hist, int idx0)"><strong>GetHistValue_1D (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/legacy/doc/histograms.html#float cvGetHistValue_2D(CvHistogram hist, int idx0, int idx1)"><strong>GetHistValue_2D (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/legacy/doc/histograms.html#float cvGetHistValue_3D(CvHistogram hist, int idx0, int idx1, int idx2)"><strong>GetHistValue_3D (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/legacy/doc/histograms.html#float cvGetHistValue_nD(CvHistogram hist, int idx)"><strong>GetHistValue_nD (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/structural_analysis_and_shape_descriptors.html#void cvGetHuMoments(CvMoments* moments, CvHuMoments* hu_moments)"><strong>GetHuMoments (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/structural_analysis_and_shape_descriptors.html#cv.GetHuMoments"><strong>GetHuMoments() (Python function in cv)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_basic_structures.html#IplImage* cvGetImage(const CvArr* arr, IplImage* image_header)"><strong>GetImage (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_basic_structures.html#cv.GetImage"><strong>GetImage() (Python function in cv)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_basic_structures.html#int cvGetImageCOI(const IplImage* image)"><strong>GetImageCOI (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_basic_structures.html#cv.GetImageCOI"><strong>GetImageCOI() (Python function in cv)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_basic_structures.html#CvRect cvGetImageROI(const IplImage* image)"><strong>GetImageROI (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_basic_structures.html#cv.GetImageROI"><strong>GetImageROI() (Python function in cv)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/filtering.html#int getKernelType(InputArray kernel, Point anchor)"><strong>getKernelType (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/filtering.html#Ptr<BaseColumnFilter> getLinearColumnFilter(int bufType, int dstType, InputArray kernel, int anchor, int symmetryType, double delta, int bits)"><strong>getLinearColumnFilter (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/filtering.html#Ptr<BaseFilter> getLinearFilter(int srcType, int dstType, InputArray kernel, Point anchor, double delta, int bits)"><strong>getLinearFilter (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/filtering.html#Ptr<BaseRowFilter> getLinearRowFilter(int srcType, int bufType, InputArray kernel, int anchor, int symmetryType)"><strong>getLinearRowFilter (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_basic_structures.html#CvMat* cvGetMat(const CvArr* arr, CvMat* header, int* coi, int allowND)"><strong>GetMat (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_basic_structures.html#cv.GetMat"><strong>GetMat() (Python function in cv)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/histograms.html#void cvGetMinMaxHistValue(const CvHistogram* hist, float* min_value, float* max_value, int* min_idx, int* max_idx)"><strong>GetMinMaxHistValue (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/histograms.html#cv.GetMinMaxHistValue"><strong>GetMinMaxHistValue() (Python function in cv)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/filtering.html#Ptr<BaseColumnFilter> getMorphologyColumnFilter(int op, int type, int ksize, int anchor)"><strong>getMorphologyColumnFilter (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/filtering.html#Ptr<BaseFilter> getMorphologyFilter(int op, int type, InputArray kernel, Point anchor)"><strong>getMorphologyFilter (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/filtering.html#Ptr<BaseRowFilter> getMorphologyRowFilter(int op, int type, int ksize, int anchor)"><strong>getMorphologyRowFilter (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_basic_structures.html#CvScalar cvGetND(const CvArr* arr, const int* idx)"><strong>GetND (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_basic_structures.html#cv.GetND"><strong>GetND() (Python function in cv)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_basic_structures.html#CvSparseNode* cvGetNextSparseNode(CvSparseMatIterator* mat_iterator)"><strong>GetNextSparseNode (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/utility_and_system_functions_and_macros.html#int getNumberOfCPUs()"><strong>getNumberOfCPUs (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/utility_and_system_functions_and_macros.html#int getNumThreads()"><strong>getNumThreads (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#int cvGetOptimalDFTSize(int size0)"><strong>GetOptimalDFTSize (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#int getOptimalDFTSize(int vecsize)"><strong>getOptimalDFTSize (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#cv.GetOptimalDFTSize"><strong>GetOptimalDFTSize() (Python function in cv)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#cv2.getOptimalDFTSize"><strong>getOptimalDFTSize() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/calib3d/doc/camera_calibration_and_3d_reconstruction.html#void cvGetOptimalNewCameraMatrix(const CvMat* camera_matrix, const CvMat* dist_coeffs, CvSize image_size, double alpha, CvMat* new_camera_matrix, CvSize new_imag_size, CvRect* valid_pixel_ROI, int center_principal_point)"><strong>GetOptimalNewCameraMatrix (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/calib3d/doc/camera_calibration_and_3d_reconstruction.html#Mat getOptimalNewCameraMatrix(InputArray cameraMatrix, InputArray distCoeffs, Size imageSize, double alpha, Size newImgSize, Rect* validPixROI, bool centerPrincipalPoint)"><strong>getOptimalNewCameraMatrix (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/calib3d/doc/camera_calibration_and_3d_reconstruction.html#cv.GetOptimalNewCameraMatrix"><strong>GetOptimalNewCameraMatrix() (Python function in cv)</strong></a>
  </dt>

      
  <dt><a href="modules/calib3d/doc/camera_calibration_and_3d_reconstruction.html#cv2.getOptimalNewCameraMatrix"><strong>getOptimalNewCameraMatrix() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/geometric_transformations.html#CvMat* cvGetPerspectiveTransform(const CvPoint2D32f* src, const CvPoint2D32f* dst, CvMat* map_matrix)"><strong>GetPerspectiveTransform (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/geometric_transformations.html#Mat getPerspectiveTransform(InputArray src, InputArray dst)"><strong>getPerspectiveTransform (C++ function)</strong></a>, <a href="modules/imgproc/doc/geometric_transformations.html#Mat getPerspectiveTransform(const Point2f src[], const Point2f dst[])"><strong>[1]</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/geometric_transformations.html#cv.GetPerspectiveTransform"><strong>GetPerspectiveTransform() (Python function in cv)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/geometric_transformations.html#cv2.getPerspectiveTransform"><strong>getPerspectiveTransform() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/viz/doc/widget.html#static vtkSmartPointer<vtkProp> getProp(const Widget &widget)"><strong>getProp (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/geometric_transformations.html#void cvGetQuadrangleSubPix(const CvArr* src, CvArr* dst, const CvMat* map_matrix)"><strong>GetQuadrangleSubPix (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/geometric_transformations.html#cv.GetQuadrangleSubPix"><strong>GetQuadrangleSubPix() (Python function in cv)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_basic_structures.html#void cvGetRawData(const CvArr* arr, uchar** data, int* step, CvSize* roi_size)"><strong>GetRawData (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_basic_structures.html#double cvGetReal1D(const CvArr* arr, int idx0)"><strong>GetReal1D (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_basic_structures.html#cv.GetReal1D"><strong>GetReal1D() (Python function in cv)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_basic_structures.html#double cvGetReal2D(const CvArr* arr, int idx0, int idx1)"><strong>GetReal2D (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_basic_structures.html#cv.GetReal2D"><strong>GetReal2D() (Python function in cv)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_basic_structures.html#double cvGetReal3D(const CvArr* arr, int idx0, int idx1, int idx2)"><strong>GetReal3D (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_basic_structures.html#cv.GetReal3D"><strong>GetReal3D() (Python function in cv)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_basic_structures.html#double cvGetRealND(const CvArr* arr, const int* idx)"><strong>GetRealND (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_basic_structures.html#cv.GetRealND"><strong>GetRealND() (Python function in cv)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/geometric_transformations.html#void cvGetRectSubPix(const CvArr* src, CvArr* dst, CvPoint2D32f center)"><strong>GetRectSubPix (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/geometric_transformations.html#void getRectSubPix(InputArray image, Size patchSize, Point2f center, OutputArray patch, int patchType)"><strong>getRectSubPix (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/geometric_transformations.html#cv.GetRectSubPix"><strong>GetRectSubPix() (Python function in cv)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/geometric_transformations.html#cv2.getRectSubPix"><strong>getRectSubPix() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/viz/doc/viz3d.html#double getRenderingProperty(const String &id, int property)"><strong>getRenderingProperty (C++ function)</strong></a>, <a href="modules/viz/doc/widget.html#double getRenderingProperty(int property) const"><strong>[1]</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_xml_yaml_persistence.html#CvFileNode* cvGetRootFileNode(const CvFileStorage* fs, int stream_index)"><strong>GetRootFileNode (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/geometric_transformations.html#Mat getRotationMatrix2D(Point2f center, double angle, double scale)"><strong>getRotationMatrix2D (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/geometric_transformations.html#cv.GetRotationMatrix2D"><strong>GetRotationMatrix2D() (Python function in cv)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/geometric_transformations.html#cv2.getRotationMatrix2D"><strong>getRotationMatrix2D() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_basic_structures.html#CvMat* cvGetRow(const CvArr* arr, CvMat* submat, int row)"><strong>GetRow (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_basic_structures.html#cv.GetRow"><strong>GetRow() (Python function in cv)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_basic_structures.html#CvMat* cvGetRows(const CvArr* arr, CvMat* submat, int start_row, int end_row, int delta_row)"><strong>GetRows (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_basic_structures.html#cv.GetRows"><strong>GetRows() (Python function in cv)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/filtering.html#Ptr<BaseRowFilter> getRowSumFilter(int srcType, int sumType, int ksize, int anchor)"><strong>getRowSumFilter (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/dynamic_structures.html#schar* cvGetSeqElem(const CvSeq* seq, int index)"><strong>GetSeqElem (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/dynamic_structures.html#int cvGetSeqReaderPos(CvSeqReader* reader)"><strong>GetSeqReaderPos (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/dynamic_structures.html#CvSetElem* cvGetSetElem(const CvSet* set_header, int idx)"><strong>GetSetElem (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_basic_structures.html#CvSize cvGetSize(const CvArr* arr)"><strong>GetSize (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_basic_structures.html#cv.GetSize"><strong>GetSize() (Python function in cv)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/filtering.html#Mat getStructuringElement(int shape, Size ksize, Point anchor)"><strong>getStructuringElement (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/filtering.html#cv2.getStructuringElement"><strong>getStructuringElement() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_basic_structures.html#CvMat* cvGetSubRect(const CvArr* arr, CvMat* submat, CvRect rect)"><strong>GetSubRect (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_basic_structures.html#cv.GetSubRect"><strong>GetSubRect() (Python function in cv)</strong></a>
  </dt>

      
  <dt><a href="modules/contrib/doc/openfabmap.html#const vector<Mat>& getTestImgDescriptors() const"><strong>getTestImgDescriptors (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/viz/doc/widget.html#String getText() const"><strong>getText (C++ function)</strong></a>, <a href="modules/viz/doc/widget.html#String getText() const"><strong>[1]</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/drawing_functions.html#void cvGetTextSize(const char* text_string, const CvFont* font, CvSize* text_size, int* baseline)"><strong>GetTextSize (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/drawing_functions.html#Size getTextSize(const string& text, int fontFace, double fontScale, int thickness, int* baseLine)"><strong>getTextSize (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/drawing_functions.html#cv.GetTextSize"><strong>GetTextSize() (Python function in cv)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/drawing_functions.html#cv2.getTextSize"><strong>getTextSize() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/utility_and_system_functions_and_macros.html#int getThreadNum()"><strong>getThreadNum (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/utility_and_system_functions_and_macros.html#int64 getTickCount()"><strong>getTickCount (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/utility_and_system_functions_and_macros.html#cv2.getTickCount"><strong>getTickCount() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/utility_and_system_functions_and_macros.html#double getTickFrequency()"><strong>getTickFrequency (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/utility_and_system_functions_and_macros.html#cv2.getTickFrequency"><strong>getTickFrequency() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/highgui/doc/user_interface.html#int cvGetTrackbarPos(const char* trackbar_name, const char* window_name)"><strong>GetTrackbarPos (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/highgui/doc/user_interface.html#int getTrackbarPos(const string& trackbarname, const string& winname)"><strong>getTrackbarPos (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/highgui/doc/user_interface.html#cv.GetTrackbarPos"><strong>GetTrackbarPos() (Python function in cv)</strong></a>
  </dt>

      
  <dt><a href="modules/highgui/doc/user_interface.html#cv2.getTrackbarPos"><strong>getTrackbarPos() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/contrib/doc/openfabmap.html#const vector<Mat>& getTrainingImgDescriptors() const"><strong>getTrainingImgDescriptors (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/viz/doc/viz3d.html#Widget getWidget(const String &id) const"><strong>getWidget (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/viz/doc/viz3d.html#Affine3d getWidgetPose(const String &id) const"><strong>getWidgetPose (C++ function)</strong></a>, <a href="modules/viz/doc/widget.html#Affine3d getWidgetPose() const"><strong>[1]</strong></a>
  </dt>

      
  <dt><a href="modules/viz/doc/viz3d.html#Viz3d getWindowByName(const String &window_name)"><strong>getWindowByName (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/viz/doc/viz3d.html#String getWindowName() const"><strong>getWindowName (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/highgui/doc/qt_new_functions.html#double cvGetWindowProperty(const char* name, int prop_id)"><strong>GetWindowProperty (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/highgui/doc/qt_new_functions.html#double getWindowProperty(const string& winname, int prop_id)"><strong>getWindowProperty (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/highgui/doc/qt_new_functions.html#cv2.getWindowProperty"><strong>getWindowProperty() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/viz/doc/viz3d.html#Size getWindowSize() const"><strong>getWindowSize (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/feature_detection.html#void cvGoodFeaturesToTrack(const CvArr* image, CvArr* eig_image, CvArr* temp_image, CvPoint2D32f* corners, int* corner_count, double quality_level, double min_distance, const CvArr* mask, int block_size, int use_harris, double k)"><strong>GoodFeaturesToTrack (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/feature_detection.html#void goodFeaturesToTrack(InputArray image, OutputArray corners, int maxCorners, double qualityLevel, double minDistance, InputArray mask, int blockSize, bool useHarrisDetector, double k)"><strong>goodFeaturesToTrack (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/feature_detection.html#cv.GoodFeaturesToTrack"><strong>GoodFeaturesToTrack() (Python function in cv)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/feature_detection.html#cv2.goodFeaturesToTrack"><strong>goodFeaturesToTrack() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/features2d/doc/common_interfaces_of_feature_detectors.html#GoodFeaturesToTrackDetector : public FeatureDetector"><strong>GoodFeaturesToTrackDetector (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/gpu/doc/per_element_operations.html#void gpu::abs(const GpuMat& src, GpuMat& dst, Stream& stream)"><strong>gpu::abs (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/gpu/doc/per_element_operations.html#void gpu::absdiff(const GpuMat& a, const GpuMat& b, GpuMat& c, Stream& stream)"><strong>gpu::absdiff (C++ function)</strong></a>, <a href="modules/gpu/doc/per_element_operations.html#void gpu::absdiff(const GpuMat& a, const Scalar& s, GpuMat& c, Stream& stream)"><strong>[1]</strong></a>
  </dt>

      
  <dt><a href="modules/gpu/doc/matrix_reductions.html#Scalar gpu::absSum(const GpuMat& src)"><strong>gpu::absSum (C++ function)</strong></a>, <a href="modules/gpu/doc/matrix_reductions.html#Scalar gpu::absSum(const GpuMat& src, GpuMat& buf)"><strong>[1]</strong></a>, <a href="modules/gpu/doc/matrix_reductions.html#Scalar gpu::absSum(const GpuMat& src, const GpuMat& mask, GpuMat& buf)"><strong>[2]</strong></a>
  </dt>

      
  <dt><a href="modules/gpu/doc/per_element_operations.html#void gpu::add(const GpuMat& a, const GpuMat& b, GpuMat& c, const GpuMat& mask, int dtype, Stream& stream)"><strong>gpu::add (C++ function)</strong></a>, <a href="modules/gpu/doc/per_element_operations.html#void gpu::add(const GpuMat& a, const Scalar& sc, GpuMat& c, const GpuMat& mask, int dtype, Stream& stream)"><strong>[1]</strong></a>
  </dt>

      
  <dt><a href="modules/gpu/doc/per_element_operations.html#void gpu::addWeighted(const GpuMat& src1, double alpha, const GpuMat& src2, double beta, double gamma, GpuMat& dst, int dtype , Stream& stream)"><strong>gpu::addWeighted (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/gpu/doc/image_processing.html#void gpu::alphaComp(const GpuMat& img1, const GpuMat& img2, GpuMat& dst, int alpha_op, Stream& stream)"><strong>gpu::alphaComp (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/gpu/doc/image_filtering.html#gpu::BaseColumnFilter_GPU"><strong>gpu::BaseColumnFilter_GPU (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/gpu/doc/image_filtering.html#gpu::BaseFilter_GPU"><strong>gpu::BaseFilter_GPU (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/gpu/doc/image_filtering.html#gpu::BaseRowFilter_GPU"><strong>gpu::BaseRowFilter_GPU (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/gpu/doc/image_processing.html#void gpu::bilateralFilter(const GpuMat& src, GpuMat& dst, int kernel_size, float sigma_color, float sigma_spatial, int borderMode, Stream& stream)"><strong>gpu::bilateralFilter (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/gpu/doc/per_element_operations.html#void gpu::bitwise_and(const GpuMat& src1, const GpuMat& src2, GpuMat& dst, const GpuMat& mask, Stream& stream)"><strong>gpu::bitwise_and (C++ function)</strong></a>, <a href="modules/gpu/doc/per_element_operations.html#void gpu::bitwise_and(const GpuMat& src1, const Scalar& sc, GpuMat& dst, Stream& stream)"><strong>[1]</strong></a>
  </dt>

      
  <dt><a href="modules/gpu/doc/per_element_operations.html#void gpu::bitwise_not(const GpuMat& src, GpuMat& dst, const GpuMat& mask, Stream& stream)"><strong>gpu::bitwise_not (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/gpu/doc/per_element_operations.html#void gpu::bitwise_or(const GpuMat& src1, const GpuMat& src2, GpuMat& dst, const GpuMat& mask, Stream& stream)"><strong>gpu::bitwise_or (C++ function)</strong></a>, <a href="modules/gpu/doc/per_element_operations.html#void gpu::bitwise_or(const GpuMat& src1, const Scalar& sc, GpuMat& dst, Stream& stream)"><strong>[1]</strong></a>
  </dt>

      
  <dt><a href="modules/gpu/doc/per_element_operations.html#void gpu::bitwise_xor(const GpuMat& src1, const GpuMat& src2, GpuMat& dst, const GpuMat& mask, Stream& stream)"><strong>gpu::bitwise_xor (C++ function)</strong></a>, <a href="modules/gpu/doc/per_element_operations.html#void gpu::bitwise_xor(const GpuMat& src1, const Scalar& sc, GpuMat& dst, Stream& stream)"><strong>[1]</strong></a>
  </dt>

      
  <dt><a href="modules/gpu/doc/image_processing.html#void gpu::blendLinear(const GpuMat& img1, const GpuMat& img2, const GpuMat& weights1, const GpuMat& weights2, GpuMat& result, Stream& stream)"><strong>gpu::blendLinear (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/gpu/doc/image_filtering.html#void gpu::blur(const GpuMat& src, GpuMat& dst, Size ksize, Point anchor , Stream& stream)"><strong>gpu::blur (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/gpu/doc/image_filtering.html#void gpu::boxFilter(const GpuMat& src, GpuMat& dst, int ddepth, Size ksize, Point anchor , Stream& stream)"><strong>gpu::boxFilter (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/gpu/doc/video.html#gpu::BroxOpticalFlow"><strong>gpu::BroxOpticalFlow (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/gpu/doc/feature_detection_and_description.html#gpu::BruteForceMatcher_GPU_base"><strong>gpu::BruteForceMatcher_GPU_base (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/gpu/doc/feature_detection_and_description.html#void gpu::BruteForceMatcher_GPU_base::knnMatch(const GpuMat& query, const GpuMat& train, std::vector< std::vector<DMatch> >&matches, int k, const GpuMat& mask , bool compactResult)"><strong>gpu::BruteForceMatcher_GPU_base::knnMatch (C++ function)</strong></a>, <a href="modules/gpu/doc/feature_detection_and_description.html#void gpu::BruteForceMatcher_GPU_base::knnMatch(const GpuMat& query, std::vector< std::vector<DMatch> >&matches, int k, const std::vector<GpuMat>&masks , bool compactResult)"><strong>[1]</strong></a>
  </dt>

      
  <dt><a href="modules/gpu/doc/feature_detection_and_description.html#void gpu::BruteForceMatcher_GPU_base::knnMatch2Collection(const GpuMat& query, const GpuMat& trainCollection, GpuMat& trainIdx, GpuMat& imgIdx, GpuMat& distance, const GpuMat& maskCollection , Stream& stream)"><strong>gpu::BruteForceMatcher_GPU_base::knnMatch2Collection (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/gpu/doc/feature_detection_and_description.html#void gpu::BruteForceMatcher_GPU_base::knnMatch2Convert(const Mat& trainIdx, const Mat& imgIdx, const Mat& distance, std::vector< std::vector<DMatch> >& matches, bool compactResult)"><strong>gpu::BruteForceMatcher_GPU_base::knnMatch2Convert (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/gpu/doc/feature_detection_and_description.html#void gpu::BruteForceMatcher_GPU_base::knnMatch2Download(const GpuMat& trainIdx, const GpuMat& imgIdx, const GpuMat& distance, std::vector< std::vector<DMatch> >& matches, bool compactResult)"><strong>gpu::BruteForceMatcher_GPU_base::knnMatch2Download (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/gpu/doc/feature_detection_and_description.html#void gpu::BruteForceMatcher_GPU_base::knnMatchConvert(const Mat& trainIdx, const Mat& distance, std::vector< std::vector<DMatch> >&matches, bool compactResult)"><strong>gpu::BruteForceMatcher_GPU_base::knnMatchConvert (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/gpu/doc/feature_detection_and_description.html#void gpu::BruteForceMatcher_GPU_base::knnMatchDownload(const GpuMat& trainIdx, const GpuMat& distance, std::vector< std::vector<DMatch> >&matches, bool compactResult)"><strong>gpu::BruteForceMatcher_GPU_base::knnMatchDownload (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/gpu/doc/feature_detection_and_description.html#void gpu::BruteForceMatcher_GPU_base::knnMatchSingle(const GpuMat& query, const GpuMat& train, GpuMat& trainIdx, GpuMat& distance, GpuMat& allDist, int k, const GpuMat& mask , Stream& stream)"><strong>gpu::BruteForceMatcher_GPU_base::knnMatchSingle (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/gpu/doc/feature_detection_and_description.html#void gpu::BruteForceMatcher_GPU_base::makeGpuCollection(GpuMat& trainCollection, GpuMat& maskCollection, const vector<GpuMat>& masks)"><strong>gpu::BruteForceMatcher_GPU_base::makeGpuCollection (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/gpu/doc/feature_detection_and_description.html#void gpu::BruteForceMatcher_GPU_base::match(const GpuMat& query, const GpuMat& train, std::vector<DMatch>& matches, const GpuMat& mask)"><strong>gpu::BruteForceMatcher_GPU_base::match (C++ function)</strong></a>, <a href="modules/gpu/doc/feature_detection_and_description.html#void gpu::BruteForceMatcher_GPU_base::match(const GpuMat& query, std::vector<DMatch>& matches, const std::vector<GpuMat>& masks)"><strong>[1]</strong></a>
  </dt>

      
  <dt><a href="modules/gpu/doc/feature_detection_and_description.html#void gpu::BruteForceMatcher_GPU_base::matchCollection(const GpuMat& query, const GpuMat& trainCollection, GpuMat& trainIdx, GpuMat& imgIdx, GpuMat& distance, const GpuMat& masks, Stream& stream)"><strong>gpu::BruteForceMatcher_GPU_base::matchCollection (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/gpu/doc/feature_detection_and_description.html#void gpu::BruteForceMatcher_GPU_base::matchConvert(const Mat& trainIdx, const Mat& distance, std::vector<DMatch>&matches)"><strong>gpu::BruteForceMatcher_GPU_base::matchConvert (C++ function)</strong></a>, <a href="modules/gpu/doc/feature_detection_and_description.html#void gpu::BruteForceMatcher_GPU_base::matchConvert(const Mat& trainIdx, const Mat& imgIdx, const Mat& distance, std::vector<DMatch>&matches)"><strong>[1]</strong></a>
  </dt>

      
  <dt><a href="modules/gpu/doc/feature_detection_and_description.html#static void gpu::BruteForceMatcher_GPU_base::matchDownload(const GpuMat& trainIdx, const GpuMat& distance, std::vector<DMatch>&matches)"><strong>gpu::BruteForceMatcher_GPU_base::matchDownload (C++ function)</strong></a>, <a href="modules/gpu/doc/feature_detection_and_description.html#static void gpu::BruteForceMatcher_GPU_base::matchDownload(const GpuMat& trainIdx, const GpuMat& imgIdx, const GpuMat& distance, std::vector<DMatch>& matches)"><strong>[1]</strong></a>
  </dt>

      
  <dt><a href="modules/gpu/doc/feature_detection_and_description.html#void gpu::BruteForceMatcher_GPU_base::matchSingle(const GpuMat& query, const GpuMat& train, GpuMat& trainIdx, GpuMat& distance, const GpuMat& mask , Stream& stream)"><strong>gpu::BruteForceMatcher_GPU_base::matchSingle (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/gpu/doc/feature_detection_and_description.html#void gpu::BruteForceMatcher_GPU_base::radiusMatch(const GpuMat& query, const GpuMat& train, std::vector< std::vector<DMatch> >&matches, float maxDistance, const GpuMat& mask , bool compactResult)"><strong>gpu::BruteForceMatcher_GPU_base::radiusMatch (C++ function)</strong></a>, <a href="modules/gpu/doc/feature_detection_and_description.html#void gpu::BruteForceMatcher_GPU_base::radiusMatch(const GpuMat& query, std::vector< std::vector<DMatch> >&matches, float maxDistance, const std::vector<GpuMat>& masks , bool compactResult)"><strong>[1]</strong></a>
  </dt>

      
  <dt><a href="modules/gpu/doc/feature_detection_and_description.html#void gpu::BruteForceMatcher_GPU_base::radiusMatchCollection(const GpuMat& query, GpuMat& trainIdx, GpuMat& imgIdx, GpuMat& distance, GpuMat& nMatches, float maxDistance, const std::vector<GpuMat>& masks , Stream& stream)"><strong>gpu::BruteForceMatcher_GPU_base::radiusMatchCollection (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/gpu/doc/feature_detection_and_description.html#void gpu::BruteForceMatcher_GPU_base::radiusMatchConvert(const Mat& trainIdx, const Mat& distance, const Mat& nMatches, std::vector< std::vector<DMatch> >&matches, bool compactResult)"><strong>gpu::BruteForceMatcher_GPU_base::radiusMatchConvert (C++ function)</strong></a>, <a href="modules/gpu/doc/feature_detection_and_description.html#void gpu::BruteForceMatcher_GPU_base::radiusMatchConvert(const Mat& trainIdx, const Mat& imgIdx, const Mat& distance, const Mat& nMatches, std::vector< std::vector<DMatch> >& matches, bool compactResult)"><strong>[1]</strong></a>
  </dt>

      
  <dt><a href="modules/gpu/doc/feature_detection_and_description.html#void gpu::BruteForceMatcher_GPU_base::radiusMatchDownload(const GpuMat& trainIdx, const GpuMat& distance, const GpuMat& nMatches, std::vector< std::vector<DMatch> >&matches, bool compactResult)"><strong>gpu::BruteForceMatcher_GPU_base::radiusMatchDownload (C++ function)</strong></a>, <a href="modules/gpu/doc/feature_detection_and_description.html#void gpu::BruteForceMatcher_GPU_base::radiusMatchDownload(const GpuMat& trainIdx, const GpuMat& imgIdx, const GpuMat& distance, const GpuMat& nMatches, std::vector< std::vector<DMatch> >& matches, bool compactResult)"><strong>[1]</strong></a>
  </dt>

      
  <dt><a href="modules/gpu/doc/feature_detection_and_description.html#void gpu::BruteForceMatcher_GPU_base::radiusMatchSingle(const GpuMat& query, const GpuMat& train, GpuMat& trainIdx, GpuMat& distance, GpuMat& nMatches, float maxDistance, const GpuMat& mask , Stream& stream)"><strong>gpu::BruteForceMatcher_GPU_base::radiusMatchSingle (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/gpu/doc/image_processing.html#void gpu::buildWarpAffineMaps(const Mat& M, bool inverse, Size dsize, GpuMat& xmap, GpuMat& ymap, Stream& stream)"><strong>gpu::buildWarpAffineMaps (C++ function)</strong></a>, <a href="modules/gpu/doc/image_processing.html#void gpu::buildWarpAffineMaps(const Mat& M, bool inverse, Size dsize, GpuMat& xmap, GpuMat& ymap, Stream& stream)"><strong>[1]</strong></a>
  </dt>

      
  <dt><a href="modules/gpu/doc/image_processing.html#void gpu::buildWarpCylindricalMaps(Size src_size, Rect dst_roi, const Mat & K, const Mat& R, float scale, GpuMat& map_x, GpuMat& map_y, Stream& stream)"><strong>gpu::buildWarpCylindricalMaps (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/gpu/doc/image_processing.html#void gpu::buildWarpPlaneMaps(Size src_size, Rect dst_roi, const Mat & K, const Mat& R, const Mat & T, float scale, GpuMat& map_x, GpuMat& map_y, Stream& stream)"><strong>gpu::buildWarpPlaneMaps (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/gpu/doc/image_processing.html#void gpu::buildWarpSphericalMaps(Size src_size, Rect dst_roi, const Mat & K, const Mat& R, float scale, GpuMat& map_x, GpuMat& map_y, Stream& stream)"><strong>gpu::buildWarpSphericalMaps (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/gpu/doc/image_processing.html#void gpu::calcHist(const GpuMat& src, GpuMat& hist, GpuMat& buf, Stream& stream)"><strong>gpu::calcHist (C++ function)</strong></a>, <a href="modules/gpu/doc/image_processing.html#void gpu::calcHist(const GpuMat& src, GpuMat& hist, Stream& stream)"><strong>[1]</strong></a>
  </dt>

      
  <dt><a href="modules/gpu/doc/image_processing.html#void gpu::Canny(const GpuMat& dx, const GpuMat& dy, CannyBuf& buf, GpuMat& edges, double low_thresh, double high_thresh, bool L2gradient)"><strong>gpu::Canny (C++ function)</strong></a>, <a href="modules/gpu/doc/image_processing.html#void gpu::Canny(const GpuMat& dx, const GpuMat& dy, GpuMat& edges, double low_thresh, double high_thresh, bool L2gradient)"><strong>[1]</strong></a>, <a href="modules/gpu/doc/image_processing.html#void gpu::Canny(const GpuMat& image, CannyBuf& buf, GpuMat& edges, double low_thresh, double high_thresh, int apperture_size , bool L2gradient)"><strong>[2]</strong></a>, <a href="modules/gpu/doc/image_processing.html#void gpu::Canny(const GpuMat& image, GpuMat& edges, double low_thresh, double high_thresh, int apperture_size , bool L2gradient)"><strong>[3]</strong></a>
  </dt>

      
  <dt><a href="modules/gpu/doc/operations_on_matrices.html#void gpu::cartToPolar(const GpuMat& x, const GpuMat& y, GpuMat& magnitude, GpuMat& angle, bool angleInDegrees, Stream& stream)"><strong>gpu::cartToPolar (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/gpu/doc/object_detection.html#gpu::CascadeClassifier_GPU"><strong>gpu::CascadeClassifier_GPU (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/gpu/doc/object_detection.html#gpu::CascadeClassifier_GPU::CascadeClassifier_GPU(const string& filename)"><strong>gpu::CascadeClassifier_GPU::CascadeClassifier_GPU (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/gpu/doc/object_detection.html#int gpu::CascadeClassifier_GPU::detectMultiScale(const GpuMat& image, GpuMat& objectsBuf, Size maxObjectSize, Size minSize , double scaleFactor , int minNeighbors)"><strong>gpu::CascadeClassifier_GPU::detectMultiScale (C++ function)</strong></a>, <a href="modules/gpu/doc/object_detection.html#int gpu::CascadeClassifier_GPU::detectMultiScale(const GpuMat& image, GpuMat& objectsBuf, double scaleFactor, int minNeighbors, Size minSize)"><strong>[1]</strong></a>
  </dt>

      
  <dt><a href="modules/gpu/doc/object_detection.html#bool gpu::CascadeClassifier_GPU::empty() const"><strong>gpu::CascadeClassifier_GPU::empty (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/gpu/doc/object_detection.html#bool gpu::CascadeClassifier_GPU::load(const string& filename)"><strong>gpu::CascadeClassifier_GPU::load (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/gpu/doc/object_detection.html#void gpu::CascadeClassifier_GPU::release()"><strong>gpu::CascadeClassifier_GPU::release (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/gpu/doc/image_processing.html#void gpu::columnSum(const GpuMat& src, GpuMat& sum)"><strong>gpu::columnSum (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/gpu/doc/per_element_operations.html#void gpu::compare(const GpuMat& a, Scalar sc, GpuMat& c, int cmpop, Stream& stream)"><strong>gpu::compare (C++ function)</strong></a>, <a href="modules/gpu/doc/per_element_operations.html#void gpu::compare(const GpuMat& a, const GpuMat& b, GpuMat& c, int cmpop, Stream& stream)"><strong>[1]</strong></a>
  </dt>

      
  <dt><a href="modules/gpu/doc/image_processing.html#void gpu::convolve(const GpuMat& image, const GpuMat& templ, GpuMat& result, bool ccorr)"><strong>gpu::convolve (C++ function)</strong></a>, <a href="modules/gpu/doc/image_processing.html#void gpu::convolve(const GpuMat& image, const GpuMat& templ, GpuMat& result, bool ccorr, ConvolveBuf& buf, Stream& stream)"><strong>[1]</strong></a>
  </dt>

      
  <dt><a href="modules/gpu/doc/image_processing.html#gpu::ConvolveBuf"><strong>gpu::ConvolveBuf (C++ structure)</strong></a>
  </dt>

      
  <dt><a href="modules/gpu/doc/image_processing.html#gpu::ConvolveBuf::create(Size image_size, Size templ_size)"><strong>gpu::ConvolveBuf::create (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/gpu/doc/image_processing.html#void gpu::copyMakeBorder(const GpuMat& src, GpuMat& dst, int top, int bottom, int left, int right, int borderType, const Scalar& value , Stream& stream)"><strong>gpu::copyMakeBorder (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/gpu/doc/image_processing.html#void gpu::cornerHarris(const GpuMat& src, GpuMat& dst, int blockSize, int ksize, double k, int borderType)"><strong>gpu::cornerHarris (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/gpu/doc/image_processing.html#void gpu::cornerMinEigenVal(const GpuMat& src, GpuMat& dst, GpuMat& Dx, GpuMat& Dy, GpuMat& buf, int blockSize, int ksize, int borderType, Stream& stream)"><strong>gpu::cornerMinEigenVal (C++ function)</strong></a>, <a href="modules/gpu/doc/image_processing.html#void gpu::cornerMinEigenVal(const GpuMat& src, GpuMat& dst, GpuMat& Dx, GpuMat& Dy, int blockSize, int ksize, int borderType)"><strong>[1]</strong></a>, <a href="modules/gpu/doc/image_processing.html#void gpu::cornerMinEigenVal(const GpuMat& src, GpuMat& dst, int blockSize, int ksize, int borderType)"><strong>[2]</strong></a>
  </dt>

      
  <dt><a href="modules/gpu/doc/matrix_reductions.html#int gpu::countNonZero(const GpuMat& src)"><strong>gpu::countNonZero (C++ function)</strong></a>, <a href="modules/gpu/doc/matrix_reductions.html#int gpu::countNonZero(const GpuMat& src, GpuMat& buf)"><strong>[1]</strong></a>
  </dt>

      
  <dt><a href="modules/gpu/doc/image_filtering.html#Ptr<FilterEngine_GPU> gpu::createBoxFilter_GPU(int srcType, int dstType, const Size& ksize, const Point& anchor)"><strong>gpu::createBoxFilter_GPU (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/gpu/doc/data_structures.html#GpuMat gpu::createContinuous(Size size, int type)"><strong>gpu::createContinuous (C++ function)</strong></a>, <a href="modules/gpu/doc/data_structures.html#GpuMat gpu::createContinuous(int rows, int cols, int type)"><strong>[1]</strong></a>, <a href="modules/gpu/doc/data_structures.html#void gpu::createContinuous(Size size, int type, GpuMat& m)"><strong>[2]</strong></a>, <a href="modules/gpu/doc/data_structures.html#void gpu::createContinuous(int rows, int cols, int type, GpuMat& m)"><strong>[3]</strong></a>
  </dt>

      
  <dt><a href="modules/gpu/doc/image_filtering.html#Ptr<FilterEngine_GPU> gpu::createDerivFilter_GPU(int srcType, int dstType, int dx, int dy, int ksize, int rowBorderType , int columnBorderType)"><strong>gpu::createDerivFilter_GPU (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/gpu/doc/image_filtering.html#Ptr<FilterEngine_GPU> gpu::createFilter2D_GPU(const Ptr<BaseFilter_GPU>& filter2D, int srcType, int dstType)"><strong>gpu::createFilter2D_GPU (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/gpu/doc/image_filtering.html#Ptr<FilterEngine_GPU> gpu::createGaussianFilter_GPU(int type, Size ksize, double sigma1, double sigma2, int rowBorderType, int columnBorderType)"><strong>gpu::createGaussianFilter_GPU (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/gpu/doc/image_filtering.html#Ptr<FilterEngine_GPU> gpu::createLinearFilter_GPU(int srcType, int dstType, const Mat& kernel, Point anchor , int borderType)"><strong>gpu::createLinearFilter_GPU (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/gpu/doc/image_filtering.html#Ptr<FilterEngine_GPU> gpu::createMorphologyFilter_GPU(int op, int type, const Mat& kernel, const Point& anchor , int iterations)"><strong>gpu::createMorphologyFilter_GPU (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/gpu/doc/image_filtering.html#Ptr<FilterEngine_GPU> gpu::createSeparableFilter_GPU(const Ptr<BaseRowFilter_GPU>& rowFilter, const Ptr<BaseColumnFilter_GPU>& columnFilter, int srcType, int bufType, int dstType)"><strong>gpu::createSeparableFilter_GPU (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/gpu/doc/image_filtering.html#Ptr<FilterEngine_GPU> gpu::createSeparableLinearFilter_GPU(int srcType, int dstType, const Mat& rowKernel, const Mat& columnKernel, const Point& anchor , int rowBorderType , int columnBorderType)"><strong>gpu::createSeparableLinearFilter_GPU (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/gpu/doc/data_structures.html#gpu::CudaMem"><strong>gpu::CudaMem (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/gpu/doc/data_structures.html#static bool gpu::CudaMem::canMapHostMemory()"><strong>gpu::CudaMem::canMapHostMemory (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/gpu/doc/data_structures.html#GpuMat gpu::CudaMem::createGpuMatHeader() const"><strong>gpu::CudaMem::createGpuMatHeader (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/gpu/doc/data_structures.html#Mat gpu::CudaMem::createMatHeader() const"><strong>gpu::CudaMem::createMatHeader (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/gpu/doc/image_processing.html#void gpu::cvtColor(const GpuMat& src, GpuMat& dst, int code, int dcn , Stream& stream)"><strong>gpu::cvtColor (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/gpu/doc/initalization_and_information.html#gpu::DeviceInfo"><strong>gpu::DeviceInfo (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/gpu/doc/initalization_and_information.html#int gpu::DeviceInfo::deviceID()"><strong>gpu::DeviceInfo::deviceID (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/gpu/doc/initalization_and_information.html#gpu::DeviceInfo::DeviceInfo()"><strong>gpu::DeviceInfo::DeviceInfo (C++ function)</strong></a>, <a href="modules/gpu/doc/initalization_and_information.html#gpu::DeviceInfo::DeviceInfo(int device_id)"><strong>[1]</strong></a>
  </dt>

      
  <dt><a href="modules/gpu/doc/initalization_and_information.html#size_t gpu::DeviceInfo::freeMemory()"><strong>gpu::DeviceInfo::freeMemory (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/gpu/doc/initalization_and_information.html#bool gpu::DeviceInfo::isCompatible()"><strong>gpu::DeviceInfo::isCompatible (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/gpu/doc/initalization_and_information.html#int gpu::DeviceInfo::majorVersion()"><strong>gpu::DeviceInfo::majorVersion (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/gpu/doc/initalization_and_information.html#int gpu::DeviceInfo::minorVersion()"><strong>gpu::DeviceInfo::minorVersion (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/gpu/doc/initalization_and_information.html#int gpu::DeviceInfo::multiProcessorCount()"><strong>gpu::DeviceInfo::multiProcessorCount (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/gpu/doc/initalization_and_information.html#string gpu::DeviceInfo::name() const"><strong>gpu::DeviceInfo::name (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/gpu/doc/initalization_and_information.html#bool gpu::DeviceInfo::supports(FeatureSet feature_set) const"><strong>gpu::DeviceInfo::supports (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/gpu/doc/initalization_and_information.html#size_t gpu::DeviceInfo::totalMemory()"><strong>gpu::DeviceInfo::totalMemory (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/gpu/doc/image_processing.html#void gpu::dft(const GpuMat& src, GpuMat& dst, Size dft_size, int flags, Stream& stream)"><strong>gpu::dft (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/gpu/doc/image_filtering.html#void gpu::dilate(const GpuMat& src, GpuMat& dst, const Mat& kernel, GpuMat& buf, Point anchor, int iterations, Stream& stream)"><strong>gpu::dilate (C++ function)</strong></a>, <a href="modules/gpu/doc/image_filtering.html#void gpu::dilate(const GpuMat& src, GpuMat& dst, const Mat& kernel, Point anchor, int iterations)"><strong>[1]</strong></a>
  </dt>

  </dl></td>
  <td style="width: 33%" valign="top"><dl>
      
  <dt><a href="modules/gpu/doc/camera_calibration_and_3d_reconstruction.html#gpu::DisparityBilateralFilter"><strong>gpu::DisparityBilateralFilter (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/gpu/doc/camera_calibration_and_3d_reconstruction.html#gpu::DisparityBilateralFilter::DisparityBilateralFilter(int ndisp , int radius , int iters)"><strong>gpu::DisparityBilateralFilter::DisparityBilateralFilter (C++ function)</strong></a>, <a href="modules/gpu/doc/camera_calibration_and_3d_reconstruction.html#gpu::DisparityBilateralFilter::DisparityBilateralFilter(int ndisp, int radius, int iters, float edge_threshold, float max_disc_threshold, float sigma_range)"><strong>[1]</strong></a>
  </dt>

      
  <dt><a href="modules/gpu/doc/camera_calibration_and_3d_reconstruction.html#void gpu::DisparityBilateralFilter::operator ()(const GpuMat& disparity, const GpuMat& image, GpuMat& dst, Stream& stream)"><strong>gpu::DisparityBilateralFilter::operator() (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/gpu/doc/per_element_operations.html#void gpu::divide(const GpuMat& a, const GpuMat& b, GpuMat& c, double scale, int dtype, Stream& stream)"><strong>gpu::divide (C++ function)</strong></a>, <a href="modules/gpu/doc/per_element_operations.html#void gpu::divide(const GpuMat& a, const Scalar& sc, GpuMat& c, double scale , int dtype , Stream& stream)"><strong>[1]</strong></a>, <a href="modules/gpu/doc/per_element_operations.html#void gpu::divide(double scale, const GpuMat& b, GpuMat& c, int dtype, Stream& stream)"><strong>[2]</strong></a>
  </dt>

      
  <dt><a href="modules/gpu/doc/camera_calibration_and_3d_reconstruction.html#void gpu::drawColorDisp(const GpuMat& src_disp, GpuMat& dst_disp, int ndisp, Stream& stream)"><strong>gpu::drawColorDisp (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/gpu/doc/data_structures.html#void gpu::ensureSizeIsEnough(Size size, int type, GpuMat& m)"><strong>gpu::ensureSizeIsEnough (C++ function)</strong></a>, <a href="modules/gpu/doc/data_structures.html#void gpu::ensureSizeIsEnough(int rows, int cols, int type, GpuMat& m)"><strong>[1]</strong></a>
  </dt>

      
  <dt><a href="modules/gpu/doc/image_processing.html#void gpu::equalizeHist(const GpuMat& src, GpuMat& dst, GpuMat& hist, GpuMat& buf, Stream& stream)"><strong>gpu::equalizeHist (C++ function)</strong></a>, <a href="modules/gpu/doc/image_processing.html#void gpu::equalizeHist(const GpuMat& src, GpuMat& dst, GpuMat& hist, Stream& stream)"><strong>[1]</strong></a>, <a href="modules/gpu/doc/image_processing.html#void gpu::equalizeHist(const GpuMat& src, GpuMat& dst, Stream& stream)"><strong>[2]</strong></a>
  </dt>

      
  <dt><a href="modules/gpu/doc/image_filtering.html#void gpu::erode(const GpuMat& src, GpuMat& dst, const Mat& kernel, GpuMat& buf, Point anchor, int iterations, Stream& stream)"><strong>gpu::erode (C++ function)</strong></a>, <a href="modules/gpu/doc/image_filtering.html#void gpu::erode(const GpuMat& src, GpuMat& dst, const Mat& kernel, Point anchor, int iterations)"><strong>[1]</strong></a>
  </dt>

      
  <dt><a href="modules/gpu/doc/image_processing.html#void gpu::evenLevels(GpuMat& levels, int nLevels, int lowerLevel, int upperLevel)"><strong>gpu::evenLevels (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/gpu/doc/per_element_operations.html#void gpu::exp(const GpuMat& a, GpuMat& b, Stream& stream)"><strong>gpu::exp (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/gpu/doc/video.html#gpu::FarnebackOpticalFlow"><strong>gpu::FarnebackOpticalFlow (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/gpu/doc/video.html#void gpu::FarnebackOpticalFlow::operator ()(const GpuMat &frame0, const GpuMat &frame1, GpuMat &flowx, GpuMat &flowy, Stream &s)"><strong>gpu::FarnebackOpticalFlow::operator() (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/gpu/doc/video.html#void gpu::FarnebackOpticalFlow::releaseMemory()"><strong>gpu::FarnebackOpticalFlow::releaseMemory (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/gpu/doc/feature_detection_and_description.html#gpu::FAST_GPU"><strong>gpu::FAST_GPU (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/gpu/doc/feature_detection_and_description.html#int gpu::FAST_GPU::calcKeyPointsLocation(const GpuMat& image, const GpuMat& mask)"><strong>gpu::FAST_GPU::calcKeyPointsLocation (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/gpu/doc/feature_detection_and_description.html#void gpu::FAST_GPU::convertKeypoints(const Mat& h_keypoints, std::vector<KeyPoint>& keypoints)"><strong>gpu::FAST_GPU::convertKeypoints (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/gpu/doc/feature_detection_and_description.html#void gpu::FAST_GPU::downloadKeypoints(const GpuMat& d_keypoints, std::vector<KeyPoint>& keypoints)"><strong>gpu::FAST_GPU::downloadKeypoints (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/gpu/doc/feature_detection_and_description.html#gpu::FAST_GPU::FAST_GPU(int threshold, bool nonmaxSuppression , double keypointsRatio)"><strong>gpu::FAST_GPU::FAST_GPU (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/gpu/doc/feature_detection_and_description.html#int gpu::FAST_GPU::getKeyPoints(GpuMat& keypoints)"><strong>gpu::FAST_GPU::getKeyPoints (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/gpu/doc/feature_detection_and_description.html#void gpu::FAST_GPU::operator ()(const GpuMat& image, const GpuMat& mask, GpuMat& keypoints)"><strong>gpu::FAST_GPU::operator() (C++ function)</strong></a>, <a href="modules/gpu/doc/feature_detection_and_description.html#void gpu::FAST_GPU::operator ()(const GpuMat& image, const GpuMat& mask, std::vector<KeyPoint>& keypoints)"><strong>[1]</strong></a>
  </dt>

      
  <dt><a href="modules/gpu/doc/feature_detection_and_description.html#void gpu::FAST_GPU::release()"><strong>gpu::FAST_GPU::release (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/gpu/doc/image_processing.html#gpu::FastNonLocalMeansDenoising"><strong>gpu::FastNonLocalMeansDenoising (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/gpu/doc/image_processing.html#void gpu::FastNonLocalMeansDenoising::labMethod(const GpuMat& src, GpuMat& dst, float h_luminance, float h_color, int search_window , int block_size , Stream& s)"><strong>gpu::FastNonLocalMeansDenoising::labMethod (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/gpu/doc/image_processing.html#void gpu::FastNonLocalMeansDenoising::simpleMethod(const GpuMat& src, GpuMat& dst, float h, int search_window , int block_size , Stream& s)"><strong>gpu::FastNonLocalMeansDenoising::simpleMethod (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/gpu/doc/initalization_and_information.html#gpu::FeatureSet"><strong>gpu::FeatureSet (enum)</strong></a>
  </dt>

      
  <dt><a href="modules/gpu/doc/video.html#gpu::FGDStatModel"><strong>gpu::FGDStatModel (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/gpu/doc/video.html#cv::gpu::GpuMat background"><strong>gpu::FGDStatModel::background (C++ member)</strong></a>
  </dt>

      
  <dt><a href="modules/gpu/doc/video.html#void gpu::FGDStatModel::create(const cv::gpu::GpuMat& firstFrame, const Params& params)"><strong>gpu::FGDStatModel::create (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/gpu/doc/video.html#gpu::FGDStatModel::FGDStatModel(const cv::gpu::GpuMat& firstFrame, const Params& params , int out_cn)"><strong>gpu::FGDStatModel::FGDStatModel (C++ function)</strong></a>, <a href="modules/gpu/doc/video.html#gpu::FGDStatModel::FGDStatModel(int out_cn)"><strong>[1]</strong></a>
  </dt>

      
  <dt><a href="modules/gpu/doc/video.html#cv::gpu::GpuMat foreground"><strong>gpu::FGDStatModel::foreground (C++ member)</strong></a>
  </dt>

      
  <dt><a href="modules/gpu/doc/video.html#cv::gpu::GpuMat foreground_regions"><strong>gpu::FGDStatModel::foreground_regions (C++ member)</strong></a>
  </dt>

      
  <dt><a href="modules/gpu/doc/video.html#void gpu::FGDStatModel::release()"><strong>gpu::FGDStatModel::release (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/gpu/doc/video.html#int gpu::FGDStatModel::update(const cv::gpu::GpuMat& curFrame)"><strong>gpu::FGDStatModel::update (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/gpu/doc/image_filtering.html#void gpu::filter2D(const GpuMat& src, GpuMat& dst, int ddepth, const Mat& kernel, Point anchor, int borderType , Stream& stream)"><strong>gpu::filter2D (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/gpu/doc/image_filtering.html#gpu::FilterEngine_GPU"><strong>gpu::FilterEngine_GPU (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/gpu/doc/operations_on_matrices.html#void gpu::flip(const GpuMat& a, GpuMat& b, int flipCode, Stream& stream)"><strong>gpu::flip (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/gpu/doc/image_filtering.html#void gpu::GaussianBlur(const GpuMat& src, GpuMat& dst, Size ksize, GpuMat& buf, double sigma1, double sigma2, int rowBorderType, int columnBorderType, Stream& stream)"><strong>gpu::GaussianBlur (C++ function)</strong></a>, <a href="modules/gpu/doc/image_filtering.html#void gpu::GaussianBlur(const GpuMat& src, GpuMat& dst, Size ksize, double sigma1, double sigma2, int rowBorderType, int columnBorderType)"><strong>[1]</strong></a>
  </dt>

      
  <dt><a href="modules/gpu/doc/operations_on_matrices.html#void gpu::gemm(const GpuMat& src1, const GpuMat& src2, double alpha, const GpuMat& src3, double beta, GpuMat& dst, int flags , Stream& stream)"><strong>gpu::gemm (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/gpu/doc/image_filtering.html#Ptr<BaseFilter_GPU> gpu::getBoxFilter_GPU(int srcType, int dstType, const Size& ksize, Point anchor)"><strong>gpu::getBoxFilter_GPU (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/gpu/doc/image_filtering.html#Ptr<BaseColumnFilter_GPU> gpu::getColumnSumFilter_GPU(int sumType, int dstType, int ksize, int anchor)"><strong>gpu::getColumnSumFilter_GPU (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/gpu/doc/initalization_and_information.html#int gpu::getCudaEnabledDeviceCount()"><strong>gpu::getCudaEnabledDeviceCount (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/gpu/doc/initalization_and_information.html#int gpu::getDevice()"><strong>gpu::getDevice (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/gpu/doc/image_filtering.html#Ptr<BaseColumnFilter_GPU> gpu::getLinearColumnFilter_GPU(int bufType, int dstType, const Mat& columnKernel, int anchor, int borderType)"><strong>gpu::getLinearColumnFilter_GPU (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/gpu/doc/image_filtering.html#Ptr<BaseRowFilter_GPU> gpu::getLinearRowFilter_GPU(int srcType, int bufType, const Mat& rowKernel, int anchor, int borderType)"><strong>gpu::getLinearRowFilter_GPU (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/gpu/doc/image_filtering.html#Ptr<BaseFilter_GPU> gpu::getMaxFilter_GPU(int srcType, int dstType, const Size& ksize, Point anchor)"><strong>gpu::getMaxFilter_GPU (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/gpu/doc/image_filtering.html#Ptr<BaseFilter_GPU> gpu::getMinFilter_GPU(int srcType, int dstType, const Size& ksize, Point anchor)"><strong>gpu::getMinFilter_GPU (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/gpu/doc/image_filtering.html#Ptr<BaseFilter_GPU> gpu::getMorphologyFilter_GPU(int op, int type, const Mat& kernel, const Size& ksize, Point anchor)"><strong>gpu::getMorphologyFilter_GPU (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/gpu/doc/image_filtering.html#Ptr<BaseRowFilter_GPU> gpu::getRowSumFilter_GPU(int srcType, int sumType, int ksize, int anchor)"><strong>gpu::getRowSumFilter_GPU (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/gpu/doc/video.html#gpu::GMG_GPU"><strong>gpu::GMG_GPU (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/gpu/doc/video.html#float backgroundPrior"><strong>gpu::GMG_GPU::backgroundPrior (C++ member)</strong></a>
  </dt>

      
  <dt><a href="modules/gpu/doc/video.html#float decisionThreshold"><strong>gpu::GMG_GPU::decisionThreshold (C++ member)</strong></a>
  </dt>

      
  <dt><a href="modules/gpu/doc/video.html#gpu::GMG_GPU::GMG_GPU()"><strong>gpu::GMG_GPU::GMG_GPU (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/gpu/doc/video.html#void gpu::GMG_GPU::initialize(Size frameSize, float min , float max)"><strong>gpu::GMG_GPU::initialize (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/gpu/doc/video.html#float learningRate"><strong>gpu::GMG_GPU::learningRate (C++ member)</strong></a>
  </dt>

      
  <dt><a href="modules/gpu/doc/video.html#int maxFeatures"><strong>gpu::GMG_GPU::maxFeatures (C++ member)</strong></a>
  </dt>

      
  <dt><a href="modules/gpu/doc/video.html#int numInitializationFrames"><strong>gpu::GMG_GPU::numInitializationFrames (C++ member)</strong></a>
  </dt>

      
  <dt><a href="modules/gpu/doc/video.html#void gpu::GMG_GPU::operator ()(const GpuMat& frame, GpuMat& fgmask, float learningRate, Stream& stream)"><strong>gpu::GMG_GPU::operator() (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/gpu/doc/video.html#int quantizationLevels"><strong>gpu::GMG_GPU::quantizationLevels (C++ member)</strong></a>
  </dt>

      
  <dt><a href="modules/gpu/doc/video.html#void gpu::GMG_GPU::release()"><strong>gpu::GMG_GPU::release (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/gpu/doc/video.html#float smoothingRadius"><strong>gpu::GMG_GPU::smoothingRadius (C++ member)</strong></a>
  </dt>

      
  <dt><a href="modules/gpu/doc/video.html#gpu::GoodFeaturesToTrackDetector_GPU"><strong>gpu::GoodFeaturesToTrackDetector_GPU (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/gpu/doc/video.html#gpu::GoodFeaturesToTrackDetector_GPU::GoodFeaturesToTrackDetector_GPU(int maxCorners , double qualityLevel , double minDistance , int blockSize , bool useHarrisDetector , double harrisK)"><strong>gpu::GoodFeaturesToTrackDetector_GPU::GoodFeaturesToTrackDetector_GPU (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/gpu/doc/video.html#void gpu::GoodFeaturesToTrackDetector_GPU::operator ()(const GpuMat& image, GpuMat& corners, const GpuMat& mask)"><strong>gpu::GoodFeaturesToTrackDetector_GPU::operator() (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/gpu/doc/video.html#void gpu::GoodFeaturesToTrackDetector_GPU::releaseMemory()"><strong>gpu::GoodFeaturesToTrackDetector_GPU::releaseMemory (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/gpu/doc/data_structures.html#gpu::GpuMat"><strong>gpu::GpuMat (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/gpu/doc/image_processing.html#void gpu::histEven(const GpuMat& src, GpuMat hist[4], GpuMat& buf, int histSize[4], int lowerLevel[4], int upperLevel[4], Stream& stream)"><strong>gpu::histEven (C++ function)</strong></a>, <a href="modules/gpu/doc/image_processing.html#void gpu::histEven(const GpuMat& src, GpuMat hist[4], int histSize[4], int lowerLevel[4], int upperLevel[4], Stream& stream)"><strong>[1]</strong></a>, <a href="modules/gpu/doc/image_processing.html#void gpu::histEven(const GpuMat& src, GpuMat& hist, GpuMat& buf, int histSize, int lowerLevel, int upperLevel, Stream& stream)"><strong>[2]</strong></a>, <a href="modules/gpu/doc/image_processing.html#void gpu::histEven(const GpuMat& src, GpuMat& hist, int histSize, int lowerLevel, int upperLevel, Stream& stream)"><strong>[3]</strong></a>
  </dt>

      
  <dt><a href="modules/gpu/doc/image_processing.html#void gpu::histRange(const GpuMat& src, GpuMat& hist, const GpuMat& levels, GpuMat& buf, Stream& stream)"><strong>gpu::histRange (C++ function)</strong></a>, <a href="modules/gpu/doc/image_processing.html#void gpu::histRange(const GpuMat& src, GpuMat& hist, const GpuMat& levels, Stream& stream)"><strong>[1]</strong></a>
  </dt>

      
  <dt><a href="modules/gpu/doc/object_detection.html#gpu::HOGDescriptor"><strong>gpu::HOGDescriptor (C++ structure)</strong></a>
  </dt>

      
  <dt><a href="modules/gpu/doc/object_detection.html#void gpu::HOGDescriptor::detect(const GpuMat& img, vector<Point>& found_locations, double hit_threshold, Size win_stride, Size padding)"><strong>gpu::HOGDescriptor::detect (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/gpu/doc/object_detection.html#void gpu::HOGDescriptor::detectMultiScale(const GpuMat& img, vector<Rect>& found_locations, double hit_threshold, Size win_stride, Size padding, double scale0, int group_threshold)"><strong>gpu::HOGDescriptor::detectMultiScale (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/gpu/doc/object_detection.html#size_t gpu::HOGDescriptor::getBlockHistogramSize() const"><strong>gpu::HOGDescriptor::getBlockHistogramSize (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/gpu/doc/object_detection.html#static vector<float> gpu::HOGDescriptor::getDefaultPeopleDetector()"><strong>gpu::HOGDescriptor::getDefaultPeopleDetector (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/gpu/doc/object_detection.html#void gpu::HOGDescriptor::getDescriptors(const GpuMat& img, Size win_stride, GpuMat& descriptors, int descr_format)"><strong>gpu::HOGDescriptor::getDescriptors (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/gpu/doc/object_detection.html#size_t gpu::HOGDescriptor::getDescriptorSize() const"><strong>gpu::HOGDescriptor::getDescriptorSize (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/gpu/doc/object_detection.html#static vector<float> gpu::HOGDescriptor::getPeopleDetector48x96()"><strong>gpu::HOGDescriptor::getPeopleDetector48x96 (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/gpu/doc/object_detection.html#static vector<float> gpu::HOGDescriptor::getPeopleDetector64x128()"><strong>gpu::HOGDescriptor::getPeopleDetector64x128 (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/gpu/doc/object_detection.html#gpu::HOGDescriptor::HOGDescriptor(Size win_size, Size block_size, Size block_stride, Size cell_size, int nbins, double win_sigma, double threshold_L2hys, bool gamma_correction, int nlevels)"><strong>gpu::HOGDescriptor::HOGDescriptor (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/gpu/doc/object_detection.html#void gpu::HOGDescriptor::setSVMDetector(const vector<float>& detector)"><strong>gpu::HOGDescriptor::setSVMDetector (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/gpu/doc/image_processing.html#void gpu::HoughCircles(const GpuMat& src, GpuMat& circles, HoughCirclesBuf& buf, int method, float dp, float minDist, int cannyThreshold, int votesThreshold, int minRadius, int maxRadius, int maxCircles)"><strong>gpu::HoughCircles (C++ function)</strong></a>, <a href="modules/gpu/doc/image_processing.html#void gpu::HoughCircles(const GpuMat& src, GpuMat& circles, int method, float dp, float minDist, int cannyThreshold, int votesThreshold, int minRadius, int maxRadius, int maxCircles)"><strong>[1]</strong></a>
  </dt>

      
  <dt><a href="modules/gpu/doc/image_processing.html#void gpu::HoughCirclesDownload(const GpuMat& d_circles, OutputArray h_circles)"><strong>gpu::HoughCirclesDownload (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/gpu/doc/image_processing.html#void gpu::HoughLines(const GpuMat& src, GpuMat& lines, HoughLinesBuf& buf, float rho, float theta, int threshold, bool doSort , int maxLines)"><strong>gpu::HoughLines (C++ function)</strong></a>, <a href="modules/gpu/doc/image_processing.html#void gpu::HoughLines(const GpuMat& src, GpuMat& lines, float rho, float theta, int threshold, bool doSort , int maxLines)"><strong>[1]</strong></a>
  </dt>

      
  <dt><a href="modules/gpu/doc/image_processing.html#void gpu::HoughLinesDownload(const GpuMat& d_lines, OutputArray h_lines, OutputArray h_votes)"><strong>gpu::HoughLinesDownload (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/gpu/doc/image_processing.html#void gpu::integral(const GpuMat& src, GpuMat& sum, Stream& stream)"><strong>gpu::integral (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/gpu/doc/video.html#void gpu::interpolateFrames(const GpuMat& frame0, const GpuMat& frame1, const GpuMat& fu, const GpuMat& fv, const GpuMat& bu, const GpuMat& bv, float pos, GpuMat& newFrame, GpuMat& buf, Stream& stream)"><strong>gpu::interpolateFrames (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/gpu/doc/image_filtering.html#void gpu::Laplacian(const GpuMat& src, GpuMat& dst, int ddepth, int ksize , double scale , int borderType , Stream& stream)"><strong>gpu::Laplacian (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/gpu/doc/per_element_operations.html#void gpu::log(const GpuMat& a, GpuMat& b, Stream& stream)"><strong>gpu::log (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/gpu/doc/per_element_operations.html#void gpu::lshift(const GpuMat& src, Scalar_<int> sc, GpuMat& dst, Stream& stream)"><strong>gpu::lshift (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/gpu/doc/operations_on_matrices.html#void gpu::LUT(const GpuMat& src, const Mat& lut, GpuMat& dst, Stream& stream)"><strong>gpu::LUT (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/gpu/doc/operations_on_matrices.html#void gpu::magnitude(const GpuMat& x, const GpuMat& y, GpuMat& magnitude, Stream& stream)"><strong>gpu::magnitude (C++ function)</strong></a>, <a href="modules/gpu/doc/operations_on_matrices.html#void gpu::magnitude(const GpuMat& xy, GpuMat& magnitude, Stream& stream)"><strong>[1]</strong></a>
  </dt>

      
  <dt><a href="modules/gpu/doc/operations_on_matrices.html#void gpu::magnitudeSqr(const GpuMat& x, const GpuMat& y, GpuMat& magnitude, Stream& stream)"><strong>gpu::magnitudeSqr (C++ function)</strong></a>, <a href="modules/gpu/doc/operations_on_matrices.html#void gpu::magnitudeSqr(const GpuMat& xy, GpuMat& magnitude, Stream& stream)"><strong>[1]</strong></a>
  </dt>

      
  <dt><a href="modules/gpu/doc/image_processing.html#void gpu::matchTemplate(const GpuMat& image, const GpuMat& templ, GpuMat& result, int method, MatchTemplateBuf &buf, Stream& stream)"><strong>gpu::matchTemplate (C++ function)</strong></a>, <a href="modules/gpu/doc/image_processing.html#void gpu::matchTemplate(const GpuMat& image, const GpuMat& templ, GpuMat& result, int method, Stream &stream)"><strong>[1]</strong></a>
  </dt>

      
  <dt><a href="modules/gpu/doc/image_processing.html#gpu::MatchTemplateBuf"><strong>gpu::MatchTemplateBuf (C++ structure)</strong></a>
  </dt>

      
  <dt><a href="modules/gpu/doc/per_element_operations.html#void gpu::max(const GpuMat& src1, const GpuMat& src2, GpuMat& dst, Stream& stream)"><strong>gpu::max (C++ function)</strong></a>, <a href="modules/gpu/doc/per_element_operations.html#void gpu::max(const GpuMat& src1, double src2, GpuMat& dst, Stream& stream)"><strong>[1]</strong></a>
  </dt>

      
  <dt><a href="modules/gpu/doc/image_processing.html#void gpu::meanShiftFiltering(const GpuMat& src, GpuMat& dst, int sp, int sr, TermCriteria criteria, Stream& stream)"><strong>gpu::meanShiftFiltering (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/gpu/doc/image_processing.html#void gpu::meanShiftProc(const GpuMat& src, GpuMat& dstr, GpuMat& dstsp, int sp, int sr, TermCriteria criteria, Stream& stream)"><strong>gpu::meanShiftProc (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/gpu/doc/image_processing.html#void gpu::meanShiftSegmentation(const GpuMat& src, Mat& dst, int sp, int sr, int minsize, TermCriteria criteria)"><strong>gpu::meanShiftSegmentation (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/gpu/doc/matrix_reductions.html#void gpu::meanStdDev(const GpuMat& mtx, Scalar& mean, Scalar& stddev)"><strong>gpu::meanStdDev (C++ function)</strong></a>, <a href="modules/gpu/doc/matrix_reductions.html#void gpu::meanStdDev(const GpuMat& mtx, Scalar& mean, Scalar& stddev, GpuMat& buf)"><strong>[1]</strong></a>
  </dt>

      
  <dt><a href="modules/gpu/doc/operations_on_matrices.html#void gpu::merge(const GpuMat* src, size_t n, GpuMat& dst, Stream& stream)"><strong>gpu::merge (C++ function)</strong></a>, <a href="modules/gpu/doc/operations_on_matrices.html#void gpu::merge(const vector<GpuMat>& src, GpuMat& dst, Stream& stream)"><strong>[1]</strong></a>
  </dt>

      
  <dt><a href="modules/gpu/doc/per_element_operations.html#void gpu::min(const GpuMat& src1, const GpuMat& src2, GpuMat& dst, Stream& stream)"><strong>gpu::min (C++ function)</strong></a>, <a href="modules/gpu/doc/per_element_operations.html#void gpu::min(const GpuMat& src1, double src2, GpuMat& dst, Stream& stream)"><strong>[1]</strong></a>
  </dt>

      
  <dt><a href="modules/gpu/doc/matrix_reductions.html#void gpu::minMax(const GpuMat& src, double* minVal, double* maxVal, const GpuMat& mask)"><strong>gpu::minMax (C++ function)</strong></a>, <a href="modules/gpu/doc/matrix_reductions.html#void gpu::minMax(const GpuMat& src, double* minVal, double* maxVal, const GpuMat& mask, GpuMat& buf)"><strong>[1]</strong></a>
  </dt>

      
  <dt><a href="modules/gpu/doc/matrix_reductions.html#void gpu::minMaxLoc(const GpuMat& src, double* minVal, double* maxVal, Point* minLoc, Point* maxLoc, const GpuMat& mask)"><strong>gpu::minMaxLoc (C++ function)</strong></a>, <a href="modules/gpu/doc/matrix_reductions.html#void gpu::minMaxLoc(const GpuMat& src, double* minVal, double* maxVal, Point* minLoc, Point* maxLoc, const GpuMat& mask, GpuMat& valbuf, GpuMat& locbuf)"><strong>[1]</strong></a>
  </dt>

      
  <dt><a href="modules/gpu/doc/video.html#gpu::MOG2_GPU"><strong>gpu::MOG2_GPU (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/gpu/doc/video.html#float backgroundRatio"><strong>gpu::MOG2_GPU::backgroundRatio (C++ member)</strong></a>
  </dt>

      
  <dt><a href="modules/gpu/doc/video.html#bool bShadowDetection"><strong>gpu::MOG2_GPU::bShadowDetection (C++ member)</strong></a>
  </dt>

      
  <dt><a href="modules/gpu/doc/video.html#float fCT"><strong>gpu::MOG2_GPU::fCT (C++ member)</strong></a>
  </dt>

      
  <dt><a href="modules/gpu/doc/video.html#float fTau"><strong>gpu::MOG2_GPU::fTau (C++ member)</strong></a>
  </dt>

      
  <dt><a href="modules/gpu/doc/video.html#float fVarInit"><strong>gpu::MOG2_GPU::fVarInit (C++ member)</strong></a>
  </dt>

      
  <dt><a href="modules/gpu/doc/video.html#float fVarMax"><strong>gpu::MOG2_GPU::fVarMax (C++ member)</strong></a>
  </dt>

      
  <dt><a href="modules/gpu/doc/video.html#float fVarMin"><strong>gpu::MOG2_GPU::fVarMin (C++ member)</strong></a>
  </dt>

      
  <dt><a href="modules/gpu/doc/video.html#void gpu::MOG2_GPU::getBackgroundImage(GpuMat& backgroundImage, Stream& stream) const"><strong>gpu::MOG2_GPU::getBackgroundImage (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/gpu/doc/video.html#gpu::MOG2_GPU::MOG2_GPU(int nmixtures)"><strong>gpu::MOG2_GPU::MOG2_GPU (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/gpu/doc/video.html#uchar nShadowDetection"><strong>gpu::MOG2_GPU::nShadowDetection (C++ member)</strong></a>
  </dt>

      
  <dt><a href="modules/gpu/doc/video.html#void gpu::MOG2_GPU::operator()(const GpuMat& frame, GpuMat& fgmask, float learningRate, Stream& stream)"><strong>gpu::MOG2_GPU::operator() (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/gpu/doc/video.html#void gpu::MOG2_GPU::release()"><strong>gpu::MOG2_GPU::release (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/gpu/doc/video.html#float varThreshold"><strong>gpu::MOG2_GPU::varThreshold (C++ member)</strong></a>
  </dt>

      
  <dt><a href="modules/gpu/doc/video.html#gpu::MOG_GPU"><strong>gpu::MOG_GPU (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/gpu/doc/video.html#void gpu::MOG_GPU::getBackgroundImage(GpuMat& backgroundImage, Stream& stream) const"><strong>gpu::MOG_GPU::getBackgroundImage (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/gpu/doc/video.html#gpu::MOG_GPU::MOG_GPU(int nmixtures)"><strong>gpu::MOG_GPU::MOG_GPU (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/gpu/doc/video.html#void gpu::MOG_GPU::operator()(const GpuMat& frame, GpuMat& fgmask, float learningRate , Stream& stream)"><strong>gpu::MOG_GPU::operator() (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/gpu/doc/video.html#void gpu::MOG_GPU::release()"><strong>gpu::MOG_GPU::release (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/gpu/doc/image_filtering.html#void gpu::morphologyEx(const GpuMat& src, GpuMat& dst, int op, const Mat& kernel, GpuMat& buf1, GpuMat& buf2, Point anchor, int iterations, Stream& stream)"><strong>gpu::morphologyEx (C++ function)</strong></a>, <a href="modules/gpu/doc/image_filtering.html#void gpu::morphologyEx(const GpuMat& src, GpuMat& dst, int op, const Mat& kernel, Point anchor, int iterations)"><strong>[1]</strong></a>
  </dt>

      
  <dt><a href="modules/gpu/doc/image_processing.html#void gpu::mulAndScaleSpectrums(const GpuMat& a, const GpuMat& b, GpuMat& c, int flags, float scale, bool conjB, Stream& stream)"><strong>gpu::mulAndScaleSpectrums (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/gpu/doc/image_processing.html#void gpu::mulSpectrums(const GpuMat& a, const GpuMat& b, GpuMat& c, int flags, bool conjB, Stream& stream)"><strong>gpu::mulSpectrums (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/gpu/doc/per_element_operations.html#void gpu::multiply(const GpuMat& a, const GpuMat& b, GpuMat& c, double scale, int dtype, Stream& stream)"><strong>gpu::multiply (C++ function)</strong></a>, <a href="modules/gpu/doc/per_element_operations.html#void gpu::multiply(const GpuMat& a, const Scalar& sc, GpuMat& c, double scale, int dtype, Stream& stream)"><strong>[1]</strong></a>
  </dt>

      
  <dt><a href="modules/gpu/doc/image_processing.html#void gpu::nonLocalMeans(const GpuMat& src, GpuMat& dst, float h, int search_window , int block_size , int borderMode , Stream& s)"><strong>gpu::nonLocalMeans (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/gpu/doc/matrix_reductions.html#double gpu::norm(const GpuMat& src1, const GpuMat& src2, int normType)"><strong>gpu::norm (C++ function)</strong></a>, <a href="modules/gpu/doc/matrix_reductions.html#double gpu::norm(const GpuMat& src1, int normType)"><strong>[1]</strong></a>, <a href="modules/gpu/doc/matrix_reductions.html#double gpu::norm(const GpuMat& src1, int normType, GpuMat& buf)"><strong>[2]</strong></a>, <a href="modules/gpu/doc/matrix_reductions.html#double gpu::norm(const GpuMat& src1, int normType, const GpuMat& mask, GpuMat& buf)"><strong>[3]</strong></a>
  </dt>

      
  <dt><a href="modules/gpu/doc/operations_on_matrices.html#void gpu::normalize(const GpuMat& src, GpuMat& dst, double a, double b, int norm_type, int dtype, const GpuMat& mask, GpuMat& norm_buf, GpuMat& cvt_buf)"><strong>gpu::normalize (C++ function)</strong></a>, <a href="modules/gpu/doc/operations_on_matrices.html#void gpu::normalize(const GpuMat& src, GpuMat& dst, double alpha , double beta , int norm_type , int dtype , const GpuMat& mask)"><strong>[1]</strong></a>
  </dt>

      
  <dt><a href="modules/gpu/doc/feature_detection_and_description.html#gpu::ORB_GPU"><strong>gpu::ORB_GPU (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/gpu/doc/feature_detection_and_description.html#void gpu::ORB_GPU::convertKeyPoints(Mat& d_keypoints, std::vector<KeyPoint>& keypoints)"><strong>gpu::ORB_GPU::convertKeyPoints (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/gpu/doc/feature_detection_and_description.html#void gpu::ORB_GPU::downloadKeyPoints(GpuMat& d_keypoints, std::vector<KeyPoint>& keypoints)"><strong>gpu::ORB_GPU::downloadKeyPoints (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/gpu/doc/feature_detection_and_description.html#void gpu::ORB_GPU::operator()(const GpuMat& image, const GpuMat& mask, GpuMat& keypoints)"><strong>gpu::ORB_GPU::operator() (C++ function)</strong></a>, <a href="modules/gpu/doc/feature_detection_and_description.html#void gpu::ORB_GPU::operator()(const GpuMat& image, const GpuMat& mask, GpuMat& keypoints, GpuMat& descriptors)"><strong>[1]</strong></a>, <a href="modules/gpu/doc/feature_detection_and_description.html#void gpu::ORB_GPU::operator()(const GpuMat& image, const GpuMat& mask, std::vector<KeyPoint>& keypoints)"><strong>[2]</strong></a>, <a href="modules/gpu/doc/feature_detection_and_description.html#void gpu::ORB_GPU::operator()(const GpuMat& image, const GpuMat& mask, std::vector<KeyPoint>& keypoints, GpuMat& descriptors)"><strong>[3]</strong></a>
  </dt>

      
  <dt><a href="modules/gpu/doc/feature_detection_and_description.html#gpu::ORB_GPU::ORB_GPU(int nFeatures , float scaleFactor , int nLevels , int edgeThreshold , int firstLevel , int WTA_K , int scoreType , int patchSize)"><strong>gpu::ORB_GPU::ORB_GPU (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/gpu/doc/feature_detection_and_description.html#void gpu::ORB_GPU::release()"><strong>gpu::ORB_GPU::release (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/gpu/doc/operations_on_matrices.html#void gpu::phase(const GpuMat& x, const GpuMat& y, GpuMat& angle, bool angleInDegrees, Stream& stream)"><strong>gpu::phase (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/gpu/doc/operations_on_matrices.html#void gpu::polarToCart(const GpuMat& magnitude, const GpuMat& angle, GpuMat& x, GpuMat& y, bool angleInDegrees, Stream& stream)"><strong>gpu::polarToCart (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/gpu/doc/per_element_operations.html#void gpu::pow(const GpuMat& src, double power, GpuMat& dst, Stream& stream)"><strong>gpu::pow (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/gpu/doc/data_structures.html#gpu::PtrStep"><strong>gpu::PtrStep (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/gpu/doc/data_structures.html#gpu::PtrStepSz"><strong>gpu::PtrStepSz (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/gpu/doc/image_processing.html#void gpu::pyrDown(const GpuMat& src, GpuMat& dst, Stream& stream)"><strong>gpu::pyrDown (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/gpu/doc/video.html#gpu::PyrLKOpticalFlow"><strong>gpu::PyrLKOpticalFlow (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/gpu/doc/video.html#void gpu::PyrLKOpticalFlow::dense(const GpuMat& prevImg, const GpuMat& nextImg, GpuMat& u, GpuMat& v, GpuMat* err)"><strong>gpu::PyrLKOpticalFlow::dense (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/gpu/doc/video.html#void gpu::PyrLKOpticalFlow::releaseMemory()"><strong>gpu::PyrLKOpticalFlow::releaseMemory (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/gpu/doc/video.html#void gpu::PyrLKOpticalFlow::sparse(const GpuMat& prevImg, const GpuMat& nextImg, const GpuMat& prevPts, GpuMat& nextPts, GpuMat& status, GpuMat* err)"><strong>gpu::PyrLKOpticalFlow::sparse (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/gpu/doc/image_processing.html#void gpu::pyrUp(const GpuMat& src, GpuMat& dst, Stream& stream)"><strong>gpu::pyrUp (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/gpu/doc/image_processing.html#void gpu::rectStdDev(const GpuMat& src, const GpuMat& sqr, GpuMat& dst, const Rect& rect, Stream& stream)"><strong>gpu::rectStdDev (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/gpu/doc/matrix_reductions.html#void gpu::reduce(const GpuMat& mtx, GpuMat& vec, int dim, int reduceOp, int dtype , Stream& stream)"><strong>gpu::reduce (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/gpu/doc/data_structures.html#void gpu::registerPageLocked(Mat& m)"><strong>gpu::registerPageLocked (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/gpu/doc/image_processing.html#void gpu::remap(const GpuMat& src, GpuMat& dst, const GpuMat& xmap, const GpuMat& ymap, int interpolation, int borderMode, Scalar borderValue, Stream& stream)"><strong>gpu::remap (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/gpu/doc/camera_calibration_and_3d_reconstruction.html#void gpu::reprojectImageTo3D(const GpuMat& disp, GpuMat& xyzw, const Mat& Q, int dst_cn , Stream& stream)"><strong>gpu::reprojectImageTo3D (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/gpu/doc/initalization_and_information.html#void gpu::resetDevice()"><strong>gpu::resetDevice (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/gpu/doc/image_processing.html#void gpu::resize(const GpuMat& src, GpuMat& dst, Size dsize, double fx, double fy, int interpolation , Stream& stream)"><strong>gpu::resize (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/gpu/doc/image_processing.html#void gpu::rotate(const GpuMat& src, GpuMat& dst, Size dsize, double angle, double xShift , double yShift , int interpolation , Stream& stream)"><strong>gpu::rotate (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/gpu/doc/per_element_operations.html#void gpu::rshift(const GpuMat& src, Scalar_<int> sc, GpuMat& dst, Stream& stream)"><strong>gpu::rshift (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/gpu/doc/image_filtering.html#void gpu::Scharr(const GpuMat& src, GpuMat& dst, int ddepth, int dx, int dy, GpuMat& buf, double scale, int rowBorderType, int columnBorderType, Stream& stream)"><strong>gpu::Scharr (C++ function)</strong></a>, <a href="modules/gpu/doc/image_filtering.html#void gpu::Scharr(const GpuMat& src, GpuMat& dst, int ddepth, int dx, int dy, double scale, int rowBorderType, int columnBorderType)"><strong>[1]</strong></a>
  </dt>

      
  <dt><a href="modules/gpu/doc/image_filtering.html#void gpu::sepFilter2D(const GpuMat& src, GpuMat& dst, int ddepth, const Mat& kernelX, const Mat& kernelY, GpuMat& buf, Point anchor, int rowBorderType, int columnBorderType, Stream& stream)"><strong>gpu::sepFilter2D (C++ function)</strong></a>, <a href="modules/gpu/doc/image_filtering.html#void gpu::sepFilter2D(const GpuMat& src, GpuMat& dst, int ddepth, const Mat& kernelX, const Mat& kernelY, Point anchor, int rowBorderType, int columnBorderType)"><strong>[1]</strong></a>
  </dt>

      
  <dt><a href="modules/gpu/doc/initalization_and_information.html#void gpu::setDevice(int device)"><strong>gpu::setDevice (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/opengl_interop.html#void gpu::setGlDevice(int device)"><strong>gpu::setGlDevice (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/gpu/doc/image_filtering.html#void gpu::Sobel(const GpuMat& src, GpuMat& dst, int ddepth, int dx, int dy, GpuMat& buf, int ksize, double scale, int rowBorderType, int columnBorderType, Stream& stream)"><strong>gpu::Sobel (C++ function)</strong></a>, <a href="modules/gpu/doc/image_filtering.html#void gpu::Sobel(const GpuMat& src, GpuMat& dst, int ddepth, int dx, int dy, int ksize, double scale, int rowBorderType, int columnBorderType)"><strong>[1]</strong></a>
  </dt>

      
  <dt><a href="modules/gpu/doc/camera_calibration_and_3d_reconstruction.html#void gpu::solvePnPRansac(const Mat& object, const Mat& image, const Mat& camera_mat, const Mat& dist_coef, Mat& rvec, Mat& tvec, bool use_extrinsic_guess, int num_iters, float max_dist, int min_inlier_count, vector<int>* inliers)"><strong>gpu::solvePnPRansac (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/gpu/doc/operations_on_matrices.html#void gpu::split(const GpuMat& src, GpuMat* dst, Stream& stream)"><strong>gpu::split (C++ function)</strong></a>, <a href="modules/gpu/doc/operations_on_matrices.html#void gpu::split(const GpuMat& src, vector<GpuMat>& dst, Stream& stream)"><strong>[1]</strong></a>
  </dt>

      
  <dt><a href="modules/gpu/doc/per_element_operations.html#void gpu::sqr(const GpuMat& src, GpuMat& dst, Stream& stream)"><strong>gpu::sqr (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/gpu/doc/image_processing.html#void gpu::sqrIntegral(const GpuMat& src, GpuMat& sqsum, Stream& stream)"><strong>gpu::sqrIntegral (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/gpu/doc/matrix_reductions.html#Scalar gpu::sqrSum(const GpuMat& src)"><strong>gpu::sqrSum (C++ function)</strong></a>, <a href="modules/gpu/doc/matrix_reductions.html#Scalar gpu::sqrSum(const GpuMat& src, GpuMat& buf)"><strong>[1]</strong></a>, <a href="modules/gpu/doc/matrix_reductions.html#Scalar gpu::sqrSum(const GpuMat& src, const GpuMat& mask, GpuMat& buf)"><strong>[2]</strong></a>
  </dt>

      
  <dt><a href="modules/gpu/doc/per_element_operations.html#void gpu::sqrt(const GpuMat& src, GpuMat& dst, Stream& stream)"><strong>gpu::sqrt (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/gpu/doc/camera_calibration_and_3d_reconstruction.html#gpu::StereoBeliefPropagation"><strong>gpu::StereoBeliefPropagation (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/gpu/doc/camera_calibration_and_3d_reconstruction.html#void gpu::StereoBeliefPropagation::estimateRecommendedParams(int width, int height, int& ndisp, int& iters, int& levels)"><strong>gpu::StereoBeliefPropagation::estimateRecommendedParams (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/gpu/doc/camera_calibration_and_3d_reconstruction.html#void gpu::StereoBeliefPropagation::operator ()(const GpuMat& data, GpuMat& disparity, Stream& stream)"><strong>gpu::StereoBeliefPropagation::operator() (C++ function)</strong></a>, <a href="modules/gpu/doc/camera_calibration_and_3d_reconstruction.html#void gpu::StereoBeliefPropagation::operator ()(const GpuMat& left, const GpuMat& right, GpuMat& disparity, Stream& stream)"><strong>[1]</strong></a>
  </dt>

      
  <dt><a href="modules/gpu/doc/camera_calibration_and_3d_reconstruction.html#gpu::StereoBeliefPropagation::StereoBeliefPropagation(int ndisp , int iters , int levels , int msg_type)"><strong>gpu::StereoBeliefPropagation::StereoBeliefPropagation (C++ function)</strong></a>, <a href="modules/gpu/doc/camera_calibration_and_3d_reconstruction.html#gpu::StereoBeliefPropagation::StereoBeliefPropagation(int ndisp, int iters, int levels, float max_data_term, float data_weight, float max_disc_term, float disc_single_jump, int msg_type)"><strong>[1]</strong></a>
  </dt>

      
  <dt><a href="modules/gpu/doc/camera_calibration_and_3d_reconstruction.html#gpu::StereoBM_GPU"><strong>gpu::StereoBM_GPU (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/gpu/doc/camera_calibration_and_3d_reconstruction.html#bool gpu::StereoBM_GPU::checkIfGpuCallReasonable()"><strong>gpu::StereoBM_GPU::checkIfGpuCallReasonable (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/gpu/doc/camera_calibration_and_3d_reconstruction.html#void gpu::StereoBM_GPU::operator ()(const GpuMat& left, const GpuMat& right, GpuMat& disparity, Stream& stream)"><strong>gpu::StereoBM_GPU::operator() (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/gpu/doc/camera_calibration_and_3d_reconstruction.html#gpu::StereoBM_GPU::StereoBM_GPU()"><strong>gpu::StereoBM_GPU::StereoBM_GPU (C++ function)</strong></a>, <a href="modules/gpu/doc/camera_calibration_and_3d_reconstruction.html#gpu::StereoBM_GPU::StereoBM_GPU(int preset, int ndisparities , int winSize)"><strong>[1]</strong></a>
  </dt>

      
  <dt><a href="modules/gpu/doc/camera_calibration_and_3d_reconstruction.html#gpu::StereoConstantSpaceBP"><strong>gpu::StereoConstantSpaceBP (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/gpu/doc/camera_calibration_and_3d_reconstruction.html#void gpu::StereoConstantSpaceBP::estimateRecommendedParams(int width, int height, int& ndisp, int& iters, int& levels, int& nr_plane)"><strong>gpu::StereoConstantSpaceBP::estimateRecommendedParams (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/gpu/doc/camera_calibration_and_3d_reconstruction.html#void gpu::StereoConstantSpaceBP::operator ()(const GpuMat& left, const GpuMat& right, GpuMat& disparity, Stream& stream)"><strong>gpu::StereoConstantSpaceBP::operator() (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/gpu/doc/camera_calibration_and_3d_reconstruction.html#gpu::StereoConstantSpaceBP::StereoConstantSpaceBP(int ndisp , int iters , int levels , int nr_plane , int msg_type)"><strong>gpu::StereoConstantSpaceBP::StereoConstantSpaceBP (C++ function)</strong></a>, <a href="modules/gpu/doc/camera_calibration_and_3d_reconstruction.html#gpu::StereoConstantSpaceBP::StereoConstantSpaceBP(int ndisp, int iters, int levels, int nr_plane, float max_data_term, float data_weight, float max_disc_term, float disc_single_jump, int min_disp_th , int msg_type)"><strong>[1]</strong></a>
  </dt>

      
  <dt><a href="modules/gpu/doc/data_structures.html#gpu::Stream"><strong>gpu::Stream (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/gpu/doc/data_structures.html#void gpu::Stream::enqueueConvert(const GpuMat& src, GpuMat& dst, int dtype, double a, double b)"><strong>gpu::Stream::enqueueConvert (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/gpu/doc/data_structures.html#void gpu::Stream::enqueueCopy(const GpuMat& src, GpuMat& dst)"><strong>gpu::Stream::enqueueCopy (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/gpu/doc/data_structures.html#void gpu::Stream::enqueueDownload(const GpuMat& src, CudaMem& dst)"><strong>gpu::Stream::enqueueDownload (C++ function)</strong></a>, <a href="modules/gpu/doc/data_structures.html#void gpu::Stream::enqueueDownload(const GpuMat& src, Mat& dst)"><strong>[1]</strong></a>
  </dt>

      
  <dt><a href="modules/gpu/doc/data_structures.html#void gpu::Stream::enqueueHostCallback(StreamCallback callback, void* userData)"><strong>gpu::Stream::enqueueHostCallback (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/gpu/doc/data_structures.html#void gpu::Stream::enqueueMemSet(GpuMat& src, Scalar val)"><strong>gpu::Stream::enqueueMemSet (C++ function)</strong></a>, <a href="modules/gpu/doc/data_structures.html#void gpu::Stream::enqueueMemSet(GpuMat& src, Scalar val, const GpuMat& mask)"><strong>[1]</strong></a>
  </dt>

      
  <dt><a href="modules/gpu/doc/data_structures.html#void gpu::Stream::enqueueUpload(const CudaMem& src, GpuMat& dst)"><strong>gpu::Stream::enqueueUpload (C++ function)</strong></a>, <a href="modules/gpu/doc/data_structures.html#void gpu::Stream::enqueueUpload(const Mat& src, GpuMat& dst)"><strong>[1]</strong></a>
  </dt>

      
  <dt><a href="modules/gpu/doc/data_structures.html#bool gpu::Stream::queryIfComplete()"><strong>gpu::Stream::queryIfComplete (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/gpu/doc/data_structures.html#void gpu::Stream::waitForCompletion()"><strong>gpu::Stream::waitForCompletion (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/gpu/doc/data_structures.html#gpu::StreamAccessor"><strong>gpu::StreamAccessor (C++ structure)</strong></a>
  </dt>

      
  <dt><a href="modules/gpu/doc/per_element_operations.html#void gpu::subtract(const GpuMat& a, const GpuMat& b, GpuMat& c, const GpuMat& mask, int dtype, Stream& stream)"><strong>gpu::subtract (C++ function)</strong></a>, <a href="modules/gpu/doc/per_element_operations.html#void gpu::subtract(const GpuMat& a, const Scalar& sc, GpuMat& c, const GpuMat& mask, int dtype, Stream& stream)"><strong>[1]</strong></a>
  </dt>

      
  <dt><a href="modules/gpu/doc/matrix_reductions.html#Scalar gpu::sum(const GpuMat& src)"><strong>gpu::sum (C++ function)</strong></a>, <a href="modules/gpu/doc/matrix_reductions.html#Scalar gpu::sum(const GpuMat& src, GpuMat& buf)"><strong>[1]</strong></a>, <a href="modules/gpu/doc/matrix_reductions.html#Scalar gpu::sum(const GpuMat& src, const GpuMat& mask, GpuMat& buf)"><strong>[2]</strong></a>
  </dt>

      
  <dt><a href="modules/nonfree/doc/feature_detection.html#gpu::SURF_GPU"><strong>gpu::SURF_GPU (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/gpu/doc/image_processing.html#void gpu::swapChannels(GpuMat& image, const int dstOrder[4], Stream& stream)"><strong>gpu::swapChannels (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/gpu/doc/initalization_and_information.html#gpu::TargetArchs"><strong>gpu::TargetArchs (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/gpu/doc/initalization_and_information.html#static bool gpu::TargetArchs::builtWith(FeatureSet feature_set)"><strong>gpu::TargetArchs::builtWith (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/gpu/doc/initalization_and_information.html#static bool gpu::TargetArchs::has(int major, int minor)"><strong>gpu::TargetArchs::has (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/gpu/doc/initalization_and_information.html#static bool gpu::TargetArchs::hasBin(int major, int minor)"><strong>gpu::TargetArchs::hasBin (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/gpu/doc/initalization_and_information.html#static bool gpu::TargetArchs::hasEqualOrGreater(int major, int minor)"><strong>gpu::TargetArchs::hasEqualOrGreater (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/gpu/doc/initalization_and_information.html#static bool gpu::TargetArchs::hasEqualOrGreaterBin(int major, int minor)"><strong>gpu::TargetArchs::hasEqualOrGreaterBin (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/gpu/doc/initalization_and_information.html#static bool gpu::TargetArchs::hasEqualOrGreaterPtx(int major, int minor)"><strong>gpu::TargetArchs::hasEqualOrGreaterPtx (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/gpu/doc/initalization_and_information.html#static bool gpu::TargetArchs::hasEqualOrLessPtx(int major, int minor)"><strong>gpu::TargetArchs::hasEqualOrLessPtx (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/gpu/doc/initalization_and_information.html#static bool gpu::TargetArchs::hasPtx(int major, int minor)"><strong>gpu::TargetArchs::hasPtx (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/gpu/doc/image_processing.html#double gpu::threshold(const GpuMat& src, GpuMat& dst, double thresh, double maxval, int type, Stream& stream)"><strong>gpu::threshold (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/gpu/doc/operations_on_matrices.html#void gpu::transpose(const GpuMat& src1, GpuMat& dst, Stream& stream)"><strong>gpu::transpose (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/gpu/doc/data_structures.html#void gpu::unregisterPageLocked(Mat& m)"><strong>gpu::unregisterPageLocked (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/gpu/doc/video.html#gpu::VideoReader_GPU"><strong>gpu::VideoReader_GPU (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/gpu/doc/video.html#gpu::VideoReader_GPU::ChromaFormat"><strong>gpu::VideoReader_GPU::ChromaFormat (enum)</strong></a>
  </dt>

      
  <dt><a href="modules/gpu/doc/video.html#void gpu::VideoReader_GPU::close()"><strong>gpu::VideoReader_GPU::close (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/gpu/doc/video.html#gpu::VideoReader_GPU::Codec"><strong>gpu::VideoReader_GPU::Codec (enum)</strong></a>
  </dt>

      
  <dt><a href="modules/gpu/doc/video.html#void gpu::VideoReader_GPU::dumpFormat(std::ostream& st)"><strong>gpu::VideoReader_GPU::dumpFormat (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/gpu/doc/video.html#FormatInfo gpu::VideoReader_GPU::format() const"><strong>gpu::VideoReader_GPU::format (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/gpu/doc/video.html#gpu::VideoReader_GPU::FormatInfo"><strong>gpu::VideoReader_GPU::FormatInfo (C++ structure)</strong></a>
  </dt>

      
  <dt><a href="modules/gpu/doc/video.html#bool gpu::VideoReader_GPU::isOpened() const"><strong>gpu::VideoReader_GPU::isOpened (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/gpu/doc/video.html#void gpu::VideoReader_GPU::open(const cv::Ptr<VideoSource>& source)"><strong>gpu::VideoReader_GPU::open (C++ function)</strong></a>, <a href="modules/gpu/doc/video.html#void gpu::VideoReader_GPU::open(const std::string& filename)"><strong>[1]</strong></a>
  </dt>

      
  <dt><a href="modules/gpu/doc/video.html#bool gpu::VideoReader_GPU::read(GpuMat& image)"><strong>gpu::VideoReader_GPU::read (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/gpu/doc/video.html#gpu::VideoReader_GPU::VideoReader_GPU()"><strong>gpu::VideoReader_GPU::VideoReader_GPU (C++ function)</strong></a>, <a href="modules/gpu/doc/video.html#gpu::VideoReader_GPU::VideoReader_GPU(const cv::Ptr<VideoSource>& source)"><strong>[1]</strong></a>, <a href="modules/gpu/doc/video.html#gpu::VideoReader_GPU::VideoReader_GPU(const std::string& filename)"><strong>[2]</strong></a>
  </dt>

      
  <dt><a href="modules/gpu/doc/video.html#gpu::VideoReader_GPU::VideoSource"><strong>gpu::VideoReader_GPU::VideoSource (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/gpu/doc/video.html#virtual FormatInfo gpu::VideoReader_GPU::VideoSource::format() const = 0"><strong>gpu::VideoReader_GPU::VideoSource::format (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/gpu/doc/video.html#virtual bool gpu::VideoReader_GPU::VideoSource::hasError() const = 0"><strong>gpu::VideoReader_GPU::VideoSource::hasError (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/gpu/doc/video.html#virtual bool gpu::VideoReader_GPU::VideoSource::isStarted() const = 0"><strong>gpu::VideoReader_GPU::VideoSource::isStarted (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/gpu/doc/video.html#bool gpu::VideoReader_GPU::VideoSource::parseVideoData(const uchar* data, size_t size, bool endOfStream)"><strong>gpu::VideoReader_GPU::VideoSource::parseVideoData (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/gpu/doc/video.html#virtual void gpu::VideoReader_GPU::VideoSource::start() = 0"><strong>gpu::VideoReader_GPU::VideoSource::start (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/gpu/doc/video.html#virtual void gpu::VideoReader_GPU::VideoSource::stop() = 0"><strong>gpu::VideoReader_GPU::VideoSource::stop (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/gpu/doc/video.html#gpu::VideoWriter_GPU"><strong>gpu::VideoWriter_GPU (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/gpu/doc/video.html#void gpu::VideoWriter_GPU::close()"><strong>gpu::VideoWriter_GPU::close (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/gpu/doc/video.html#gpu::VideoWriter_GPU::EncoderCallBack"><strong>gpu::VideoWriter_GPU::EncoderCallBack (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/gpu/doc/video.html#virtual uchar* gpu::VideoWriter_GPU::EncoderCallBack::acquireBitStream(int* bufferSize) = 0"><strong>gpu::VideoWriter_GPU::EncoderCallBack::acquireBitStream (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/gpu/doc/video.html#virtual void gpu::VideoWriter_GPU::EncoderCallBack::onBeginFrame(int frameNumber, PicType picType) = 0"><strong>gpu::VideoWriter_GPU::EncoderCallBack::onBeginFrame (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/gpu/doc/video.html#virtual void gpu::VideoWriter_GPU::EncoderCallBack::onEndFrame(int frameNumber, PicType picType) = 0"><strong>gpu::VideoWriter_GPU::EncoderCallBack::onEndFrame (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/gpu/doc/video.html#virtual void gpu::VideoWriter_GPU::EncoderCallBack::releaseBitStream(unsigned char* data, int size) = 0"><strong>gpu::VideoWriter_GPU::EncoderCallBack::releaseBitStream (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/gpu/doc/video.html#gpu::VideoWriter_GPU::EncoderParams"><strong>gpu::VideoWriter_GPU::EncoderParams (C++ structure)</strong></a>
  </dt>

      
  <dt><a href="modules/gpu/doc/video.html#gpu::VideoWriter_GPU::EncoderParams::EncoderParams()"><strong>gpu::VideoWriter_GPU::EncoderParams::EncoderParams (C++ function)</strong></a>, <a href="modules/gpu/doc/video.html#gpu::VideoWriter_GPU::EncoderParams::EncoderParams(const std::string& configFile)"><strong>[1]</strong></a>
  </dt>

      
  <dt><a href="modules/gpu/doc/video.html#void gpu::VideoWriter_GPU::EncoderParams::load(const std::string& configFile)"><strong>gpu::VideoWriter_GPU::EncoderParams::load (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/gpu/doc/video.html#void gpu::VideoWriter_GPU::EncoderParams::save(const std::string& configFile) const"><strong>gpu::VideoWriter_GPU::EncoderParams::save (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/gpu/doc/video.html#bool gpu::VideoWriter_GPU::isOpened() const"><strong>gpu::VideoWriter_GPU::isOpened (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/gpu/doc/video.html#void gpu::VideoWriter_GPU::open(const cv::Ptr<EncoderCallBack>& encoderCallback, cv::Size frameSize, double fps, SurfaceFormat format)"><strong>gpu::VideoWriter_GPU::open (C++ function)</strong></a>, <a href="modules/gpu/doc/video.html#void gpu::VideoWriter_GPU::open(const cv::Ptr<EncoderCallBack>& encoderCallback, cv::Size frameSize, double fps, const EncoderParams& params, SurfaceFormat format)"><strong>[1]</strong></a>, <a href="modules/gpu/doc/video.html#void gpu::VideoWriter_GPU::open(const std::string& fileName, cv::Size frameSize, double fps, SurfaceFormat format)"><strong>[2]</strong></a>, <a href="modules/gpu/doc/video.html#void gpu::VideoWriter_GPU::open(const std::string& fileName, cv::Size frameSize, double fps, const EncoderParams& params, SurfaceFormat format)"><strong>[3]</strong></a>
  </dt>

      
  <dt><a href="modules/gpu/doc/video.html#gpu::VideoWriter_GPU::VideoWriter_GPU()"><strong>gpu::VideoWriter_GPU::VideoWriter_GPU (C++ function)</strong></a>, <a href="modules/gpu/doc/video.html#gpu::VideoWriter_GPU::VideoWriter_GPU(const cv::Ptr<EncoderCallBack>& encoderCallback, cv::Size frameSize, double fps, SurfaceFormat format)"><strong>[1]</strong></a>, <a href="modules/gpu/doc/video.html#gpu::VideoWriter_GPU::VideoWriter_GPU(const cv::Ptr<EncoderCallBack>& encoderCallback, cv::Size frameSize, double fps, const EncoderParams& params, SurfaceFormat format)"><strong>[2]</strong></a>, <a href="modules/gpu/doc/video.html#gpu::VideoWriter_GPU::VideoWriter_GPU(const std::string& fileName, cv::Size frameSize, double fps, SurfaceFormat format)"><strong>[3]</strong></a>, <a href="modules/gpu/doc/video.html#gpu::VideoWriter_GPU::VideoWriter_GPU(const std::string& fileName, cv::Size frameSize, double fps, const EncoderParams& params, SurfaceFormat format)"><strong>[4]</strong></a>
  </dt>

      
  <dt><a href="modules/gpu/doc/video.html#void gpu::VideoWriter_GPU::write(const cv::gpu::GpuMat& image, bool lastFrame)"><strong>gpu::VideoWriter_GPU::write (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/gpu/doc/image_processing.html#void gpu::warpAffine(const GpuMat& src, GpuMat& dst, const Mat& M, Size dsize, int flags, int borderMode, Scalar borderValue, Stream& stream)"><strong>gpu::warpAffine (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/gpu/doc/image_processing.html#void gpu::warpPerspective(const GpuMat& src, GpuMat& dst, const Mat& M, Size dsize, int flags, int borderMode, Scalar borderValue, Stream& stream)"><strong>gpu::warpPerspective (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/miscellaneous_transformations.html#void grabCut(InputArray img, InputOutputArray mask, Rect rect, InputOutputArray bgdModel, InputOutputArray fgdModel, int iterCount, int mode)"><strong>grabCut (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/miscellaneous_transformations.html#cv2.grabCut"><strong>grabCut() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/highgui/doc/reading_and_writing_images_and_video.html#int cvGrabFrame(CvCapture* capture)"><strong>GrabFrame (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/highgui/doc/reading_and_writing_images_and_video.html#cv.GrabFrame"><strong>GrabFrame() (Python function in cv)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/dynamic_structures.html#int cvGraphAddEdge(CvGraph* graph, int start_idx, int end_idx, const CvGraphEdge* edge, CvGraphEdge** inserted_edge)"><strong>GraphAddEdge (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/dynamic_structures.html#int cvGraphAddEdgeByPtr(CvGraph* graph, CvGraphVtx* start_vtx, CvGraphVtx* end_vtx, const CvGraphEdge* edge, CvGraphEdge** inserted_edge)"><strong>GraphAddEdgeByPtr (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/dynamic_structures.html#int cvGraphAddVtx(CvGraph* graph, const CvGraphVtx* vtx, CvGraphVtx** inserted_vtx)"><strong>GraphAddVtx (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/dynamic_structures.html#int cvGraphEdgeIdx(CvGraph* graph, CvGraphEdge* edge)"><strong>GraphEdgeIdx (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/dynamic_structures.html#void cvGraphRemoveEdge(CvGraph* graph, int start_idx, int end_idx)"><strong>GraphRemoveEdge (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/dynamic_structures.html#void cvGraphRemoveEdgeByPtr(CvGraph* graph, CvGraphVtx* start_vtx, CvGraphVtx* end_vtx)"><strong>GraphRemoveEdgeByPtr (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/dynamic_structures.html#int cvGraphRemoveVtx(CvGraph* graph, int index)"><strong>GraphRemoveVtx (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/dynamic_structures.html#int cvGraphRemoveVtxByPtr(CvGraph* graph, CvGraphVtx* vtx)"><strong>GraphRemoveVtxByPtr (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/dynamic_structures.html#int cvGraphVtxDegree(const CvGraph* graph, int vtx_idx)"><strong>GraphVtxDegree (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/dynamic_structures.html#int cvGraphVtxDegreeByPtr(const CvGraph* graph, const CvGraphVtx* vtx)"><strong>GraphVtxDegreeByPtr (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/dynamic_structures.html#int cvGraphVtxIdx(CvGraph* graph, CvGraphVtx* vtx)"><strong>GraphVtxIdx (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/features2d/doc/common_interfaces_of_feature_detectors.html#GridAdaptedFeatureDetector : public FeatureDetector"><strong>GridAdaptedFeatureDetector (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/objdetect/doc/cascade_classification.html#void groupRectangles(vector<Rect>& rectList, int groupThreshold, double eps)"><strong>groupRectangles (C++ function)</strong></a>, <a href="modules/objdetect/doc/cascade_classification.html#void groupRectangles(vector<Rect>& rectList, vector<int>& weights, int groupThreshold, double eps)"><strong>[1]</strong></a>
  </dt>

      
  <dt><a href="modules/objdetect/doc/cascade_classification.html#cv2.groupRectangles"><strong>groupRectangles() (Python function in cv2)</strong></a>
  </dt>

  </dl></td>
</tr></table>

<h2 id="H">H</h2>
<table style="width: 100%" class="indextable genindextable"><tr>
  <td style="width: 33%" valign="top"><dl>
      
  <dt><a href="modules/objdetect/doc/cascade_classification.html#CvSeq* cvHaarDetectObjects(const CvArr* image, CvHaarClassifierCascade* cascade, CvMemStorage* storage, double scale_factor, int min_neighbors, int flags, CvSize min_size, CvSize max_size)"><strong>HaarDetectObjects (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/objdetect/doc/cascade_classification.html#cv.HaarDetectObjects"><strong>HaarDetectObjects() (Python function in cv)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/feature_detection.html#CvSeq* cvHoughCircles(CvArr* image, void* circle_storage, int method, double dp, double min_dist, double param1, double param2, int min_radius, int max_radius)"><strong>HoughCircles (C function)</strong></a>
  </dt>

      <dd><dl>
        
  <dt><a href="modules/imgproc/doc/feature_detection.html#void HoughCircles(InputArray image, OutputArray circles, int method, double dp, double minDist, double param1, double param2, int minRadius, int maxRadius)"><strong>(C++ function)</strong></a>
  </dt>

      </dl></dd>
      
  <dt><a href="modules/imgproc/doc/feature_detection.html#cv2.HoughCircles"><strong>HoughCircles() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/feature_detection.html#void HoughLines(InputArray image, OutputArray lines, double rho, double theta, int threshold, double srn, double stn)"><strong>HoughLines (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/feature_detection.html#cv2.HoughLines"><strong>HoughLines() (Python function in cv2)</strong></a>
  </dt>

  </dl></td>
  <td style="width: 33%" valign="top"><dl>
      
  <dt><a href="modules/imgproc/doc/feature_detection.html#CvSeq* cvHoughLines2(CvArr* image, void* line_storage, int method, double rho, double theta, int threshold, double param1, double param2)"><strong>HoughLines2 (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/feature_detection.html#cv.HoughLines2"><strong>HoughLines2() (Python function in cv)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/feature_detection.html#void HoughLinesP(InputArray image, OutputArray lines, double rho, double theta, int threshold, double minLineLength, double maxLineGap)"><strong>HoughLinesP (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/feature_detection.html#cv2.HoughLinesP"><strong>HoughLinesP() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/structural_analysis_and_shape_descriptors.html#void HuMoments(const Moments& m, OutputArray hu)"><strong>HuMoments (C++ function)</strong></a>, <a href="modules/imgproc/doc/structural_analysis_and_shape_descriptors.html#void HuMoments(const Moments& moments, double hu[7])"><strong>[1]</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/structural_analysis_and_shape_descriptors.html#cv2.HuMoments"><strong>HuMoments() (Python function in cv2)</strong></a>
  </dt>

  </dl></td>
</tr></table>

<h2 id="I">I</h2>
<table style="width: 100%" class="indextable genindextable"><tr>
  <td style="width: 33%" valign="top"><dl>
      
  <dt><a href="modules/core/doc/operations_on_arrays.html#void idct(InputArray src, OutputArray dst, int flags)"><strong>idct (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#cv2.idct"><strong>idct() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#void idft(InputArray src, OutputArray dst, int flags, int nonzeroRows)"><strong>idft (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#cv2.idft"><strong>idft() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/highgui/doc/reading_and_writing_images_and_video.html#Mat imdecode(InputArray buf, int flags)"><strong>imdecode (C++ function)</strong></a>, <a href="modules/highgui/doc/reading_and_writing_images_and_video.html#Mat imdecode(InputArray buf, int flags, Mat* dst)"><strong>[1]</strong></a>
  </dt>

      
  <dt><a href="modules/highgui/doc/reading_and_writing_images_and_video.html#cv2.imdecode"><strong>imdecode() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/highgui/doc/reading_and_writing_images_and_video.html#bool imencode(const string& ext, InputArray img, vector<uchar>& buf, const vector<int>& params)"><strong>imencode (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/highgui/doc/reading_and_writing_images_and_video.html#cv2.imencode"><strong>imencode() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/highgui/doc/reading_and_writing_images_and_video.html#Mat imread(const string& filename, int flags)"><strong>imread (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/highgui/doc/reading_and_writing_images_and_video.html#cv2.imread"><strong>imread() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/highgui/doc/user_interface.html#void imshow(const string& winname, InputArray mat)"><strong>imshow (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/highgui/doc/user_interface.html#cv2.imshow"><strong>imshow() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/highgui/doc/reading_and_writing_images_and_video.html#bool imwrite(const string& filename, InputArray img, const vector<int>& params)"><strong>imwrite (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/highgui/doc/reading_and_writing_images_and_video.html#cv2.imwrite"><strong>imwrite() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="platforms/android/service/doc/LoaderCallbackInterface.html#INCOMPATIBLE_MANAGER_VERSION">INCOMPATIBLE_MANAGER_VERSION (built-in variable)</a>
  </dt>

      
  <dt><a href="modules/core/doc/old_basic_structures.html#int cvIncRefData(CvArr* arr)"><strong>IncRefData (C function)</strong></a>
  </dt>

      
  <dt><a href="platforms/android/service/doc/LoaderCallbackInterface.html#INIT_FAILED">INIT_FAILED (built-in variable)</a>
  </dt>

      
  <dt><a href="modules/calib3d/doc/camera_calibration_and_3d_reconstruction.html#Mat initCameraMatrix2D(InputArrayOfArrays objectPoints, InputArrayOfArrays imagePoints, Size imageSize, double aspectRatio)"><strong>initCameraMatrix2D (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/calib3d/doc/camera_calibration_and_3d_reconstruction.html#cv2.initCameraMatrix2D"><strong>initCameraMatrix2D() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/drawing_functions.html#void cvInitFont(CvFont* font, int font_face, double hscale, double vscale, double shear, int thickness, int line_type)"><strong>InitFont (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_basic_structures.html#IplImage* cvInitImageHeader(IplImage* image, CvSize size, int depth, int channels, int origin, int align)"><strong>InitImageHeader (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/calib3d/doc/camera_calibration_and_3d_reconstruction.html#void cvInitIntrinsicParams2D(const CvMat* object_points, const CvMat* image_points, const CvMat* npoints, CvSize image_size, CvMat* camera_matrix, double aspect_ratio)"><strong>InitIntrinsicParams2D (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/calib3d/doc/camera_calibration_and_3d_reconstruction.html#cv.InitIntrinsicParams2D"><strong>InitIntrinsicParams2D() (Python function in cv)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_basic_structures.html#CvMat* cvInitMatHeader(CvMat* mat, int rows, int cols, int type, void* data, int step)"><strong>InitMatHeader (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_basic_structures.html#CvMatND* cvInitMatNDHeader(CvMatND* mat, int dims, const int* sizes, int type, void* data)"><strong>InitMatNDHeader (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_basic_structures.html#CvSparseNode* cvInitSparseMatIterator(const CvSparseMat* mat, CvSparseMatIterator* mat_iterator)"><strong>InitSparseMatIterator (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/dynamic_structures.html#void cvInitTreeNodeIterator(CvTreeNodeIterator* tree_iterator, const void* first, int max_level)"><strong>InitTreeNodeIterator (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/geometric_transformations.html#void cvInitUndistortMap(const CvMat* camera_matrix, const CvMat* distortion_coeffs, CvArr* mapx, CvArr* mapy)"><strong>InitUndistortMap (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/geometric_transformations.html#cv.InitUndistortMap"><strong>InitUndistortMap() (Python function in cv)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/geometric_transformations.html#void cvInitUndistortRectifyMap(const CvMat* camera_matrix, const CvMat* dist_coeffs, const CvMat * R, const CvMat* new_camera_matrix, CvArr* mapx, CvArr* mapy)"><strong>InitUndistortRectifyMap (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/geometric_transformations.html#void initUndistortRectifyMap(InputArray cameraMatrix, InputArray distCoeffs, InputArray R, InputArray newCameraMatrix, Size size, int m1type, OutputArray map1, OutputArray map2)"><strong>initUndistortRectifyMap (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/geometric_transformations.html#cv.InitUndistortRectifyMap"><strong>InitUndistortRectifyMap() (Python function in cv)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/geometric_transformations.html#cv2.initUndistortRectifyMap"><strong>initUndistortRectifyMap() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/photo/doc/inpainting.html#void cvInpaint(const CvArr* src, const CvArr* inpaint_mask, CvArr* dst, double inpaintRange, int flags)"><strong>Inpaint (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/photo/doc/inpainting.html#void inpaint(InputArray src, InputArray inpaintMask, OutputArray dst, double inpaintRadius, int flags)"><strong>inpaint (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/photo/doc/inpainting.html#cv.Inpaint"><strong>Inpaint() (Python function in cv)</strong></a>
  </dt>

      
  <dt><a href="modules/photo/doc/inpainting.html#cv2.inpaint"><strong>inpaint() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/basic_structures.html#InputArray"><strong>InputArray (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#void cvInRange(const CvArr* src, const CvArr* lower, const CvArr* upper, CvArr* dst)"><strong>InRange (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#void inRange(InputArray src, InputArray lowerb, InputArray upperb, OutputArray dst)"><strong>inRange (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#cv.InRange"><strong>InRange() (Python function in cv)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#cv2.inRange"><strong>inRange() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#void cvInRangeS(const CvArr* src, CvScalar lower, CvScalar upper, CvArr* dst)"><strong>InRangeS (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#cv.InRangeS"><strong>InRangeS() (Python function in cv)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#void insertImageCOI(InputArray coiimg, CvArr* arr, int coi)"><strong>insertImageCOI (C++ function)</strong></a>
  </dt>

  </dl></td>
  <td style="width: 33%" valign="top"><dl>
      
  <dt><a href="modules/core/doc/dynamic_structures.html#void cvInsertNodeIntoTree(void* node, void* parent, void* frame)"><strong>InsertNodeIntoTree (C function)</strong></a>
  </dt>

      
  <dt><a href="platforms/android/service/doc/LoaderCallbackInterface.html#INSTALL_CANCELED">INSTALL_CANCELED (built-in variable)</a>
  </dt>

      
  <dt><a href="platforms/android/service/doc/InstallCallbackInterface.html#InstallCallbackInterface">InstallCallbackInterface (built-in class)</a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/miscellaneous_transformations.html#void cvIntegral(const CvArr* image, CvArr* sum, CvArr* sqsum, CvArr* tilted_sum)"><strong>Integral (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/miscellaneous_transformations.html#void integral(InputArray src, OutputArray sum, OutputArray sqsum, OutputArray tilted, int sdepth)"><strong>integral (C++ function)</strong></a>, <a href="modules/imgproc/doc/miscellaneous_transformations.html#void integral(InputArray src, OutputArray sum, OutputArray sqsum, int sdepth)"><strong>[1]</strong></a>, <a href="modules/imgproc/doc/miscellaneous_transformations.html#void integral(InputArray src, OutputArray sum, int sdepth)"><strong>[2]</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/miscellaneous_transformations.html#cv.Integral"><strong>Integral() (Python function in cv)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/miscellaneous_transformations.html#cv2.integral"><strong>integral() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/miscellaneous_transformations.html#cv2.integral2"><strong>integral2() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/miscellaneous_transformations.html#cv2.integral3"><strong>integral3() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#double cvInvert(const CvArr* src, CvArr* dst, int method)"><strong>Invert (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#double invert(InputArray src, OutputArray dst, int flags)"><strong>invert (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#cv.Invert"><strong>Invert() (Python function in cv)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#cv2.invert"><strong>invert() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/geometric_transformations.html#void invertAffineTransform(InputArray M, OutputArray iM)"><strong>invertAffineTransform (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/geometric_transformations.html#cv2.invertAffineTransform"><strong>invertAffineTransform() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_basic_structures.html#IplImage"><strong>IplImage (C++ structure)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_basic_structures.html#int align"><strong>IplImage::align (C++ member)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_basic_structures.html#int alphaChannel"><strong>IplImage::alphaChannel (C++ member)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_basic_structures.html#int[] BorderConst"><strong>IplImage::BorderConst (C++ member)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_basic_structures.html#int[] BorderMode"><strong>IplImage::BorderMode (C++ member)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_basic_structures.html#char[] channelSeq"><strong>IplImage::channelSeq (C++ member)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_basic_structures.html#char[] colorModel"><strong>IplImage::colorModel (C++ member)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_basic_structures.html#int dataOrder"><strong>IplImage::dataOrder (C++ member)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_basic_structures.html#int depth"><strong>IplImage::depth (C++ member)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_basic_structures.html#int height"><strong>IplImage::height (C++ member)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_basic_structures.html#int ID"><strong>IplImage::ID (C++ member)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_basic_structures.html#char* imageData"><strong>IplImage::imageData (C++ member)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_basic_structures.html#char* imageDataOrigin"><strong>IplImage::imageDataOrigin (C++ member)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_basic_structures.html#void* imageId"><strong>IplImage::imageId (C++ member)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_basic_structures.html#int imageSize"><strong>IplImage::imageSize (C++ member)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_basic_structures.html#IplImage* maskROI"><strong>IplImage::maskROI (C++ member)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_basic_structures.html#int nChannels"><strong>IplImage::nChannels (C++ member)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_basic_structures.html#int nSize"><strong>IplImage::nSize (C++ member)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_basic_structures.html#int origin"><strong>IplImage::origin (C++ member)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_basic_structures.html#IplROI* roi"><strong>IplImage::roi (C++ member)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_basic_structures.html#void* tileInfo"><strong>IplImage::tileInfo (C++ member)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_basic_structures.html#int width"><strong>IplImage::width (C++ member)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_basic_structures.html#int widthStep"><strong>IplImage::widthStep (C++ member)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/structural_analysis_and_shape_descriptors.html#bool isContourConvex(InputArray contour)"><strong>isContourConvex (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/structural_analysis_and_shape_descriptors.html#cv2.isContourConvex"><strong>isContourConvex() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/utility_and_system_functions_and_macros.html#int cvIsInf(double value)"><strong>IsInf (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/utility_and_system_functions_and_macros.html#cv.IsInf"><strong>IsInf() (Python function in cv)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/utility_and_system_functions_and_macros.html#int cvIsNaN(double value)"><strong>IsNaN (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/viz/doc/viz3d.html#bool isNan(const Point3_<_Tp>& p)"><strong>isNan (C++ function)</strong></a>, <a href="modules/viz/doc/viz3d.html#bool isNan(const Vec<_Tp, cn>& v)"><strong>[1]</strong></a>, <a href="modules/viz/doc/viz3d.html#bool isNan(double x)"><strong>[2]</strong></a>, <a href="modules/viz/doc/viz3d.html#bool isNan(float x)"><strong>[3]</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/utility_and_system_functions_and_macros.html#cv.IsNaN"><strong>IsNaN() (Python function in cv)</strong></a>
  </dt>

  </dl></td>
</tr></table>

<h2 id="K">K</h2>
<table style="width: 100%" class="indextable genindextable"><tr>
  <td style="width: 33%" valign="top"><dl>
      
  <dt><a href="modules/video/doc/motion_analysis_and_object_tracking.html#const CvMat* cvKalmanCorrect(CvKalman* kalman, const CvMat* measurement)"><strong>KalmanCorrect (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/video/doc/motion_analysis_and_object_tracking.html#cv.KalmanCorrect"><strong>KalmanCorrect() (Python function in cv)</strong></a>
  </dt>

      
  <dt><a href="modules/video/doc/motion_analysis_and_object_tracking.html#KalmanFilter"><strong>KalmanFilter (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/video/doc/motion_analysis_and_object_tracking.html#cv2.KalmanFilter"><strong>KalmanFilter() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/video/doc/motion_analysis_and_object_tracking.html#cv2.KalmanFilter.correct"><strong>KalmanFilter.correct() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/video/doc/motion_analysis_and_object_tracking.html#cv2.KalmanFilter.predict"><strong>KalmanFilter.predict() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/video/doc/motion_analysis_and_object_tracking.html#const Mat& KalmanFilter::correct(const Mat& measurement)"><strong>KalmanFilter::correct (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/video/doc/motion_analysis_and_object_tracking.html#void KalmanFilter::init(int dynamParams, int measureParams, int controlParams, int type)"><strong>KalmanFilter::init (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/video/doc/motion_analysis_and_object_tracking.html#KalmanFilter::KalmanFilter()"><strong>KalmanFilter::KalmanFilter (C++ function)</strong></a>, <a href="modules/video/doc/motion_analysis_and_object_tracking.html#KalmanFilter::KalmanFilter(int dynamParams, int measureParams, int controlParams, int type)"><strong>[1]</strong></a>
  </dt>

      
  <dt><a href="modules/video/doc/motion_analysis_and_object_tracking.html#const Mat& KalmanFilter::predict(const Mat& control)"><strong>KalmanFilter::predict (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/video/doc/motion_analysis_and_object_tracking.html#const CvMat* cvKalmanPredict(CvKalman* kalman, const CvMat* control)"><strong>KalmanPredict (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/video/doc/motion_analysis_and_object_tracking.html#cv.KalmanPredict"><strong>KalmanPredict() (Python function in cv)</strong></a>
  </dt>

      
  <dt><a href="modules/viz/doc/viz3d.html#KeyboardEvent"><strong>KeyboardEvent (C++ class)</strong></a>
  </dt>

      <dd><dl>
        
  <dt><a href="modules/viz/doc/viz3d.html#KeyboardEvent (Action action, const String& symbol, unsigned char code, Modifiers modifiers)"><strong>(C++ function)</strong></a>
  </dt>

      </dl></dd>
      
  <dt><a href="modules/features2d/doc/common_interfaces_of_feature_detectors.html#KeyPoint"><strong>KeyPoint (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/features2d/doc/common_interfaces_of_feature_detectors.html#cv2.KeyPoint"><strong>KeyPoint() (Python function in cv2)</strong></a>
  </dt>

  </dl></td>
  <td style="width: 33%" valign="top"><dl>
      
  <dt><a href="modules/features2d/doc/common_interfaces_of_feature_detectors.html#float angle"><strong>KeyPoint::angle (C++ member)</strong></a>
  </dt>

      
  <dt><a href="modules/features2d/doc/common_interfaces_of_feature_detectors.html#int class_id"><strong>KeyPoint::class_id (C++ member)</strong></a>
  </dt>

      
  <dt><a href="modules/features2d/doc/common_interfaces_of_feature_detectors.html#KeyPoint::KeyPoint()"><strong>KeyPoint::KeyPoint (C++ function)</strong></a>, <a href="modules/features2d/doc/common_interfaces_of_feature_detectors.html#KeyPoint::KeyPoint(Point2f _pt, float _size, float _angle, float _response, int _octave, int _class_id)"><strong>[1]</strong></a>, <a href="modules/features2d/doc/common_interfaces_of_feature_detectors.html#KeyPoint::KeyPoint(float x, float y, float _size, float _angle, float _response, int _octave, int _class_id)"><strong>[2]</strong></a>
  </dt>

      
  <dt><a href="modules/features2d/doc/common_interfaces_of_feature_detectors.html#int octave"><strong>KeyPoint::octave (C++ member)</strong></a>
  </dt>

      
  <dt><a href="modules/features2d/doc/common_interfaces_of_feature_detectors.html#Point2f pt"><strong>KeyPoint::pt (C++ member)</strong></a>
  </dt>

      
  <dt><a href="modules/features2d/doc/common_interfaces_of_feature_detectors.html#float response"><strong>KeyPoint::response (C++ member)</strong></a>
  </dt>

      
  <dt><a href="modules/features2d/doc/common_interfaces_of_feature_detectors.html#float size"><strong>KeyPoint::size (C++ member)</strong></a>
  </dt>

      
  <dt><a href="modules/viz/doc/viz3d.html#static Camera KinectCamera(const Size &window_size)"><strong>KinectCamera (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/clustering.html#double kmeans(InputArray data, int K, InputOutputArray bestLabels, TermCriteria criteria, int attempts, int flags, OutputArray centers)"><strong>kmeans (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/clustering.html#cv2.kmeans"><strong>kmeans() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/clustering.html#int cvKMeans2(const CvArr* samples, int cluster_count, CvArr* labels, CvTermCriteria termcrit, int attempts, CvRNG* rng, int flags, CvArr* _centers, double* compactness)"><strong>KMeans2 (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/clustering.html#cv.KMeans2"><strong>KMeans2() (Python function in cv)</strong></a>
  </dt>

      
  <dt><a href="modules/ml/doc/k_nearest_neighbors.html#cv2.KNearest.find_nearest"><strong>KNearest.find_nearest() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/ml/doc/k_nearest_neighbors.html#cv2.KNearest.train"><strong>KNearest.train() (Python function in cv2)</strong></a>
  </dt>

  </dl></td>
</tr></table>

<h2 id="L">L</h2>
<table style="width: 100%" class="indextable genindextable"><tr>
  <td style="width: 33%" valign="top"><dl>
      
  <dt><a href="modules/imgproc/doc/filtering.html#void cvLaplace(const CvArr* src, CvArr* dst, int aperture_size)"><strong>Laplace (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/filtering.html#cv.Laplace"><strong>Laplace() (Python function in cv)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/filtering.html#void Laplacian(InputArray src, OutputArray dst, int ddepth, int ksize, double scale, double delta, int borderType)"><strong>Laplacian (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/filtering.html#cv2.Laplacian"><strong>Laplacian() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/objdetect/doc/latent_svm.html#LatentSvmDetector"><strong>LatentSvmDetector (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/objdetect/doc/latent_svm.html#void LatentSvmDetector::clear()"><strong>LatentSvmDetector::clear (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/objdetect/doc/latent_svm.html#void LatentSvmDetector::detect(const Mat& image, vector<ObjectDetection>& objectDetections, float overlapThreshold, int numThreads)"><strong>LatentSvmDetector::detect (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/objdetect/doc/latent_svm.html#size_t LatentSvmDetector::getClassCount() const"><strong>LatentSvmDetector::getClassCount (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/objdetect/doc/latent_svm.html#const vector<string>& LatentSvmDetector::getClassNames() const"><strong>LatentSvmDetector::getClassNames (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/objdetect/doc/latent_svm.html#LatentSvmDetector::LatentSvmDetector()"><strong>LatentSvmDetector::LatentSvmDetector (C++ function)</strong></a>, <a href="modules/objdetect/doc/latent_svm.html#LatentSvmDetector::LatentSvmDetector(const vector<string>& filenames, const vector<string>& classNames)"><strong>[1]</strong></a>
  </dt>

      
  <dt><a href="modules/objdetect/doc/latent_svm.html#bool LatentSvmDetector::load(const vector<string>& filenames, const vector<string>& classNames)"><strong>LatentSvmDetector::load (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/objdetect/doc/latent_svm.html#LatentSvmDetector::ObjectDetection"><strong>LatentSvmDetector::ObjectDetection (C++ structure)</strong></a>
  </dt>

      
  <dt><a href="modules/objdetect/doc/latent_svm.html#int classID"><strong>LatentSvmDetector::ObjectDetection::classID (C++ member)</strong></a>
  </dt>

      
  <dt><a href="modules/objdetect/doc/latent_svm.html#Rect rect"><strong>LatentSvmDetector::ObjectDetection::rect (C++ member)</strong></a>
  </dt>

      
  <dt><a href="modules/objdetect/doc/latent_svm.html#float score"><strong>LatentSvmDetector::ObjectDetection::score (C++ member)</strong></a>
  </dt>

      
  <dt><a href="modules/objdetect/doc/latent_svm.html#LatentSvmDetector::~LatentSvmDetector()"><strong>LatentSvmDetector::~LatentSvmDetector (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/drawing_functions.html#void cvLine(CvArr* img, CvPoint pt1, CvPoint pt2, CvScalar color, int thickness, int line_type, int shift)"><strong>Line (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/drawing_functions.html#void line(Mat& img, Point pt1, Point pt2, const Scalar& color, int thickness, int lineType, int shift)"><strong>line (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/drawing_functions.html#cv.Line"><strong>Line() (Python function in cv)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/drawing_functions.html#cv2.line"><strong>line() (Python function in cv2)</strong></a>
  </dt>

  </dl></td>
  <td style="width: 33%" valign="top"><dl>
      
  <dt><a href="modules/imgproc/doc/geometric_transformations.html#void cvLinearPolar(const CvArr* src, CvArr* dst, CvPoint2D32f center, double maxRadius, int flags)"><strong>LinearPolar (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/drawing_functions.html#LineIterator"><strong>LineIterator (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_xml_yaml_persistence.html#void* cvLoad(const char* filename, CvMemStorage* memstorage, const char* name, const char** real_name)"><strong>Load (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/viz/doc/viz3d.html#static Mesh load(const String& file)"><strong>load (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_xml_yaml_persistence.html#cv.Load"><strong>Load() (Python function in cv)</strong></a>
  </dt>

      
  <dt><a href="platforms/android/service/doc/LoaderCallbackInterface.html#LoaderCallbackInterface">LoaderCallbackInterface (built-in class)</a>
  </dt>

      
  <dt><a href="modules/highgui/doc/reading_and_writing_images_and_video.html#IplImage* cvLoadImage(const char* filename, int iscolor)"><strong>LoadImage (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/highgui/doc/reading_and_writing_images_and_video.html#cv.LoadImage"><strong>LoadImage() (Python function in cv)</strong></a>
  </dt>

      
  <dt><a href="modules/highgui/doc/reading_and_writing_images_and_video.html#CvMat* cvLoadImageM(const char* filename, int iscolor)"><strong>LoadImageM (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/highgui/doc/reading_and_writing_images_and_video.html#cv.LoadImageM"><strong>LoadImageM() (Python function in cv)</strong></a>
  </dt>

      
  <dt><a href="modules/highgui/doc/qt_new_functions.html#void cvLoadWindowParameters(const char* name)"><strong>LoadWindowParameters (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/highgui/doc/qt_new_functions.html#void loadWindowParameters(const string& windowName)"><strong>loadWindowParameters (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#void cvLog(const CvArr* src, CvArr* dst)"><strong>Log (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#void log(InputArray src, OutputArray dst)"><strong>log (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#cv.Log"><strong>Log() (Python function in cv)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#cv2.log"><strong>log() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/geometric_transformations.html#void cvLogPolar(const CvArr* src, CvArr* dst, CvPoint2D32f center, double M, int flags)"><strong>LogPolar (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/geometric_transformations.html#cv.LogPolar"><strong>LogPolar() (Python function in cv)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#void cvLUT(const CvArr* src, CvArr* dst, const CvArr* lut)"><strong>LUT (C function)</strong></a>
  </dt>

      <dd><dl>
        
  <dt><a href="modules/core/doc/operations_on_arrays.html#void LUT(InputArray src, InputArray lut, OutputArray dst, int interpolation)"><strong>(C++ function)</strong></a>
  </dt>

      </dl></dd>
      
  <dt><a href="modules/core/doc/operations_on_arrays.html#cv.LUT"><strong>LUT() (Python function in cv)</strong></a>
  </dt>

      <dd><dl>
        
  <dt><a href="modules/core/doc/operations_on_arrays.html#cv2.LUT"><strong>(Python function in cv2)</strong></a>
  </dt>

      </dl></dd>
  </dl></td>
</tr></table>

<h2 id="M">M</h2>
<table style="width: 100%" class="indextable genindextable"><tr>
  <td style="width: 33%" valign="top"><dl>
      
  <dt><a href="modules/core/doc/operations_on_arrays.html#void magnitude(InputArray x, InputArray y, OutputArray magnitude)"><strong>magnitude (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#cv2.magnitude"><strong>magnitude() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#double cvMahalanobis(const CvArr* vec1, const CvArr* vec2, const CvArr* mat)"><strong>Mahalanobis (C function)</strong></a>
  </dt>

      <dd><dl>
        
  <dt><a href="modules/core/doc/operations_on_arrays.html#double Mahalanobis(InputArray v1, InputArray v2, InputArray icovar)"><strong>(C++ function)</strong></a>
  </dt>

      </dl></dd>
      
  <dt><a href="modules/core/doc/operations_on_arrays.html#cv2.Mahalanobis"><strong>Mahalanobis() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#cv.Mahalonobis"><strong>Mahalonobis() (Python function in cv)</strong></a>
  </dt>

      
  <dt><a href="modules/viz/doc/viz3d.html#Affine3d makeCameraPose(const Vec3f& position, const Vec3f& focal_point, const Vec3f& y_dir)"><strong>makeCameraPose (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/histograms.html#CvHistogram* cvMakeHistHeaderForArray(int dims, int* sizes, CvHistogram* hist, float* data, float** ranges, int uniform)"><strong>MakeHistHeaderForArray (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/dynamic_structures.html#CvSeq* cvMakeSeqHeaderForArray(int seq_type, int header_size, int elem_size, void* elements, int total, CvSeq* seq, CvSeqBlock* block)"><strong>MakeSeqHeaderForArray (C function)</strong></a>
  </dt>

      
  <dt><a href="platforms/android/service/doc/LoaderCallbackInterface.html#MARKET_ERROR">MARKET_ERROR (built-in variable)</a>
  </dt>

      
  <dt><a href="modules/core/doc/old_basic_structures.html#CvMat cvMat(int rows, int cols, int type, void* data)"><strong>Mat (C function)</strong></a>
  </dt>

      <dd><dl>
        
  <dt><a href="modules/core/doc/basic_structures.html#Mat"><strong>(C++ class)</strong></a>
  </dt>

      </dl></dd>
      
  <dt><a href="modules/core/doc/basic_structures.html#void Mat::addref()"><strong>Mat::addref (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/basic_structures.html#Mat& Mat::adjustROI(int dtop, int dbottom, int dleft, int dright)"><strong>Mat::adjustROI (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/basic_structures.html#void Mat::assignTo(Mat& m, int type) const"><strong>Mat::assignTo (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/basic_structures.html#template<typename T> T& Mat::at(Point pt)"><strong>Mat::at (C++ function)</strong></a>, <a href="modules/core/doc/basic_structures.html#template<typename T> T& Mat::at(const int* idx)"><strong>[1]</strong></a>, <a href="modules/core/doc/basic_structures.html#template<typename T> T& Mat::at(int i) const"><strong>[2]</strong></a>, <a href="modules/core/doc/basic_structures.html#template<typename T> T& Mat::at(int i, int j)"><strong>[3]</strong></a>, <a href="modules/core/doc/basic_structures.html#template<typename T> T& Mat::at(int i, int j, int k)"><strong>[4]</strong></a>, <a href="modules/core/doc/basic_structures.html#template<typename T> const T& Mat::at(Point pt) const"><strong>[5]</strong></a>, <a href="modules/core/doc/basic_structures.html#template<typename T> const T& Mat::at(const int* idx) const"><strong>[6]</strong></a>, <a href="modules/core/doc/basic_structures.html#template<typename T> const T& Mat::at(int i) const"><strong>[7]</strong></a>, <a href="modules/core/doc/basic_structures.html#template<typename T> const T& Mat::at(int i, int j) const"><strong>[8]</strong></a>, <a href="modules/core/doc/basic_structures.html#template<typename T> const T& Mat::at(int i, int j, int k) const"><strong>[9]</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/basic_structures.html#template<typename _Tp> MatConstIterator_<_Tp> Mat::begin() const"><strong>Mat::begin (C++ function)</strong></a>, <a href="modules/core/doc/basic_structures.html#template<typename _Tp> MatIterator_<_Tp> Mat::begin()"><strong>[1]</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/basic_structures.html#int Mat::channels() const"><strong>Mat::channels (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/basic_structures.html#Mat Mat::clone() const"><strong>Mat::clone (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/basic_structures.html#Mat Mat::col(int x) const"><strong>Mat::col (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/basic_structures.html#Mat Mat::colRange(const Range& r) const"><strong>Mat::colRange (C++ function)</strong></a>, <a href="modules/core/doc/basic_structures.html#Mat Mat::colRange(int startcol, int endcol) const"><strong>[1]</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/basic_structures.html#void Mat::convertTo(OutputArray m, int rtype, double alpha, double beta) const"><strong>Mat::convertTo (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/basic_structures.html#void Mat::copyTo(OutputArray m) const"><strong>Mat::copyTo (C++ function)</strong></a>, <a href="modules/core/doc/basic_structures.html#void Mat::copyTo(OutputArray m, InputArray mask) const"><strong>[1]</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/basic_structures.html#void Mat::create(Size size, int type)"><strong>Mat::create (C++ function)</strong></a>, <a href="modules/core/doc/basic_structures.html#void Mat::create(int ndims, const int* sizes, int type)"><strong>[1]</strong></a>, <a href="modules/core/doc/basic_structures.html#void Mat::create(int rows, int cols, int type)"><strong>[2]</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/basic_structures.html#Mat Mat::cross(InputArray m) const"><strong>Mat::cross (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/basic_structures.html#int Mat::depth() const"><strong>Mat::depth (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/basic_structures.html#Mat Mat::diag(int d) const"><strong>Mat::diag (C++ function)</strong></a>, <a href="modules/core/doc/basic_structures.html#static Mat Mat::diag(const Mat& d)"><strong>[1]</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/basic_structures.html#double Mat::dot(InputArray m) const"><strong>Mat::dot (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/basic_structures.html#size_t Mat::elemSize() const"><strong>Mat::elemSize (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/basic_structures.html#size_t Mat::elemSize1() const"><strong>Mat::elemSize1 (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/basic_structures.html#bool Mat::empty() const"><strong>Mat::empty (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/basic_structures.html#template<typename _Tp> MatConstIterator_<_Tp> Mat::end() const"><strong>Mat::end (C++ function)</strong></a>, <a href="modules/core/doc/basic_structures.html#template<typename _Tp> MatIterator_<_Tp> Mat::end()"><strong>[1]</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/basic_structures.html#static MatExpr Mat::eye(Size size, int type)"><strong>Mat::eye (C++ function)</strong></a>, <a href="modules/core/doc/basic_structures.html#static MatExpr Mat::eye(int rows, int cols, int type)"><strong>[1]</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/basic_structures.html#MatExpr Mat::inv(int method) const"><strong>Mat::inv (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/basic_structures.html#bool Mat::isContinuous() const"><strong>Mat::isContinuous (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/basic_structures.html#void Mat::locateROI(Size& wholeSize, Point& ofs) const"><strong>Mat::locateROI (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/basic_structures.html#Mat::Mat()"><strong>Mat::Mat (C++ function)</strong></a>, <a href="modules/core/doc/basic_structures.html#Mat::Mat(Size size, int type)"><strong>[1]</strong></a>, <a href="modules/core/doc/basic_structures.html#Mat::Mat(Size size, int type, const Scalar& s)"><strong>[2]</strong></a>, <a href="modules/core/doc/basic_structures.html#Mat::Mat(Size size, int type, void* data, size_t step)"><strong>[3]</strong></a>, <a href="modules/core/doc/basic_structures.html#Mat::Mat(const CvMat* m, bool copyData)"><strong>[4]</strong></a>, <a href="modules/core/doc/basic_structures.html#Mat::Mat(const IplImage* img, bool copyData)"><strong>[5]</strong></a>, <a href="modules/core/doc/basic_structures.html#Mat::Mat(const Mat& m)"><strong>[6]</strong></a>, <a href="modules/core/doc/basic_structures.html#Mat::Mat(const Mat& m, const Range& rowRange, const Range& colRange)"><strong>[7]</strong></a>, <a href="modules/core/doc/basic_structures.html#Mat::Mat(const Mat& m, const Range* ranges)"><strong>[8]</strong></a>, <a href="modules/core/doc/basic_structures.html#Mat::Mat(const Mat& m, const Rect& roi)"><strong>[9]</strong></a>, <a href="modules/core/doc/basic_structures.html#Mat::Mat(int ndims, const int* sizes, int type)"><strong>[10]</strong></a>, <a href="modules/core/doc/basic_structures.html#Mat::Mat(int ndims, const int* sizes, int type, const Scalar& s)"><strong>[11]</strong></a>, <a href="modules/core/doc/basic_structures.html#Mat::Mat(int ndims, const int* sizes, int type, void* data, const size_t* steps)"><strong>[12]</strong></a>, <a href="modules/core/doc/basic_structures.html#Mat::Mat(int rows, int cols, int type)"><strong>[13]</strong></a>, <a href="modules/core/doc/basic_structures.html#Mat::Mat(int rows, int cols, int type, const Scalar& s)"><strong>[14]</strong></a>, <a href="modules/core/doc/basic_structures.html#Mat::Mat(int rows, int cols, int type, void* data, size_t step)"><strong>[15]</strong></a>, <a href="modules/core/doc/basic_structures.html#template<typename T, int m, int n> explicit Mat::Mat(const Matx<T, m, n>& vec, bool copyData)"><strong>[16]</strong></a>, <a href="modules/core/doc/basic_structures.html#template<typename T, int n> explicit Mat::Mat(const Vec<T, n>& vec, bool copyData)"><strong>[17]</strong></a>, <a href="modules/core/doc/basic_structures.html#template<typename T> explicit Mat::Mat(const vector<T>& vec, bool copyData)"><strong>[18]</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/basic_structures.html#MatExpr Mat::mul(InputArray m, double scale) const"><strong>Mat::mul (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/basic_structures.html#static MatExpr Mat::ones(Size size, int type)"><strong>Mat::ones (C++ function)</strong></a>, <a href="modules/core/doc/basic_structures.html#static MatExpr Mat::ones(int ndims, const int* sz, int type)"><strong>[1]</strong></a>, <a href="modules/core/doc/basic_structures.html#static MatExpr Mat::ones(int rows, int cols, int type)"><strong>[2]</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/basic_structures.html#Mat::operator CvMat() const"><strong>Mat::operator CvMat (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/basic_structures.html#Mat::operator IplImage() const"><strong>Mat::operator IplImage (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/basic_structures.html#Mat Mat::operator()(Range rowRange, Range colRange) const"><strong>Mat::operator() (C++ function)</strong></a>, <a href="modules/core/doc/basic_structures.html#Mat Mat::operator()(const Range* ranges) const"><strong>[1]</strong></a>, <a href="modules/core/doc/basic_structures.html#Mat Mat::operator()(const Rect& roi) const"><strong>[2]</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/basic_structures.html#Mat& Mat::operator = (const Mat& m)"><strong>Mat::operator= (C++ function)</strong></a>, <a href="modules/core/doc/basic_structures.html#Mat& Mat::operator = (const Scalar& s)"><strong>[1]</strong></a>, <a href="modules/core/doc/basic_structures.html#Mat& Mat::operator =(const MatExpr& expr)"><strong>[2]</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/basic_structures.html#template<typename T> void Mat::pop_back(size_t nelems)"><strong>Mat::pop_back (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/basic_structures.html#const uchar* Mat::ptr(int i0) const"><strong>Mat::ptr (C++ function)</strong></a>, <a href="modules/core/doc/basic_structures.html#template<typename _Tp> _Tp* Mat::ptr(int i0)"><strong>[1]</strong></a>, <a href="modules/core/doc/basic_structures.html#template<typename _Tp> const _Tp* Mat::ptr(int i0) const"><strong>[2]</strong></a>, <a href="modules/core/doc/basic_structures.html#uchar* Mat::ptr(int i0)"><strong>[3]</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/basic_structures.html#template<typename T> void Mat::push_back(const T& elem)"><strong>Mat::push_back (C++ function)</strong></a>, <a href="modules/core/doc/basic_structures.html#void Mat::push_back(const Mat& m)"><strong>[1]</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/basic_structures.html#void Mat::release()"><strong>Mat::release (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/basic_structures.html#void Mat::reserve(size_t sz)"><strong>Mat::reserve (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/basic_structures.html#Mat Mat::reshape(int cn, int rows) const"><strong>Mat::reshape (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/basic_structures.html#void Mat::resize(size_t sz)"><strong>Mat::resize (C++ function)</strong></a>, <a href="modules/core/doc/basic_structures.html#void Mat::resize(size_t sz, const Scalar& s)"><strong>[1]</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/basic_structures.html#Mat Mat::row(int y) const"><strong>Mat::row (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/basic_structures.html#Mat Mat::rowRange(const Range& r) const"><strong>Mat::rowRange (C++ function)</strong></a>, <a href="modules/core/doc/basic_structures.html#Mat Mat::rowRange(int startrow, int endrow) const"><strong>[1]</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/basic_structures.html#Mat& Mat::setTo(InputArray value, InputArray mask)"><strong>Mat::setTo (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/basic_structures.html#Size Mat::size() const"><strong>Mat::size (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/basic_structures.html#size_t Mat::step1(int i) const"><strong>Mat::step1 (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/basic_structures.html#MatExpr Mat::t() const"><strong>Mat::t (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/basic_structures.html#size_t Mat::total() const"><strong>Mat::total (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/basic_structures.html#int Mat::type() const"><strong>Mat::type (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/basic_structures.html#static MatExpr Mat::zeros(Size size, int type)"><strong>Mat::zeros (C++ function)</strong></a>, <a href="modules/core/doc/basic_structures.html#static MatExpr Mat::zeros(int ndims, const int* sz, int type)"><strong>[1]</strong></a>, <a href="modules/core/doc/basic_structures.html#static MatExpr Mat::zeros(int rows, int cols, int type)"><strong>[2]</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/basic_structures.html#Mat::~Mat()"><strong>Mat::~Mat (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/basic_structures.html#Mat_"><strong>Mat_ (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/structural_analysis_and_shape_descriptors.html#double cvMatchShapes(const void* object1, const void* object2, int method, double parameter)"><strong>MatchShapes (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/structural_analysis_and_shape_descriptors.html#double matchShapes(InputArray contour1, InputArray contour2, int method, double parameter)"><strong>matchShapes (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/structural_analysis_and_shape_descriptors.html#cv.MatchShapes"><strong>MatchShapes() (Python function in cv)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/structural_analysis_and_shape_descriptors.html#cv2.matchShapes"><strong>matchShapes() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/object_detection.html#void cvMatchTemplate(const CvArr* image, const CvArr* templ, CvArr* result, int method)"><strong>MatchTemplate (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/object_detection.html#void matchTemplate(InputArray image, InputArray templ, OutputArray result, int method)"><strong>matchTemplate (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/object_detection.html#cv.MatchTemplate"><strong>MatchTemplate() (Python function in cv)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/object_detection.html#cv2.matchTemplate"><strong>matchTemplate() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/calib3d/doc/camera_calibration_and_3d_reconstruction.html#void matMulDeriv(InputArray A, InputArray B, OutputArray dABdA, OutputArray dABdB)"><strong>matMulDeriv (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/calib3d/doc/camera_calibration_and_3d_reconstruction.html#cv2.matMulDeriv"><strong>matMulDeriv() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/basic_structures.html#Matx"><strong>Matx (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#void cvMax(const CvArr* src1, const CvArr* src2, CvArr* dst)"><strong>Max (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#MatExpr max(const Mat& a, const Mat& b)"><strong>max (C++ function)</strong></a>, <a href="modules/core/doc/operations_on_arrays.html#MatExpr max(const Mat& a, double s)"><strong>[1]</strong></a>, <a href="modules/core/doc/operations_on_arrays.html#MatExpr max(double s, const Mat& a)"><strong>[2]</strong></a>, <a href="modules/core/doc/operations_on_arrays.html#void max(InputArray src1, InputArray src2, OutputArray dst)"><strong>[3]</strong></a>, <a href="modules/core/doc/operations_on_arrays.html#void max(const Mat& src1, const Mat& src2, Mat& dst)"><strong>[4]</strong></a>, <a href="modules/core/doc/operations_on_arrays.html#void max(const Mat& src1, double src2, Mat& dst)"><strong>[5]</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#cv.Max"><strong>Max() (Python function in cv)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#cv2.max"><strong>max() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#void cvMaxS(const CvArr* src, double value, CvArr* dst)"><strong>MaxS (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#cv.MaxS"><strong>MaxS() (Python function in cv)</strong></a>
  </dt>

  </dl></td>
  <td style="width: 33%" valign="top"><dl>
      
  <dt><a href="modules/core/doc/operations_on_arrays.html#Scalar mean(InputArray src, InputArray mask)"><strong>mean (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#cv2.mean"><strong>mean() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/video/doc/motion_analysis_and_object_tracking.html#int cvMeanShift(const CvArr* prob_image, CvRect window, CvTermCriteria criteria, CvConnectedComp* comp)"><strong>MeanShift (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/video/doc/motion_analysis_and_object_tracking.html#int meanShift(InputArray probImage, Rect& window, TermCriteria criteria)"><strong>meanShift (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/video/doc/motion_analysis_and_object_tracking.html#cv.MeanShift"><strong>MeanShift() (Python function in cv)</strong></a>
  </dt>

      
  <dt><a href="modules/video/doc/motion_analysis_and_object_tracking.html#cv2.meanShift"><strong>meanShift() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#void meanStdDev(InputArray src, OutputArray mean, OutputArray stddev, InputArray mask)"><strong>meanStdDev (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#cv2.meanStdDev"><strong>meanStdDev() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/filtering.html#void medianBlur(InputArray src, OutputArray dst, int ksize)"><strong>medianBlur (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/filtering.html#cv2.medianBlur"><strong>medianBlur() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/dynamic_structures.html#void* cvMemStorageAlloc(CvMemStorage* storage, size_t size)"><strong>MemStorageAlloc (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/dynamic_structures.html#CvString cvMemStorageAllocString(CvMemStorage* storage, const char* ptr, int len)"><strong>MemStorageAllocString (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#void cvMerge(const CvArr* src0, const CvArr* src1, const CvArr* src2, const CvArr* src3, CvArr* dst)"><strong>Merge (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#void merge(InputArrayOfArrays mv, OutputArray dst)"><strong>merge (C++ function)</strong></a>, <a href="modules/core/doc/operations_on_arrays.html#void merge(const Mat* mv, size_t count, OutputArray dst)"><strong>[1]</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#cv.Merge"><strong>Merge() (Python function in cv)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#cv2.merge"><strong>merge() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/viz/doc/viz3d.html#Mesh"><strong>Mesh (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_basic_structures.html#double cvmGet(const CvMat* mat, int row, int col)"><strong>mGet (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_basic_structures.html#cv.mGet"><strong>mGet() (Python function in cv)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#void cvMin(const CvArr* src1, const CvArr* src2, CvArr* dst)"><strong>Min (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#MatExpr min(const Mat& a, const Mat& b)"><strong>min (C++ function)</strong></a>, <a href="modules/core/doc/operations_on_arrays.html#MatExpr min(const Mat& a, double s)"><strong>[1]</strong></a>, <a href="modules/core/doc/operations_on_arrays.html#MatExpr min(double s, const Mat& a)"><strong>[2]</strong></a>, <a href="modules/core/doc/operations_on_arrays.html#void min(InputArray src1, InputArray src2, OutputArray dst)"><strong>[3]</strong></a>, <a href="modules/core/doc/operations_on_arrays.html#void min(const Mat& src1, const Mat& src2, Mat& dst)"><strong>[4]</strong></a>, <a href="modules/core/doc/operations_on_arrays.html#void min(const Mat& src1, double src2, Mat& dst)"><strong>[5]</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#cv.Min"><strong>Min() (Python function in cv)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#cv2.min"><strong>min() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/structural_analysis_and_shape_descriptors.html#RotatedRect minAreaRect(InputArray points)"><strong>minAreaRect (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/structural_analysis_and_shape_descriptors.html#cv2.minAreaRect"><strong>minAreaRect() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/structural_analysis_and_shape_descriptors.html#CvBox2D cvMinAreaRect2(const CvArr* points, CvMemStorage* storage)"><strong>MinAreaRect2 (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/structural_analysis_and_shape_descriptors.html#cv.MinAreaRect2"><strong>MinAreaRect2() (Python function in cv)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/structural_analysis_and_shape_descriptors.html#int cvMinEnclosingCircle(const CvArr* points, CvPoint2D32f* center, float* radius)"><strong>MinEnclosingCircle (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/structural_analysis_and_shape_descriptors.html#void minEnclosingCircle(InputArray points, Point2f& center, float& radius)"><strong>minEnclosingCircle (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/structural_analysis_and_shape_descriptors.html#cv.MinEnclosingCircle"><strong>MinEnclosingCircle() (Python function in cv)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/structural_analysis_and_shape_descriptors.html#cv2.minEnclosingCircle"><strong>minEnclosingCircle() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#void minMaxIdx(InputArray src, double* minVal, double* maxVal, int* minIdx, int* maxIdx, InputArray mask)"><strong>minMaxIdx (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#void cvMinMaxLoc(const CvArr* arr, double* min_val, double* max_val, CvPoint* min_loc, CvPoint* max_loc, const CvArr* mask)"><strong>MinMaxLoc (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#void minMaxLoc(InputArray src, double* minVal, double* maxVal, Point* minLoc, Point* maxLoc, InputArray mask)"><strong>minMaxLoc (C++ function)</strong></a>, <a href="modules/core/doc/operations_on_arrays.html#void minMaxLoc(const SparseMat& a, double* minVal, double* maxVal, int* minIdx, int* maxIdx)"><strong>[1]</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#cv.MinMaxLoc"><strong>MinMaxLoc() (Python function in cv)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#cv2.minMaxLoc"><strong>minMaxLoc() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#void cvMinS(const CvArr* src, double value, CvArr* dst)"><strong>MinS (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#cv.MinS"><strong>MinS() (Python function in cv)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#void cvMixChannels(const CvArr** src, int src_count, CvArr** dst, int dst_count, const int* from_to, int pair_count)"><strong>MixChannels (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#void mixChannels(const Mat* src, size_t nsrcs, Mat* dst, size_t ndsts, const int* fromTo, size_t npairs)"><strong>mixChannels (C++ function)</strong></a>, <a href="modules/core/doc/operations_on_arrays.html#void mixChannels(const vector<Mat>& src, vector<Mat>& dst, const int* fromTo, size_t npairs)"><strong>[1]</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#cv.MixChannels"><strong>MixChannels() (Python function in cv)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#cv2.mixChannels"><strong>mixChannels() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/structural_analysis_and_shape_descriptors.html#void cvMoments(const CvArr* arr, CvMoments* moments, int binary)"><strong>Moments (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/structural_analysis_and_shape_descriptors.html#Moments moments(InputArray array, bool binaryImage)"><strong>moments (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/structural_analysis_and_shape_descriptors.html#cv.Moments"><strong>Moments() (Python function in cv)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/structural_analysis_and_shape_descriptors.html#cv2.moments"><strong>moments() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/filtering.html#Scalar morphologyDefaultBorderValue()"><strong>morphologyDefaultBorderValue (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/filtering.html#void cvMorphologyEx(const CvArr* src, CvArr* dst, CvArr* temp, IplConvKernel* element, int operation, int iterations)"><strong>MorphologyEx (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/filtering.html#void morphologyEx(InputArray src, OutputArray dst, int op, InputArray kernel, Point anchor, int iterations, int borderType, const Scalar& borderValue)"><strong>morphologyEx (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/filtering.html#cv.MorphologyEx"><strong>MorphologyEx() (Python function in cv)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/filtering.html#cv2.morphologyEx"><strong>morphologyEx() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/viz/doc/viz3d.html#MouseEvent"><strong>MouseEvent (C++ class)</strong></a>
  </dt>

      <dd><dl>
        
  <dt><a href="modules/viz/doc/viz3d.html#MouseEvent (const Type& type, const MouseButton& button, const Point& p, Modifiers modifiers)"><strong>(C++ function)</strong></a>
  </dt>

      </dl></dd>
      
  <dt><a href="modules/highgui/doc/user_interface.html#void cvMoveWindow(const char* name, int x, int y)"><strong>MoveWindow (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/highgui/doc/user_interface.html#void moveWindow(const string& winname, int x, int y)"><strong>moveWindow (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/highgui/doc/user_interface.html#cv.MoveWindow"><strong>MoveWindow() (Python function in cv)</strong></a>
  </dt>

      
  <dt><a href="modules/highgui/doc/user_interface.html#cv2.moveWindow"><strong>moveWindow() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/features2d/doc/feature_detection_and_description.html#MSER : public FeatureDetector"><strong>MSER (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/features2d/doc/feature_detection_and_description.html#MSER::MSER(int _delta, int _min_area, int _max_area, double _max_variation, double _min_diversity, int _max_evolution, double _area_threshold, double _min_margin, int _edge_blur_size)"><strong>MSER::MSER (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/features2d/doc/feature_detection_and_description.html#void MSER::operator()(const Mat& image, vector<vector<Point> >& msers, const Mat& mask) const"><strong>MSER::operator() (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/features2d/doc/common_interfaces_of_feature_detectors.html#MserFeatureDetector : public FeatureDetector"><strong>MserFeatureDetector (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_basic_structures.html#void cvmSet(CvMat* mat, int row, int col, double value)"><strong>mSet (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_basic_structures.html#cv.mSet"><strong>mSet() (Python function in cv)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#void cvMul(const CvArr* src1, const CvArr* src2, CvArr* dst, double scale)"><strong>Mul (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#cv.Mul"><strong>Mul() (Python function in cv)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#void cvMulSpectrums(const CvArr* src1, const CvArr* src2, CvArr* dst, int flags)"><strong>MulSpectrums (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#void mulSpectrums(InputArray a, InputArray b, OutputArray c, int flags, bool conjB)"><strong>mulSpectrums (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#cv.MulSpectrums"><strong>MulSpectrums() (Python function in cv)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#cv2.mulSpectrums"><strong>mulSpectrums() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#void multiply(InputArray src1, InputArray src2, OutputArray dst, double scale, int dtype)"><strong>multiply (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#cv2.multiply"><strong>multiply() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/motion_analysis_and_object_tracking.html#void cvMultiplyAcc(const CvArr* image1, const CvArr* image2, CvArr* acc, const CvArr* mask)"><strong>MultiplyAcc (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/motion_analysis_and_object_tracking.html#cv.MultiplyAcc"><strong>MultiplyAcc() (Python function in cv)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#void cvMulTransposed(const CvArr* src, CvArr* dst, int order, const CvArr* delta, double scale)"><strong>MulTransposed (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#void mulTransposed(InputArray src, OutputArray dst, bool aTa, InputArray delta, double scale, int dtype)"><strong>mulTransposed (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#cv.MulTransposed"><strong>MulTransposed() (Python function in cv)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#cv2.mulTransposed"><strong>mulTransposed() (Python function in cv2)</strong></a>
  </dt>

  </dl></td>
</tr></table>

<h2 id="N">N</h2>
<table style="width: 100%" class="indextable genindextable"><tr>
  <td style="width: 33%" valign="top"><dl>
      
  <dt><a href="modules/highgui/doc/user_interface.html#int cvNamedWindow(const char* name, int flags)"><strong>NamedWindow (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/highgui/doc/user_interface.html#void namedWindow(const string& winname, int flags)"><strong>namedWindow (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/highgui/doc/user_interface.html#cv.NamedWindow"><strong>NamedWindow() (Python function in cv)</strong></a>
  </dt>

      
  <dt><a href="modules/highgui/doc/user_interface.html#cv2.namedWindow"><strong>namedWindow() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/basic_structures.html#NAryMatIterator"><strong>NAryMatIterator (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/dynamic_structures.html#int cvNextGraphItem(CvGraphScanner* scanner)"><strong>NextGraphItem (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/dynamic_structures.html#void* cvNextTreeNode(CvTreeNodeIterator* tree_iterator)"><strong>NextTreeNode (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#double cvNorm(const CvArr* arr1, const CvArr* arr2, int norm_type, const CvArr* mask)"><strong>Norm (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#double norm(InputArray src1, InputArray src2, int normType, InputArray mask)"><strong>norm (C++ function)</strong></a>, <a href="modules/core/doc/operations_on_arrays.html#double norm(InputArray src1, int normType, InputArray mask)"><strong>[1]</strong></a>, <a href="modules/core/doc/operations_on_arrays.html#double norm(const SparseMat& src, int normType)"><strong>[2]</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#cv.Norm"><strong>Norm() (Python function in cv)</strong></a>
  </dt>

  </dl></td>
  <td style="width: 33%" valign="top"><dl>
      
  <dt><a href="modules/core/doc/operations_on_arrays.html#cv2.norm"><strong>norm() (Python function in cv2)</strong></a>, <a href="modules/core/doc/operations_on_arrays.html#cv2.norm"><strong>[1]</strong></a>
  </dt>

      
  <dt><a href="modules/ml/doc/normal_bayes_classifier.html#cv2.NormalBayesClassifier"><strong>NormalBayesClassifier() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/ml/doc/normal_bayes_classifier.html#cv2.NormalBayesClassifier.predict"><strong>NormalBayesClassifier.predict() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/ml/doc/normal_bayes_classifier.html#cv2.NormalBayesClassifier.train"><strong>NormalBayesClassifier.train() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#void normalize(InputArray src, OutputArray dst, double alpha, double beta, int norm_type, int dtype, InputArray mask)"><strong>normalize (C++ function)</strong></a>, <a href="modules/core/doc/operations_on_arrays.html#void normalize(const SparseMat& src, SparseMat& dst, double alpha, int normType)"><strong>[1]</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#cv2.normalize"><strong>normalize() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/histograms.html#void cvNormalizeHist(CvHistogram* hist, double factor)"><strong>NormalizeHist (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/histograms.html#cv.NormalizeHist"><strong>NormalizeHist() (Python function in cv)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#void cvNot(const CvArr* src, CvArr* dst)"><strong>Not (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#cv.Not"><strong>Not() (Python function in cv)</strong></a>
  </dt>

  </dl></td>
</tr></table>

<h2 id="O">O</h2>
<table style="width: 100%" class="indextable genindextable"><tr>
  <td style="width: 33%" valign="top"><dl>
      
  <dt><a href="modules/ocl/doc/operations_on_matrices.html#void ocl::abs(const oclMat& src, oclMat& dst)"><strong>ocl::abs (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/ocl/doc/operations_on_matrices.html#void ocl::absdiff(const oclMat& src1, const Scalar& s, oclMat& dst)"><strong>ocl::absdiff (C++ function)</strong></a>, <a href="modules/ocl/doc/operations_on_matrices.html#void ocl::absdiff(const oclMat& src1, const oclMat& src2, oclMat& dst)"><strong>[1]</strong></a>
  </dt>

      
  <dt><a href="modules/ocl/doc/matrix_reductions.html#Scalar ocl::absSum(const oclMat &m)"><strong>ocl::absSum (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/ocl/doc/image_filtering.html#void ocl::adaptiveBilateralFilter(const oclMat& src, oclMat& dst, Size ksize, double sigmaSpace, double maxSigmaColor , Point anchor , int borderType)"><strong>ocl::adaptiveBilateralFilter (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/ocl/doc/operations_on_matrices.html#void ocl::add(const oclMat & src1, const Scalar & s, oclMat & dst, const oclMat & mask)"><strong>ocl::add (C++ function)</strong></a>, <a href="modules/ocl/doc/operations_on_matrices.html#void ocl::add(const oclMat & src1, const oclMat & src2, oclMat & dst, const oclMat & mask)"><strong>[1]</strong></a>
  </dt>

      
  <dt><a href="modules/ocl/doc/operations_on_matrices.html#void ocl::addWeighted(const oclMat& src1, double alpha, const oclMat& src2, double beta, double gama, oclMat& dst)"><strong>ocl::addWeighted (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/ocl/doc/video_analysis.html#ocl::BackgroundSubtractor"><strong>ocl::BackgroundSubtractor (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/ocl/doc/video_analysis.html#void ocl::BackgroundSubtractor::getBackgroundImage(oclMat& backgroundImage) const"><strong>ocl::BackgroundSubtractor::getBackgroundImage (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/ocl/doc/video_analysis.html#void ocl::BackgroundSubtractor::operator()(const oclMat& image, oclMat& fgmask, float learningRate)"><strong>ocl::BackgroundSubtractor::operator() (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/ocl/doc/image_filtering.html#ocl::BaseColumnFilter_GPU"><strong>ocl::BaseColumnFilter_GPU (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/ocl/doc/image_filtering.html#ocl::BaseFilter_GPU"><strong>ocl::BaseFilter_GPU (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/ocl/doc/image_filtering.html#ocl::BaseRowFilter_GPU"><strong>ocl::BaseRowFilter_GPU (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/ocl/doc/image_filtering.html#void ocl::bilateralFilter(const oclMat &src, oclMat &dst, int d, double sigmaColor, double sigmaSpace, int borderType)"><strong>ocl::bilateralFilter (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/ocl/doc/operations_on_matrices.html#void ocl::bitwise_and(const oclMat& src1, const Scalar& s, oclMat& dst, const oclMat& mask)"><strong>ocl::bitwise_and (C++ function)</strong></a>, <a href="modules/ocl/doc/operations_on_matrices.html#void ocl::bitwise_and(const oclMat& src1, const oclMat& src2, oclMat& dst, const oclMat& mask)"><strong>[1]</strong></a>
  </dt>

      
  <dt><a href="modules/ocl/doc/operations_on_matrices.html#void ocl::bitwise_not(const oclMat &src, oclMat &dst)"><strong>ocl::bitwise_not (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/ocl/doc/operations_on_matrices.html#void ocl::bitwise_or(const oclMat& src1, const Scalar& s, oclMat& dst, const oclMat& mask)"><strong>ocl::bitwise_or (C++ function)</strong></a>, <a href="modules/ocl/doc/operations_on_matrices.html#void ocl::bitwise_or(const oclMat& src1, const oclMat& src2, oclMat& dst, const oclMat& mask)"><strong>[1]</strong></a>
  </dt>

      
  <dt><a href="modules/ocl/doc/operations_on_matrices.html#void ocl::bitwise_xor(const oclMat& src1, const Scalar& s, oclMat& dst, const oclMat& mask)"><strong>ocl::bitwise_xor (C++ function)</strong></a>, <a href="modules/ocl/doc/operations_on_matrices.html#void ocl::bitwise_xor(const oclMat& src1, const oclMat& src2, oclMat& dst, const oclMat& mask)"><strong>[1]</strong></a>
  </dt>

      
  <dt><a href="modules/ocl/doc/image_filtering.html#void ocl::blendLinear(const oclMat& img1, const oclMat& img2, const oclMat& weights1, const oclMat& weights2, oclMat& result)"><strong>ocl::blendLinear (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/ocl/doc/image_filtering.html#void ocl::blur(const oclMat &src, oclMat &dst, Size ksize, Point anchor , int borderType)"><strong>ocl::blur (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/ocl/doc/image_filtering.html#void ocl::boxFilter(const oclMat &src, oclMat &dst, int ddepth, Size ksize, Point anchor , int borderType)"><strong>ocl::boxFilter (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/ocl/doc/feature_detection_and_description.html#ocl::BruteForceMatcher_OCL_base"><strong>ocl::BruteForceMatcher_OCL_base (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/ocl/doc/feature_detection_and_description.html#void ocl::BruteForceMatcher_OCL_base::knnMatch(const oclMat& query, const oclMat& train, std::vector< std::vector<DMatch> >&matches, int k, const oclMat& mask , bool compactResult)"><strong>ocl::BruteForceMatcher_OCL_base::knnMatch (C++ function)</strong></a>, <a href="modules/ocl/doc/feature_detection_and_description.html#void ocl::BruteForceMatcher_OCL_base::knnMatch(const oclMat& query, std::vector< std::vector<DMatch> >&matches, int k, const std::vector<oclMat>&masks , bool compactResult)"><strong>[1]</strong></a>
  </dt>

      
  <dt><a href="modules/ocl/doc/feature_detection_and_description.html#void ocl::BruteForceMatcher_OCL_base::knnMatch2Collection(const oclMat& query, const oclMat& trainCollection, oclMat& trainIdx, oclMat& imgIdx, oclMat& distance, const oclMat& maskCollection)"><strong>ocl::BruteForceMatcher_OCL_base::knnMatch2Collection (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/ocl/doc/feature_detection_and_description.html#void ocl::BruteForceMatcher_OCL_base::knnMatch2Convert(const Mat& trainIdx, const Mat& imgIdx, const Mat& distance, std::vector< std::vector<DMatch> >& matches, bool compactResult)"><strong>ocl::BruteForceMatcher_OCL_base::knnMatch2Convert (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/ocl/doc/feature_detection_and_description.html#void ocl::BruteForceMatcher_OCL_base::knnMatch2Download(const oclMat& trainIdx, const oclMat& imgIdx, const oclMat& distance, std::vector< std::vector<DMatch> >& matches, bool compactResult)"><strong>ocl::BruteForceMatcher_OCL_base::knnMatch2Download (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/ocl/doc/feature_detection_and_description.html#void ocl::BruteForceMatcher_OCL_base::knnMatchConvert(const Mat& trainIdx, const Mat& distance, std::vector< std::vector<DMatch> >&matches, bool compactResult)"><strong>ocl::BruteForceMatcher_OCL_base::knnMatchConvert (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/ocl/doc/feature_detection_and_description.html#void ocl::BruteForceMatcher_OCL_base::knnMatchDownload(const oclMat& trainIdx, const oclMat& distance, std::vector< std::vector<DMatch> >&matches, bool compactResult)"><strong>ocl::BruteForceMatcher_OCL_base::knnMatchDownload (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/ocl/doc/feature_detection_and_description.html#void ocl::BruteForceMatcher_OCL_base::knnMatchSingle(const oclMat& query, const oclMat& train, oclMat& trainIdx, oclMat& distance, oclMat& allDist, int k, const oclMat& mask)"><strong>ocl::BruteForceMatcher_OCL_base::knnMatchSingle (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/ocl/doc/feature_detection_and_description.html#void ocl::BruteForceMatcher_OCL_base::makeGpuCollection(oclMat& trainCollection, oclMat& maskCollection, const vector<oclMat>& masks)"><strong>ocl::BruteForceMatcher_OCL_base::makeGpuCollection (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/ocl/doc/feature_detection_and_description.html#void ocl::BruteForceMatcher_OCL_base::match(const oclMat& query, const oclMat& train, std::vector<DMatch>& matches, const oclMat& mask)"><strong>ocl::BruteForceMatcher_OCL_base::match (C++ function)</strong></a>, <a href="modules/ocl/doc/feature_detection_and_description.html#void ocl::BruteForceMatcher_OCL_base::match(const oclMat& query, std::vector<DMatch>& matches, const std::vector<oclMat>& masks)"><strong>[1]</strong></a>
  </dt>

      
  <dt><a href="modules/ocl/doc/feature_detection_and_description.html#void ocl::BruteForceMatcher_OCL_base::matchCollection(const oclMat& query, const oclMat& trainCollection, oclMat& trainIdx, oclMat& imgIdx, oclMat& distance, const oclMat& masks)"><strong>ocl::BruteForceMatcher_OCL_base::matchCollection (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/ocl/doc/feature_detection_and_description.html#void ocl::BruteForceMatcher_OCL_base::matchConvert(const Mat& trainIdx, const Mat& distance, std::vector<DMatch>&matches)"><strong>ocl::BruteForceMatcher_OCL_base::matchConvert (C++ function)</strong></a>, <a href="modules/ocl/doc/feature_detection_and_description.html#void ocl::BruteForceMatcher_OCL_base::matchConvert(const Mat& trainIdx, const Mat& imgIdx, const Mat& distance, std::vector<DMatch>&matches)"><strong>[1]</strong></a>
  </dt>

      
  <dt><a href="modules/ocl/doc/feature_detection_and_description.html#static void ocl::BruteForceMatcher_OCL_base::matchDownload(const oclMat& trainIdx, const oclMat& distance, std::vector<DMatch>& matches)"><strong>ocl::BruteForceMatcher_OCL_base::matchDownload (C++ function)</strong></a>, <a href="modules/ocl/doc/feature_detection_and_description.html#static void ocl::BruteForceMatcher_OCL_base::matchDownload(const oclMat& trainIdx, const oclMat& imgIdx, const oclMat& distance, std::vector<DMatch>& matches)"><strong>[1]</strong></a>
  </dt>

      
  <dt><a href="modules/ocl/doc/feature_detection_and_description.html#void ocl::BruteForceMatcher_OCL_base::matchSingle(const oclMat& query, const oclMat& train, oclMat& trainIdx, oclMat& distance, const oclMat& mask)"><strong>ocl::BruteForceMatcher_OCL_base::matchSingle (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/ocl/doc/feature_detection_and_description.html#void ocl::BruteForceMatcher_OCL_base::radiusMatch(const oclMat& query, const oclMat& train, std::vector< std::vector<DMatch> >&matches, float maxDistance, const oclMat& mask , bool compactResult)"><strong>ocl::BruteForceMatcher_OCL_base::radiusMatch (C++ function)</strong></a>, <a href="modules/ocl/doc/feature_detection_and_description.html#void ocl::BruteForceMatcher_OCL_base::radiusMatch(const oclMat& query, std::vector< std::vector<DMatch> >&matches, float maxDistance, const std::vector<oclMat>& masks , bool compactResult)"><strong>[1]</strong></a>
  </dt>

      
  <dt><a href="modules/ocl/doc/feature_detection_and_description.html#void ocl::BruteForceMatcher_OCL_base::radiusMatchCollection(const oclMat& query, oclMat& trainIdx, oclMat& imgIdx, oclMat& distance, oclMat& nMatches, float maxDistance, const std::vector<oclMat>& masks)"><strong>ocl::BruteForceMatcher_OCL_base::radiusMatchCollection (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/ocl/doc/feature_detection_and_description.html#void ocl::BruteForceMatcher_OCL_base::radiusMatchConvert(const Mat& trainIdx, const Mat& distance, const Mat& nMatches, std::vector< std::vector<DMatch> >&matches, bool compactResult)"><strong>ocl::BruteForceMatcher_OCL_base::radiusMatchConvert (C++ function)</strong></a>, <a href="modules/ocl/doc/feature_detection_and_description.html#void ocl::BruteForceMatcher_OCL_base::radiusMatchConvert(const Mat& trainIdx, const Mat& imgIdx, const Mat& distance, const Mat& nMatches, std::vector< std::vector<DMatch> >& matches, bool compactResult)"><strong>[1]</strong></a>
  </dt>

      
  <dt><a href="modules/ocl/doc/feature_detection_and_description.html#void ocl::BruteForceMatcher_OCL_base::radiusMatchDownload(const oclMat& trainIdx, const oclMat& distance, const oclMat& nMatches, std::vector< std::vector<DMatch> >&matches, bool compactResult)"><strong>ocl::BruteForceMatcher_OCL_base::radiusMatchDownload (C++ function)</strong></a>, <a href="modules/ocl/doc/feature_detection_and_description.html#void ocl::BruteForceMatcher_OCL_base::radiusMatchDownload(const oclMat& trainIdx, const oclMat& imgIdx, const oclMat& distance, const oclMat& nMatches, std::vector< std::vector<DMatch> >& matches, bool compactResult)"><strong>[1]</strong></a>
  </dt>

      
  <dt><a href="modules/ocl/doc/feature_detection_and_description.html#void ocl::BruteForceMatcher_OCL_base::radiusMatchSingle(const oclMat& query, const oclMat& train, oclMat& trainIdx, oclMat& distance, oclMat& nMatches, float maxDistance, const oclMat& mask)"><strong>ocl::BruteForceMatcher_OCL_base::radiusMatchSingle (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/ocl/doc/image_processing.html#void ocl::buildWarpAffineMaps(const Mat& M, bool inverse, Size dsize, oclMat& xmap, oclMat& ymap)"><strong>ocl::buildWarpAffineMaps (C++ function)</strong></a>, <a href="modules/ocl/doc/image_processing.html#void ocl::buildWarpAffineMaps(const Mat& M, bool inverse, Size dsize, oclMat& xmap, oclMat& ymap)"><strong>[1]</strong></a>
  </dt>

      
  <dt><a href="modules/ocl/doc/image_processing.html#void ocl::buildWarpCylindricalMaps(Size src_size, Rect dst_roi, const Mat& K, const Mat& R, float scale, oclMat& map_x, oclMat& map_y)"><strong>ocl::buildWarpCylindricalMaps (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/ocl/doc/image_processing.html#void ocl::buildWarpPlaneMaps(Size src_size, Rect dst_roi, const Mat& K, const Mat& R, const Mat& T, float scale, oclMat& map_x, oclMat& map_y)"><strong>ocl::buildWarpPlaneMaps (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/ocl/doc/image_processing.html#void ocl::buildWarpSphericalMaps(Size src_size, Rect dst_roi, const Mat& K, const Mat& R, float scale, oclMat& map_x, oclMat& map_y)"><strong>ocl::buildWarpSphericalMaps (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/ocl/doc/image_processing.html#void ocl::calcHist(const oclMat &mat_src, oclMat &mat_hist)"><strong>ocl::calcHist (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/ocl/doc/feature_detection_and_description.html#void ocl::Canny(const oclMat& dx, const oclMat& dy, CannyBuf& buf, oclMat& edges, double low_thresh, double high_thresh, bool L2gradient)"><strong>ocl::Canny (C++ function)</strong></a>, <a href="modules/ocl/doc/feature_detection_and_description.html#void ocl::Canny(const oclMat& dx, const oclMat& dy, oclMat& edges, double low_thresh, double high_thresh, bool L2gradient)"><strong>[1]</strong></a>, <a href="modules/ocl/doc/feature_detection_and_description.html#void ocl::Canny(const oclMat& image, CannyBuf& buf, oclMat& edges, double low_thresh, double high_thresh, int apperture_size , bool L2gradient)"><strong>[2]</strong></a>, <a href="modules/ocl/doc/feature_detection_and_description.html#void ocl::Canny(const oclMat& image, oclMat& edges, double low_thresh, double high_thresh, int apperture_size , bool L2gradient)"><strong>[3]</strong></a>
  </dt>

      
  <dt><a href="modules/ocl/doc/operations_on_matrices.html#void ocl::cartToPolar(const oclMat &x, const oclMat &y, oclMat &magnitude, oclMat &angle, bool angleInDegrees)"><strong>ocl::cartToPolar (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/ocl/doc/image_filtering.html#void ocl::columnSum(const oclMat& src, oclMat& sum)"><strong>ocl::columnSum (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/ocl/doc/operations_on_matrices.html#void ocl::compare(const oclMat &src1, const oclMat &src2, oclMat &dst, int cmpop)"><strong>ocl::compare (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/ocl/doc/image_filtering.html#void ocl::convolve(const oclMat &image, const oclMat &temp1, oclMat &result)"><strong>ocl::convolve (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/ocl/doc/image_filtering.html#void ocl::copyMakeBorder(const oclMat &src, oclMat &dst, int top, int bottom, int left, int right, int boardtype, const Scalar &value)"><strong>ocl::copyMakeBorder (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/ocl/doc/image_processing.html#void ocl::cornerHarris(const oclMat &src, oclMat &dst, int blockSize, int ksize, double k, int bordertype)"><strong>ocl::cornerHarris (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/ocl/doc/image_processing.html#void ocl::cornerMinEigenVal(const oclMat &src, oclMat &dst, int blockSize, int ksize, int bordertype)"><strong>ocl::cornerMinEigenVal (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/ocl/doc/matrix_reductions.html#int ocl::countNonZero(const oclMat &src)"><strong>ocl::countNonZero (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/ocl/doc/image_filtering.html#Ptr<FilterEngine_GPU> ocl::createBoxFilter_GPU(int srcType, int dstType, const Size &ksize, const Point &anchor , int borderType)"><strong>ocl::createBoxFilter_GPU (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/ocl/doc/image_filtering.html#Ptr<FilterEngine_GPU> ocl::createDerivFilter_GPU(int srcType, int dstType, int dx, int dy, int ksize, int borderType , Size imgSize)"><strong>ocl::createDerivFilter_GPU (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/ocl/doc/image_filtering.html#Ptr<FilterEngine_GPU> ocl::createFilter2D_GPU(const Ptr<BaseFilter_GPU> filter2D)"><strong>ocl::createFilter2D_GPU (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/ocl/doc/image_filtering.html#Ptr<FilterEngine_GPU> ocl::createGaussianFilter_GPU(int type, Size ksize, double sigma1, double sigma2 , int bordertype , Size imgSize)"><strong>ocl::createGaussianFilter_GPU (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/ocl/doc/image_filtering.html#Ptr<FilterEngine_GPU> ocl::createLinearFilter_GPU(int srcType, int dstType, const Mat &kernel, const Point &anchor , int borderType)"><strong>ocl::createLinearFilter_GPU (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/ocl/doc/image_filtering.html#Ptr<FilterEngine_GPU> ocl::createMorphologyFilter_GPU(int op, int type, const Mat &kernel, const Point &anchor , int iterations)"><strong>ocl::createMorphologyFilter_GPU (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/ocl/doc/image_filtering.html#Ptr<FilterEngine_GPU> ocl::createSeparableFilter_GPU(const Ptr<BaseRowFilter_GPU> &rowFilter, const Ptr<BaseColumnFilter_GPU> &columnFilter)"><strong>ocl::createSeparableFilter_GPU (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/ocl/doc/image_filtering.html#Ptr<FilterEngine_GPU> ocl::createSeparableLinearFilter_GPU(int srcType, int dstType, const Mat &rowKernel, const Mat &columnKernel, const Point &anchor , double delta , int bordertype , Size imgSize)"><strong>ocl::createSeparableLinearFilter_GPU (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/ocl/doc/image_processing.html#void ocl::cvtColor(const oclMat &src, oclMat &dst, int code, int dcn)"><strong>ocl::cvtColor (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/ocl/doc/operations_on_matrices.html#void ocl::dft(const oclMat& src, oclMat& dst, Size dft_size , int flags)"><strong>ocl::dft (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/ocl/doc/image_filtering.html#void ocl::dilate(const oclMat &src, oclMat &dst, const Mat &kernel, Point anchor , int iterations , int borderType , const Scalar &borderValue)"><strong>ocl::dilate (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/ocl/doc/ml_machine_learning.html#void ocl::distanceToCenters(const oclMat &src, const oclMat &centers, Mat &dists, Mat &labels, int distType)"><strong>ocl::distanceToCenters (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/ocl/doc/operations_on_matrices.html#void ocl::divide(const oclMat& src1, const oclMat& src2, oclMat& dst, double scale)"><strong>ocl::divide (C++ function)</strong></a>, <a href="modules/ocl/doc/operations_on_matrices.html#void ocl::divide(double scale, const oclMat& src1, oclMat& dst)"><strong>[1]</strong></a>
  </dt>

      
  <dt><a href="modules/ocl/doc/image_processing.html#void ocl::equalizeHist(const oclMat &mat_src, oclMat &mat_dst)"><strong>ocl::equalizeHist (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/ocl/doc/image_filtering.html#void ocl::erode(const oclMat &src, oclMat &dst, const Mat &kernel, Point anchor , int iterations , int borderType , const Scalar &borderValue)"><strong>ocl::erode (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/ocl/doc/operations_on_matrices.html#void ocl::exp(const oclMat &src, oclMat &dst)"><strong>ocl::exp (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/ocl/doc/video_analysis.html#ocl::FarnebackOpticalFlow"><strong>ocl::FarnebackOpticalFlow (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/ocl/doc/video_analysis.html#void ocl::FarnebackOpticalFlow::operator ()(const oclMat &frame0, const oclMat &frame1, oclMat &flowx, oclMat &flowy)"><strong>ocl::FarnebackOpticalFlow::operator() (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/ocl/doc/video_analysis.html#void ocl::FarnebackOpticalFlow::releaseMemory()"><strong>ocl::FarnebackOpticalFlow::releaseMemory (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/ocl/doc/image_filtering.html#void ocl::filter2D(const oclMat &src, oclMat &dst, int ddepth, const Mat &kernel, Point anchor , double delta , int borderType)"><strong>ocl::filter2D (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/ocl/doc/image_filtering.html#ocl::FilterEngine_GPU"><strong>ocl::FilterEngine_GPU (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/ocl/doc/operations_on_matrices.html#void ocl::flip(const oclMat& src, oclMat& dst, int flipCode)"><strong>ocl::flip (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/ocl/doc/image_filtering.html#void ocl::GaussianBlur(const oclMat &src, oclMat &dst, Size ksize, double sigma1, double sigma2 , int bordertype)"><strong>ocl::GaussianBlur (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/ocl/doc/operations_on_matrices.html#void ocl::gemm(const oclMat& src1, const oclMat& src2, double alpha, const oclMat& src3, double beta, oclMat& dst, int flags)"><strong>ocl::gemm (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/ocl/doc/image_filtering.html#Ptr<BaseFilter_GPU> ocl::getBoxFilter_GPU(int srcType, int dstType, const Size &ksize, Point anchor , int borderType)"><strong>ocl::getBoxFilter_GPU (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/ocl/doc/image_filtering.html#Ptr<BaseColumnFilter_GPU> ocl::getLinearColumnFilter_GPU(int bufType, int dstType, const Mat &columnKernel, int anchor , int bordertype , double delta)"><strong>ocl::getLinearColumnFilter_GPU (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/ocl/doc/image_filtering.html#Ptr<BaseRowFilter_GPU> ocl::getLinearRowFilter_GPU(int srcType, int bufType, const Mat &rowKernel, int anchor , int bordertype)"><strong>ocl::getLinearRowFilter_GPU (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/ocl/doc/image_filtering.html#Ptr<BaseFilter_GPU> ocl::getMorphologyFilter_GPU(int op, int type, const Mat &kernel, const Size &ksize, Point anchor)"><strong>ocl::getMorphologyFilter_GPU (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/ocl/doc/structures_and_utility_functions.html#int ocl::getOpenCLDevices(DevicesInfo& devices, int deviceType , const PlatformInfo* platform)"><strong>ocl::getOpenCLDevices (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/ocl/doc/structures_and_utility_functions.html#int ocl::getOpenCLPlatforms(PlatformsInfo& platforms)"><strong>ocl::getOpenCLPlatforms (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/ocl/doc/video_analysis.html#ocl::GoodFeaturesToTrackDetector_OCL"><strong>ocl::GoodFeaturesToTrackDetector_OCL (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/ocl/doc/video_analysis.html#ocl::GoodFeaturesToTrackDetector_OCL::GoodFeaturesToTrackDetector_OCL(int maxCorners , double qualityLevel , double minDistance , int blockSize , bool useHarrisDetector , double harrisK)"><strong>ocl::GoodFeaturesToTrackDetector_OCL::GoodFeaturesToTrackDetector_OCL (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/ocl/doc/video_analysis.html#void ocl::GoodFeaturesToTrackDetector_OCL::operator ()(const oclMat& image, oclMat& corners, const oclMat& mask)"><strong>ocl::GoodFeaturesToTrackDetector_OCL::operator() (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/ocl/doc/video_analysis.html#void ocl::GoodFeaturesToTrackDetector_OCL::releaseMemory()"><strong>ocl::GoodFeaturesToTrackDetector_OCL::releaseMemory (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/ocl/doc/feature_detection_and_description.html#ocl::HOGDescriptor"><strong>ocl::HOGDescriptor (C++ structure)</strong></a>
  </dt>

      
  <dt><a href="modules/ocl/doc/feature_detection_and_description.html#void ocl::HOGDescriptor::detect(const oclMat& img, vector<Point>& found_locations, double hit_threshold, Size win_stride, Size padding)"><strong>ocl::HOGDescriptor::detect (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/ocl/doc/feature_detection_and_description.html#void ocl::HOGDescriptor::detectMultiScale(const oclMat& img, vector<Rect>& found_locations, double hit_threshold, Size win_stride, Size padding, double scale0, int group_threshold)"><strong>ocl::HOGDescriptor::detectMultiScale (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/ocl/doc/feature_detection_and_description.html#size_t ocl::HOGDescriptor::getBlockHistogramSize() const"><strong>ocl::HOGDescriptor::getBlockHistogramSize (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/ocl/doc/feature_detection_and_description.html#static vector<float> ocl::HOGDescriptor::getDefaultPeopleDetector()"><strong>ocl::HOGDescriptor::getDefaultPeopleDetector (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/ocl/doc/feature_detection_and_description.html#void ocl::HOGDescriptor::getDescriptors(const oclMat& img, Size win_stride, oclMat& descriptors, int descr_format)"><strong>ocl::HOGDescriptor::getDescriptors (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/ocl/doc/feature_detection_and_description.html#size_t ocl::HOGDescriptor::getDescriptorSize() const"><strong>ocl::HOGDescriptor::getDescriptorSize (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/ocl/doc/feature_detection_and_description.html#static vector<float> ocl::HOGDescriptor::getPeopleDetector48x96()"><strong>ocl::HOGDescriptor::getPeopleDetector48x96 (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/ocl/doc/feature_detection_and_description.html#static vector<float> ocl::HOGDescriptor::getPeopleDetector64x128()"><strong>ocl::HOGDescriptor::getPeopleDetector64x128 (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/ocl/doc/feature_detection_and_description.html#ocl::HOGDescriptor::HOGDescriptor(Size win_size, Size block_size, Size block_stride, Size cell_size, int nbins, double win_sigma, double threshold_L2hys, bool gamma_correction, int nlevels)"><strong>ocl::HOGDescriptor::HOGDescriptor (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/ocl/doc/feature_detection_and_description.html#void ocl::HOGDescriptor::setSVMDetector(const vector<float>& detector)"><strong>ocl::HOGDescriptor::setSVMDetector (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/ocl/doc/structures_and_utility_functions.html#void ocl::initializeContext(void* pClPlatform, void* pClContext, void* pClDevice)"><strong>ocl::initializeContext (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/ocl/doc/image_processing.html#void ocl::integral(const oclMat &src, oclMat &sum)"><strong>ocl::integral (C++ function)</strong></a>, <a href="modules/ocl/doc/image_processing.html#void ocl::integral(const oclMat &src, oclMat &sum, oclMat &sqsum)"><strong>[1]</strong></a>
  </dt>

      
  <dt><a href="modules/ocl/doc/video_analysis.html#void ocl::interpolateFrames(const oclMat& frame0, const oclMat& frame1, const oclMat& fu, const oclMat& fv, const oclMat& bu, const oclMat& bv, float pos, oclMat& newFrame, oclMat& buf)"><strong>ocl::interpolateFrames (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/ocl/doc/video_analysis.html#ocl::KalmanFilter"><strong>ocl::KalmanFilter (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/ocl/doc/video_analysis.html#const oclMat& ocl::KalmanFilter::correct(const oclMat& measurement)"><strong>ocl::KalmanFilter::correct (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/ocl/doc/video_analysis.html#void ocl::KalmanFilter::init(int dynamParams, int measureParams, int controlParams, int type)"><strong>ocl::KalmanFilter::init (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/ocl/doc/video_analysis.html#ocl::KalmanFilter::KalmanFilter()"><strong>ocl::KalmanFilter::KalmanFilter (C++ function)</strong></a>, <a href="modules/ocl/doc/video_analysis.html#ocl::KalmanFilter::KalmanFilter(int dynamParams, int measureParams, int controlParams, int type)"><strong>[1]</strong></a>
  </dt>

      
  <dt><a href="modules/ocl/doc/video_analysis.html#const oclMat& ocl::KalmanFilter::predict(const oclMat& control)"><strong>ocl::KalmanFilter::predict (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/ocl/doc/ml_machine_learning.html#double ocl::kmeans(const oclMat &src, int K, oclMat &bestLabels, TermCriteria criteria, int attemps, int flags, oclMat &centers)"><strong>ocl::kmeans (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/ocl/doc/ml_machine_learning.html#ocl::KNearestNeighbour : public ocl::CvKNearest"><strong>ocl::KNearestNeighbour (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/ocl/doc/ml_machine_learning.html#void ocl::KNearestNeighbour::find_nearest(const oclMat& samples, int k, oclMat& lables)"><strong>ocl::KNearestNeighbour::find_nearest (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/ocl/doc/ml_machine_learning.html#bool ocl::KNearestNeighbour::train(const Mat& trainData, Mat& labels, Mat& sampleIdx)), bool isRegression , int max_k , bool updateBase)"><strong>ocl::KNearestNeighbour::train (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/ocl/doc/image_filtering.html#void ocl::Laplacian(const oclMat &src, oclMat &dst, int ddepth, int ksize , double scale , double delta , int borderType)"><strong>ocl::Laplacian (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/ocl/doc/operations_on_matrices.html#void ocl::log(const oclMat &src, oclMat &dst)"><strong>ocl::log (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/ocl/doc/operations_on_matrices.html#void ocl::LUT(const oclMat &src, const oclMat &lut, oclMat &dst)"><strong>ocl::LUT (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/ocl/doc/operations_on_matrices.html#void ocl::magnitude(const oclMat &x, const oclMat &y, oclMat &magnitude)"><strong>ocl::magnitude (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/ocl/doc/object_detection.html#void ocl::matchTemplate(const oclMat& image, const oclMat& templ, oclMat& result, int method)"><strong>ocl::matchTemplate (C++ function)</strong></a>, <a href="modules/ocl/doc/object_detection.html#void ocl::matchTemplate(const oclMat& image, const oclMat& templ, oclMat& result, int method, MatchTemplateBuf &buf)"><strong>[1]</strong></a>
  </dt>

      
  <dt><a href="modules/ocl/doc/object_detection.html#ocl::MatchTemplateBuf"><strong>ocl::MatchTemplateBuf (C++ structure)</strong></a>
  </dt>

      
  <dt><a href="modules/ocl/doc/matrix_reductions.html#void ocl::max(const oclMat &src1, const oclMat &src2, oclMat &dst)"><strong>ocl::max (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/ocl/doc/image_processing.html#void ocl::meanShiftFiltering(const oclMat &src, oclMat &dst, int sp, int sr, TermCriteria criteria)"><strong>ocl::meanShiftFiltering (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/ocl/doc/image_processing.html#void ocl::meanShiftProc(const oclMat &src, oclMat &dstr, oclMat &dstsp, int sp, int sr, TermCriteria criteria)"><strong>ocl::meanShiftProc (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/ocl/doc/image_processing.html#void ocl::meanShiftSegmentation(const oclMat &src, Mat &dst, int sp, int sr, int minsize, TermCriteria criteria)"><strong>ocl::meanShiftSegmentation (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/ocl/doc/operations_on_matrices.html#void ocl::meanStdDev(const oclMat &mtx, Scalar &mean, Scalar &stddev)"><strong>ocl::meanStdDev (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/ocl/doc/image_filtering.html#void ocl::medianFilter(const oclMat &src, oclMat &dst, int m)"><strong>ocl::medianFilter (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/ocl/doc/operations_on_matrices.html#void ocl::merge(const vector<oclMat> &src, oclMat &dst)"><strong>ocl::merge (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/ocl/doc/matrix_reductions.html#void ocl::min(const oclMat &src1, const oclMat &src2, oclMat &dst)"><strong>ocl::min (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/ocl/doc/matrix_reductions.html#void ocl::minMax(const oclMat &src, double *minVal, double *maxVal , const oclMat &mask)"><strong>ocl::minMax (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/ocl/doc/matrix_reductions.html#void ocl::minMaxLoc(const oclMat &src, double *minVal, double *maxVal , Point *minLoc , Point *maxLoc ,const oclMat &mask)"><strong>ocl::minMaxLoc (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/ocl/doc/video_analysis.html#ocl::MOG : public ocl::BackgroundSubtractor"><strong>ocl::MOG (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/ocl/doc/video_analysis.html#ocl::MOG2 : public ocl::BackgroundSubtractor"><strong>ocl::MOG2 (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/ocl/doc/video_analysis.html#float backgroundRatio"><strong>ocl::MOG2::backgroundRatio (C++ member)</strong></a>
  </dt>

      
  <dt><a href="modules/ocl/doc/video_analysis.html#bool bShadowDetection"><strong>ocl::MOG2::bShadowDetection (C++ member)</strong></a>
  </dt>

      
  <dt><a href="modules/ocl/doc/video_analysis.html#float fCT"><strong>ocl::MOG2::fCT (C++ member)</strong></a>
  </dt>

      
  <dt><a href="modules/ocl/doc/video_analysis.html#float fTau"><strong>ocl::MOG2::fTau (C++ member)</strong></a>
  </dt>

      
  <dt><a href="modules/ocl/doc/video_analysis.html#float fVarInit"><strong>ocl::MOG2::fVarInit (C++ member)</strong></a>
  </dt>

      
  <dt><a href="modules/ocl/doc/video_analysis.html#float fVarMax"><strong>ocl::MOG2::fVarMax (C++ member)</strong></a>
  </dt>

  </dl></td>
  <td style="width: 33%" valign="top"><dl>
      
  <dt><a href="modules/ocl/doc/video_analysis.html#float fVarMin"><strong>ocl::MOG2::fVarMin (C++ member)</strong></a>
  </dt>

      
  <dt><a href="modules/ocl/doc/video_analysis.html#void ocl::MOG2::getBackgroundImage(oclMat& backgroundImage) const"><strong>ocl::MOG2::getBackgroundImage (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/ocl/doc/video_analysis.html#ocl::MOG2::MOG2(int nmixtures)"><strong>ocl::MOG2::MOG2 (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/ocl/doc/video_analysis.html#uchar nShadowDetection"><strong>ocl::MOG2::nShadowDetection (C++ member)</strong></a>
  </dt>

      
  <dt><a href="modules/ocl/doc/video_analysis.html#void ocl::MOG2::operator()(const oclMat& frame, oclMat& fgmask, float learningRate)"><strong>ocl::MOG2::operator() (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/ocl/doc/video_analysis.html#void ocl::MOG2::release()"><strong>ocl::MOG2::release (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/ocl/doc/video_analysis.html#float varThreshold"><strong>ocl::MOG2::varThreshold (C++ member)</strong></a>
  </dt>

      
  <dt><a href="modules/ocl/doc/video_analysis.html#void ocl::MOG::getBackgroundImage(oclMat& backgroundImage) const"><strong>ocl::MOG::getBackgroundImage (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/ocl/doc/video_analysis.html#ocl::MOG::MOG(int nmixtures)"><strong>ocl::MOG::MOG (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/ocl/doc/video_analysis.html#void ocl::MOG::operator()(const oclMat& frame, oclMat& fgmask, float learningRate)"><strong>ocl::MOG::operator() (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/ocl/doc/video_analysis.html#void ocl::MOG::release()"><strong>ocl::MOG::release (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/ocl/doc/image_filtering.html#void ocl::morphologyEx(const oclMat &src, oclMat &dst, int op, const Mat &kernel, Point anchor , int iterations , int borderType , const Scalar &borderValue)"><strong>ocl::morphologyEx (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/ocl/doc/operations_on_matrices.html#void ocl::multiply(const oclMat& src1, const oclMat& src2, oclMat& dst, double scale)"><strong>ocl::multiply (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/ocl/doc/operations_on_matrices.html#double ocl::norm(const oclMat &src1, const oclMat &src2, int normType)"><strong>ocl::norm (C++ function)</strong></a>, <a href="modules/ocl/doc/operations_on_matrices.html#double ocl::norm(const oclMat &src1, int normType)"><strong>[1]</strong></a>
  </dt>

      
  <dt><a href="modules/ocl/doc/object_detection.html#ocl::OclCascadeClassifier : public CascadeClassifier"><strong>ocl::OclCascadeClassifier (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/ocl/doc/object_detection.html#CvSeq* ocl::OclCascadeClassifier::oclHaarDetectObjects(oclMat &gimg, CvMemStorage *storage, double scaleFactor, int minNeighbors, int flags, CvSize minSize , CvSize maxSize)"><strong>ocl::OclCascadeClassifier::oclHaarDetectObjects (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/ocl/doc/data_structures.html#ocl::oclMat"><strong>ocl::oclMat (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/ocl/doc/operations_on_matrices.html#void ocl::oclMat::convertTo(oclMat &m, int rtype, double alpha , double beta) const"><strong>ocl::oclMat::convertTo (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/ocl/doc/operations_on_matrices.html#void ocl::oclMat::copyTo(oclMat &m, const oclMat &mask) const"><strong>ocl::oclMat::copyTo (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/ocl/doc/operations_on_matrices.html#oclMat& ocl::oclMat::setTo(const Scalar &s, const oclMat &mask)"><strong>ocl::oclMat::setTo (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/ocl/doc/operations_on_matrices.html#void ocl::phase(const oclMat &x, const oclMat &y, oclMat &angle, bool angleInDegrees)"><strong>ocl::phase (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/ocl/doc/operations_on_matrices.html#void ocl::polarToCart(const oclMat &magnitude, const oclMat &angle, oclMat &x, oclMat &y, bool angleInDegrees)"><strong>ocl::polarToCart (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/ocl/doc/operations_on_matrices.html#void ocl::pow(const oclMat &x, double p, oclMat &y)"><strong>ocl::pow (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/ocl/doc/image_filtering.html#void ocl::pyrDown(const oclMat& src, oclMat& dst)"><strong>ocl::pyrDown (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/ocl/doc/video_analysis.html#ocl::PyrLKOpticalFlow"><strong>ocl::PyrLKOpticalFlow (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/ocl/doc/video_analysis.html#void ocl::PyrLKOpticalFlow::dense(const oclMat& prevImg, const oclMat& nextImg, oclMat& u, oclMat& v, oclMat* err)"><strong>ocl::PyrLKOpticalFlow::dense (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/ocl/doc/video_analysis.html#void ocl::PyrLKOpticalFlow::releaseMemory()"><strong>ocl::PyrLKOpticalFlow::releaseMemory (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/ocl/doc/video_analysis.html#void ocl::PyrLKOpticalFlow::sparse(const oclMat& prevImg, const oclMat& nextImg, const oclMat& prevPts, oclMat& nextPts, oclMat& status, oclMat* err)"><strong>ocl::PyrLKOpticalFlow::sparse (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/ocl/doc/image_filtering.html#void ocl::pyrUp(const oclMat& src, oclMat& dst)"><strong>ocl::pyrUp (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/ocl/doc/image_processing.html#void ocl::remap(const oclMat &src, oclMat &dst, oclMat &map1, oclMat &map2, int interpolation, int bordertype, const Scalar &value)"><strong>ocl::remap (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/ocl/doc/image_processing.html#void ocl::resize(const oclMat &src, oclMat &dst, Size dsize, double fx , double fy , int interpolation)"><strong>ocl::resize (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/ocl/doc/image_filtering.html#void ocl::Scharr(const oclMat &src, oclMat &dst, int ddepth, int dx, int dy, double scale , double delta , int bordertype)"><strong>ocl::Scharr (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/ocl/doc/image_filtering.html#void ocl::sepFilter2D(const oclMat &src, oclMat &dst, int ddepth, const Mat &kernelX, const Mat &kernelY, Point anchor , double delta , int bordertype)"><strong>ocl::sepFilter2D (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/ocl/doc/structures_and_utility_functions.html#void ocl::setBinaryPath(const char *path)"><strong>ocl::setBinaryPath (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/ocl/doc/structures_and_utility_functions.html#void ocl::setDevice(const DeviceInfo* info)"><strong>ocl::setDevice (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/ocl/doc/operations_on_matrices.html#void ocl::setIdentity(oclMat& src, const Scalar & val)"><strong>ocl::setIdentity (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/ocl/doc/image_filtering.html#void ocl::Sobel(const oclMat &src, oclMat &dst, int ddepth, int dx, int dy, int ksize , double scale , double delta , int bordertype)"><strong>ocl::Sobel (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/ocl/doc/operations_on_matrices.html#void ocl::sortByKey(oclMat& keys, oclMat& values, int method, bool isGreaterThan)"><strong>ocl::sortByKey (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/ocl/doc/operations_on_matrices.html#void ocl::split(const oclMat &src, vector<oclMat> &dst)"><strong>ocl::split (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/ocl/doc/matrix_reductions.html#Scalar ocl::sqrSum(const oclMat &m)"><strong>ocl::sqrSum (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/ocl/doc/camera_calibration_and_3D_reconstruction.html#ocl::StereoBeliefPropagation"><strong>ocl::StereoBeliefPropagation (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/ocl/doc/camera_calibration_and_3D_reconstruction.html#void ocl::StereoBeliefPropagation::estimateRecommendedParams(int width, int height, int& ndisp, int& iters, int& levels)"><strong>ocl::StereoBeliefPropagation::estimateRecommendedParams (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/ocl/doc/camera_calibration_and_3D_reconstruction.html#void ocl::StereoBeliefPropagation::operator ()(const oclMat& data, oclMat& disparity)"><strong>ocl::StereoBeliefPropagation::operator() (C++ function)</strong></a>, <a href="modules/ocl/doc/camera_calibration_and_3D_reconstruction.html#void ocl::StereoBeliefPropagation::operator ()(const oclMat& left, const oclMat& right, oclMat& disparity)"><strong>[1]</strong></a>
  </dt>

      
  <dt><a href="modules/ocl/doc/camera_calibration_and_3D_reconstruction.html#ocl::StereoBeliefPropagation::StereoBeliefPropagation(int ndisp , int iters , int levels , int msg_type)"><strong>ocl::StereoBeliefPropagation::StereoBeliefPropagation (C++ function)</strong></a>, <a href="modules/ocl/doc/camera_calibration_and_3D_reconstruction.html#ocl::StereoBeliefPropagation::StereoBeliefPropagation(int ndisp, int iters, int levels, float max_data_term, float data_weight, float max_disc_term, float disc_single_jump, int msg_type)"><strong>[1]</strong></a>
  </dt>

      
  <dt><a href="modules/ocl/doc/camera_calibration_and_3D_reconstruction.html#ocl::StereoBM_OCL"><strong>ocl::StereoBM_OCL (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/ocl/doc/camera_calibration_and_3D_reconstruction.html#bool ocl::StereoBM_OCL::checkIfGpuCallReasonable()"><strong>ocl::StereoBM_OCL::checkIfGpuCallReasonable (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/ocl/doc/camera_calibration_and_3D_reconstruction.html#void ocl::StereoBM_OCL::operator ()(const oclMat& left, const oclMat& right, oclMat& disparity)"><strong>ocl::StereoBM_OCL::operator() (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/ocl/doc/camera_calibration_and_3D_reconstruction.html#ocl::StereoBM_OCL::StereoBM_OCL()"><strong>ocl::StereoBM_OCL::StereoBM_OCL (C++ function)</strong></a>, <a href="modules/ocl/doc/camera_calibration_and_3D_reconstruction.html#ocl::StereoBM_OCL::StereoBM_OCL(int preset, int ndisparities , int winSize)"><strong>[1]</strong></a>
  </dt>

      
  <dt><a href="modules/ocl/doc/camera_calibration_and_3D_reconstruction.html#ocl::StereoConstantSpaceBP"><strong>ocl::StereoConstantSpaceBP (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/ocl/doc/camera_calibration_and_3D_reconstruction.html#void ocl::StereoConstantSpaceBP::estimateRecommendedParams(int width, int height, int& ndisp, int& iters, int& levels, int& nr_plane)"><strong>ocl::StereoConstantSpaceBP::estimateRecommendedParams (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/ocl/doc/camera_calibration_and_3D_reconstruction.html#void ocl::StereoConstantSpaceBP::operator ()(const oclMat& left, const oclMat& right, oclMat& disparity)"><strong>ocl::StereoConstantSpaceBP::operator() (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/ocl/doc/camera_calibration_and_3D_reconstruction.html#ocl::StereoConstantSpaceBP::StereoConstantSpaceBP(int ndisp , int iters , int levels , int nr_plane , int msg_type)"><strong>ocl::StereoConstantSpaceBP::StereoConstantSpaceBP (C++ function)</strong></a>, <a href="modules/ocl/doc/camera_calibration_and_3D_reconstruction.html#ocl::StereoConstantSpaceBP::StereoConstantSpaceBP(int ndisp, int iters, int levels, int nr_plane, float max_data_term, float data_weight, float max_disc_term, float disc_single_jump, int min_disp_th , int msg_type)"><strong>[1]</strong></a>
  </dt>

      
  <dt><a href="modules/ocl/doc/operations_on_matrices.html#void ocl::subtract(const oclMat& src1, const Scalar& s, oclMat& dst, const oclMat& mask)"><strong>ocl::subtract (C++ function)</strong></a>, <a href="modules/ocl/doc/operations_on_matrices.html#void ocl::subtract(const oclMat& src1, const oclMat& src2, oclMat& dst, const oclMat& mask)"><strong>[1]</strong></a>
  </dt>

      
  <dt><a href="modules/ocl/doc/matrix_reductions.html#Scalar ocl::sum(const oclMat &m)"><strong>ocl::sum (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/nonfree/doc/feature_detection.html#ocl::SURF_OCL : public Feature2D"><strong>ocl::SURF_OCL (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/ocl/doc/image_processing.html#double ocl::threshold(const oclMat &src, oclMat &dst, double thresh, double maxVal, int type)"><strong>ocl::threshold (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/ocl/doc/operations_on_matrices.html#void ocl::transpose(const oclMat &src, oclMat &dst)"><strong>ocl::transpose (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/ocl/doc/image_processing.html#void ocl::warpAffine(const oclMat &src, oclMat &dst, const Mat &M, Size dsize, int flags)"><strong>ocl::warpAffine (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/ocl/doc/image_processing.html#void ocl::warpPerspective(const oclMat &src, oclMat &dst, const Mat &M, Size dsize, int flags)"><strong>ocl::warpPerspective (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/contrib/doc/openfabmap.html#of2::BOWMSCTrainer : public of2::BOWTrainer"><strong>of2::BOWMSCTrainer (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/contrib/doc/openfabmap.html#of2::BOWMSCTrainer::BOWMSCTrainer(double clusterSize)"><strong>of2::BOWMSCTrainer::BOWMSCTrainer (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/contrib/doc/openfabmap.html#virtual Mat of2::BOWMSCTrainer::cluster() const"><strong>of2::BOWMSCTrainer::cluster (C++ function)</strong></a>, <a href="modules/contrib/doc/openfabmap.html#virtual Mat of2::BOWMSCTrainer::cluster(const Mat& descriptors) const"><strong>[1]</strong></a>
  </dt>

      
  <dt><a href="modules/contrib/doc/openfabmap.html#of2::ChowLiuTree"><strong>of2::ChowLiuTree (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/contrib/doc/openfabmap.html#void of2::ChowLiuTree::add(const Mat& imgDescriptor)"><strong>of2::ChowLiuTree::add (C++ function)</strong></a>, <a href="modules/contrib/doc/openfabmap.html#void of2::ChowLiuTree::add(const vector<Mat>& imgDescriptors)"><strong>[1]</strong></a>
  </dt>

      
  <dt><a href="modules/contrib/doc/openfabmap.html#of2::ChowLiuTree::ChowLiuTree()"><strong>of2::ChowLiuTree::ChowLiuTree (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/contrib/doc/openfabmap.html#const vector<Mat>& of2::ChowLiuTree::getImgDescriptors() const"><strong>of2::ChowLiuTree::getImgDescriptors (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/contrib/doc/openfabmap.html#Mat of2::ChowLiuTree::make(double infoThreshold)"><strong>of2::ChowLiuTree::make (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/contrib/doc/openfabmap.html#of2::FabMap"><strong>of2::FabMap (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/contrib/doc/openfabmap.html#of2::IMatch"><strong>of2::IMatch (C++ structure)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/opengl_interop.html#ogl::Arrays"><strong>ogl::Arrays (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/opengl_interop.html#void ogl::Arrays::bind() const"><strong>ogl::Arrays::bind (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/opengl_interop.html#void ogl::Arrays::release()"><strong>ogl::Arrays::release (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/opengl_interop.html#void ogl::Arrays::resetColorArray()"><strong>ogl::Arrays::resetColorArray (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/opengl_interop.html#void ogl::Arrays::resetNormalArray()"><strong>ogl::Arrays::resetNormalArray (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/opengl_interop.html#void ogl::Arrays::resetTexCoordArray()"><strong>ogl::Arrays::resetTexCoordArray (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/opengl_interop.html#void ogl::Arrays::resetVertexArray()"><strong>ogl::Arrays::resetVertexArray (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/opengl_interop.html#void ogl::Arrays::setAutoRelease(bool flag)"><strong>ogl::Arrays::setAutoRelease (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/opengl_interop.html#void ogl::Arrays::setColorArray(InputArray color)"><strong>ogl::Arrays::setColorArray (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/opengl_interop.html#void ogl::Arrays::setNormalArray(InputArray normal)"><strong>ogl::Arrays::setNormalArray (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/opengl_interop.html#void ogl::Arrays::setTexCoordArray(InputArray texCoord)"><strong>ogl::Arrays::setTexCoordArray (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/opengl_interop.html#void ogl::Arrays::setVertexArray(InputArray vertex)"><strong>ogl::Arrays::setVertexArray (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/opengl_interop.html#int ogl::Arrays::size() const"><strong>ogl::Arrays::size (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/opengl_interop.html#ogl::Buffer"><strong>ogl::Buffer (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/opengl_interop.html#void ogl::Buffer::bind(Target target) const"><strong>ogl::Buffer::bind (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/opengl_interop.html#ogl::Buffer::Buffer()"><strong>ogl::Buffer::Buffer (C++ function)</strong></a>, <a href="modules/core/doc/opengl_interop.html#ogl::Buffer::Buffer(InputArray arr, Target target , bool autoRelease)"><strong>[1]</strong></a>, <a href="modules/core/doc/opengl_interop.html#ogl::Buffer::Buffer(Size asize, int atype, Target target , bool autoRelease)"><strong>[2]</strong></a>, <a href="modules/core/doc/opengl_interop.html#ogl::Buffer::Buffer(Size asize, int atype, unsigned int abufId, bool autoRelease)"><strong>[3]</strong></a>, <a href="modules/core/doc/opengl_interop.html#ogl::Buffer::Buffer(int arows, int acols, int atype, Target target , bool autoRelease)"><strong>[4]</strong></a>, <a href="modules/core/doc/opengl_interop.html#ogl::Buffer::Buffer(int arows, int acols, int atype, unsigned int abufId, bool autoRelease)"><strong>[5]</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/opengl_interop.html#Buffer ogl::Buffer::clone(Target target , bool autoRelease) const"><strong>ogl::Buffer::clone (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/opengl_interop.html#void ogl::Buffer::copyFrom(InputArray arr, Target target , bool autoRelease)"><strong>ogl::Buffer::copyFrom (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/opengl_interop.html#void ogl::Buffer::copyTo(OutputArray arr, Target target , bool autoRelease) const"><strong>ogl::Buffer::copyTo (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/opengl_interop.html#void ogl::Buffer::create(Size asize, int atype, Target target , bool autoRelease)"><strong>ogl::Buffer::create (C++ function)</strong></a>, <a href="modules/core/doc/opengl_interop.html#void ogl::Buffer::create(int arows, int acols, int atype, Target target , bool autoRelease)"><strong>[1]</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/opengl_interop.html#gpu::GpuMat ogl::Buffer::mapDevice()"><strong>ogl::Buffer::mapDevice (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/opengl_interop.html#Mat ogl::Buffer::mapHost(Access access)"><strong>ogl::Buffer::mapHost (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/opengl_interop.html#void ogl::Buffer::release()"><strong>ogl::Buffer::release (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/opengl_interop.html#void ogl::Buffer::setAutoRelease(bool flag)"><strong>ogl::Buffer::setAutoRelease (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/opengl_interop.html#ogl::Buffer::Target"><strong>ogl::Buffer::Target (enum)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/opengl_interop.html#static void ogl::Buffer::unbind(Target target)"><strong>ogl::Buffer::unbind (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/opengl_interop.html#void ogl::Buffer::unmapDevice()"><strong>ogl::Buffer::unmapDevice (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/opengl_interop.html#void ogl::Buffer::unmapHost()"><strong>ogl::Buffer::unmapHost (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/opengl_interop.html#void ogl::render(const Arrays& arr, InputArray indices, int mode , Scalar color)"><strong>ogl::render (C++ function)</strong></a>, <a href="modules/core/doc/opengl_interop.html#void ogl::render(const Arrays& arr, int mode , Scalar color)"><strong>[1]</strong></a>, <a href="modules/core/doc/opengl_interop.html#void ogl::render(const Texture2D& tex, Rect_<double> wndRect , Rect_<double> texRect)"><strong>[2]</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/opengl_interop.html#ogl::Texture2D"><strong>ogl::Texture2D (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/opengl_interop.html#void ogl::Texture2D::bind() const"><strong>ogl::Texture2D::bind (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/opengl_interop.html#void ogl::Texture2D::copyFrom(InputArray arr, bool autoRelease)"><strong>ogl::Texture2D::copyFrom (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/opengl_interop.html#void ogl::Texture2D::copyTo(OutputArray arr, int ddepth , bool autoRelease) const"><strong>ogl::Texture2D::copyTo (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/opengl_interop.html#void ogl::Texture2D::create(Size asize, Format aformat, bool autoRelease)"><strong>ogl::Texture2D::create (C++ function)</strong></a>, <a href="modules/core/doc/opengl_interop.html#void ogl::Texture2D::create(int arows, int acols, Format aformat, bool autoRelease)"><strong>[1]</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/opengl_interop.html#ogl::Texture2D::Format"><strong>ogl::Texture2D::Format (enum)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/opengl_interop.html#void ogl::Texture2D::release()"><strong>ogl::Texture2D::release (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/opengl_interop.html#void ogl::Texture2D::setAutoRelease(bool flag)"><strong>ogl::Texture2D::setAutoRelease (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/opengl_interop.html#ogl::Texture2D::Texture2D()"><strong>ogl::Texture2D::Texture2D (C++ function)</strong></a>, <a href="modules/core/doc/opengl_interop.html#ogl::Texture2D::Texture2D(InputArray arr, bool autoRelease)"><strong>[1]</strong></a>, <a href="modules/core/doc/opengl_interop.html#ogl::Texture2D::Texture2D(Size asize, Format aformat, bool autoRelease)"><strong>[2]</strong></a>, <a href="modules/core/doc/opengl_interop.html#ogl::Texture2D::Texture2D(Size asize, Format aformat, unsigned int atexId, bool autoRelease)"><strong>[3]</strong></a>, <a href="modules/core/doc/opengl_interop.html#ogl::Texture2D::Texture2D(int arows, int acols, Format aformat, bool autoRelease)"><strong>[4]</strong></a>, <a href="modules/core/doc/opengl_interop.html#ogl::Texture2D::Texture2D(int arows, int acols, Format aformat, unsigned int atexId, bool autoRelease)"><strong>[5]</strong></a>
  </dt>

      
  <dt><a href="modules/legacy/doc/common_interfaces_of_generic_descriptor_matchers.html#OneWayDescriptorBase"><strong>OneWayDescriptorBase (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/legacy/doc/common_interfaces_of_generic_descriptor_matchers.html#OneWayDescriptorMatcher : public GenericDescriptorMatcher"><strong>OneWayDescriptorMatcher (C++ class)</strong></a>
  </dt>

      
  <dt><a href="platforms/android/service/doc/JavaHelper.html#OPENCV_VERSION_2_4_10">OPENCV_VERSION_2_4_10 (built-in variable)</a>
  </dt>

      
  <dt><a href="platforms/android/service/doc/JavaHelper.html#OPENCV_VERSION_2_4_11">OPENCV_VERSION_2_4_11 (built-in variable)</a>
  </dt>

      
  <dt><a href="platforms/android/service/doc/JavaHelper.html#OPENCV_VERSION_2_4_12">OPENCV_VERSION_2_4_12 (built-in variable)</a>
  </dt>

      
  <dt><a href="platforms/android/service/doc/JavaHelper.html#OPENCV_VERSION_2_4_13">OPENCV_VERSION_2_4_13 (built-in variable)</a>
  </dt>

      
  <dt><a href="platforms/android/service/doc/JavaHelper.html#OPENCV_VERSION_2_4_2">OPENCV_VERSION_2_4_2 (built-in variable)</a>
  </dt>

      
  <dt><a href="platforms/android/service/doc/JavaHelper.html#OPENCV_VERSION_2_4_3">OPENCV_VERSION_2_4_3 (built-in variable)</a>
  </dt>

      
  <dt><a href="platforms/android/service/doc/JavaHelper.html#OPENCV_VERSION_2_4_4">OPENCV_VERSION_2_4_4 (built-in variable)</a>
  </dt>

      
  <dt><a href="platforms/android/service/doc/JavaHelper.html#OPENCV_VERSION_2_4_5">OPENCV_VERSION_2_4_5 (built-in variable)</a>
  </dt>

      
  <dt><a href="platforms/android/service/doc/JavaHelper.html#OPENCV_VERSION_2_4_6">OPENCV_VERSION_2_4_6 (built-in variable)</a>
  </dt>

      
  <dt><a href="platforms/android/service/doc/JavaHelper.html#OPENCV_VERSION_2_4_7">OPENCV_VERSION_2_4_7 (built-in variable)</a>
  </dt>

      
  <dt><a href="platforms/android/service/doc/JavaHelper.html#OPENCV_VERSION_2_4_8">OPENCV_VERSION_2_4_8 (built-in variable)</a>
  </dt>

      
  <dt><a href="platforms/android/service/doc/JavaHelper.html#OPENCV_VERSION_2_4_9">OPENCV_VERSION_2_4_9 (built-in variable)</a>
  </dt>

      
  <dt><a href="platforms/android/service/doc/JavaHelper.html#OpenCVLoader">OpenCVLoader (built-in class)</a>
  </dt>

      
  <dt><a href="modules/core/doc/old_xml_yaml_persistence.html#CvFileStorage* cvOpenFileStorage(const char* filename, CvMemStorage* memstorage, int flags, const char* encoding)"><strong>OpenFileStorage (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/xml_yaml_persistence.html#template<typename _Tp> FileStorage& operator << (FileStorage& fs, const _Tp& value)"><strong>operator&lt;&lt; (C++ function)</strong></a>, <a href="modules/core/doc/xml_yaml_persistence.html#template<typename _Tp> FileStorage& operator << (FileStorage& fs, const vector<_Tp>& vec)"><strong>[1]</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/xml_yaml_persistence.html#template<typename _Tp> FileNodeIterator& operator >> (FileNodeIterator& it, _Tp& value)"><strong>operator&gt;&gt; (C++ function)</strong></a>, <a href="modules/core/doc/xml_yaml_persistence.html#template<typename _Tp> FileNodeIterator& operator >> (FileNodeIterator& it, vector<_Tp>& vec)"><strong>[1]</strong></a>, <a href="modules/core/doc/xml_yaml_persistence.html#template<typename _Tp> void operator >> (const FileNode& n, _Tp& value)"><strong>[2]</strong></a>, <a href="modules/core/doc/xml_yaml_persistence.html#template<typename _Tp> void operator >> (const FileNode& n, vector<_Tp>& vec)"><strong>[3]</strong></a>
  </dt>

      
  <dt><a href="modules/features2d/doc/common_interfaces_of_descriptor_extractors.html#OpponentColorDescriptorExtractor : public DescriptorExtractor"><strong>OpponentColorDescriptorExtractor (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#void cvOr(const CvArr* src1, const CvArr* src2, CvArr* dst, const CvArr* mask)"><strong>Or (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#cv.Or"><strong>Or() (Python function in cv)</strong></a>
  </dt>

      
  <dt><a href="modules/features2d/doc/feature_detection_and_description.html#ORB : public Feature2D"><strong>ORB (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/features2d/doc/feature_detection_and_description.html#void ORB::operator()(InputArray image, InputArray mask, vector<KeyPoint>& keypoints, OutputArray descriptors, bool useProvidedKeypoints) const"><strong>ORB::operator() (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/features2d/doc/feature_detection_and_description.html#ORB::ORB(int nfeatures , float scaleFactor , int nlevels , int edgeThreshold , int firstLevel , int WTA_K, int scoreType, int patchSize)"><strong>ORB::ORB (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#void cvOrS(const CvArr* src, CvScalar value, CvArr* dst, const CvArr* mask)"><strong>OrS (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#cv.OrS"><strong>OrS() (Python function in cv)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/basic_structures.html#OutputArray : public InputArray"><strong>OutputArray (C++ class)</strong></a>
  </dt>

  </dl></td>
</tr></table>

<h2 id="P">P</h2>
<table style="width: 100%" class="indextable genindextable"><tr>
  <td style="width: 33%" valign="top"><dl>
      
  <dt><a href="modules/core/doc/clustering.html#template<typename _Tp, class _EqPredicate> int partition(const vector<_Tp>& vec, vector<int>& labels, _EqPredicate predicate)"><strong>partition (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#PCA"><strong>PCA (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#Mat PCA::backProject(InputArray vec) const"><strong>PCA::backProject (C++ function)</strong></a>, <a href="modules/core/doc/operations_on_arrays.html#void PCA::backProject(InputArray vec, OutputArray result) const"><strong>[1]</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#PCA& PCA::computeVar(InputArray data, InputArray mean, int flags, double retainedVariance)"><strong>PCA::computeVar (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#PCA& PCA::operator()(InputArray data, InputArray mean, int flags, int maxComponents)"><strong>PCA::operator() (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#PCA::PCA()"><strong>PCA::PCA (C++ function)</strong></a>, <a href="modules/core/doc/operations_on_arrays.html#PCA::PCA(InputArray data, InputArray mean, int flags, double retainedVariance)"><strong>[1]</strong></a>, <a href="modules/core/doc/operations_on_arrays.html#PCA::PCA(InputArray data, InputArray mean, int flags, int maxComponents)"><strong>[2]</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#Mat PCA::project(InputArray vec) const"><strong>PCA::project (C++ function)</strong></a>, <a href="modules/core/doc/operations_on_arrays.html#void PCA::project(InputArray vec, OutputArray result) const"><strong>[1]</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#cv2.PCABackProject"><strong>PCABackProject() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#cv2.PCACompute"><strong>PCACompute() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#cv2.PCAComputeVar"><strong>PCAComputeVar() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#cv2.PCAProject"><strong>PCAProject() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#void cvPerspectiveTransform(const CvArr* src, CvArr* dst, const CvMat* mat)"><strong>PerspectiveTransform (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#void perspectiveTransform(InputArray src, OutputArray dst, InputArray m)"><strong>perspectiveTransform (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#cv.PerspectiveTransform"><strong>PerspectiveTransform() (Python function in cv)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#cv2.perspectiveTransform"><strong>perspectiveTransform() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#void phase(InputArray x, InputArray y, OutputArray angle, bool angleInDegrees)"><strong>phase (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#cv2.phase"><strong>phase() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/motion_analysis_and_object_tracking.html#Point2d phaseCorrelate(InputArray src1, InputArray src2, InputArray window)"><strong>phaseCorrelate (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/motion_analysis_and_object_tracking.html#Point2d phaseCorrelateRes(InputArray src1, InputArray src2, InputArray window, double* response)"><strong>phaseCorrelateRes (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/stitching/doc/high_level.html#PlaneWarper : public WarperCreator"><strong>PlaneWarper (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_basic_structures.html#CvPoint cvPoint(int x, int y)"><strong>Point (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_basic_structures.html#CvPoint2D32f cvPoint2D32f(double x, double y)"><strong>Point2D32f (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_basic_structures.html#CvPoint2D64f cvPoint2D64f(double x, double y)"><strong>Point2D64f (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/basic_structures.html#Point3_"><strong>Point3_ (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_basic_structures.html#CvPoint3D32f cvPoint3D32f(double x, double y, double z)"><strong>Point3D32f (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_basic_structures.html#CvPoint3D64f cvPoint3D64f(double x, double y, double z)"><strong>Point3D64f (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/basic_structures.html#Point_"><strong>Point_ (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_basic_structures.html#CvPoint cvPointFrom32f(CvPoint2D32f point)"><strong>PointFrom32f (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/structural_analysis_and_shape_descriptors.html#double cvPointPolygonTest(const CvArr* contour, CvPoint2D32f pt, int measure_dist)"><strong>PointPolygonTest (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/structural_analysis_and_shape_descriptors.html#double pointPolygonTest(InputArray contour, Point2f pt, bool measureDist)"><strong>pointPolygonTest (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/structural_analysis_and_shape_descriptors.html#cv.PointPolygonTest"><strong>PointPolygonTest() (Python function in cv)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/structural_analysis_and_shape_descriptors.html#cv2.pointPolygonTest"><strong>pointPolygonTest() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_basic_structures.html#CvPoint2D32f cvPointTo32f(CvPoint point)"><strong>PointTo32f (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#void cvPolarToCart(const CvArr* magnitude, const CvArr* angle, CvArr* x, CvArr* y, int angle_in_degrees)"><strong>PolarToCart (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#void polarToCart(InputArray magnitude, InputArray angle, OutputArray x, OutputArray y, bool angleInDegrees)"><strong>polarToCart (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#cv.PolarToCart"><strong>PolarToCart() (Python function in cv)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#cv2.polarToCart"><strong>polarToCart() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/drawing_functions.html#void cvPolyLine(CvArr* img, CvPoint** pts, const int* npts, int contours, int is_closed, CvScalar color, int thickness, int line_type, int shift)"><strong>PolyLine (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/drawing_functions.html#cv.PolyLine"><strong>PolyLine() (Python function in cv)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/drawing_functions.html#void polylines(InputOutputArray img, InputArrayOfArrays pts, bool isClosed, const Scalar& color, int thickness, int lineType, int shift)"><strong>polylines (C++ function)</strong></a>, <a href="modules/core/doc/drawing_functions.html#void polylines(Mat& img, const Point** pts, const int* npts, int ncontours, bool isClosed, const Scalar& color, int thickness, int lineType, int shift)"><strong>[1]</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/drawing_functions.html#cv2.polylines"><strong>polylines() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#void cvPow(const CvArr* src, CvArr* dst, double power)"><strong>Pow (C function)</strong></a>
  </dt>

  </dl></td>
  <td style="width: 33%" valign="top"><dl>
      
  <dt><a href="modules/core/doc/operations_on_arrays.html#void pow(InputArray src, double power, OutputArray dst)"><strong>pow (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#cv.Pow"><strong>Pow() (Python function in cv)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#cv2.pow"><strong>pow() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/feature_detection.html#void cvPreCornerDetect(const CvArr* image, CvArr* corners, int aperture_size)"><strong>PreCornerDetect (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/feature_detection.html#void preCornerDetect(InputArray src, OutputArray dst, int ksize, int borderType)"><strong>preCornerDetect (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/feature_detection.html#cv.PreCornerDetect"><strong>PreCornerDetect() (Python function in cv)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/feature_detection.html#cv2.preCornerDetect"><strong>preCornerDetect() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/dynamic_structures.html#void* cvPrevTreeNode(CvTreeNodeIterator* tree_iterator)"><strong>PrevTreeNode (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/calib3d/doc/camera_calibration_and_3d_reconstruction.html#void projectPoints(InputArray objectPoints, InputArray rvec, InputArray tvec, InputArray cameraMatrix, InputArray distCoeffs, OutputArray imagePoints, OutputArray jacobian, double aspectRatio)"><strong>projectPoints (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/calib3d/doc/camera_calibration_and_3d_reconstruction.html#cv2.projectPoints"><strong>projectPoints() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/calib3d/doc/camera_calibration_and_3d_reconstruction.html#void cvProjectPoints2(const CvMat* object_points, const CvMat* rotation_vector, const CvMat* translation_vector, const CvMat* camera_matrix, const CvMat* distortion_coeffs, CvMat* image_points, CvMat* dpdrot, CvMat* dpdt, CvMat* dpdf, CvMat* dpdc, CvMat* dpddist, double aspect_ratio)"><strong>ProjectPoints2 (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/calib3d/doc/camera_calibration_and_3d_reconstruction.html#cv.ProjectPoints2"><strong>ProjectPoints2() (Python function in cv)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/basic_structures.html#Ptr"><strong>Ptr (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_basic_structures.html#uchar* cvPtr1D(const CvArr* arr, int idx0, int* type)"><strong>Ptr1D (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_basic_structures.html#uchar* cvPtr2D(const CvArr* arr, int idx0, int idx1, int* type)"><strong>Ptr2D (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_basic_structures.html#uchar* cvPtr3D(const CvArr* arr, int idx0, int idx1, int idx2, int* type)"><strong>Ptr3D (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/basic_structures.html#void Ptr::addref()"><strong>Ptr::addref (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/basic_structures.html#void Ptr::delete_obj()"><strong>Ptr::delete_obj (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/basic_structures.html#template<typename _Tp> _Tp* Ptr::operator -> ()"><strong>Ptr::operator-&gt; (C++ function)</strong></a>, <a href="modules/core/doc/basic_structures.html#template<typename _Tp> const _Tp* Ptr::operator -> () const"><strong>[1]</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/basic_structures.html#Ptr& Ptr::operator = (const Ptr& ptr)"><strong>Ptr::operator= (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/basic_structures.html#Ptr::Ptr()"><strong>Ptr::Ptr (C++ function)</strong></a>, <a href="modules/core/doc/basic_structures.html#Ptr::Ptr(_Tp* _obj)"><strong>[1]</strong></a>, <a href="modules/core/doc/basic_structures.html#Ptr::Ptr(const Ptr& ptr)"><strong>[2]</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/basic_structures.html#void Ptr::release()"><strong>Ptr::release (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/basic_structures.html#Ptr::~Ptr()"><strong>Ptr::~Ptr (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_basic_structures.html#uchar* cvPtrND(const CvArr* arr, const int* idx, int* type, int create_node, unsigned* precalc_hashval)"><strong>PtrND (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/drawing_functions.html#void cvPutText(CvArr* img, const char* text, CvPoint org, const CvFont* font, CvScalar color)"><strong>PutText (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/drawing_functions.html#void putText(Mat& img, const string& text, Point org, int fontFace, double fontScale, Scalar color, int thickness, int lineType, bool bottomLeftOrigin)"><strong>putText (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/drawing_functions.html#cv.PutText"><strong>PutText() (Python function in cv)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/drawing_functions.html#cv2.putText"><strong>putText() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/features2d/doc/common_interfaces_of_feature_detectors.html#PyramidAdaptedFeatureDetector : public FeatureDetector"><strong>PyramidAdaptedFeatureDetector (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/filtering.html#void cvPyrDown(const CvArr* src, CvArr* dst, int filter)"><strong>PyrDown (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/filtering.html#void pyrDown(InputArray src, OutputArray dst, const Size& dstsize, int borderType)"><strong>pyrDown (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/filtering.html#cv.PyrDown"><strong>PyrDown() (Python function in cv)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/filtering.html#cv2.pyrDown"><strong>pyrDown() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/filtering.html#void cvPyrMeanShiftFiltering(const CvArr* src, CvArr* dst, double sp, double sr, int max_level, CvTermCriteria termcrit)"><strong>PyrMeanShiftFiltering (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/filtering.html#void pyrMeanShiftFiltering(InputArray src, OutputArray dst, double sp, double sr, int maxLevel, TermCriteria termcrit)"><strong>pyrMeanShiftFiltering (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/filtering.html#cv.PyrMeanShiftFiltering"><strong>PyrMeanShiftFiltering() (Python function in cv)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/filtering.html#cv2.pyrMeanShiftFiltering"><strong>pyrMeanShiftFiltering() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/filtering.html#cvPyrUp(const CvArr* src, CvArr* dst, int filter)"><strong>PyrUp (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/filtering.html#void pyrUp(InputArray src, OutputArray dst, const Size& dstsize, int borderType)"><strong>pyrUp (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/filtering.html#cv.PyrUp"><strong>PyrUp() (Python function in cv)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/filtering.html#cv2.pyrUp"><strong>pyrUp() (Python function in cv2)</strong></a>
  </dt>

  </dl></td>
</tr></table>

<h2 id="Q">Q</h2>
<table style="width: 100%" class="indextable genindextable"><tr>
  <td style="width: 33%" valign="top"><dl>
      
  <dt><a href="modules/highgui/doc/reading_and_writing_images_and_video.html#IplImage* cvQueryFrame(CvCapture* capture)"><strong>QueryFrame (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/highgui/doc/reading_and_writing_images_and_video.html#cv.QueryFrame"><strong>QueryFrame() (Python function in cv)</strong></a>
  </dt>

      
  <dt><a href="modules/legacy/doc/histograms.html#float cvQueryHistValue_1D(CvHistogram hist, int idx0)"><strong>QueryHistValue_1D (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/legacy/doc/histograms.html#cv.QueryHistValue_1D"><strong>QueryHistValue_1D() (Python function in cv)</strong></a>
  </dt>

      
  <dt><a href="modules/legacy/doc/histograms.html#float cvQueryHistValue_2D(CvHistogram hist, int idx0, int idx1)"><strong>QueryHistValue_2D (C function)</strong></a>
  </dt>

  </dl></td>
  <td style="width: 33%" valign="top"><dl>
      
  <dt><a href="modules/legacy/doc/histograms.html#cv.QueryHistValue_2D"><strong>QueryHistValue_2D() (Python function in cv)</strong></a>
  </dt>

      
  <dt><a href="modules/legacy/doc/histograms.html#float cvQueryHistValue_3D(CvHistogram hist, int idx0, int idx1, int idx2)"><strong>QueryHistValue_3D (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/legacy/doc/histograms.html#cv.QueryHistValue_3D"><strong>QueryHistValue_3D() (Python function in cv)</strong></a>
  </dt>

      
  <dt><a href="modules/legacy/doc/histograms.html#float cvQueryHistValue_nD(CvHistogram hist, const int* idx)"><strong>QueryHistValue_nD (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/legacy/doc/histograms.html#cv.QueryHistValue_nD"><strong>QueryHistValue_nD() (Python function in cv)</strong></a>
  </dt>

  </dl></td>
</tr></table>

<h2 id="R">R</h2>
<table style="width: 100%" class="indextable genindextable"><tr>
  <td style="width: 33%" valign="top"><dl>
      
  <dt><a href="modules/core/doc/old_basic_structures.html#void cvRandArr(CvRNG* rng, CvArr* arr, int dist_type, CvScalar param1, CvScalar param2)"><strong>RandArr (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_basic_structures.html#cv.RandArr"><strong>RandArr() (Python function in cv)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_basic_structures.html#unsigned cvRandInt(CvRNG* rng)"><strong>RandInt (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_basic_structures.html#cv.RandInt"><strong>RandInt() (Python function in cv)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#void randn(InputOutputArray dst, InputArray mean, InputArray stddev)"><strong>randn (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#cv2.randn"><strong>randn() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/legacy/doc/feature_detection_and_description.html#RandomizedTree"><strong>RandomizedTree (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/legacy/doc/feature_detection_and_description.html#void RandomizedTree::applyQuantization(int num_quant_bits)"><strong>RandomizedTree::applyQuantization (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/legacy/doc/feature_detection_and_description.html#RandomizedTree::read(const char* file_name, int num_quant_bits)"><strong>RandomizedTree::read (C++ function)</strong></a>, <a href="modules/legacy/doc/feature_detection_and_description.html#RandomizedTree::read(std::istream &is, int num_quant_bits)"><strong>[1]</strong></a>
  </dt>

      
  <dt><a href="modules/legacy/doc/feature_detection_and_description.html#void RandomizedTree::train(vector<BaseKeypoint> const& base_set, RNG & rng, PatchGenerator & make_patch, int depth, int views, size_t reduced_num_dim, int num_quant_bits)"><strong>RandomizedTree::train (C++ function)</strong></a>, <a href="modules/legacy/doc/feature_detection_and_description.html#void RandomizedTree::train(vector<BaseKeypoint> const& base_set, RNG & rng, int depth, int views, size_t reduced_num_dim, int num_quant_bits)"><strong>[1]</strong></a>
  </dt>

      
  <dt><a href="modules/legacy/doc/feature_detection_and_description.html#void RandomizedTree::write(const char* file_name) const"><strong>RandomizedTree::write (C++ function)</strong></a>, <a href="modules/legacy/doc/feature_detection_and_description.html#void RandomizedTree::write(std::ostream &os) const"><strong>[1]</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_basic_structures.html#double cvRandReal(CvRNG* rng)"><strong>RandReal (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_basic_structures.html#cv.RandReal"><strong>RandReal() (Python function in cv)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#void randShuffle(InputOutputArray dst, double iterFactor, RNG* rng)"><strong>randShuffle (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#cv2.randShuffle"><strong>randShuffle() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#template<typename _Tp> _Tp randu()"><strong>randu (C++ function)</strong></a>, <a href="modules/core/doc/operations_on_arrays.html#void randu(InputOutputArray dst, InputArray low, InputArray high)"><strong>[1]</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#cv2.randu"><strong>randu() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/basic_structures.html#Range"><strong>Range (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_xml_yaml_persistence.html#void* cvRead(CvFileStorage* fs, CvFileNode* node, CvAttrList* attributes)"><strong>Read (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_xml_yaml_persistence.html#void* cvReadByName(CvFileStorage* fs, const CvFileNode* map, const char* name, CvAttrList* attributes)"><strong>ReadByName (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_xml_yaml_persistence.html#int cvReadInt(const CvFileNode* node, int default_value)"><strong>ReadInt (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_xml_yaml_persistence.html#int cvReadIntByName(const CvFileStorage* fs, const CvFileNode* map, const char* name, int default_value)"><strong>ReadIntByName (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_xml_yaml_persistence.html#void cvReadRawData(const CvFileStorage* fs, const CvFileNode* src, void* dst, const char* dt)"><strong>ReadRawData (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_xml_yaml_persistence.html#void cvReadRawDataSlice(const CvFileStorage* fs, CvSeqReader* reader, int count, void* dst, const char* dt)"><strong>ReadRawDataSlice (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_xml_yaml_persistence.html#double cvReadReal(const CvFileNode* node, double default_value)"><strong>ReadReal (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_xml_yaml_persistence.html#double cvReadRealByName(const CvFileStorage* fs, const CvFileNode* map, const char* name, double default_value)"><strong>ReadRealByName (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_xml_yaml_persistence.html#const char* cvReadString(const CvFileNode* node, const char* default_value)"><strong>ReadString (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_xml_yaml_persistence.html#const char* cvReadStringByName(const CvFileStorage* fs, const CvFileNode* map, const char* name, const char* default_value)"><strong>ReadStringByName (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_basic_structures.html#CvRect cvRect(int x, int y, int width, int height)"><strong>Rect (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/basic_structures.html#Rect_"><strong>Rect_ (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/drawing_functions.html#void cvRectangle(CvArr* img, CvPoint pt1, CvPoint pt2, CvScalar color, int thickness, int line_type, int shift)"><strong>Rectangle (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/drawing_functions.html#void rectangle(Mat& img, Point pt1, Point pt2, const Scalar& color, int thickness, int lineType, int shift)"><strong>rectangle (C++ function)</strong></a>, <a href="modules/core/doc/drawing_functions.html#void rectangle(Mat& img, Rect rec, const Scalar& color, int thickness, int lineType, int shift)"><strong>[1]</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/drawing_functions.html#cv.Rectangle"><strong>Rectangle() (Python function in cv)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/drawing_functions.html#cv2.rectangle"><strong>rectangle() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#void cvReduce(const CvArr* src, CvArr* dst, int dim, int op)"><strong>Reduce (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#void reduce(InputArray src, OutputArray dst, int dim, int rtype, int dtype)"><strong>reduce (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#cv.Reduce"><strong>Reduce() (Python function in cv)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#cv2.reduce"><strong>reduce() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/viz/doc/viz3d.html#void registerKeyboardCallback(KeyboardCallback callback, void* cookie)"><strong>registerKeyboardCallback (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/viz/doc/viz3d.html#void registerMouseCallback(MouseCallback callback, void* cookie)"><strong>registerMouseCallback (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_xml_yaml_persistence.html#void cvRegisterType(const CvTypeInfo* info)"><strong>RegisterType (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_xml_yaml_persistence.html#void cvRelease(void** struct_ptr)"><strong>Release (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/highgui/doc/reading_and_writing_images_and_video.html#void cvReleaseCapture(CvCapture** capture)"><strong>ReleaseCapture (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_basic_structures.html#void cvReleaseData(CvArr* arr)"><strong>ReleaseData (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_xml_yaml_persistence.html#void cvReleaseFileStorage(CvFileStorage** fs)"><strong>ReleaseFileStorage (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/dynamic_structures.html#void cvReleaseGraphScanner(CvGraphScanner** scanner)"><strong>ReleaseGraphScanner (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/histograms.html#void cvReleaseHist(CvHistogram** hist)"><strong>ReleaseHist (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_basic_structures.html#void cvReleaseImage(IplImage** image)"><strong>ReleaseImage (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_basic_structures.html#void cvReleaseImageHeader(IplImage** image)"><strong>ReleaseImageHeader (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_basic_structures.html#void cvReleaseMat(CvMat** mat)"><strong>ReleaseMat (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_basic_structures.html#void cvReleaseMatND(CvMatND** mat)"><strong>ReleaseMatND (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/dynamic_structures.html#void cvReleaseMemStorage(CvMemStorage** storage)"><strong>ReleaseMemStorage (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_basic_structures.html#void cvReleaseSparseMat(CvSparseMat** mat)"><strong>ReleaseSparseMat (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/highgui/doc/reading_and_writing_images_and_video.html#void cvReleaseVideoWriter(CvVideoWriter** writer)"><strong>ReleaseVideoWriter (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/geometric_transformations.html#void cvRemap(const CvArr* src, CvArr* dst, const CvArr* mapx, const CvArr* mapy, int flags, CvScalar fillval)"><strong>Remap (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/geometric_transformations.html#void remap(InputArray src, OutputArray dst, InputArray map1, InputArray map2, int interpolation, int borderMode, const Scalar& borderValue)"><strong>remap (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/geometric_transformations.html#cv.Remap"><strong>Remap() (Python function in cv)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/geometric_transformations.html#cv2.remap"><strong>remap() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/viz/doc/viz3d.html#void removeAllWidgets()"><strong>removeAllWidgets (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/viz/doc/viz3d.html#void removeWidget(const String &id)"><strong>removeWidget (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#void cvRepeat(const CvArr* src, CvArr* dst)"><strong>Repeat (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#Mat repeat(const Mat& src, int ny, int nx)"><strong>repeat (C++ function)</strong></a>, <a href="modules/core/doc/operations_on_arrays.html#void repeat(InputArray src, int ny, int nx, OutputArray dst)"><strong>[1]</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#cv.Repeat"><strong>Repeat() (Python function in cv)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#cv2.repeat"><strong>repeat() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/calib3d/doc/camera_calibration_and_3d_reconstruction.html#void cvReprojectImageTo3D(const CvArr* disparityImage, CvArr* _3dImage, const CvMat* Q, int handleMissingValues)"><strong>ReprojectImageTo3D (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/calib3d/doc/camera_calibration_and_3d_reconstruction.html#void reprojectImageTo3D(InputArray disparity, OutputArray _3dImage, InputArray Q, bool handleMissingValues, int ddepth)"><strong>reprojectImageTo3D (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/calib3d/doc/camera_calibration_and_3d_reconstruction.html#cv.ReprojectImageTo3D"><strong>ReprojectImageTo3D() (Python function in cv)</strong></a>
  </dt>

      
  <dt><a href="modules/calib3d/doc/camera_calibration_and_3d_reconstruction.html#cv2.reprojectImageTo3D"><strong>reprojectImageTo3D() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/viz/doc/viz3d.html#void resetCamera()"><strong>resetCamera (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/viz/doc/viz3d.html#void resetCameraViewpoint (const String &id)"><strong>resetCameraViewpoint (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_basic_structures.html#void cvResetImageROI(IplImage* image)"><strong>ResetImageROI (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_basic_structures.html#cv.ResetImageROI"><strong>ResetImageROI() (Python function in cv)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_basic_structures.html#CvMat* cvReshape(const CvArr* arr, CvMat* header, int new_cn, int new_rows)"><strong>Reshape (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_basic_structures.html#cv.Reshape"><strong>Reshape() (Python function in cv)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_basic_structures.html#CvArr* cvReshapeMatND(const CvArr* arr, int sizeof_header, CvArr* header, int new_cn, int new_dims, int* new_sizes)"><strong>ReshapeMatND (C function)</strong></a>
  </dt>

  </dl></td>
  <td style="width: 33%" valign="top"><dl>
      
  <dt><a href="modules/core/doc/old_basic_structures.html#cv.ReshapeMatND"><strong>ReshapeMatND() (Python function in cv)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/geometric_transformations.html#void cvResize(const CvArr* src, CvArr* dst, int interpolation)"><strong>Resize (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/geometric_transformations.html#void resize(InputArray src, OutputArray dst, Size dsize, double fx, double fy, int interpolation)"><strong>resize (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/geometric_transformations.html#cv.Resize"><strong>Resize() (Python function in cv)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/geometric_transformations.html#cv2.resize"><strong>resize() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/highgui/doc/user_interface.html#void cvResizeWindow(const char* name, int width, int height)"><strong>ResizeWindow (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/highgui/doc/user_interface.html#void resizeWindow(const string& winname, int width, int height)"><strong>resizeWindow (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/highgui/doc/user_interface.html#cv.ResizeWindow"><strong>ResizeWindow() (Python function in cv)</strong></a>
  </dt>

      
  <dt><a href="modules/highgui/doc/user_interface.html#cv2.resizeWindow"><strong>resizeWindow() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/dynamic_structures.html#void cvRestoreMemStoragePos(CvMemStorage* storage, CvMemStoragePos* pos)"><strong>RestoreMemStoragePos (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/contrib/doc/retina/index.html#Retina"><strong>Retina (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/contrib/doc/retina/index.html#void Retina::activateContoursProcessing(const bool activate)"><strong>Retina::activateContoursProcessing (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/contrib/doc/retina/index.html#void Retina::activateMovingContoursProcessing(const bool activate)"><strong>Retina::activateMovingContoursProcessing (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/contrib/doc/retina/index.html#void Retina::clearBuffers()"><strong>Retina::clearBuffers (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/contrib/doc/retina/index.html#const std::valarray<float> & Retina::getMagno() const"><strong>Retina::getMagno (C++ function)</strong></a>, <a href="modules/contrib/doc/retina/index.html#void Retina::getMagno(Mat & retinaOutput_magno)"><strong>[1]</strong></a>, <a href="modules/contrib/doc/retina/index.html#void Retina::getMagno(std::valarray<float> & retinaOutput_magno)"><strong>[2]</strong></a>
  </dt>

      
  <dt><a href="modules/contrib/doc/retina/index.html#Retina::RetinaParameters Retina::getParameters()"><strong>Retina::getParameters (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/contrib/doc/retina/index.html#const std::valarray<float> & Retina::getParvo() const"><strong>Retina::getParvo (C++ function)</strong></a>, <a href="modules/contrib/doc/retina/index.html#void Retina::getParvo(Mat & retinaOutput_parvo)"><strong>[1]</strong></a>, <a href="modules/contrib/doc/retina/index.html#void Retina::getParvo(std::valarray<float> & retinaOutput_parvo)"><strong>[2]</strong></a>
  </dt>

      
  <dt><a href="modules/contrib/doc/retina/index.html#Size Retina::inputSize()"><strong>Retina::inputSize (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/contrib/doc/retina/index.html#Size Retina::outputSize()"><strong>Retina::outputSize (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/contrib/doc/retina/index.html#const std::string Retina::printSetup()"><strong>Retina::printSetup (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/contrib/doc/retina/index.html#Retina::Retina(Size inputSize)"><strong>Retina::Retina (C++ function)</strong></a>, <a href="modules/contrib/doc/retina/index.html#Retina::Retina(Size inputSize, const bool colorMode, RETINA_COLORSAMPLINGMETHOD colorSamplingMethod , const bool useRetinaLogSampling , const double reductionFactor , const double samplingStrenght)"><strong>[1]</strong></a>
  </dt>

      
  <dt><a href="modules/contrib/doc/retina/index.html#Retina::RetinaParameters"><strong>Retina::RetinaParameters (C++ structure)</strong></a>
  </dt>

      
  <dt><a href="modules/contrib/doc/retina/index.html#void Retina::run(const Mat & inputImage)"><strong>Retina::run (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/contrib/doc/retina/index.html#void Retina::setColorSaturation(const bool saturateColors , const float colorSaturationValue)"><strong>Retina::setColorSaturation (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/contrib/doc/retina/index.html#void Retina::setup(FileStorage & fs, const bool applyDefaultSetupOnFailure)"><strong>Retina::setup (C++ function)</strong></a>, <a href="modules/contrib/doc/retina/index.html#void Retina::setup(RetinaParameters newParameters)"><strong>[1]</strong></a>, <a href="modules/contrib/doc/retina/index.html#void Retina::setup(std::string retinaParameterFile , const bool applyDefaultSetupOnFailure)"><strong>[2]</strong></a>
  </dt>

      
  <dt><a href="modules/contrib/doc/retina/index.html#void Retina::setupIPLMagnoChannel(const bool normaliseOutput , const float parasolCells_beta , const float parasolCells_tau , const float parasolCells_k , const float amacrinCellsTemporalCutFrequency , const float V0CompressionParameter , const float localAdaptintegration_tau , const float localAdaptintegration_k)"><strong>Retina::setupIPLMagnoChannel (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/contrib/doc/retina/index.html#void Retina::setupOPLandIPLParvoChannel(const bool colorMode , const bool normaliseOutput , const float photoreceptorsLocalAdaptationSensitivity , const float photoreceptorsTemporalConstant , const float photoreceptorsSpatialConstant , const float horizontalCellsGain , const float HcellsTemporalConstant , const float HcellsSpatialConstant , const float ganglionCellsSensitivity)"><strong>Retina::setupOPLandIPLParvoChannel (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/contrib/doc/retina/index.html#void Retina::write(FileStorage& fs) const"><strong>Retina::write (C++ function)</strong></a>, <a href="modules/contrib/doc/retina/index.html#void Retina::write(std::string fs) const"><strong>[1]</strong></a>
  </dt>

      
  <dt><a href="modules/highgui/doc/reading_and_writing_images_and_video.html#IplImage* cvRetrieveFrame(CvCapture* capture, int streamIdx)"><strong>RetrieveFrame (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/highgui/doc/reading_and_writing_images_and_video.html#cv.RetrieveFrame"><strong>RetrieveFrame() (Python function in cv)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_basic_structures.html#CvRNG cvRNG(int64 seed)"><strong>RNG (C function)</strong></a>
  </dt>

      <dd><dl>
        
  <dt><a href="modules/core/doc/operations_on_arrays.html#RNG"><strong>(C++ class)</strong></a>
  </dt>

      </dl></dd>
      
  <dt><a href="modules/core/doc/old_basic_structures.html#cv.RNG"><strong>RNG() (Python function in cv)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#void RNG::fill(InputOutputArray mat, int distType, InputArray a, InputArray b, bool saturateRange)"><strong>RNG::fill (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#double RNG::gaussian(double sigma)"><strong>RNG::gaussian (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#unsigned RNG::next()"><strong>RNG::next (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#RNG::operator double()"><strong>RNG::operator double (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#RNG::operator float()"><strong>RNG::operator float (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#RNG::operator int()"><strong>RNG::operator int (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#RNG::operator schar()"><strong>RNG::operator schar (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#RNG::operator short()"><strong>RNG::operator short int (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#RNG::operator uchar()"><strong>RNG::operator uchar (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#RNG::operator unsigned()"><strong>RNG::operator unsigned int (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#RNG::operator ushort()"><strong>RNG::operator ushort (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#unsigned RNG::operator ()()"><strong>RNG::operator() (C++ function)</strong></a>, <a href="modules/core/doc/operations_on_arrays.html#unsigned RNG::operator ()(unsigned N)"><strong>[1]</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#RNG::RNG()"><strong>RNG::RNG (C++ function)</strong></a>, <a href="modules/core/doc/operations_on_arrays.html#RNG::RNG(uint64 state)"><strong>[1]</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#double RNG::uniform(double a, double b)"><strong>RNG::uniform (C++ function)</strong></a>, <a href="modules/core/doc/operations_on_arrays.html#float RNG::uniform(float a, float b)"><strong>[1]</strong></a>, <a href="modules/core/doc/operations_on_arrays.html#int RNG::uniform(int a, int b)"><strong>[2]</strong></a>
  </dt>

      
  <dt><a href="modules/calib3d/doc/camera_calibration_and_3d_reconstruction.html#void Rodrigues(InputArray src, OutputArray dst, OutputArray jacobian)"><strong>Rodrigues (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/calib3d/doc/camera_calibration_and_3d_reconstruction.html#cv2.Rodrigues"><strong>Rodrigues() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/calib3d/doc/camera_calibration_and_3d_reconstruction.html#int cvRodrigues2(const CvMat* src, CvMat* dst, CvMat* jacobian)"><strong>Rodrigues2 (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/calib3d/doc/camera_calibration_and_3d_reconstruction.html#cv.Rodrigues2"><strong>Rodrigues2() (Python function in cv)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/basic_structures.html#RotatedRect"><strong>RotatedRect (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/basic_structures.html#Rect RotatedRect::boundingRect() const"><strong>RotatedRect::boundingRect (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/basic_structures.html#RotatedRect::operator CvBox2D() const"><strong>RotatedRect::operator CvBox2D (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/basic_structures.html#void RotatedRect::points(Point2f pts[]) const"><strong>RotatedRect::points (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/basic_structures.html#RotatedRect::RotatedRect()"><strong>RotatedRect::RotatedRect (C++ function)</strong></a>, <a href="modules/core/doc/basic_structures.html#RotatedRect::RotatedRect(const CvBox2D& box)"><strong>[1]</strong></a>, <a href="modules/core/doc/basic_structures.html#RotatedRect::RotatedRect(const Point2f& center, const Size2f& size, float angle)"><strong>[2]</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/utility_and_system_functions_and_macros.html#int cvRound(double value)"><strong>Round (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/utility_and_system_functions_and_macros.html#cv.Round"><strong>Round() (Python function in cv)</strong></a>
  </dt>

      
  <dt><a href="modules/calib3d/doc/camera_calibration_and_3d_reconstruction.html#void cvRQDecomp3x3(const CvMat * matrixM, CvMat * matrixR, CvMat * matrixQ, CvMat * matrixQx, CvMat * matrixQy, CvMat * matrixQz, CvPoint3D64f * eulerAngles)"><strong>RQDecomp3x3 (C function)</strong></a>
  </dt>

      <dd><dl>
        
  <dt><a href="modules/calib3d/doc/camera_calibration_and_3d_reconstruction.html#Vec3d RQDecomp3x3(InputArray src, OutputArray mtxR, OutputArray mtxQ, OutputArray Qx, OutputArray Qy, OutputArray Qz)"><strong>(C++ function)</strong></a>
  </dt>

      </dl></dd>
      
  <dt><a href="modules/calib3d/doc/camera_calibration_and_3d_reconstruction.html#cv.RQDecomp3x3"><strong>RQDecomp3x3() (Python function in cv)</strong></a>
  </dt>

      <dd><dl>
        
  <dt><a href="modules/calib3d/doc/camera_calibration_and_3d_reconstruction.html#cv2.RQDecomp3x3"><strong>(Python function in cv2)</strong></a>
  </dt>

      </dl></dd>
      
  <dt><a href="modules/legacy/doc/feature_detection_and_description.html#RTreeClassifier"><strong>RTreeClassifier (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/legacy/doc/feature_detection_and_description.html#static int RTreeClassifier::countNonZeroElements(float *vec, int n, double tol)"><strong>RTreeClassifier::countNonZeroElements (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/legacy/doc/feature_detection_and_description.html#void RTreeClassifier::getSignature(IplImage *patch, float *sig)"><strong>RTreeClassifier::getSignature (C++ function)</strong></a>, <a href="modules/legacy/doc/feature_detection_and_description.html#void RTreeClassifier::getSignature(IplImage *patch, uchar *sig)"><strong>[1]</strong></a>
  </dt>

      
  <dt><a href="modules/legacy/doc/feature_detection_and_description.html#void RTreeClassifier::getSparseSignature(IplImage *patch, float *sig, float thresh)"><strong>RTreeClassifier::getSparseSignature (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/legacy/doc/feature_detection_and_description.html#void RTreeClassifier::read(const char* file_name)"><strong>RTreeClassifier::read (C++ function)</strong></a>, <a href="modules/legacy/doc/feature_detection_and_description.html#void RTreeClassifier::read(std::istream & is)"><strong>[1]</strong></a>
  </dt>

      
  <dt><a href="modules/legacy/doc/feature_detection_and_description.html#void RTreeClassifier::setQuantization(int num_quant_bits)"><strong>RTreeClassifier::setQuantization (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/legacy/doc/feature_detection_and_description.html#void RTreeClassifier::train(vector<BaseKeypoint> const& base_set, RNG & rng, PatchGenerator & make_patch, int num_trees, int depth, int views, size_t reduced_num_dim, int num_quant_bits)"><strong>RTreeClassifier::train (C++ function)</strong></a>, <a href="modules/legacy/doc/feature_detection_and_description.html#void RTreeClassifier::train(vector<BaseKeypoint> const& base_set, RNG & rng, int num_trees, int depth, int views, size_t reduced_num_dim, int num_quant_bits)"><strong>[1]</strong></a>
  </dt>

      
  <dt><a href="modules/legacy/doc/feature_detection_and_description.html#void RTreeClassifier::write(const char* file_name) const"><strong>RTreeClassifier::write (C++ function)</strong></a>, <a href="modules/legacy/doc/feature_detection_and_description.html#void RTreeClassifier::write(std::ostream &os) const"><strong>[1]</strong></a>
  </dt>

      
  <dt><a href="modules/legacy/doc/feature_detection_and_description.html#RTreeNode"><strong>RTreeNode (C++ structure)</strong></a>
  </dt>

      
  <dt><a href="modules/ml/doc/random_trees.html#cv2.RTrees.getVarImportance"><strong>RTrees.getVarImportance() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/ml/doc/random_trees.html#cv2.RTrees.predict"><strong>RTrees.predict() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/ml/doc/random_trees.html#cv2.RTrees.predict_prob"><strong>RTrees.predict_prob() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/ml/doc/random_trees.html#cv2.RTrees.train"><strong>RTrees.train() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/objdetect/doc/cascade_classification.html#int cvRunHaarClassifierCascade(const CvHaarClassifierCascade* cascade, CvPoint pt, int start_stage)"><strong>RunHaarClassifierCascade (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/motion_analysis_and_object_tracking.html#void cvRunningAvg(const CvArr* image, CvArr* acc, double alpha, const CvArr* mask)"><strong>RunningAvg (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/motion_analysis_and_object_tracking.html#cv.RunningAvg"><strong>RunningAvg() (Python function in cv)</strong></a>
  </dt>

  </dl></td>
</tr></table>

<h2 id="S">S</h2>
<table style="width: 100%" class="indextable genindextable"><tr>
  <td style="width: 33%" valign="top"><dl>
      
  <dt><a href="modules/core/doc/utility_and_system_functions_and_macros.html#template<...> _Tp saturate_cast(_Tp2 v)"><strong>saturate_cast (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_xml_yaml_persistence.html#void cvSave(const char* filename, const void* struct_ptr, const char* name, const char* comment, CvAttrList attributes)"><strong>Save (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_xml_yaml_persistence.html#cv.Save"><strong>Save() (Python function in cv)</strong></a>
  </dt>

      
  <dt><a href="modules/highgui/doc/reading_and_writing_images_and_video.html#int cvSaveImage(const char* filename, const CvArr* image, const int* params)"><strong>SaveImage (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/highgui/doc/reading_and_writing_images_and_video.html#cv.SaveImage"><strong>SaveImage() (Python function in cv)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/dynamic_structures.html#void cvSaveMemStoragePos(const CvMemStorage* storage, CvMemStoragePos* pos)"><strong>SaveMemStoragePos (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/viz/doc/viz3d.html#void saveScreenshot(const String &file)"><strong>saveScreenshot (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/highgui/doc/qt_new_functions.html#void cvSaveWindowParameters(const char* name)"><strong>SaveWindowParameters (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/highgui/doc/qt_new_functions.html#void saveWindowParameters(const string& windowName)"><strong>saveWindowParameters (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/basic_structures.html#Scalar_"><strong>Scalar_ (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#void cvScaleAdd(const CvArr* src1, CvScalar scale, const CvArr* src2, CvArr* dst)"><strong>ScaleAdd (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#void scaleAdd(InputArray src1, double alpha, InputArray src2, OutputArray dst)"><strong>scaleAdd (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#cv.ScaleAdd"><strong>ScaleAdd() (Python function in cv)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#cv2.scaleAdd"><strong>scaleAdd() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/filtering.html#void Scharr(InputArray src, OutputArray dst, int ddepth, int dx, int dy, double scale, double delta, int borderType)"><strong>Scharr (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/filtering.html#cv2.Scharr"><strong>Scharr() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/video/doc/motion_analysis_and_object_tracking.html#CvSeq* cvSegmentMotion(const CvArr* mhi, CvArr* seg_mask, CvMemStorage* storage, double timestamp, double seg_thresh)"><strong>SegmentMotion (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/video/doc/motion_analysis_and_object_tracking.html#void segmentMotion(InputArray mhi, OutputArray segmask, vector<Rect>& boundingRects, double timestamp, double segThresh)"><strong>segmentMotion (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/video/doc/motion_analysis_and_object_tracking.html#cv.SegmentMotion"><strong>SegmentMotion() (Python function in cv)</strong></a>
  </dt>

      
  <dt><a href="modules/video/doc/motion_analysis_and_object_tracking.html#cv2.segmentMotion"><strong>segmentMotion() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/filtering.html#void sepFilter2D(InputArray src, OutputArray dst, int ddepth, InputArray kernelX, InputArray kernelY, Point anchor, double delta, int borderType)"><strong>sepFilter2D (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/filtering.html#cv2.sepFilter2D"><strong>sepFilter2D() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/dynamic_structures.html#int cvSeqElemIdx(const CvSeq* seq, const void* element, CvSeqBlock** block)"><strong>SeqElemIdx (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/dynamic_structures.html#schar* cvSeqInsert(CvSeq* seq, int before_index, const void* element)"><strong>SeqInsert (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/dynamic_structures.html#void cvSeqInsertSlice(CvSeq* seq, int before_index, const CvArr* from_arr)"><strong>SeqInsertSlice (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/dynamic_structures.html#void cvSeqInvert(CvSeq* seq)"><strong>SeqInvert (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/dynamic_structures.html#void cvSeqPop(CvSeq* seq, void* element)"><strong>SeqPop (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/dynamic_structures.html#void cvSeqPopFront(CvSeq* seq, void* element)"><strong>SeqPopFront (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/dynamic_structures.html#void cvSeqPopMulti(CvSeq* seq, void* elements, int count, int in_front)"><strong>SeqPopMulti (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/dynamic_structures.html#schar* cvSeqPush(CvSeq* seq, const void* element)"><strong>SeqPush (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/dynamic_structures.html#schar* cvSeqPushFront(CvSeq* seq, const void* element)"><strong>SeqPushFront (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/dynamic_structures.html#void cvSeqPushMulti(CvSeq* seq, const void* elements, int count, int in_front)"><strong>SeqPushMulti (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/dynamic_structures.html#void cvSeqRemove(CvSeq* seq, int index)"><strong>SeqRemove (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/dynamic_structures.html#void cvSeqRemoveSlice(CvSeq* seq, CvSlice slice)"><strong>SeqRemoveSlice (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/dynamic_structures.html#schar* cvSeqSearch(CvSeq* seq, const void* elem, CvCmpFunc func, int is_sorted, int* elem_idx, void* userdata)"><strong>SeqSearch (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/dynamic_structures.html#CvSeq* cvSeqSlice(const CvSeq* seq, CvSlice slice, CvMemStorage* storage, int copy_data)"><strong>SeqSlice (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/dynamic_structures.html#void cvSeqSort(CvSeq* seq, CvCmpFunc func, void* userdata)"><strong>SeqSort (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_basic_structures.html#void cvSet(CvArr* arr, CvScalar value, const CvArr* mask)"><strong>Set (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_basic_structures.html#cv.Set"><strong>Set() (Python function in cv)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_basic_structures.html#void cvSet1D(CvArr* arr, int idx0, CvScalar value)"><strong>Set1D (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_basic_structures.html#cv.Set1D"><strong>Set1D() (Python function in cv)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_basic_structures.html#void cvSet2D(CvArr* arr, int idx0, int idx1, CvScalar value)"><strong>Set2D (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_basic_structures.html#cv.Set2D"><strong>Set2D() (Python function in cv)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_basic_structures.html#void cvSet3D(CvArr* arr, int idx0, int idx1, int idx2, CvScalar value)"><strong>Set3D (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_basic_structures.html#cv.Set3D"><strong>Set3D() (Python function in cv)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/dynamic_structures.html#int cvSetAdd(CvSet* set_header, CvSetElem* elem, CvSetElem** inserted_elem)"><strong>SetAdd (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/viz/doc/viz3d.html#void setBackgroundColor(const Color& color)"><strong>setBackgroundColor (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/viz/doc/viz3d.html#void setCamera(const Camera &camera)"><strong>setCamera (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/highgui/doc/reading_and_writing_images_and_video.html#int cvSetCaptureProperty(CvCapture* capture, int property_id, double value)"><strong>SetCaptureProperty (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/highgui/doc/reading_and_writing_images_and_video.html#cv.SetCaptureProperty"><strong>SetCaptureProperty() (Python function in cv)</strong></a>
  </dt>

      
  <dt><a href="modules/viz/doc/widget.html#void setColor(const Color &color)"><strong>setColor (C++ function)</strong></a>, <a href="modules/viz/doc/widget.html#void setColor(const Color &color)"><strong>[1]</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_basic_structures.html#void cvSetData(CvArr* arr, void* data, int step)"><strong>SetData (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_basic_structures.html#cv.SetData"><strong>SetData() (Python function in cv)</strong></a>
  </dt>

      
  <dt><a href="modules/viz/doc/viz3d.html#void setFullScreen(bool mode)"><strong>setFullScreen (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/histograms.html#void cvSetHistBinRanges(CvHistogram* hist, float** ranges, int uniform)"><strong>SetHistBinRanges (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#void cvSetIdentity(CvArr* mat, CvScalar value)"><strong>SetIdentity (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#void setIdentity(InputOutputArray mtx, const Scalar& s)"><strong>setIdentity (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#cv.SetIdentity"><strong>SetIdentity() (Python function in cv)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#cv2.setIdentity"><strong>setIdentity() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/viz/doc/widget.html#void setImage(InputArray image)"><strong>setImage (C++ function)</strong></a>, <a href="modules/viz/doc/widget.html#void setImage(InputArray image)"><strong>[1]</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_basic_structures.html#void cvSetImageCOI(IplImage* image, int coi)"><strong>SetImageCOI (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_basic_structures.html#cv.SetImageCOI"><strong>SetImageCOI() (Python function in cv)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_basic_structures.html#void cvSetImageROI(IplImage* image, CvRect rect)"><strong>SetImageROI (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_basic_structures.html#cv.SetImageROI"><strong>SetImageROI() (Python function in cv)</strong></a>
  </dt>

      
  <dt><a href="modules/objdetect/doc/cascade_classification.html#void cvSetImagesForHaarClassifierCascade(CvHaarClassifierCascade* cascade, const CvArr* sum, const CvArr* sqsum, const CvArr* tilted_sum, double scale)"><strong>SetImagesForHaarClassifierCascade (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_basic_structures.html#void cvSetIPLAllocators(Cv_iplCreateImageHeader create_header, Cv_iplAllocateImageData allocate_data, Cv_iplDeallocate deallocate, Cv_iplCreateROI create_roi, Cv_iplCloneImage clone_image)"><strong>SetIPLAllocators (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/highgui/doc/user_interface.html#void cvSetMouseCallback(const char* window_name, CvMouseCallback on_mouse, void* param)"><strong>SetMouseCallback (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/highgui/doc/user_interface.html#void setMouseCallback(const string& winname, MouseCallback onMouse, void* userdata)"><strong>setMouseCallback (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/highgui/doc/user_interface.html#cv.SetMouseCallback"><strong>SetMouseCallback() (Python function in cv)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_basic_structures.html#void cvSetND(CvArr* arr, const int* idx, CvScalar value)"><strong>SetND (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_basic_structures.html#cv.SetND"><strong>SetND() (Python function in cv)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/dynamic_structures.html#CvSetElem* cvSetNew(CvSet* set_header)"><strong>SetNew (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/utility_and_system_functions_and_macros.html#void setNumThreads(int nthreads)"><strong>setNumThreads (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/highgui/doc/user_interface.html#void setOpenGlContext(const string& winname)"><strong>setOpenGlContext (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/highgui/doc/qt_new_functions.html#void cvSetOpenGlDrawCallback(const char* window_name, CvOpenGlDrawCallback callback, void* userdata)"><strong>SetOpenGlDrawCallback (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/highgui/doc/qt_new_functions.html#void setOpenGlDrawCallback(const string& winname, OpenGlDrawCallback onOpenGlDraw, void* userdata)"><strong>setOpenGlDrawCallback (C++ function)</strong></a>, <a href="modules/highgui/doc/user_interface.html#void setOpenGlDrawCallback(const string& winname, OpenGlDrawCallback onOpenGlDraw, void* userdata)"><strong>[1]</strong></a>
  </dt>

      
  <dt><a href="modules/viz/doc/widget.html#void setPose(const Affine3d &pose)"><strong>setPose (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/viz/doc/widget.html#static void setProp(Widget &widget, vtkSmartPointer<vtkProp> prop)"><strong>setProp (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_basic_structures.html#void cvSetReal1D(CvArr* arr, int idx0, double value)"><strong>SetReal1D (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_basic_structures.html#cv.SetReal1D"><strong>SetReal1D() (Python function in cv)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_basic_structures.html#void cvSetReal2D(CvArr* arr, int idx0, int idx1, double value)"><strong>SetReal2D (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_basic_structures.html#cv.SetReal2D"><strong>SetReal2D() (Python function in cv)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_basic_structures.html#void cvSetReal3D(CvArr* arr, int idx0, int idx1, int idx2, double value)"><strong>SetReal3D (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_basic_structures.html#cv.SetReal3D"><strong>SetReal3D() (Python function in cv)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_basic_structures.html#void cvSetRealND(CvArr* arr, const int* idx, double value)"><strong>SetRealND (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_basic_structures.html#cv.SetRealND"><strong>SetRealND() (Python function in cv)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/dynamic_structures.html#void cvSetRemove(CvSet* set_header, int index)"><strong>SetRemove (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/dynamic_structures.html#void cvSetRemoveByPtr(CvSet* set_header, void* elem)"><strong>SetRemoveByPtr (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/viz/doc/viz3d.html#void setRenderingProperty(const String &id, int property, double value)"><strong>setRenderingProperty (C++ function)</strong></a>, <a href="modules/viz/doc/widget.html#void setRenderingProperty(int property, double value)"><strong>[1]</strong></a>
  </dt>

      
  <dt><a href="modules/viz/doc/viz3d.html#void setRepresentation(int representation)"><strong>setRepresentation (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/dynamic_structures.html#void cvSetSeqBlockSize(CvSeq* seq, int delta_elems)"><strong>SetSeqBlockSize (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/dynamic_structures.html#void cvSetSeqReaderPos(CvSeqReader* reader, int index, int is_relative)"><strong>SetSeqReaderPos (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/viz/doc/widget.html#void setText(const String &text)"><strong>setText (C++ function)</strong></a>, <a href="modules/viz/doc/widget.html#void setText(const String &text)"><strong>[1]</strong></a>
  </dt>

      
  <dt><a href="modules/highgui/doc/user_interface.html#void cvSetTrackbarPos(const char* trackbar_name, const char* window_name, int pos)"><strong>SetTrackbarPos (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/highgui/doc/user_interface.html#void setTrackbarPos(const string& trackbarname, const string& winname, int pos)"><strong>setTrackbarPos (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/highgui/doc/user_interface.html#cv.SetTrackbarPos"><strong>SetTrackbarPos() (Python function in cv)</strong></a>
  </dt>

      
  <dt><a href="modules/highgui/doc/user_interface.html#cv2.setTrackbarPos"><strong>setTrackbarPos() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/utility_and_system_functions_and_macros.html#cv2.setUseOptimized"><strong>setUseOptimized() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/viz/doc/viz3d.html#void setViewerPose(const Affine3d &pose)"><strong>setViewerPose (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/viz/doc/viz3d.html#void setWidgetPose(const String &id, const Affine3d &pose)"><strong>setWidgetPose (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/viz/doc/viz3d.html#void setWindowPosition(int x, int y)"><strong>setWindowPosition (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/highgui/doc/qt_new_functions.html#void cvSetWindowProperty(const char* name, int prop_id, double prop_value)"><strong>SetWindowProperty (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/highgui/doc/qt_new_functions.html#void setWindowProperty(const string& winname, int prop_id, double prop_value)"><strong>setWindowProperty (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/highgui/doc/qt_new_functions.html#cv2.setWindowProperty"><strong>setWindowProperty() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/viz/doc/viz3d.html#void setWindowSize(const Size &window_size)"><strong>setWindowSize (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_basic_structures.html#void cvSetZero(CvArr* arr)"><strong>SetZero (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_basic_structures.html#cv.SetZero"><strong>SetZero() (Python function in cv)</strong></a>
  </dt>

      
  <dt><a href="modules/highgui/doc/user_interface.html#void cvShowImage(const char* name, const CvArr* image)"><strong>ShowImage (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/viz/doc/viz3d.html#void showImage(InputArray image, const Size& window_size)"><strong>showImage (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/highgui/doc/user_interface.html#cv.ShowImage"><strong>ShowImage() (Python function in cv)</strong></a>
  </dt>

      
  <dt><a href="modules/nonfree/doc/feature_detection.html#SIFT : public Feature2D"><strong>SIFT (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/nonfree/doc/feature_detection.html#void SIFT::operator()(InputArray img, InputArray mask, vector<KeyPoint>& keypoints, OutputArray descriptors, bool useProvidedKeypoints)"><strong>SIFT::operator() (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/nonfree/doc/feature_detection.html#SIFT::SIFT(int nfeatures, int nOctaveLayers, double contrastThreshold, double edgeThreshold, double sigma)"><strong>SIFT::SIFT (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/features2d/doc/common_interfaces_of_feature_detectors.html#SimpleBlobDetector : public FeatureDetector"><strong>SimpleBlobDetector (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_basic_structures.html#CvSize cvSize(int width, int height)"><strong>Size (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_basic_structures.html#CvSize2D32f cvSize2D32f(double width, double height)"><strong>Size2D32f (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/basic_structures.html#Size_"><strong>Size_ (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/dynamic_structures.html#CvSlice cvSlice(int start, int end)"><strong>Slice (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/dynamic_structures.html#int cvSliceLength(CvSlice slice, const CvSeq* seq)"><strong>SliceLength (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/filtering.html#void cvSmooth(const CvArr* src, CvArr* dst, int smoothtype, int size1, int size2, double sigma1, double sigma2)"><strong>Smooth (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/filtering.html#cv.Smooth"><strong>Smooth() (Python function in cv)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/filtering.html#void cvSobel(const CvArr* src, CvArr* dst, int xorder, int yorder, int aperture_size)"><strong>Sobel (C function)</strong></a>
  </dt>

      <dd><dl>
        
  <dt><a href="modules/imgproc/doc/filtering.html#void Sobel(InputArray src, OutputArray dst, int ddepth, int dx, int dy, int ksize, double scale, double delta, int borderType)"><strong>(C++ function)</strong></a>
  </dt>

      </dl></dd>
      
  <dt><a href="modules/imgproc/doc/filtering.html#cv.Sobel"><strong>Sobel() (Python function in cv)</strong></a>
  </dt>

      <dd><dl>
        
  <dt><a href="modules/imgproc/doc/filtering.html#cv2.Sobel"><strong>(Python function in cv2)</strong></a>
  </dt>

      </dl></dd>
      
  <dt><a href="modules/core/doc/operations_on_arrays.html#int cvSolve(const CvArr* src1, const CvArr* src2, CvArr* dst, int method)"><strong>Solve (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#bool solve(InputArray src1, InputArray src2, OutputArray dst, int flags)"><strong>solve (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#cv.Solve"><strong>Solve() (Python function in cv)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#cv2.solve"><strong>solve() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#int cvSolveCubic(const CvMat* coeffs, CvMat* roots)"><strong>SolveCubic (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#int solveCubic(InputArray coeffs, OutputArray roots)"><strong>solveCubic (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#cv.SolveCubic"><strong>SolveCubic() (Python function in cv)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#cv2.solveCubic"><strong>solveCubic() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/calib3d/doc/camera_calibration_and_3d_reconstruction.html#bool solvePnP(InputArray objectPoints, InputArray imagePoints, InputArray cameraMatrix, InputArray distCoeffs, OutputArray rvec, OutputArray tvec, bool useExtrinsicGuess, int flags)"><strong>solvePnP (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/calib3d/doc/camera_calibration_and_3d_reconstruction.html#cv2.solvePnP"><strong>solvePnP() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/calib3d/doc/camera_calibration_and_3d_reconstruction.html#void solvePnPRansac(InputArray objectPoints, InputArray imagePoints, InputArray cameraMatrix, InputArray distCoeffs, OutputArray rvec, OutputArray tvec, bool useExtrinsicGuess, int iterationsCount , float reprojectionError , int minInliersCount , OutputArray inliers , int flags)"><strong>solvePnPRansac (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/calib3d/doc/camera_calibration_and_3d_reconstruction.html#cv2.solvePnPRansac"><strong>solvePnPRansac() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#double solvePoly(InputArray coeffs, OutputArray roots, int maxIters)"><strong>solvePoly (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#cv2.solvePoly"><strong>solvePoly() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#void sort(InputArray src, OutputArray dst, int flags)"><strong>sort (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#cv2.sort"><strong>sort() (Python function in cv2)</strong></a>
  </dt>

  </dl></td>
  <td style="width: 33%" valign="top"><dl>
      
  <dt><a href="modules/core/doc/operations_on_arrays.html#void sortIdx(InputArray src, OutputArray dst, int flags)"><strong>sortIdx (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#cv2.sortIdx"><strong>sortIdx() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/basic_structures.html#SparseMat"><strong>SparseMat (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/basic_structures.html#void SparseMat::addref()"><strong>SparseMat::addref (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/basic_structures.html#int SparseMat::channels() const"><strong>SparseMat::channels (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/basic_structures.html#void SparseMat::clear()"><strong>SparseMat::clear (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/basic_structures.html#SparseMat SparseMat::clone() const"><strong>SparseMat::clone (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/basic_structures.html#void SparseMat::convertTo(Mat& m, int rtype, double alpha, double beta) const"><strong>SparseMat::convertTo (C++ function)</strong></a>, <a href="modules/core/doc/basic_structures.html#void SparseMat::convertTo(SparseMat& m, int rtype, double alpha) const"><strong>[1]</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/basic_structures.html#void SparseMat::copyTo(Mat& m) const"><strong>SparseMat::copyTo (C++ function)</strong></a>, <a href="modules/core/doc/basic_structures.html#void SparseMat::copyTo(SparseMat& m) const"><strong>[1]</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/basic_structures.html#void SparseMat::create(int dims, const int* _sizes, int _type)"><strong>SparseMat::create (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/basic_structures.html#int SparseMat::depth() const"><strong>SparseMat::depth (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/basic_structures.html#int SparseMat::dims() const"><strong>SparseMat::dims (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/basic_structures.html#size_t SparseMat::elemSize() const"><strong>SparseMat::elemSize (C++ function)</strong></a>, <a href="modules/core/doc/basic_structures.html#size_t SparseMat::elemSize() const"><strong>[1]</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/basic_structures.html#void SparseMat::erase(const int* idx, size_t* hashval)"><strong>SparseMat::erase (C++ function)</strong></a>, <a href="modules/core/doc/basic_structures.html#void SparseMat::erase(int i0, int i1, int i2, size_t* hashval)"><strong>[1]</strong></a>, <a href="modules/core/doc/basic_structures.html#void SparseMat::erase(int i0, int i1, size_t* hashval)"><strong>[2]</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/basic_structures.html#size_t SparseMat::hash(const int* idx) const"><strong>SparseMat::hash (C++ function)</strong></a>, <a href="modules/core/doc/basic_structures.html#size_t SparseMat::hash(int i0) const"><strong>[1]</strong></a>, <a href="modules/core/doc/basic_structures.html#size_t SparseMat::hash(int i0, int i1) const"><strong>[2]</strong></a>, <a href="modules/core/doc/basic_structures.html#size_t SparseMat::hash(int i0, int i1, int i2) const"><strong>[3]</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/basic_structures.html#size_t SparseMat::nzcount() const"><strong>SparseMat::nzcount (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/basic_structures.html#SparseMat::operator CvSparseMat*() const"><strong>SparseMat::operator CvSparseMat* (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/basic_structures.html#SparseMat& SparseMat::operator = (const Mat& m)"><strong>SparseMat::operator= (C++ function)</strong></a>, <a href="modules/core/doc/basic_structures.html#SparseMat& SparseMat::operator = (const SparseMat& m)"><strong>[1]</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/basic_structures.html#uchar* SparseMat::ptr(const int* idx, bool createMissing, size_t* hashval)"><strong>SparseMat::ptr (C++ function)</strong></a>, <a href="modules/core/doc/basic_structures.html#uchar* SparseMat::ptr(int i0, bool createMissing, size_t* hashval)"><strong>[1]</strong></a>, <a href="modules/core/doc/basic_structures.html#uchar* SparseMat::ptr(int i0, int i1, bool createMissing, size_t* hashval)"><strong>[2]</strong></a>, <a href="modules/core/doc/basic_structures.html#uchar* SparseMat::ptr(int i0, int i1, int i2, bool createMissing, size_t* hashval)"><strong>[3]</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/basic_structures.html#void SparseMat::release()"><strong>SparseMat::release (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/basic_structures.html#const int* SparseMat::size() const"><strong>SparseMat::size (C++ function)</strong></a>, <a href="modules/core/doc/basic_structures.html#int SparseMat::size(int i) const"><strong>[1]</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/basic_structures.html#SparseMat::SparseMat()"><strong>SparseMat::SparseMat (C++ function)</strong></a>, <a href="modules/core/doc/basic_structures.html#SparseMat::SparseMat(const CvSparseMat* m)"><strong>[1]</strong></a>, <a href="modules/core/doc/basic_structures.html#SparseMat::SparseMat(const Mat& m)"><strong>[2]</strong></a>, <a href="modules/core/doc/basic_structures.html#SparseMat::SparseMat(const SparseMat& m)"><strong>[3]</strong></a>, <a href="modules/core/doc/basic_structures.html#SparseMat::SparseMat(int dims, const int* _sizes, int _type)"><strong>[4]</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/basic_structures.html#int SparseMat::type() const"><strong>SparseMat::type (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/basic_structures.html#SparseMat::~SparseMat()"><strong>SparseMat::~SparseMat (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/basic_structures.html#SparseMat_"><strong>SparseMat_ (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/stitching/doc/high_level.html#SphericalWarper : public WarperCreator"><strong>SphericalWarper (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/viz/doc/viz3d.html#void spin()"><strong>spin (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/viz/doc/viz3d.html#void spinOnce(int time , bool force_redraw)"><strong>spinOnce (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#void cvSplit(const CvArr* src, CvArr* dst0, CvArr* dst1, CvArr* dst2, CvArr* dst3)"><strong>Split (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#void split(InputArray m, OutputArrayOfArrays mv)"><strong>split (C++ function)</strong></a>, <a href="modules/core/doc/operations_on_arrays.html#void split(const Mat& src, Mat* mvbegin)"><strong>[1]</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#cv.Split"><strong>Split() (Python function in cv)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#cv2.split"><strong>split() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#float cvSqrt(float value)"><strong>Sqrt (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#void sqrt(InputArray src, OutputArray dst)"><strong>sqrt (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#cv.Sqrt"><strong>Sqrt() (Python function in cv)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#cv2.sqrt"><strong>sqrt() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/motion_analysis_and_object_tracking.html#void cvSquareAcc(const CvArr* image, CvArr* sqsum, const CvArr* mask)"><strong>SquareAcc (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/motion_analysis_and_object_tracking.html#cv.SquareAcc"><strong>SquareAcc() (Python function in cv)</strong></a>
  </dt>

      
  <dt><a href="modules/features2d/doc/common_interfaces_of_feature_detectors.html#StarAdjuster : public AdjusterAdapter"><strong>StarAdjuster (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/features2d/doc/common_interfaces_of_feature_detectors.html#StarFeatureDetector : public FeatureDetector"><strong>StarFeatureDetector (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/dynamic_structures.html#void cvStartAppendToSeq(CvSeq* seq, CvSeqWriter* writer)"><strong>StartAppendToSeq (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_xml_yaml_persistence.html#void cvStartNextStream(CvFileStorage* fs)"><strong>StartNextStream (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_xml_yaml_persistence.html#void cvStartReadRawData(const CvFileStorage* fs, const CvFileNode* src, CvSeqReader* reader)"><strong>StartReadRawData (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/dynamic_structures.html#void cvStartReadSeq(const CvSeq* seq, CvSeqReader* reader, int reverse)"><strong>StartReadSeq (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/dynamic_structures.html#void cvStartWriteSeq(int seq_flags, int header_size, int elem_size, CvMemStorage* storage, CvSeqWriter* writer)"><strong>StartWriteSeq (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_xml_yaml_persistence.html#void cvStartWriteStruct(CvFileStorage* fs, const char* name, int struct_flags, const char* type_name, CvAttrList attributes)"><strong>StartWriteStruct (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/ml/doc/statistical_models.html#cv2.StatModel.load"><strong>StatModel.load() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/ml/doc/statistical_models.html#cv2.StatModel.save"><strong>StatModel.save() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/calib3d/doc/camera_calibration_and_3d_reconstruction.html#StereoBM"><strong>StereoBM (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/calib3d/doc/camera_calibration_and_3d_reconstruction.html#cv2.StereoBM"><strong>StereoBM() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/calib3d/doc/camera_calibration_and_3d_reconstruction.html#cv2.StereoBM.compute"><strong>StereoBM.compute() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/calib3d/doc/camera_calibration_and_3d_reconstruction.html#void StereoBM::operator()(InputArray left, InputArray right, OutputArray disparity, int disptype)"><strong>StereoBM::operator() (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/calib3d/doc/camera_calibration_and_3d_reconstruction.html#StereoBM::StereoBM()"><strong>StereoBM::StereoBM (C++ function)</strong></a>, <a href="modules/calib3d/doc/camera_calibration_and_3d_reconstruction.html#StereoBM::StereoBM(int preset, int ndisparities, int SADWindowSize)"><strong>[1]</strong></a>
  </dt>

      
  <dt><a href="modules/calib3d/doc/camera_calibration_and_3d_reconstruction.html#double cvStereoCalibrate(const CvMat* object_points, const CvMat* image_points1, const CvMat* image_points2, const CvMat* npoints, CvMat* camera_matrix1, CvMat* dist_coeffs1, CvMat* camera_matrix2, CvMat* dist_coeffs2, CvSize image_size, CvMat* R, CvMat* T, CvMat* E, CvMat* F, CvTermCriteria term_crit, int flags)"><strong>StereoCalibrate (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/calib3d/doc/camera_calibration_and_3d_reconstruction.html#double stereoCalibrate(InputArrayOfArrays objectPoints, InputArrayOfArrays imagePoints1, InputArrayOfArrays imagePoints2, InputOutputArray cameraMatrix1, InputOutputArray distCoeffs1, InputOutputArray cameraMatrix2, InputOutputArray distCoeffs2, Size imageSize, OutputArray R, OutputArray T, OutputArray E, OutputArray F, TermCriteria criteria, int flags)"><strong>stereoCalibrate (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/calib3d/doc/camera_calibration_and_3d_reconstruction.html#cv.StereoCalibrate"><strong>StereoCalibrate() (Python function in cv)</strong></a>
  </dt>

      
  <dt><a href="modules/calib3d/doc/camera_calibration_and_3d_reconstruction.html#cv2.stereoCalibrate"><strong>stereoCalibrate() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/calib3d/doc/camera_calibration_and_3d_reconstruction.html#void cvStereoRectify(const CvMat* camera_matrix1, const CvMat* camera_matrix2, const CvMat* dist_coeffs1, const CvMat* dist_coeffs2, CvSize image_size, const CvMat* R, const CvMat* T, CvMat* R1, CvMat* R2, CvMat* P1, CvMat* P2, CvMat* Q, int flags, double alpha, CvSize new_image_size, CvRect* valid_pix_ROI1, CvRect* valid_pix_ROI2)"><strong>StereoRectify (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/calib3d/doc/camera_calibration_and_3d_reconstruction.html#void stereoRectify(InputArray cameraMatrix1, InputArray distCoeffs1, InputArray cameraMatrix2, InputArray distCoeffs2, Size imageSize, InputArray R, InputArray T, OutputArray R1, OutputArray R2, OutputArray P1, OutputArray P2, OutputArray Q, int flags, double alpha, Size newImageSize, Rect* validPixROI1, Rect* validPixROI2)"><strong>stereoRectify (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/calib3d/doc/camera_calibration_and_3d_reconstruction.html#cv.StereoRectify"><strong>StereoRectify() (Python function in cv)</strong></a>
  </dt>

      
  <dt><a href="modules/calib3d/doc/camera_calibration_and_3d_reconstruction.html#int cvStereoRectifyUncalibrated(const CvMat* points1, const CvMat* points2, const CvMat* F, CvSize img_size, CvMat* H1, CvMat* H2, double threshold)"><strong>StereoRectifyUncalibrated (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/calib3d/doc/camera_calibration_and_3d_reconstruction.html#bool stereoRectifyUncalibrated(InputArray points1, InputArray points2, InputArray F, Size imgSize, OutputArray H1, OutputArray H2, double threshold)"><strong>stereoRectifyUncalibrated (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/calib3d/doc/camera_calibration_and_3d_reconstruction.html#cv.StereoRectifyUncalibrated"><strong>StereoRectifyUncalibrated() (Python function in cv)</strong></a>
  </dt>

      
  <dt><a href="modules/calib3d/doc/camera_calibration_and_3d_reconstruction.html#cv2.stereoRectifyUncalibrated"><strong>stereoRectifyUncalibrated() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/calib3d/doc/camera_calibration_and_3d_reconstruction.html#StereoSGBM"><strong>StereoSGBM (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/calib3d/doc/camera_calibration_and_3d_reconstruction.html#cv2.StereoSGBM"><strong>StereoSGBM() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/calib3d/doc/camera_calibration_and_3d_reconstruction.html#cv2.StereoSGBM.compute"><strong>StereoSGBM.compute() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/calib3d/doc/camera_calibration_and_3d_reconstruction.html#void StereoSGBM::operator()(InputArray left, InputArray right, OutputArray disp)"><strong>StereoSGBM::operator() (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/calib3d/doc/camera_calibration_and_3d_reconstruction.html#StereoSGBM::StereoSGBM()"><strong>StereoSGBM::StereoSGBM (C++ function)</strong></a>, <a href="modules/calib3d/doc/camera_calibration_and_3d_reconstruction.html#StereoSGBM::StereoSGBM(int minDisparity, int numDisparities, int SADWindowSize, int P1, int P2, int disp12MaxDiff, int preFilterCap, int uniquenessRatio, int speckleWindowSize, int speckleRange, bool fullDP)"><strong>[1]</strong></a>
  </dt>

      
  <dt><a href="modules/contrib/doc/stereo.html#StereoVar"><strong>StereoVar (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/contrib/doc/stereo.html#void StereoVar::operator()(const Mat& left, const Mat& right, Mat& disp)"><strong>StereoVar::operator() (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/contrib/doc/stereo.html#StereoVar::StereoVar()"><strong>StereoVar::StereoVar (C++ function)</strong></a>, <a href="modules/contrib/doc/stereo.html#StereoVar::StereoVar(int levels, double pyrScale, int nIt, int minDisp, int maxDisp, int poly_n, double poly_sigma, float fi, float lambda, int penalization, int cycle, int flags)"><strong>[1]</strong></a>
  </dt>

      
  <dt><a href="modules/stitching/doc/high_level.html#Stitcher"><strong>Stitcher (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/stitching/doc/high_level.html#Status Stitcher::composePanorama(InputArray images, OutputArray pano)"><strong>Stitcher::composePanorama (C++ function)</strong></a>, <a href="modules/stitching/doc/high_level.html#Status Stitcher::composePanorama(OutputArray pano)"><strong>[1]</strong></a>
  </dt>

      
  <dt><a href="modules/stitching/doc/high_level.html#Stitcher Stitcher::createDefault(bool try_use_gpu)"><strong>Stitcher::createDefault (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/stitching/doc/high_level.html#Status Stitcher::estimateTransform(InputArray images)"><strong>Stitcher::estimateTransform (C++ function)</strong></a>, <a href="modules/stitching/doc/high_level.html#Status Stitcher::estimateTransform(InputArray images, const std::vector<std::vector<Rect> > &rois)"><strong>[1]</strong></a>
  </dt>

      
  <dt><a href="modules/stitching/doc/high_level.html#Status Stitcher::stitch(InputArray images, OutputArray pano)"><strong>Stitcher::stitch (C++ function)</strong></a>, <a href="modules/stitching/doc/high_level.html#Status Stitcher::stitch(InputArray images, const std::vector<std::vector<Rect> > &rois, OutputArray pano)"><strong>[1]</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#void cvSub(const CvArr* src1, const CvArr* src2, CvArr* dst, const CvArr* mask)"><strong>Sub (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#cv.Sub"><strong>Sub() (Python function in cv)</strong></a>
  </dt>

      
  <dt><a href="modules/legacy/doc/planar_subdivisions.html#CvSubdiv2DPoint* cvSubdiv2DEdgeDst(CvSubdiv2DEdge edge)"><strong>Subdiv2DEdgeDst (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/legacy/doc/planar_subdivisions.html#cv.Subdiv2DEdgeDst"><strong>Subdiv2DEdgeDst() (Python function in cv)</strong></a>
  </dt>

      
  <dt><a href="modules/legacy/doc/planar_subdivisions.html#CvSubdiv2DEdge cvSubdiv2DGetEdge(CvSubdiv2DEdge edge, CvNextEdgeType type)"><strong>Subdiv2DGetEdge (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/legacy/doc/planar_subdivisions.html#cv.Subdiv2DGetEdge"><strong>Subdiv2DGetEdge() (Python function in cv)</strong></a>
  </dt>

      
  <dt><a href="modules/legacy/doc/planar_subdivisions.html#CvSubdiv2DPointLocation cvSubdiv2DLocate(CvSubdiv2D* subdiv, CvPoint2D32f pt, CvSubdiv2DEdge* edge, CvSubdiv2DPoint** vertex)"><strong>Subdiv2DLocate (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/legacy/doc/planar_subdivisions.html#cv.Subdiv2DLocate"><strong>Subdiv2DLocate() (Python function in cv)</strong></a>
  </dt>

      
  <dt><a href="modules/legacy/doc/planar_subdivisions.html#CvSubdiv2DEdge cvSubdiv2DNextEdge(CvSubdiv2DEdge edge)"><strong>Subdiv2DNextEdge (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/legacy/doc/planar_subdivisions.html#cv.Subdiv2DNextEdge"><strong>Subdiv2DNextEdge() (Python function in cv)</strong></a>
  </dt>

      
  <dt><a href="modules/legacy/doc/planar_subdivisions.html#CvSubdiv2DEdge cvSubdiv2DRotateEdge(CvSubdiv2DEdge edge, int rotate)"><strong>Subdiv2DRotateEdge (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/legacy/doc/planar_subdivisions.html#cv.Subdiv2DRotateEdge"><strong>Subdiv2DRotateEdge() (Python function in cv)</strong></a>
  </dt>

      
  <dt><a href="modules/legacy/doc/planar_subdivisions.html#CvSubdiv2DPoint* cvSubdivDelaunay2DInsert(CvSubdiv2D* subdiv, CvPoint2D32f pt)"><strong>SubdivDelaunay2DInsert (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/legacy/doc/planar_subdivisions.html#cv.SubdivDelaunay2DInsert"><strong>SubdivDelaunay2DInsert() (Python function in cv)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#void cvSubRS(const CvArr* src, CvScalar value, CvArr* dst, const CvArr* mask)"><strong>SubRS (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#cv.SubRS"><strong>SubRS() (Python function in cv)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#void cvSubS(const CvArr* src, CvScalar value, CvArr* dst, const CvArr* mask)"><strong>SubS (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#cv.SubS"><strong>SubS() (Python function in cv)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#void subtract(InputArray src1, InputArray src2, OutputArray dst, InputArray mask, int dtype)"><strong>subtract (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#cv2.subtract"><strong>subtract() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="platforms/android/service/doc/LoaderCallbackInterface.html#SUCCESS">SUCCESS (built-in variable)</a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#CvScalar cvSum(const CvArr* arr)"><strong>Sum (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#Scalar sum(InputArray src)"><strong>sum (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#cv.Sum"><strong>Sum() (Python function in cv)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#cv2.sumElems"><strong>sumElems() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/superres/doc/super_resolution.html#Ptr<SuperResolution> superres::createSuperResolution_BTVL1()"><strong>superres::createSuperResolution_BTVL1 (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/superres/doc/super_resolution.html#Ptr<SuperResolution> superres::createSuperResolution_BTVL1_GPU()"><strong>superres::createSuperResolution_BTVL1_GPU (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/superres/doc/super_resolution.html#superres::SuperResolution : public Algorithm, public superres::FrameSource"><strong>superres::SuperResolution (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/superres/doc/super_resolution.html#void superres::SuperResolution::collectGarbage()"><strong>superres::SuperResolution::collectGarbage (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/superres/doc/super_resolution.html#void superres::SuperResolution::nextFrame(OutputArray frame)"><strong>superres::SuperResolution::nextFrame (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/superres/doc/super_resolution.html#void superres::SuperResolution::setInput(const Ptr<FrameSource>& frameSource)"><strong>superres::SuperResolution::setInput (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/nonfree/doc/feature_detection.html#SURF : public Feature2D"><strong>SURF (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/nonfree/doc/feature_detection.html#cv2.SURF"><strong>SURF() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/nonfree/doc/feature_detection.html#cv2.SURF.detect"><strong>SURF.detect() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/nonfree/doc/feature_detection.html#cv2.SURF.detectAndCompute"><strong>SURF.detectAndCompute() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/nonfree/doc/feature_detection.html#int extended"><strong>SURF::extended (C++ member)</strong></a>
  </dt>

      
  <dt><a href="modules/nonfree/doc/feature_detection.html#double hessianThreshold"><strong>SURF::hessianThreshold (C++ member)</strong></a>
  </dt>

      
  <dt><a href="modules/nonfree/doc/feature_detection.html#int nOctaveLayers"><strong>SURF::nOctaveLayers (C++ member)</strong></a>
  </dt>

      
  <dt><a href="modules/nonfree/doc/feature_detection.html#int nOctaves"><strong>SURF::nOctaves (C++ member)</strong></a>
  </dt>

      
  <dt><a href="modules/nonfree/doc/feature_detection.html#void SURF::operator()(InputArray img, InputArray mask, vector<KeyPoint>& keypoints) const"><strong>SURF::operator() (C++ function)</strong></a>, <a href="modules/nonfree/doc/feature_detection.html#void SURF::operator()(InputArray img, InputArray mask, vector<KeyPoint>& keypoints, OutputArray descriptors, bool useProvidedKeypoints)"><strong>[1]</strong></a>
  </dt>

      
  <dt><a href="modules/nonfree/doc/feature_detection.html#SURF::SURF()"><strong>SURF::SURF (C++ function)</strong></a>, <a href="modules/nonfree/doc/feature_detection.html#SURF::SURF(double hessianThreshold, int nOctaves, int nOctaveLayers, bool extended, bool upright)"><strong>[1]</strong></a>
  </dt>

      
  <dt><a href="modules/nonfree/doc/feature_detection.html#int upright"><strong>SURF::upright (C++ member)</strong></a>
  </dt>

      
  <dt><a href="modules/features2d/doc/common_interfaces_of_feature_detectors.html#SurfAdjuster : public AdjusterAdapter"><strong>SurfAdjuster (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#cv2.SVBackSubst"><strong>SVBackSubst() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#void cvSVBkSb(const CvArr* W, const CvArr* U, const CvArr* V, const CvArr* B, CvArr* X, int flags)"><strong>SVBkSb (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#cv.SVBkSb"><strong>SVBkSb() (Python function in cv)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#void cvSVD(CvArr* A, CvArr* W, CvArr* U, CvArr* V, int flags)"><strong>SVD (C function)</strong></a>
  </dt>

      <dd><dl>
        
  <dt><a href="modules/core/doc/operations_on_arrays.html#SVD"><strong>(C++ class)</strong></a>
  </dt>

      </dl></dd>
      
  <dt><a href="modules/core/doc/operations_on_arrays.html#cv.SVD"><strong>SVD() (Python function in cv)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#static void SVD::backSubst(InputArray w, InputArray u, InputArray vt, InputArray rhs, OutputArray dst)"><strong>SVD::backSubst (C++ function)</strong></a>, <a href="modules/core/doc/operations_on_arrays.html#void SVD::backSubst(InputArray rhs, OutputArray dst) const"><strong>[1]</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#static void SVD::compute(InputArray src, OutputArray w, OutputArray u, OutputArray vt, int flags)"><strong>SVD::compute (C++ function)</strong></a>, <a href="modules/core/doc/operations_on_arrays.html#static void SVD::compute(InputArray src, OutputArray w, int flags)"><strong>[1]</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#SVD& SVD::operator()(InputArray src, int flags)"><strong>SVD::operator() (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#static void SVD::solveZ(InputArray src, OutputArray dst)"><strong>SVD::solveZ (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#SVD::SVD()"><strong>SVD::SVD (C++ function)</strong></a>, <a href="modules/core/doc/operations_on_arrays.html#SVD::SVD(InputArray src, int flags)"><strong>[1]</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#cv2.SVDecomp"><strong>SVDecomp() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/ml/doc/support_vector_machines.html#cv2.SVM"><strong>SVM() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/ml/doc/support_vector_machines.html#cv2.SVM.get_support_vector_count"><strong>SVM.get_support_vector_count() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/ml/doc/support_vector_machines.html#cv2.SVM.get_var_count"><strong>SVM.get_var_count() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/ml/doc/support_vector_machines.html#cv2.SVM.predict"><strong>SVM.predict() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/ml/doc/support_vector_machines.html#cv2.SVM.predict_all"><strong>SVM.predict_all() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/ml/doc/support_vector_machines.html#cv2.SVM.train"><strong>SVM.train() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/ml/doc/support_vector_machines.html#cv2.SVM.train_auto"><strong>SVM.train_auto() (Python function in cv2)</strong></a>
  </dt>

  </dl></td>
</tr></table>

<h2 id="T">T</h2>
<table style="width: 100%" class="indextable genindextable"><tr>
  <td style="width: 33%" valign="top"><dl>
      
  <dt><a href="modules/core/doc/basic_structures.html#template<typename _Tp> Ptr::operator _Tp* ()"><strong>template&lt;typename _Tp&gt; Ptr::operator _Tp* (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/basic_structures.html#template<typename _Tp> Ptr::operator const _Tp*() const"><strong>template&lt;typename _Tp&gt; Ptr::operator const _Tp* (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/basic_structures.html#TermCriteria"><strong>TermCriteria (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/basic_structures.html#TermCriteria::operator CvTermCriteria() const"><strong>TermCriteria::operator CvTermCriteria (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/basic_structures.html#TermCriteria::TermCriteria()"><strong>TermCriteria::TermCriteria (C++ function)</strong></a>, <a href="modules/core/doc/basic_structures.html#TermCriteria::TermCriteria(const CvTermCriteria& criteria)"><strong>[1]</strong></a>, <a href="modules/core/doc/basic_structures.html#TermCriteria::TermCriteria(int type, int maxCount, double epsilon)"><strong>[2]</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#RNG& theRNG()"><strong>theRNG (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/histograms.html#void cvThreshHist(CvHistogram* hist, double threshold)"><strong>ThreshHist (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/histograms.html#cv.ThreshHist"><strong>ThreshHist() (Python function in cv)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/miscellaneous_transformations.html#double cvThreshold(const CvArr* src, CvArr* dst, double threshold, double max_value, int threshold_type)"><strong>Threshold (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/miscellaneous_transformations.html#double threshold(InputArray src, OutputArray dst, double thresh, double maxval, int type)"><strong>threshold (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/miscellaneous_transformations.html#cv.Threshold"><strong>Threshold() (Python function in cv)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/miscellaneous_transformations.html#cv2.threshold"><strong>threshold() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#CvScalar cvTrace(const CvArr* mat)"><strong>Trace (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#Scalar trace(InputArray mtx)"><strong>trace (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#cv.Trace"><strong>Trace() (Python function in cv)</strong></a>
  </dt>

  </dl></td>
  <td style="width: 33%" valign="top"><dl>
      
  <dt><a href="modules/core/doc/operations_on_arrays.html#cv2.trace"><strong>trace() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#void cvTransform(const CvArr* src, CvArr* dst, const CvMat* transmat, const CvMat* shiftvec)"><strong>Transform (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#void transform(InputArray src, OutputArray dst, InputArray m)"><strong>transform (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#cv.Transform"><strong>Transform() (Python function in cv)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#cv2.transform"><strong>transform() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#void cvTranspose(const CvArr* src, CvArr* dst)"><strong>Transpose (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#void transpose(InputArray src, OutputArray dst)"><strong>transpose (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#cv.Transpose"><strong>Transpose() (Python function in cv)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#cv2.transpose"><strong>transpose() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/dynamic_structures.html#CvSeq* cvTreeToNodeSeq(const void* first, int header_size, CvMemStorage* storage)"><strong>TreeToNodeSeq (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/calib3d/doc/camera_calibration_and_3d_reconstruction.html#void cvTriangulatePoints(CvMat* projMatr1, CvMat* projMatr2, CvMat* projPoints1, CvMat* projPoints2, CvMat* points4D)"><strong>TriangulatePoints (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/calib3d/doc/camera_calibration_and_3d_reconstruction.html#void triangulatePoints(InputArray projMatr1, InputArray projMatr2, InputArray projPoints1, InputArray projPoints2, OutputArray points4D)"><strong>triangulatePoints (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/calib3d/doc/camera_calibration_and_3d_reconstruction.html#cv2.triangulatePoints"><strong>triangulatePoints() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_xml_yaml_persistence.html#CvTypeInfo* cvTypeOf(const void* struct_ptr)"><strong>TypeOf (C function)</strong></a>
  </dt>

  </dl></td>
</tr></table>

<h2 id="U">U</h2>
<table style="width: 100%" class="indextable genindextable"><tr>
  <td style="width: 33%" valign="top"><dl>
      
  <dt><a href="modules/imgproc/doc/geometric_transformations.html#void undistort(InputArray src, OutputArray dst, InputArray cameraMatrix, InputArray distCoeffs, InputArray newCameraMatrix)"><strong>undistort (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/geometric_transformations.html#cv2.undistort"><strong>undistort() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/geometric_transformations.html#void cvUndistort2(const CvArr* src, CvArr* dst, const CvMat* camera_matrix, const CvMat* distortion_coeffs, const CvMat* new_camera_matrix)"><strong>Undistort2 (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/geometric_transformations.html#cv.Undistort2"><strong>Undistort2() (Python function in cv)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/geometric_transformations.html#void cvUndistortPoints(const CvMat* src, CvMat* dst, const CvMat* camera_matrix, const CvMat* dist_coeffs, const CvMat* R, const CvMat* P)"><strong>UndistortPoints (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/geometric_transformations.html#void undistortPoints(InputArray src, OutputArray dst, InputArray cameraMatrix, InputArray distCoeffs, InputArray R, InputArray P)"><strong>undistortPoints (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/geometric_transformations.html#cv.UndistortPoints"><strong>UndistortPoints() (Python function in cv)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/geometric_transformations.html#cv2.undistortPoints"><strong>undistortPoints() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_xml_yaml_persistence.html#void cvUnregisterType(const char* type_name)"><strong>UnregisterType (C function)</strong></a>
  </dt>

  </dl></td>
  <td style="width: 33%" valign="top"><dl>
      
  <dt><a href="modules/video/doc/motion_analysis_and_object_tracking.html#void cvUpdateMotionHistory(const CvArr* silhouette, CvArr* mhi, double timestamp, double duration)"><strong>UpdateMotionHistory (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/video/doc/motion_analysis_and_object_tracking.html#void updateMotionHistory(InputArray silhouette, InputOutputArray mhi, double timestamp, double duration)"><strong>updateMotionHistory (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/video/doc/motion_analysis_and_object_tracking.html#cv.UpdateMotionHistory"><strong>UpdateMotionHistory() (Python function in cv)</strong></a>
  </dt>

      
  <dt><a href="modules/video/doc/motion_analysis_and_object_tracking.html#cv2.updateMotionHistory"><strong>updateMotionHistory() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/viz/doc/viz3d.html#void updateWidgetPose(const String &id, const Affine3d &pose)"><strong>updateWidgetPose (C++ function)</strong></a>, <a href="modules/viz/doc/widget.html#void updateWidgetPose(const Affine3d &pose)"><strong>[1]</strong></a>
  </dt>

      
  <dt><a href="modules/highgui/doc/user_interface.html#void updateWindow(const string& winname)"><strong>updateWindow (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/utility_and_system_functions_and_macros.html#int cvUseOptimized(int on_off)"><strong>UseOptimized (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/utility_and_system_functions_and_macros.html#bool useOptimized()"><strong>useOptimized (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/utility_and_system_functions_and_macros.html#cv2.useOptimized"><strong>useOptimized() (Python function in cv2)</strong></a>
  </dt>

  </dl></td>
</tr></table>

<h2 id="V">V</h2>
<table style="width: 100%" class="indextable genindextable"><tr>
  <td style="width: 33%" valign="top"><dl>
      
  <dt><a href="modules/core/doc/basic_structures.html#Vec"><strong>Vec (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/features2d/doc/common_interfaces_of_generic_descriptor_matchers.html#VectorDescriptorMatcher : public GenericDescriptorMatcher"><strong>VectorDescriptorMatcher (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/highgui/doc/reading_and_writing_images_and_video.html#VideoCapture"><strong>VideoCapture (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/highgui/doc/reading_and_writing_images_and_video.html#cv2.VideoCapture"><strong>VideoCapture() (Python function in cv2)</strong></a>, <a href="modules/highgui/doc/reading_and_writing_images_and_video.html#cv2.VideoCapture"><strong>[1]</strong></a>, <a href="modules/highgui/doc/reading_and_writing_images_and_video.html#cv2.VideoCapture"><strong>[2]</strong></a>
  </dt>

      
  <dt><a href="modules/highgui/doc/reading_and_writing_images_and_video.html#cv2.VideoCapture.get"><strong>VideoCapture.get() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/highgui/doc/reading_and_writing_images_and_video.html#cv2.VideoCapture.grab"><strong>VideoCapture.grab() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/highgui/doc/reading_and_writing_images_and_video.html#cv2.VideoCapture.isOpened"><strong>VideoCapture.isOpened() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/highgui/doc/reading_and_writing_images_and_video.html#cv2.VideoCapture.open"><strong>VideoCapture.open() (Python function in cv2)</strong></a>, <a href="modules/highgui/doc/reading_and_writing_images_and_video.html#cv2.VideoCapture.open"><strong>[1]</strong></a>
  </dt>

      
  <dt><a href="modules/highgui/doc/reading_and_writing_images_and_video.html#cv2.VideoCapture.read"><strong>VideoCapture.read() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/highgui/doc/reading_and_writing_images_and_video.html#cv2.VideoCapture.release"><strong>VideoCapture.release() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/highgui/doc/reading_and_writing_images_and_video.html#cv2.VideoCapture.retrieve"><strong>VideoCapture.retrieve() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/highgui/doc/reading_and_writing_images_and_video.html#cv2.VideoCapture.set"><strong>VideoCapture.set() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/highgui/doc/reading_and_writing_images_and_video.html#double VideoCapture::get(int propId)"><strong>VideoCapture::get (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/highgui/doc/reading_and_writing_images_and_video.html#bool VideoCapture::grab()"><strong>VideoCapture::grab (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/highgui/doc/reading_and_writing_images_and_video.html#bool VideoCapture::isOpened()"><strong>VideoCapture::isOpened (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/highgui/doc/reading_and_writing_images_and_video.html#bool VideoCapture::open(const string& filename)"><strong>VideoCapture::open (C++ function)</strong></a>, <a href="modules/highgui/doc/reading_and_writing_images_and_video.html#bool VideoCapture::open(int device)"><strong>[1]</strong></a>
  </dt>

      
  <dt><a href="modules/highgui/doc/reading_and_writing_images_and_video.html#VideoCapture& VideoCapture::operator >> (Mat& image)"><strong>VideoCapture::operator&gt;&gt; (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/highgui/doc/reading_and_writing_images_and_video.html#bool VideoCapture::read(Mat& image)"><strong>VideoCapture::read (C++ function)</strong></a>
  </dt>

  </dl></td>
  <td style="width: 33%" valign="top"><dl>
      
  <dt><a href="modules/highgui/doc/reading_and_writing_images_and_video.html#void VideoCapture::release()"><strong>VideoCapture::release (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/highgui/doc/reading_and_writing_images_and_video.html#bool VideoCapture::retrieve(Mat& image, int channel)"><strong>VideoCapture::retrieve (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/highgui/doc/reading_and_writing_images_and_video.html#bool VideoCapture::set(int propId, double value)"><strong>VideoCapture::set (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/highgui/doc/reading_and_writing_images_and_video.html#VideoCapture::VideoCapture()"><strong>VideoCapture::VideoCapture (C++ function)</strong></a>, <a href="modules/highgui/doc/reading_and_writing_images_and_video.html#VideoCapture::VideoCapture(const string& filename)"><strong>[1]</strong></a>, <a href="modules/highgui/doc/reading_and_writing_images_and_video.html#VideoCapture::VideoCapture(int device)"><strong>[2]</strong></a>
  </dt>

      
  <dt><a href="modules/highgui/doc/reading_and_writing_images_and_video.html#VideoWriter"><strong>VideoWriter (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/highgui/doc/reading_and_writing_images_and_video.html#cv2.VideoWriter"><strong>VideoWriter() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/highgui/doc/reading_and_writing_images_and_video.html#cv2.VideoWriter.isOpened"><strong>VideoWriter.isOpened() (Python function in cv2)</strong></a>, <a href="modules/highgui/doc/reading_and_writing_images_and_video.html#cv2.VideoWriter.isOpened"><strong>[1]</strong></a>
  </dt>

      
  <dt><a href="modules/highgui/doc/reading_and_writing_images_and_video.html#cv2.VideoWriter.open"><strong>VideoWriter.open() (Python function in cv2)</strong></a>, <a href="modules/highgui/doc/reading_and_writing_images_and_video.html#cv2.VideoWriter.open"><strong>[1]</strong></a>
  </dt>

      
  <dt><a href="modules/highgui/doc/reading_and_writing_images_and_video.html#cv2.VideoWriter.write"><strong>VideoWriter.write() (Python function in cv2)</strong></a>, <a href="modules/highgui/doc/reading_and_writing_images_and_video.html#cv2.VideoWriter.write"><strong>[1]</strong></a>
  </dt>

      
  <dt><a href="modules/highgui/doc/reading_and_writing_images_and_video.html#bool VideoWriter::isOpened()"><strong>VideoWriter::isOpened (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/highgui/doc/reading_and_writing_images_and_video.html#bool VideoWriter::open(const string& filename, int fourcc, double fps, Size frameSize, bool isColor)"><strong>VideoWriter::open (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/highgui/doc/reading_and_writing_images_and_video.html#VideoWriter& VideoWriter::operator << (const Mat& image)"><strong>VideoWriter::operator&lt;&lt; (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/highgui/doc/reading_and_writing_images_and_video.html#VideoWriter::VideoWriter()"><strong>VideoWriter::VideoWriter (C++ function)</strong></a>, <a href="modules/highgui/doc/reading_and_writing_images_and_video.html#VideoWriter::VideoWriter(const string& filename, int fourcc, double fps, Size frameSize, bool isColor)"><strong>[1]</strong></a>
  </dt>

      
  <dt><a href="modules/highgui/doc/reading_and_writing_images_and_video.html#void VideoWriter::write(const Mat& image)"><strong>VideoWriter::write (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/viz/doc/viz3d.html#Viz3d"><strong>Viz3d (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/viz/doc/viz3d.html#void Viz3d::showWidget(const String &id, const Widget &widget, const Affine3d &pose)"><strong>Viz3d::showWidget (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/viz/doc/viz3d.html#Viz3d::Viz3d(const String& window_name)"><strong>Viz3d::Viz3d (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/viz/doc/viz3d.html#Affine3d viz::makeTransformToGlobal(const Vec3f& axis_x, const Vec3f& axis_y, const Vec3f& axis_z, const Vec3f& origin)"><strong>viz::makeTransformToGlobal (C++ function)</strong></a>
  </dt>

  </dl></td>
</tr></table>

<h2 id="W">W</h2>
<table style="width: 100%" class="indextable genindextable"><tr>
  <td style="width: 33%" valign="top"><dl>
      
  <dt><a href="modules/highgui/doc/user_interface.html#int cvWaitKey(int delay)"><strong>WaitKey (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/highgui/doc/user_interface.html#int waitKey(int delay)"><strong>waitKey (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/highgui/doc/user_interface.html#cv.WaitKey"><strong>WaitKey() (Python function in cv)</strong></a>
  </dt>

      
  <dt><a href="modules/highgui/doc/user_interface.html#cv2.waitKey"><strong>waitKey() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/geometric_transformations.html#void cvWarpAffine(const CvArr* src, CvArr* dst, const CvMat* map_matrix, int flags, CvScalar fillval)"><strong>WarpAffine (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/geometric_transformations.html#void warpAffine(InputArray src, OutputArray dst, InputArray M, Size dsize, int flags, int borderMode, const Scalar& borderValue)"><strong>warpAffine (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/geometric_transformations.html#cv.WarpAffine"><strong>WarpAffine() (Python function in cv)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/geometric_transformations.html#cv2.warpAffine"><strong>warpAffine() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/stitching/doc/high_level.html#WarperCreator"><strong>WarperCreator (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/geometric_transformations.html#void cvWarpPerspective(const CvArr* src, CvArr* dst, const CvMat* map_matrix, int flags, CvScalar fillval)"><strong>WarpPerspective (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/geometric_transformations.html#void warpPerspective(InputArray src, OutputArray dst, InputArray M, Size dsize, int flags, int borderMode, const Scalar& borderValue)"><strong>warpPerspective (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/geometric_transformations.html#cv.WarpPerspective"><strong>WarpPerspective() (Python function in cv)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/geometric_transformations.html#cv2.warpPerspective"><strong>warpPerspective() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/viz/doc/widget.html#WArrow"><strong>WArrow (C++ class)</strong></a>
  </dt>

      <dd><dl>
        
  <dt><a href="modules/viz/doc/widget.html#WArrow(const Point3f& pt1, const Point3f& pt2, double thickness , const Color &color)"><strong>(C++ function)</strong></a>
  </dt>

      </dl></dd>
      
  <dt><a href="modules/viz/doc/viz3d.html#bool wasStopped()"><strong>wasStopped (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/miscellaneous_transformations.html#void cvWatershed(const CvArr* image, CvArr* markers)"><strong>Watershed (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/miscellaneous_transformations.html#void watershed(InputArray image, InputOutputArray markers)"><strong>watershed (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/miscellaneous_transformations.html#cv2.watershed"><strong>watershed() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/viz/doc/widget.html#WCameraPosition"><strong>WCameraPosition (C++ class)</strong></a>
  </dt>

      <dd><dl>
        
  <dt><a href="modules/viz/doc/widget.html#WCameraPosition(const Matx33d &K, InputArray image, double scale , const Color &color)"><strong>(C++ function)</strong></a>, <a href="modules/viz/doc/widget.html#WCameraPosition(const Matx33d &K, double scale , const Color &color)"><strong>[1]</strong></a>, <a href="modules/viz/doc/widget.html#WCameraPosition(const Vec2d &fov, InputArray image, double scale , const Color &color)"><strong>[2]</strong></a>, <a href="modules/viz/doc/widget.html#WCameraPosition(const Vec2d &fov, double scale , const Color &color)"><strong>[3]</strong></a>, <a href="modules/viz/doc/widget.html#WCameraPosition(double scale)"><strong>[4]</strong></a>
  </dt>

      </dl></dd>
      
  <dt><a href="modules/viz/doc/widget.html#WCircle"><strong>WCircle (C++ class)</strong></a>
  </dt>

      <dd><dl>
        
  <dt><a href="modules/viz/doc/widget.html#WCircle(double radius, const Point3d& center, const Vec3d& normal, double thickness , const Color &color)"><strong>(C++ function)</strong></a>, <a href="modules/viz/doc/widget.html#WCircle(double radius, double thickness , const Color &color)"><strong>[1]</strong></a>
  </dt>

      </dl></dd>
      
  <dt><a href="modules/viz/doc/widget.html#WCloud"><strong>WCloud (C++ class)</strong></a>
  </dt>

      <dd><dl>
        
  <dt><a href="modules/viz/doc/widget.html#WCloud(InputArray cloud, InputArray colors)"><strong>(C++ function)</strong></a>, <a href="modules/viz/doc/widget.html#WCloud(InputArray cloud, InputArray colors, InputArray normals)"><strong>[1]</strong></a>, <a href="modules/viz/doc/widget.html#WCloud(InputArray cloud, const Color &color)"><strong>[2]</strong></a>, <a href="modules/viz/doc/widget.html#WCloud(InputArray cloud, const Color &color, InputArray normals)"><strong>[3]</strong></a>
  </dt>

      </dl></dd>
      
  <dt><a href="modules/viz/doc/widget.html#WCloudCollection"><strong>WCloudCollection (C++ class)</strong></a>
  </dt>

      <dd><dl>
        
  <dt><a href="modules/viz/doc/widget.html#WCloudCollection()"><strong>(C++ function)</strong></a>
  </dt>

      </dl></dd>
      
  <dt><a href="modules/viz/doc/widget.html#WCloudNormals"><strong>WCloudNormals (C++ class)</strong></a>
  </dt>

      <dd><dl>
        
  <dt><a href="modules/viz/doc/widget.html#WCloudNormals(InputArray cloud, InputArray normals, int level , double scale , const Color &color)"><strong>(C++ function)</strong></a>
  </dt>

      </dl></dd>
      
  <dt><a href="modules/viz/doc/widget.html#WCone"><strong>WCone (C++ class)</strong></a>
  </dt>

      <dd><dl>
        
  <dt><a href="modules/viz/doc/widget.html#WCone(double length, double radius, int resolution , const Color &color)"><strong>(C++ function)</strong></a>, <a href="modules/viz/doc/widget.html#WCone(double radius, const Point3d& center, const Point3d& tip, int resolution , const Color &color)"><strong>[1]</strong></a>
  </dt>

      </dl></dd>
      
  <dt><a href="modules/viz/doc/widget.html#WCoordinateSystem"><strong>WCoordinateSystem (C++ class)</strong></a>
  </dt>

      <dd><dl>
        
  <dt><a href="modules/viz/doc/widget.html#WCoordinateSystem(double scale)"><strong>(C++ function)</strong></a>
  </dt>

      </dl></dd>
      
  <dt><a href="modules/viz/doc/widget.html#WCube"><strong>WCube (C++ class)</strong></a>
  </dt>

      <dd><dl>
        
  <dt><a href="modules/viz/doc/widget.html#WCube(const Point3f& pt_min, const Point3f& pt_max, bool wire_frame , const Color &color)"><strong>(C++ function)</strong></a>
  </dt>

      </dl></dd>
      
  <dt><a href="modules/viz/doc/widget.html#WCylinder"><strong>WCylinder (C++ class)</strong></a>
  </dt>

      <dd><dl>
        
  <dt><a href="modules/viz/doc/widget.html#WCylinder(const Point3f& pt_on_axis, const Point3f& axis_direction, double radius, int numsides , const Color &color)"><strong>(C++ function)</strong></a>
  </dt>

      </dl></dd>
  </dl></td>
  <td style="width: 33%" valign="top"><dl>
      
  <dt><a href="modules/viz/doc/widget.html#WGrid"><strong>WGrid (C++ class)</strong></a>
  </dt>

      <dd><dl>
        
  <dt><a href="modules/viz/doc/widget.html#WGrid(const Vec2i &cells , const Vec2d &cells_spacing , const Color &color)"><strong>(C++ function)</strong></a>
  </dt>

      </dl></dd>
      
  <dt><a href="modules/viz/doc/widget.html#Widget"><strong>Widget (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/viz/doc/widget.html#Widget2D"><strong>Widget2D (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/viz/doc/widget.html#Widget3D"><strong>Widget3D (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/viz/doc/widget.html#WidgetAccessor"><strong>WidgetAccessor (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/viz/doc/widget.html#WImage3D"><strong>WImage3D (C++ class)</strong></a>
  </dt>

      <dd><dl>
        
  <dt><a href="modules/viz/doc/widget.html#WImage3D(InputArray image, const Size2d &size)"><strong>(C++ function)</strong></a>, <a href="modules/viz/doc/widget.html#WImage3D(InputArray image, const Size2d &size, const Vec3d &position, const Vec3d &normal, const Vec3d &up_vector)"><strong>[1]</strong></a>
  </dt>

      </dl></dd>
      
  <dt><a href="modules/viz/doc/widget.html#WImageOverlay"><strong>WImageOverlay (C++ class)</strong></a>
  </dt>

      <dd><dl>
        
  <dt><a href="modules/viz/doc/widget.html#WImageOverlay(InputArray image, const Rect &rect)"><strong>(C++ function)</strong></a>
  </dt>

      </dl></dd>
      
  <dt><a href="modules/viz/doc/widget.html#WLine"><strong>WLine (C++ class)</strong></a>
  </dt>

      <dd><dl>
        
  <dt><a href="modules/viz/doc/widget.html#WLine(const Point3f &pt1, const Point3f &pt2, const Color &color)"><strong>(C++ function)</strong></a>
  </dt>

      </dl></dd>
      
  <dt><a href="modules/viz/doc/widget.html#WMesh"><strong>WMesh (C++ class)</strong></a>
  </dt>

      <dd><dl>
        
  <dt><a href="modules/viz/doc/widget.html#WMesh(InputArray cloud, InputArray polygons, InputArray colors , InputArray normals)"><strong>(C++ function)</strong></a>, <a href="modules/viz/doc/widget.html#WMesh(const Mesh &mesh)"><strong>[1]</strong></a>
  </dt>

      </dl></dd>
      
  <dt><a href="modules/viz/doc/widget.html#WPlane"><strong>WPlane (C++ class)</strong></a>
  </dt>

      <dd><dl>
        
  <dt><a href="modules/viz/doc/widget.html#WPlane(const Point3d& center, const Vec3d& normal, const Vec3d& new_yaxis,const Size2d& size , const Color &color)"><strong>(C++ function)</strong></a>, <a href="modules/viz/doc/widget.html#WPlane(const Size2d& size , const Color &color)"><strong>[1]</strong></a>
  </dt>

      </dl></dd>
      
  <dt><a href="modules/viz/doc/widget.html#WPolyLine"><strong>WPolyLine (C++ class)</strong></a>
  </dt>

      <dd><dl>
        
  <dt><a href="modules/viz/doc/widget.html#WPolyLine(InputArray points, const Color &color)"><strong>(C++ function)</strong></a>
  </dt>

      </dl></dd>
      
  <dt><a href="modules/core/doc/old_xml_yaml_persistence.html#void cvWrite(CvFileStorage* fs, const char* name, const void* ptr, CvAttrList attributes)"><strong>Write (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_xml_yaml_persistence.html#void cvWriteComment(CvFileStorage* fs, const char* comment, int eol_comment)"><strong>WriteComment (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_xml_yaml_persistence.html#void cvWriteFileNode(CvFileStorage* fs, const char* new_node_name, const CvFileNode* node, int embed)"><strong>WriteFileNode (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/highgui/doc/reading_and_writing_images_and_video.html#int cvWriteFrame(CvVideoWriter* writer, const IplImage* image)"><strong>WriteFrame (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/highgui/doc/reading_and_writing_images_and_video.html#cv.WriteFrame"><strong>WriteFrame() (Python function in cv)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_xml_yaml_persistence.html#void cvWriteInt(CvFileStorage* fs, const char* name, int value)"><strong>WriteInt (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_xml_yaml_persistence.html#void cvWriteRawData(CvFileStorage* fs, const void* src, int len, const char* dt)"><strong>WriteRawData (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_xml_yaml_persistence.html#void cvWriteReal(CvFileStorage* fs, const char* name, double value)"><strong>WriteReal (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_xml_yaml_persistence.html#void cvWriteString(CvFileStorage* fs, const char* name, const char* str, int quote)"><strong>WriteString (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/viz/doc/widget.html#WSphere"><strong>WSphere (C++ class)</strong></a>
  </dt>

      <dd><dl>
        
  <dt><a href="modules/viz/doc/widget.html#WSphere(const cv::Point3f &center, double radius, int sphere_resolution , const Color &color)"><strong>(C++ function)</strong></a>
  </dt>

      </dl></dd>
      
  <dt><a href="modules/viz/doc/widget.html#WText"><strong>WText (C++ class)</strong></a>
  </dt>

      <dd><dl>
        
  <dt><a href="modules/viz/doc/widget.html#WText(const String &text, const Point2i &pos, int font_size , const Color &color)"><strong>(C++ function)</strong></a>
  </dt>

      </dl></dd>
      
  <dt><a href="modules/viz/doc/widget.html#WText3D"><strong>WText3D (C++ class)</strong></a>
  </dt>

      <dd><dl>
        
  <dt><a href="modules/viz/doc/widget.html#WText3D(const String &text, const Point3f &position, double text_scale , bool face_camera , const Color &color)"><strong>(C++ function)</strong></a>
  </dt>

      </dl></dd>
      
  <dt><a href="modules/viz/doc/widget.html#WTrajectory"><strong>WTrajectory (C++ class)</strong></a>
  </dt>

      <dd><dl>
        
  <dt><a href="modules/viz/doc/widget.html#WTrajectory(InputArray path, int display_mode , double scale , const Color &color)"><strong>(C++ function)</strong></a>
  </dt>

      </dl></dd>
      
  <dt><a href="modules/viz/doc/widget.html#WTrajectoryFrustums"><strong>WTrajectoryFrustums (C++ class)</strong></a>
  </dt>

      <dd><dl>
        
  <dt><a href="modules/viz/doc/widget.html#WTrajectoryFrustums(const std::vector<Affine3d> &path, const Matx33d &K, double scale , const Color &color)"><strong>(C++ function)</strong></a>, <a href="modules/viz/doc/widget.html#WTrajectoryFrustums(const std::vector<Affine3d> &path, const Vec2d &fov, double scale , const Color &color)"><strong>[1]</strong></a>
  </dt>

      </dl></dd>
      
  <dt><a href="modules/viz/doc/widget.html#WTrajectorySpheres"><strong>WTrajectorySpheres (C++ class)</strong></a>
  </dt>

      <dd><dl>
        
  <dt><a href="modules/viz/doc/widget.html#WTrajectorySpheres(InputArray path, double line_length , double radius , const Color &from , const Color &to)"><strong>(C++ function)</strong></a>
  </dt>

      </dl></dd>
      
  <dt><a href="modules/viz/doc/widget.html#WWidgetMerger"><strong>WWidgetMerger (C++ class)</strong></a>
  </dt>

      <dd><dl>
        
  <dt><a href="modules/viz/doc/widget.html#WWidgetMerger()"><strong>(C++ function)</strong></a>
  </dt>

      </dl></dd>
  </dl></td>
</tr></table>

<h2 id="X">X</h2>
<table style="width: 100%" class="indextable genindextable"><tr>
  <td style="width: 33%" valign="top"><dl>
      
  <dt><a href="modules/core/doc/operations_on_arrays.html#void cvXor(const CvArr* src1, const CvArr* src2, CvArr* dst, const CvArr* mask)"><strong>Xor (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#cv.Xor"><strong>Xor() (Python function in cv)</strong></a>
  </dt>

  </dl></td>
  <td style="width: 33%" valign="top"><dl>
      
  <dt><a href="modules/core/doc/operations_on_arrays.html#void cvXorS(const CvArr* src, CvScalar value, CvArr* dst, const CvArr* mask)"><strong>XorS (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#cv.XorS"><strong>XorS() (Python function in cv)</strong></a>
  </dt>

  </dl></td>
</tr></table>



          </div>
          <div class="feedback">
              <h2>Help and Feedback</h2>
              You did not find what you were looking for?
              <ul>
                  
                  
                  
                  <li>Ask a question on the <a href="http://answers.opencv.org">Q&A forum</a>.</li>
                  <li>If you think something is missing or wrong in the documentation,
                  please file a <a href="http://code.opencv.org">bug report</a>.</li>
              </ul>
          </div>
        </div>
      </div>

      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="index.html">
              <img class="logo" src="_static/opencv-logo-white.png" alt="Logo"/>
            </a></p>
<div id="searchbox" style="display: none">
      <form class="search" action="search.html" method="get">
      <input type="text" name="q" size="18" />
      <input type="submit" value="Search" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
      </p>
    </form>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>

   

        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="#" title="General Index"
             >index</a></li>
        <li><a href="index.html">OpenCV 2.4.13.7 documentation</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2011-2014, opencv dev team.
      Last updated on Jul 12, 2018.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.3.6.
    </div>
  </body>
</html>